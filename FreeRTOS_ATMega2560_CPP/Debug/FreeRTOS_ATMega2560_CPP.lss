
FreeRTOS_ATMega2560_CPP.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000011e  00800200  00008ffa  000090ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008ffa  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001d5f  0080031e  0080031e  000091ce  2**3
                  ALLOC
  3 .fuse         00000003  00820000  00820000  000091cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  000091cf  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000922c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000c28  00000000  00000000  0000926c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000155af  00000000  00000000  00009e94  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000056f1  00000000  00000000  0001f443  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000876e  00000000  00000000  00024b34  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000033c8  00000000  00000000  0002d2a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000529d  00000000  00000000  0003066c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00011393  00000000  00000000  00035909  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000c48  00000000  00000000  00046c9c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 71 09 	jmp	0x12e2	; 0x12e2 <__ctors_end>
       4:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
       8:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
       c:	0c 94 1f 0e 	jmp	0x1c3e	; 0x1c3e <__vector_3>
      10:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      14:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      18:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      1c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      20:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      24:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      28:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      2c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      30:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      34:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      38:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      3c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      40:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      44:	0c 94 bf 31 	jmp	0x637e	; 0x637e <__vector_17>
      48:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      4c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      50:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      54:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      58:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      5c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      60:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      64:	0c 94 7f 35 	jmp	0x6afe	; 0x6afe <__vector_25>
      68:	0c 94 c2 35 	jmp	0x6b84	; 0x6b84 <__vector_26>
      6c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      70:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      74:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      78:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      7c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      80:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      84:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      88:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      8c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      90:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      94:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      98:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      9c:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      a0:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      a4:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      a8:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      ac:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      b0:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      b4:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      b8:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      bc:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      c0:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      c4:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      c8:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      cc:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      d0:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      d4:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      d8:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      dc:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      e0:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__bad_interrupt>
      e4:	e0 1a       	sub	r14, r16
      e6:	e2 1a       	sub	r14, r18
      e8:	ec 1a       	sub	r14, r28
      ea:	e4 1a       	sub	r14, r20
      ec:	e6 1a       	sub	r14, r22
      ee:	e8 1a       	sub	r14, r24
      f0:	e0 1a       	sub	r14, r16
      f2:	ea 1a       	sub	r14, r26
      f4:	c2 2a       	or	r12, r18
      f6:	3d 2c       	mov	r3, r13
      f8:	49 2c       	mov	r4, r9
      fa:	af 2c       	mov	r10, r15
      fc:	bb 2c       	mov	r11, r11
      fe:	d5 2c       	mov	r13, r5
     100:	e6 2c       	mov	r14, r6
     102:	d3 2d       	mov	r29, r3
     104:	bb 2d       	mov	r27, r11
     106:	be 2d       	mov	r27, r14
     108:	c1 2d       	mov	r28, r1
     10a:	c4 2d       	mov	r28, r4
     10c:	c7 2d       	mov	r28, r7
     10e:	ca 2d       	mov	r28, r10
     110:	cd 2d       	mov	r28, r13
     112:	79 11       	cpse	r23, r9
     114:	ab 11       	cpse	r26, r11
     116:	4c 10       	cpse	r4, r12
     118:	b5 11       	cpse	r27, r5
     11a:	56 10       	cpse	r5, r6
     11c:	60 10       	cpse	r6, r0
     11e:	6a 10       	cpse	r6, r10
     120:	74 10       	cpse	r7, r4
     122:	a3 11       	cpse	r26, r3
     124:	a3 11       	cpse	r26, r3
     126:	7c 10       	cpse	r7, r12
     128:	84 10       	cpse	r8, r4
     12a:	8c 10       	cpse	r8, r12
     12c:	93 10       	cpse	r9, r3
     12e:	9a 10       	cpse	r9, r10
     130:	a1 10       	cpse	r10, r1
     132:	83 11       	cpse	r24, r3
     134:	bf 11       	cpse	r27, r15
     136:	b4 10       	cpse	r11, r4
     138:	a5 11       	cpse	r26, r5
     13a:	bc 10       	cpse	r11, r12
     13c:	c6 10       	cpse	r12, r6
     13e:	ce 10       	cpse	r12, r14
     140:	d8 10       	cpse	r13, r8
     142:	e0 10       	cpse	r14, r0
     144:	a5 11       	cpse	r26, r5
     146:	ea 10       	cpse	r14, r10
     148:	f4 10       	cpse	r15, r4
     14a:	fe 10       	cpse	r15, r14
     14c:	06 11       	cpse	r16, r6
     14e:	10 11       	cpse	r17, r0
     150:	17 11       	cpse	r17, r7
     152:	8b 11       	cpse	r24, r11
     154:	c7 11       	cpse	r28, r7
     156:	2c 11       	cpse	r18, r12
     158:	36 11       	cpse	r19, r6
     15a:	3d 11       	cpse	r19, r13
     15c:	a7 11       	cpse	r26, r7
     15e:	46 11       	cpse	r20, r6
     160:	4f 11       	cpse	r20, r15
     162:	59 11       	cpse	r21, r9
     164:	5f 11       	cpse	r21, r15
     166:	69 11       	cpse	r22, r9
     168:	70 11       	cpse	r23, r0
     16a:	eb 14       	cp	r14, r11
     16c:	d8 14       	cp	r13, r8
     16e:	da 14       	cp	r13, r10
     170:	dc 14       	cp	r13, r12
     172:	de 14       	cp	r13, r14
     174:	e0 14       	cp	r14, r0
     176:	e2 14       	cp	r14, r2
     178:	e4 14       	cp	r14, r4
     17a:	0b 15       	cp	r16, r11
     17c:	0d 15       	cp	r16, r13
     17e:	0f 15       	cp	r16, r15
     180:	11 15       	cp	r17, r1
     182:	13 15       	cp	r17, r3
     184:	15 15       	cp	r17, r5
     186:	17 15       	cp	r17, r7
     188:	19 15       	cp	r17, r9
     18a:	65 40       	sbci	r22, 0x05	; 5
     18c:	65 40       	sbci	r22, 0x05	; 5
     18e:	65 40       	sbci	r22, 0x05	; 5
     190:	92 40       	sbci	r25, 0x02	; 2
     192:	9a 40       	sbci	r25, 0x0A	; 10
     194:	a8 40       	sbci	r26, 0x08	; 8
     196:	65 40       	sbci	r22, 0x05	; 5
     198:	65 40       	sbci	r22, 0x05	; 5
     19a:	92 40       	sbci	r25, 0x02	; 2
     19c:	9a 40       	sbci	r25, 0x0A	; 10

0000019e <__trampolines_end>:
     19e:	71 75       	andi	r23, 0x51	; 81
     1a0:	65 75       	andi	r22, 0x55	; 85
     1a2:	65 20       	and	r6, r5
     1a4:	66 61       	ori	r22, 0x16	; 22
     1a6:	69 6c       	ori	r22, 0xC9	; 201
	...

000001a9 <_ZZ9CanRxFuncE3__c_3>:
     1a9:	71 75 65 75 65 20 66 61 69 6c 00                    queue fail.

000001b4 <_ZZ9CanRxFuncE3__c_2>:
     1b4:	43 41 4e 20 52 65 63 20 3d 20 25 64 00              CAN Rec = %d.

000001c1 <_ZZ9CanRxFuncE3__c_1>:
     1c1:	54 6f 6f 20 4d 61 6e 79 20 46 72 61 6d 65 73 00     Too Many Frames.

000001d1 <_ZZ9CanRxFuncE3__c_0>:
     1d1:	44 4c 43 20 3d 20 25 64 00                          DLC = %d.

000001da <_ZZ9CanRxFuncE3__c>:
     1da:	25 73 20 25 64 0a 00                                %s %d..

000001e1 <_ZZ8can_sendE3__c>:
     1e1:	63 61 6e 20 74 78 20 65 72 72 6f 72 00              can tx error.

000001ee <__c.3148>:
     1ee:	46 52 45 45 3a 20 25 70 00                          FREE: %p.

000001f7 <__c.3146>:
     1f7:	46 52 45 45 3a 20 42 75 66 66 65 72 20 25 70 20     FREE: Buffer %p 
     207:	69 6e 20 75 73 65 20 62 79 20 25 75 20 75 73 65     in use by %u use
     217:	72 73 00                                            rs.

0000021a <__c.3144>:
     21a:	46 52 45 45 3a 20 42 75 66 66 65 72 20 61 6c 72     FREE: Buffer alr
     22a:	65 61 64 79 20 66 72 65 65 20 25 70 00              eady free %p.

00000237 <__c.3142>:
     237:	46 52 45 45 3a 20 49 6e 76 61 6c 69 64 20 43 53     FREE: Invalid CS
     247:	50 20 62 75 66 66 65 72 20 70 6f 69 6e 74 65 72     P buffer pointer
     257:	20 25 70 00                                          %p.

0000025b <__c.3137>:
     25b:	41 74 74 65 6d 70 74 20 74 6f 20 66 72 65 65 20     Attempt to free 
     26b:	6e 75 6c 6c 20 70 6f 69 6e 74 65 72 00              null pointer.

00000278 <__c.3127>:
     278:	43 6f 72 72 75 70 74 20 43 53 50 20 62 75 66 66     Corrupt CSP buff
     288:	65 72 00                                            er.

0000028b <__c.3125>:
     28b:	47 45 54 3a 20 25 70 20 25 70 00                    GET: %p %p.

00000296 <__c.3123>:
     296:	4f 75 74 20 6f 66 20 62 75 66 66 65 72 73 00        Out of buffers.

000002a5 <__c.3121>:
     2a5:	41 74 74 65 6d 70 74 20 74 6f 20 61 6c 6c 6f 63     Attempt to alloc
     2b5:	61 74 65 20 74 6f 6f 20 6c 61 72 67 65 20 62 6c     ate too large bl
     2c5:	6f 63 6b 20 25 75 00                                ock %u.

000002cc <__c.3299>:
     2cc:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     2dc:	65 20 58 54 45 41 20 65 6e 63 72 79 70 74 65 64     e XTEA encrypted
     2ec:	20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74      connection, but
     2fc:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     30c:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     31c:	75 70 70 6f 72 74 00                                upport.

00000323 <__c.3297>:
     323:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     333:	65 20 48 4d 41 43 20 61 75 74 68 65 6e 74 69 63     e HMAC authentic
     343:	61 74 65 64 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c     ated connection,
     353:	20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d      but CSP was com
     363:	70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48 4d     piled without HM
     373:	41 43 20 73 75 70 70 6f 72 74 00                    AC support.

0000037e <__c.3295>:
     37e:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     38e:	65 20 52 44 50 20 63 6f 6e 6e 65 63 74 69 6f 6e     e RDP connection
     39e:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     3ae:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 52     mpiled without R
     3be:	44 50 20 73 75 70 70 6f 72 74 00                    DP support.

000003c9 <__c.3284>:
     3c9:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     3d9:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

000003e3 <__c.3282>:
     3e3:	43 6f 6e 6e 20 61 6c 72 65 61 64 79 20 63 6c 6f     Conn already clo
     3f3:	73 65 64 00                                         sed.

000003f7 <__c.3280>:
     3f7:	4e 55 4c 4c 20 50 6f 69 6e 74 65 72 20 67 69 76     NULL Pointer giv
     407:	65 6e 20 74 6f 20 63 73 70 5f 63 6c 6f 73 65 00     en to csp_close.

00000417 <__c.3270>:
     417:	4e 6f 20 6d 6f 72 65 20 66 72 65 65 20 63 6f 6e     No more free con
     427:	6e 65 63 74 69 6f 6e 73 00                          nections.

00000430 <__c.3265>:
     430:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     440:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

0000044a <__c.3236>:
     44a:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     45a:	6f 72 20 63 6f 6e 6e 20 73 65 6d 61 70 68 6f 72     or conn semaphor
     46a:	65 00                                               e.

0000046c <__c.3231>:
     46c:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
     47c:	20 63 6f 6e 6e 65 63 74 69 6f 6e 20 6c 6f 63 6b      connection lock
	...

0000048d <__c.3224>:
     48d:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     49d:	6f 72 20 73 70 6f 72 74 20 73 65 6d 61 70 68 6f     or sport semapho
     4ad:	72 65 00                                            re.

000004b0 <__c.3219>:
     4b0:	52 58 20 71 75 65 75 65 20 25 70 20 66 75 6c 6c     RX queue %p full
     4c0:	20 77 69 74 68 20 25 75 20 69 74 65 6d 73 00         with %u items.

000004cf <crc_tab>:
     4cf:	00 00 00 00 03 83 6b f2 f7 70 3b e1 f4 f3 50 13     ......k..p;...P.
     4df:	1f 97 9a c7 1c 14 f1 35 e8 e7 a1 26 eb 64 ca d4     .......5...&.d..
     4ef:	cf 58 d9 8a cc db b2 78 38 28 e2 6b 3b ab 89 99     .X.....x8(.k;...
     4ff:	d0 cf 43 4d d3 4c 28 bf 27 bf 78 ac 24 3c 13 5e     ..CM.L(.'.x.$<.^
     50f:	6f c7 5e 10 6c 44 35 e2 98 b7 65 f1 9b 34 0e 03     o.^.lD5...e..4..
     51f:	70 50 c4 d7 73 d3 af 25 87 20 ff 36 84 a3 94 c4     pP..s..%. .6....
     52f:	a0 9f 87 9a a3 1c ec 68 57 ef bc 7b 54 6c d7 89     .......hW..{Tl..
     53f:	bf 08 1d 5d bc 8b 76 af 48 78 26 bc 4b fb 4d 4e     ...]..v.Hx&.K.MN
     54f:	de 8e bd 20 dd 0d d6 d2 29 fe 86 c1 2a 7d ed 33     ... ....)...*}.3
     55f:	c1 19 27 e7 c2 9a 4c 15 36 69 1c 06 35 ea 77 f4     ..'...L.6i..5.w.
     56f:	11 d6 64 aa 12 55 0f 58 e6 a6 5f 4b e5 25 34 b9     ..d..U.X.._K.%4.
     57f:	0e 41 fe 6d 0d c2 95 9f f9 31 c5 8c fa b2 ae 7e     .A.m.....1.....~
     58f:	b1 49 e3 30 b2 ca 88 c2 46 39 d8 d1 45 ba b3 23     .I.0....F9..E..#
     59f:	ae de 79 f7 ad 5d 12 05 59 ae 42 16 5a 2d 29 e4     ..y..]..Y.B.Z-).
     5af:	7e 11 3a ba 7d 92 51 48 89 61 01 5b 8a e2 6a a9     ~.:.}.QH.a.[..j.
     5bf:	61 86 a0 7d 62 05 cb 8f 96 f6 9b 9c 95 75 f0 6e     a..}b........u.n
     5cf:	bc 1d 7b 41 bf 9e 10 b3 4b 6d 40 a0 48 ee 2b 52     ..{A....Km@.H.+R
     5df:	a3 8a e1 86 a0 09 8a 74 54 fa da 67 57 79 b1 95     .......tT..gWy..
     5ef:	73 45 a2 cb 70 c6 c9 39 84 35 99 2a 87 b6 f2 d8     sE..p..9.5.*....
     5ff:	6c d2 38 0c 6f 51 53 fe 9b a2 03 ed 98 21 68 1f     l.8.oQS......!h.
     60f:	d3 da 25 51 d0 59 4e a3 24 aa 1e b0 27 29 75 42     ..%Q.YN.$...')uB
     61f:	cc 4d bf 96 cf ce d4 64 3b 3d 84 77 38 be ef 85     .M.....d;=.w8...
     62f:	1c 82 fc db 1f 01 97 29 eb f2 c7 3a e8 71 ac c8     .......)...:.q..
     63f:	03 15 66 1c 00 96 0d ee f4 65 5d fd f7 e6 36 0f     ..f......e]...6.
     64f:	62 93 c6 61 61 10 ad 93 95 e3 fd 80 96 60 96 72     b..aa........`.r
     65f:	7d 04 5c a6 7e 87 37 54 8a 74 67 47 89 f7 0c b5     }.\.~.7T.tgG....
     66f:	ad cb 1f eb ae 48 74 19 5a bb 24 0a 59 38 4f f8     .....Ht.Z.$.Y8O.
     67f:	b2 5c 85 2c b1 df ee de 45 2c be cd 46 af d5 3f     .\.,....E,..F..?
     68f:	0d 54 98 71 0e d7 f3 83 fa 24 a3 90 f9 a7 c8 62     .T.q.....$.....b
     69f:	12 c3 02 b6 11 40 69 44 e5 b3 39 57 e6 30 52 a5     .....@iD..9W.0R.
     6af:	c2 0c 41 fb c1 8f 2a 09 35 7c 7a 1a 36 ff 11 e8     ..A...*.5|z.6...
     6bf:	dd 9b db 3c de 18 b0 ce 2a eb e0 dd 29 68 8b 2f     ...<....*...)h./
     6cf:	78 3b f6 82 7b b8 9d 70 8f 4b cd 63 8c c8 a6 91     x;..{..p.K.c....
     6df:	67 ac 6c 45 64 2f 07 b7 90 dc 57 a4 93 5f 3c 56     g.lEd/....W.._<V
     6ef:	b7 63 2f 08 b4 e0 44 fa 40 13 14 e9 43 90 7f 1b     .c/...D.@...C...
     6ff:	a8 f4 b5 cf ab 77 de 3d 5f 84 8e 2e 5c 07 e5 dc     .....w.=_...\...
     70f:	17 fc a8 92 14 7f c3 60 e0 8c 93 73 e3 0f f8 81     .......`...s....
     71f:	08 6b 32 55 0b e8 59 a7 ff 1b 09 b4 fc 98 62 46     .k2U..Y.......bF
     72f:	d8 a4 71 18 db 27 1a ea 2f d4 4a f9 2c 57 21 0b     ..q..'../.J.,W!.
     73f:	c7 33 eb df c4 b0 80 2d 30 43 d0 3e 33 c0 bb cc     .3.....-0C.>3...
     74f:	a6 b5 4b a2 a5 36 20 50 51 c5 70 43 52 46 1b b1     ..K..6 PQ.pCRF..
     75f:	b9 22 d1 65 ba a1 ba 97 4e 52 ea 84 4d d1 81 76     .".e....NR..M..v
     76f:	69 ed 92 28 6a 6e f9 da 9e 9d a9 c9 9d 1e c2 3b     i..(jn.........;
     77f:	76 7a 08 ef 75 f9 63 1d 81 0a 33 0e 82 89 58 fc     vz..u.c...3...X.
     78f:	c9 72 15 b2 ca f1 7e 40 3e 02 2e 53 3d 81 45 a1     .r....~@>..S=.E.
     79f:	d6 e5 8f 75 d5 66 e4 87 21 95 b4 94 22 16 df 66     ...u.f..!..."..f
     7af:	06 2a cc 38 05 a9 a7 ca f1 5a f7 d9 f2 d9 9c 2b     .*.8.....Z.....+
     7bf:	19 bd 56 ff 1a 3e 3d 0d ee cd 6d 1e ed 4e 06 ec     ..V..>=...m..N..
     7cf:	c4 26 8d c3 c7 a5 e6 31 33 56 b6 22 30 d5 dd d0     .&.....13V."0...
     7df:	db b1 17 04 d8 32 7c f6 2c c1 2c e5 2f 42 47 17     .....2|.,.,./BG.
     7ef:	0b 7e 54 49 08 fd 3f bb fc 0e 6f a8 ff 8d 04 5a     .~TI..?...o....Z
     7ff:	14 e9 ce 8e 17 6a a5 7c e3 99 f5 6f e0 1a 9e 9d     .....j.|...o....
     80f:	ab e1 d3 d3 a8 62 b8 21 5c 91 e8 32 5f 12 83 c0     .....b.!\..2_...
     81f:	b4 76 49 14 b7 f5 22 e6 43 06 72 f5 40 85 19 07     .vI...".C.r.@...
     82f:	64 b9 0a 59 67 3a 61 ab 93 c9 31 b8 90 4a 5a 4a     d..Yg:a...1..JZJ
     83f:	7b 2e 90 9e 78 ad fb 6c 8c 5e ab 7f 8f dd c0 8d     {...x..l.^......
     84f:	1a a8 30 e3 19 2b 5b 11 ed d8 0b 02 ee 5b 60 f0     ..0..+[......[`.
     85f:	05 3f aa 24 06 bc c1 d6 f2 4f 91 c5 f1 cc fa 37     .?.$.....O.....7
     86f:	d5 f0 e9 69 d6 73 82 9b 22 80 d2 88 21 03 b9 7a     ...i.s.."...!..z
     87f:	ca 67 73 ae c9 e4 18 5c 3d 17 48 4f 3e 94 23 bd     .gs....\=.HO>.#.
     88f:	75 6f 6e f3 76 ec 05 01 82 1f 55 12 81 9c 3e e0     uon.v.....U...>.
     89f:	6a f8 f4 34 69 7b 9f c6 9d 88 cf d5 9e 0b a4 27     j..4i{.........'
     8af:	ba 37 b7 79 b9 b4 dc 8b 4d 47 8c 98 4e c4 e7 6a     .7.y....MG..N..j
     8bf:	a5 a0 2d be a6 23 46 4c 52 d0 16 5f 51 53 7d ad     ..-..#FLR.._QS}.

000008cf <__c.2576>:
     8cf:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

000008dc <__c.2572>:
     8dc:	43 53 50 20 52 45 53 45 54 20 25 73 00              CSP RESET %s.

000008e9 <__c.2570>:
     8e9:	0d 0a 00                                            ...

000008ec <__c.2543>:
     8ec:	25 2e 31 66 25 63 00                                %.1f%c.

000008f3 <__c.2551>:
     8f3:	25 2d 35 73 20 20 20 74 78 3a 20 25 30 35 6c 75     %-5s   tx: %05lu
     903:	20 72 78 3a 20 25 30 35 6c 75 20 74 78 65 3a 20      rx: %05lu txe: 
     913:	25 30 35 6c 75 20 72 78 65 3a 20 25 30 35 6c 75     %05lu rxe: %05lu
     923:	0d 0a 20 20 20 20 20 20 20 20 64 72 6f 70 3a 20     ..        drop: 
     933:	25 30 35 6c 75 20 61 75 74 68 65 72 72 3a 20 25     %05lu autherr: %
     943:	30 35 6c 75 20 66 72 61 6d 65 3a 20 25 30 35 6c     05lu frame: %05l
     953:	75 0d 0a 20 20 20 20 20 20 20 20 74 78 62 3a 20     u..        txb: 
     963:	25 6c 75 20 28 25 73 29 20 72 78 62 3a 20 25 6c     %lu (%s) rxb: %l
     973:	75 20 28 25 73 29 0d 0a 0d 0a 00                    u (%s).....

0000097e <__c.3323>:
     97e:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
     98e:	41 4e 20 66 72 61 6d 65 20 69 6e 20 54 78 20 63     AN frame in Tx c
     99e:	61 6c 6c 62 61 63 6b 00                             allback.

000009a6 <__c.3320>:
     9a6:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
     9b6:	41 4e 20 66 72 61 6d 65 20 69 6e 20 63 73 70 5f     AN frame in csp_
     9c6:	74 78 5f 63 61 6e 00                                tx_can.

000009cd <__c.3315>:
     9cd:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 43 46     Failed to get CF
     9dd:	50 20 69 64 65 6e 74 69 66 69 63 61 74 69 6f 6e     P identification
     9ed:	20 6e 75 6d 62 65 72 00                              number.

000009f5 <__c.3200>:
     9f5:	43 6f 75 6c 64 20 6e 6f 74 20 69 6e 69 74 69 61     Could not initia
     a05:	6c 69 7a 65 20 43 46 50 20 69 64 20 73 65 6d 61     lize CFP id sema
     a15:	70 68 6f 72 65 00                                   phore.

00000a1b <__c.3288>:
     a1b:	52 65 63 65 69 76 65 64 20 75 6e 6b 6e 6f 77 6e     Received unknown
     a2b:	20 43 46 50 20 6d 65 73 73 61 67 65 20 74 79 70      CFP message typ
     a3b:	65 00                                               e.

00000a3d <__c.3285>:
     a3d:	52 58 20 62 75 66 66 65 72 20 6f 76 65 72 66 6c     RX buffer overfl
     a4d:	6f 77 00                                            ow.

00000a50 <__c.3283>:
     a50:	43 41 4e 20 66 72 61 6d 65 20 6c 6f 73 74 20 69     CAN frame lost i
     a60:	6e 20 43 53 50 20 70 61 63 6b 65 74 00              n CSP packet.

00000a6d <__c.3280>:
     a6d:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 62 75     Failed to get bu
     a7d:	66 66 65 72 20 66 6f 72 20 43 53 50 5f 42 45 47     ffer for CSP_BEG
     a8d:	49 4e 20 70 61 63 6b 65 74 00                       IN packet.

00000a97 <__c.3278>:
     a97:	49 6e 63 6f 6d 70 6c 65 74 65 20 66 72 61 6d 65     Incomplete frame
	...

00000aa8 <__c.3275>:
     aa8:	53 68 6f 72 74 20 42 45 47 49 4e 20 66 72 61 6d     Short BEGIN fram
     ab8:	65 20 72 65 63 65 69 76 65 64 00                    e received.

00000ac3 <__c.3272>:
     ac3:	4f 75 74 20 6f 66 20 6f 72 64 65 72 20 4d 4f 52     Out of order MOR
     ad3:	45 20 66 72 61 6d 65 20 72 65 63 65 69 76 65 64     E frame received
	...

00000ae4 <__c.3270>:
     ae4:	4e 6f 20 61 76 61 69 6c 61 62 6c 65 20 70 61 63     No available pac
     af4:	6b 65 74 20 62 75 66 66 65 72 20 66 6f 72 20 43     ket buffer for C
     b04:	41 4e 00                                            AN.

00000b07 <__c.3259>:
     b07:	43 41 4e 20 42 75 66 66 65 72 20 65 6c 65 6d 65     CAN Buffer eleme
     b17:	6e 74 20 74 69 6d 65 64 20 6f 75 74 00              nt timed out.

00000b24 <__c.3295>:
     b24:	25 73 20 25 64 0a 00                                %s %d..

00000b2b <__c.3345>:
     b2b:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
     b3b:	6c 69 7a 65 20 43 41 4e 20 64 72 69 76 65 72 00     lize CAN driver.

00000b4b <__c.3342>:
     b4b:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 20 43     Failed to init C
     b5b:	41 4e 20 52 58 20 74 61 73 6b 00                    AN RX task.

00000b66 <__c.3340>:
     b66:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
     b76:	20 43 41 4e 20 52 58 20 71 75 65 75 65 00            CAN RX queue.

00000b84 <__c.3338>:
     b84:	55 6e 6b 6e 6f 77 6e 20 43 41 4e 20 6d 6f 64 65     Unknown CAN mode
	...

00000b95 <__c.3336>:
     b95:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
     ba5:	6c 69 7a 65 20 43 41 4e 20 69 64 65 6e 74 69 66     lize CAN identif
     bb5:	69 63 61 74 69 6f 6e 20 6e 75 6d 62 65 72 00        ication number.

00000bc4 <__c.3384>:
     bc4:	49 6e 76 61 6c 69 64 20 63 61 6c 6c 20 74 6f 20     Invalid call to 
     bd4:	63 73 70 5f 73 65 6e 64 00                          csp_send.

00000bdd <__c.3374>:
     bdd:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     bed:	58 54 45 41 20 65 6e 63 72 79 70 74 65 64 20 70     XTEA encrypted p
     bfd:	61 63 6b 65 74 2c 20 62 75 74 20 43 53 50 20 77     acket, but CSP w
     c0d:	61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68     as compiled with
     c1d:	6f 75 74 20 58 54 45 41 20 73 75 70 70 6f 72 74     out XTEA support
     c2d:	2e 20 44 69 73 63 61 72 64 69 6e 67 20 70 61 63     . Discarding pac
     c3d:	6b 65 74 00                                         ket.

00000c41 <__c.3372>:
     c41:	43 52 43 33 32 20 61 70 70 65 6e 64 20 66 61 69     CRC32 append fai
     c51:	6c 65 64 21 00                                      led!.

00000c56 <__c.3369>:
     c56:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     c66:	70 61 63 6b 65 74 20 77 69 74 68 20 48 4d 41 43     packet with HMAC
     c76:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     c86:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48     mpiled without H
     c96:	4d 41 43 20 73 75 70 70 6f 72 74 2e 20 44 69 73     MAC support. Dis
     ca6:	63 61 72 64 69 6e 67 20 70 61 63 6b 65 74 00        carding packet.

00000cb5 <__c.3367>:
     cb5:	4f 55 54 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     OUT: S %u, D %u,
     cc5:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
     cd5:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
     ce5:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

00000cf4 <__c.3365>:
     cf4:	4e 6f 20 72 6f 75 74 65 20 74 6f 20 68 6f 73 74     No route to host
     d04:	3a 20 25 23 30 38 78 00                             : %#08x.

00000d0c <__c.3362>:
     d0c:	63 73 70 5f 73 65 6e 64 5f 64 69 72 65 63 74 20     csp_send_direct 
     d1c:	63 61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c     called with NULL
     d2c:	20 70 61 63 6b 65 74 00                              packet.

00000d34 <__c.3343>:
     d34:	49 6e 76 61 6c 69 64 20 73 6f 63 6b 65 74 20 6f     Invalid socket o
     d44:	70 74 69 6f 6e 00                                   ption.

00000d4a <__c.3341>:
     d4a:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     d5a:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     d6a:	71 75 69 72 65 73 20 48 4d 41 43 2c 20 62 75 74     quires HMAC, but
     d7a:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     d8a:	64 20 77 69 74 68 6f 75 74 20 48 4d 41 43 20 73     d without HMAC s
     d9a:	75 70 70 6f 72 74 00                                upport.

00000da1 <__c.3339>:
     da1:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     db1:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     dc1:	71 75 69 72 65 73 20 58 54 45 41 2c 20 62 75 74     quires XTEA, but
     dd1:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     de1:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     df1:	75 70 70 6f 72 74 00                                upport.

00000df8 <__c.3337>:
     df8:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     e08:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     e18:	71 75 69 72 65 73 20 52 44 50 2c 20 62 75 74 20     quires RDP, but 
     e28:	43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64     CSP was compiled
     e38:	20 77 69 74 68 6f 75 74 20 52 44 50 20 73 75 70      without RDP sup
     e48:	70 6f 72 74 00                                      port.

00000e4d <__c.3192>:
     e4d:	42 69 6e 64 69 6e 67 20 73 6f 63 6b 65 74 20 25     Binding socket %
     e5d:	70 20 74 6f 20 70 6f 72 74 20 25 75 00              p to port %u.

00000e6a <__c.3190>:
     e6a:	50 6f 72 74 20 25 64 20 69 73 20 61 6c 72 65 61     Port %d is alrea
     e7a:	64 79 20 69 6e 20 75 73 65 00                       dy in use.

00000e84 <__c.3188>:
     e84:	4f 6e 6c 79 20 70 6f 72 74 73 20 66 72 6f 6d 20     Only ports from 
     e94:	30 2d 25 75 20 28 61 6e 64 20 43 53 50 5f 41 4e     0-%u (and CSP_AN
     ea4:	59 20 66 6f 72 20 64 65 66 61 75 6c 74 29 20 61     Y for default) a
     eb4:	72 65 20 61 76 61 69 6c 61 62 6c 65 20 66 6f 72     re available for
     ec4:	20 69 6e 63 6f 6d 69 6e 67 20 70 6f 72 74 73 00      incoming ports.

00000ed4 <__c.2386>:
     ed4:	45 52 52 4f 52 3a 20 52 6f 75 74 69 6e 67 20 69     ERROR: Routing i
     ee4:	6e 70 75 74 20 46 49 46 4f 20 69 73 20 46 55 4c     nput FIFO is FUL
     ef4:	4c 2e 20 44 72 6f 70 70 69 6e 67 20 70 61 63 6b     L. Dropping pack
     f04:	65 74 2e 00                                         et..

00000f08 <__c.2382>:
     f08:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     f18:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     f28:	69 6e 74 65 72 66 61 63 65 00                       interface.

00000f32 <__c.2380>:
     f32:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     f42:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     f52:	70 61 63 6b 65 74 00                                packet.

00000f59 <__c.3124>:
     f59:	25 73 20 25 64 0a 00                                %s %d..

00000f60 <__c.3133>:
     f60:	46 61 69 6c 65 64 20 74 6f 20 73 74 61 72 74 20     Failed to start 
     f70:	72 6f 75 74 65 72 20 74 61 73 6b 00                 router task.

00000f7c <__c.3102>:
     f7c:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
     f8c:	77 69 74 68 6f 75 74 20 43 52 43 33 32 2e 20 41     without CRC32. A
     f9c:	63 63 65 70 74 69 6e 67 20 70 61 63 6b 65 74 00     ccepting packet.

00000fac <__c.3100>:
     fac:	43 52 43 33 32 20 76 65 72 69 66 69 63 61 74 69     CRC32 verificati
     fbc:	6f 6e 20 65 72 72 6f 72 21 20 44 69 73 63 61 72     on error! Discar
     fcc:	64 69 6e 67 20 70 61 63 6b 65 74 00                 ding packet.

00000fd8 <__c.3098>:
     fd8:	54 6f 6f 20 73 68 6f 72 74 20 70 61 63 6b 65 74     Too short packet
     fe8:	20 66 6f 72 20 43 52 43 33 32 2c 20 25 75 00         for CRC32, %u.

00000ff7 <__c.3091>:
     ff7:	52 65 63 65 69 76 65 64 20 52 44 50 20 70 61 63     Received RDP pac
    1007:	6b 65 74 2c 20 62 75 74 20 43 53 50 20 77 61 73     ket, but CSP was
    1017:	20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68 6f 75      compiled withou
    1027:	74 20 52 44 50 20 73 75 70 70 6f 72 74 2e 20 44     t RDP support. D
    1037:	69 73 63 61 72 64 69 6e 67 20 70 61 63 6b 65 74     iscarding packet
	...

00001048 <__c.3089>:
    1048:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
    1058:	77 69 74 68 20 48 4d 41 43 2c 20 62 75 74 20 43     with HMAC, but C
    1068:	53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20     SP was compiled 
    1078:	77 69 74 68 6f 75 74 20 48 4d 41 43 20 73 75 70     without HMAC sup
    1088:	70 6f 72 74 2e 20 44 69 73 63 61 72 64 69 6e 67     port. Discarding
    1098:	20 70 61 63 6b 65 74 00                              packet.

000010a0 <__c.3087>:
    10a0:	52 65 63 65 69 76 65 64 20 58 54 45 41 20 65 6e     Received XTEA en
    10b0:	63 72 79 70 74 65 64 20 70 61 63 6b 65 74 2c 20     crypted packet, 
    10c0:	62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70     but CSP was comp
    10d0:	69 6c 65 64 20 77 69 74 68 6f 75 74 20 58 54 45     iled without XTE
    10e0:	41 20 73 75 70 70 6f 72 74 2e 20 44 69 73 63 61     A support. Disca
    10f0:	72 64 69 6e 67 20 70 61 63 6b 65 74 00              rding packet.

000010fd <__c.3119>:
    10fd:	4e 6f 20 6d 6f 72 65 20 63 6f 6e 6e 65 63 74 69     No more connecti
    110d:	6f 6e 73 20 61 76 61 69 6c 61 62 6c 65 00           ons available.

0000111b <__c.3116>:
    111b:	43 6f 6e 6e 2d 6c 65 73 73 20 73 6f 63 6b 65 74     Conn-less socket
    112b:	20 71 75 65 75 65 20 66 75 6c 6c 00                  queue full.

00001137 <__c.3114>:
    1137:	52 6f 75 74 65 72 20 66 61 69 6c 65 64 20 74 6f     Router failed to
    1147:	20 73 65 6e 64 00                                    send.

0000114d <__c.3111>:
    114d:	49 4e 50 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     INP: S %u, D %u,
    115d:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
    116d:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
    117d:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

0000118c <__c.2552>:
    118c:	46 61 69 6c 65 64 20 74 6f 20 73 65 74 20 72 6f     Failed to set ro
    119c:	75 74 65 3a 20 69 6e 76 61 6c 69 64 20 6e 6f 64     ute: invalid nod
    11ac:	65 20 69 64 20 25 75 00                             e id %u.

000011b4 <__c.3117>:
    11b4:	50 6f 73 74 3a 20 25 70 00                          Post: %p.

000011bd <__c.3112>:
    11bd:	57 61 69 74 3a 20 25 70 00                          Wait: %p.

000011c6 <__c.3139>:
    11c6:	53 45 52 56 49 43 45 3a 20 50 69 6e 67 20 72 65     SERVICE: Ping re
    11d6:	63 65 69 76 65 64 00                                ceived.

000011dd <__c.2850>:
    11dd:	1b 5b 25 75 3b 25 75 6d 00                          .[%u;%um.

000011e6 <__c.2824>:
    11e6:	46 61 69 6c 65 64 20 74 6f 20 73 68 75 74 64 6f     Failed to shutdo
    11f6:	77 6e 00                                            wn.

000011f9 <__c.2814>:
    11f9:	46 61 69 6c 65 64 20 74 6f 20 72 65 62 6f 6f 74     Failed to reboot
	...

0000120a <__c.2836>:
    120a:	57 61 72 6e 69 6e 67 20 73 6f 63 6b 65 74 20 63     Warning socket c
    121a:	6f 6e 6e 65 63 74 69 6f 6e 20 71 75 65 75 65 20     onnection queue 
    122a:	66 75 6c 6c 00                                      full.

0000122f <__c.2834>:
    122f:	43 6f 6e 6e 65 63 74 69 6f 6e 20 62 75 66 66 65     Connection buffe
    123f:	72 20 71 75 65 75 65 20 66 75 6c 6c 21 00           r queue full!.

0000124d <_ZZ16__vector_defaultE3__c_0>:
    124d:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

0000125a <_ZZ16__vector_defaultE3__c>:
    125a:	55 6e 65 78 20 56 65 63 74 6f 72 00                 Unex Vector.

00001266 <_ZZ11task_clientPvE3__c_2>:
    1266:	50 69 6e 67 20 72 65 73 75 6c 74 20 25 64 20 5b     Ping result %d [
    1276:	6d 73 5d 0d 0a 00                                   ms]...

0000127c <_ZZ11task_clientPvE3__c_1>:
    127c:	50 69 6e 67 20 46 61 69 6c 65 64 0a 00              Ping Failed..

00001289 <_ZZ11task_clientPvE3__c_0>:
    1289:	53 50 20 3d 20 30 78 25 30 34 78 0a 00              SP = 0x%04x..

00001296 <_ZZ11task_clientPvE3__c>:
    1296:	25 73 20 25 64 0a 00                                %s %d..

0000129d <_ZZ11task_serverPvE3__c_0>:
    129d:	50 61 63 6b 65 74 20 72 65 63 65 69 76 65 64 20     Packet received 
    12ad:	6f 6e 20 4d 59 5f 50 4f 52 54 3a 20 25 73 0d 0a     on MY_PORT: %s..
	...

000012be <_ZZ11task_serverPvE3__c>:
    12be:	25 73 20 25 64 0a 00                                %s %d..

000012c5 <_ZZ4mainE3__c_0>:
    12c5:	49 6e 74 65 72 66 61 63 65 73 0d 0a 00              Interfaces...

000012d2 <_ZZ4mainE3__c>:
    12d2:	45 72 72 6f 72 20 52 65 73 65 74 0a 00 00           Error Reset...

000012e0 <__ctors_start>:
    12e0:	f2 0b       	sbc	r31, r18

000012e2 <__ctors_end>:
    12e2:	11 24       	eor	r1, r1
    12e4:	1f be       	out	0x3f, r1	; 63
    12e6:	cf ef       	ldi	r28, 0xFF	; 255
    12e8:	d1 e2       	ldi	r29, 0x21	; 33
    12ea:	de bf       	out	0x3e, r29	; 62
    12ec:	cd bf       	out	0x3d, r28	; 61
    12ee:	00 e0       	ldi	r16, 0x00	; 0
    12f0:	0c bf       	out	0x3c, r16	; 60

000012f2 <__do_copy_data>:
    12f2:	13 e0       	ldi	r17, 0x03	; 3
    12f4:	a0 e0       	ldi	r26, 0x00	; 0
    12f6:	b2 e0       	ldi	r27, 0x02	; 2
    12f8:	ea ef       	ldi	r30, 0xFA	; 250
    12fa:	ff e8       	ldi	r31, 0x8F	; 143
    12fc:	00 e0       	ldi	r16, 0x00	; 0
    12fe:	0b bf       	out	0x3b, r16	; 59
    1300:	02 c0       	rjmp	.+4      	; 0x1306 <__do_copy_data+0x14>
    1302:	07 90       	elpm	r0, Z+
    1304:	0d 92       	st	X+, r0
    1306:	ae 31       	cpi	r26, 0x1E	; 30
    1308:	b1 07       	cpc	r27, r17
    130a:	d9 f7       	brne	.-10     	; 0x1302 <__do_copy_data+0x10>

0000130c <__do_clear_bss>:
    130c:	20 e2       	ldi	r18, 0x20	; 32
    130e:	ae e1       	ldi	r26, 0x1E	; 30
    1310:	b3 e0       	ldi	r27, 0x03	; 3
    1312:	01 c0       	rjmp	.+2      	; 0x1316 <.do_clear_bss_start>

00001314 <.do_clear_bss_loop>:
    1314:	1d 92       	st	X+, r1

00001316 <.do_clear_bss_start>:
    1316:	ad 37       	cpi	r26, 0x7D	; 125
    1318:	b2 07       	cpc	r27, r18
    131a:	e1 f7       	brne	.-8      	; 0x1314 <.do_clear_bss_loop>

0000131c <__do_global_ctors>:
    131c:	19 e0       	ldi	r17, 0x09	; 9
    131e:	c1 e7       	ldi	r28, 0x71	; 113
    1320:	d9 e0       	ldi	r29, 0x09	; 9
    1322:	00 e0       	ldi	r16, 0x00	; 0
    1324:	06 c0       	rjmp	.+12     	; 0x1332 <__do_global_ctors+0x16>
    1326:	21 97       	sbiw	r28, 0x01	; 1
    1328:	01 09       	sbc	r16, r1
    132a:	80 2f       	mov	r24, r16
    132c:	fe 01       	movw	r30, r28
    132e:	0e 94 16 42 	call	0x842c	; 0x842c <__tablejump2__>
    1332:	c0 37       	cpi	r28, 0x70	; 112
    1334:	d1 07       	cpc	r29, r17
    1336:	80 e0       	ldi	r24, 0x00	; 0
    1338:	08 07       	cpc	r16, r24
    133a:	a9 f7       	brne	.-22     	; 0x1326 <__do_global_ctors+0xa>
    133c:	cd d3       	rcall	.+1946   	; 0x1ad8 <main>
    133e:	0c 94 fb 47 	jmp	0x8ff6	; 0x8ff6 <_exit>

00001342 <__bad_interrupt>:
    1342:	b8 c4       	rjmp	.+2416   	; 0x1cb4 <__vector_default>

00001344 <can_init>:
	
#define RETRY_NO 8



int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
    1344:	8f 92       	push	r8
    1346:	9f 92       	push	r9
    1348:	af 92       	push	r10
    134a:	bf 92       	push	r11
    134c:	cf 92       	push	r12
    134e:	df 92       	push	r13
    1350:	ef 92       	push	r14
    1352:	ff 92       	push	r15
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	6b 01       	movw	r12, r22
    135e:	7c 01       	movw	r14, r24
    1360:	49 01       	movw	r8, r18
    1362:	5a 01       	movw	r10, r20
	int error = 0;
	portENTER_CRITICAL();
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	0f 92       	push	r0
		SPI.begin();
    136a:	0e 94 9d 14 	call	0x293a	; 0x293a <_ZN8SPIClass5beginEv>
			errorfunc(mcp2515.reset(),error);
    136e:	80 ef       	ldi	r24, 0xF0	; 240
    1370:	93 e0       	ldi	r25, 0x03	; 3
    1372:	cd d5       	rcall	.+2970   	; 0x1f0e <_ZN7MCP25155resetEv>
    1374:	d8 2f       	mov	r29, r24
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    1376:	6f e0       	ldi	r22, 0x0F	; 15
    1378:	80 ef       	ldi	r24, 0xF0	; 240
    137a:	93 e0       	ldi	r25, 0x03	; 3
    137c:	0e 94 d6 11 	call	0x23ac	; 0x23ac <_ZN7MCP251510setBitrateE9CAN_SPEED>
    1380:	81 11       	cpse	r24, r1
    1382:	0b c0       	rjmp	.+22     	; 0x139a <can_init+0x56>

int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
	int error = 0;
	portENTER_CRITICAL();
		SPI.begin();
			errorfunc(mcp2515.reset(),error);
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	d1 11       	cpse	r29, r1
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <can_init+0x4c>
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	cc 27       	eor	r28, r28
    1392:	dd 27       	eor	r29, r29
    1394:	c8 1b       	sub	r28, r24
    1396:	d9 0b       	sbc	r29, r25
    1398:	02 c0       	rjmp	.+4      	; 0x139e <can_init+0x5a>
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    139a:	cf ef       	ldi	r28, 0xFF	; 255
    139c:	df ef       	ldi	r29, 0xFF	; 255
			//printf(" mask = %lx",mask);
			//while(1);
			errorfunc(mcp2515.setFilterMask(MCP2515::MASK0,1,mask),error);
    139e:	95 01       	movw	r18, r10
    13a0:	84 01       	movw	r16, r8
    13a2:	41 e0       	ldi	r20, 0x01	; 1
    13a4:	60 e0       	ldi	r22, 0x00	; 0
    13a6:	80 ef       	ldi	r24, 0xF0	; 240
    13a8:	93 e0       	ldi	r25, 0x03	; 3
    13aa:	0e 94 29 12 	call	0x2452	; 0x2452 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    13ae:	88 23       	and	r24, r24
    13b0:	11 f0       	breq	.+4      	; 0x13b6 <can_init+0x72>
    13b2:	cf ef       	ldi	r28, 0xFF	; 255
    13b4:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilterMask(MCP2515::MASK1,1,mask),error);
    13b6:	95 01       	movw	r18, r10
    13b8:	84 01       	movw	r16, r8
    13ba:	41 e0       	ldi	r20, 0x01	; 1
    13bc:	61 e0       	ldi	r22, 0x01	; 1
    13be:	80 ef       	ldi	r24, 0xF0	; 240
    13c0:	93 e0       	ldi	r25, 0x03	; 3
    13c2:	0e 94 29 12 	call	0x2452	; 0x2452 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    13c6:	88 23       	and	r24, r24
    13c8:	11 f0       	breq	.+4      	; 0x13ce <can_init+0x8a>
    13ca:	cf ef       	ldi	r28, 0xFF	; 255
    13cc:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF0,1,id),error);
    13ce:	97 01       	movw	r18, r14
    13d0:	86 01       	movw	r16, r12
    13d2:	41 e0       	ldi	r20, 0x01	; 1
    13d4:	60 e0       	ldi	r22, 0x00	; 0
    13d6:	80 ef       	ldi	r24, 0xF0	; 240
    13d8:	93 e0       	ldi	r25, 0x03	; 3
    13da:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <_ZN7MCP25159setFilterENS_3RXFEbm>
    13de:	88 23       	and	r24, r24
    13e0:	11 f0       	breq	.+4      	; 0x13e6 <can_init+0xa2>
    13e2:	cf ef       	ldi	r28, 0xFF	; 255
    13e4:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF2,1,id),error);
    13e6:	97 01       	movw	r18, r14
    13e8:	86 01       	movw	r16, r12
    13ea:	41 e0       	ldi	r20, 0x01	; 1
    13ec:	62 e0       	ldi	r22, 0x02	; 2
    13ee:	80 ef       	ldi	r24, 0xF0	; 240
    13f0:	93 e0       	ldi	r25, 0x03	; 3
    13f2:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <_ZN7MCP25159setFilterENS_3RXFEbm>
    13f6:	88 23       	and	r24, r24
    13f8:	11 f0       	breq	.+4      	; 0x13fe <can_init+0xba>
    13fa:	cf ef       	ldi	r28, 0xFF	; 255
    13fc:	df ef       	ldi	r29, 0xFF	; 255
			errorfunc(mcp2515.setNormalMode(),error);
    13fe:	80 ef       	ldi	r24, 0xF0	; 240
    1400:	93 e0       	ldi	r25, 0x03	; 3
    1402:	26 d6       	rcall	.+3148   	; 0x2050 <_ZN7MCP251513setNormalModeEv>
    1404:	88 23       	and	r24, r24
    1406:	11 f0       	breq	.+4      	; 0x140c <can_init+0xc8>
    1408:	cf ef       	ldi	r28, 0xFF	; 255
    140a:	df ef       	ldi	r29, 0xFF	; 255
			
	portEXIT_CRITICAL();
    140c:	0f 90       	pop	r0
    140e:	0f be       	out	0x3f, r0	; 63
			


			
	return error;
}
    1410:	ce 01       	movw	r24, r28
    1412:	df 91       	pop	r29
    1414:	cf 91       	pop	r28
    1416:	1f 91       	pop	r17
    1418:	0f 91       	pop	r16
    141a:	ff 90       	pop	r15
    141c:	ef 90       	pop	r14
    141e:	df 90       	pop	r13
    1420:	cf 90       	pop	r12
    1422:	bf 90       	pop	r11
    1424:	af 90       	pop	r10
    1426:	9f 90       	pop	r9
    1428:	8f 90       	pop	r8
    142a:	08 95       	ret

0000142c <can_send>:


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    142c:	cf 92       	push	r12
    142e:	df 92       	push	r13
    1430:	ef 92       	push	r14
    1432:	ff 92       	push	r15
    1434:	0f 93       	push	r16
    1436:	1f 93       	push	r17
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    1440:	cd b6       	in	r12, 0x3d	; 61
    1442:	de b6       	in	r13, 0x3e	; 62
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    1444:	ed b7       	in	r30, 0x3d	; 61
    1446:	fe b7       	in	r31, 0x3e	; 62
    1448:	77 97       	sbiw	r30, 0x17	; 23
    144a:	0f b6       	in	r0, 0x3f	; 63
    144c:	f8 94       	cli
    144e:	fe bf       	out	0x3e, r31	; 62
    1450:	0f be       	out	0x3f, r0	; 63
    1452:	ed bf       	out	0x3d, r30	; 61
    1454:	ed b6       	in	r14, 0x3d	; 61
    1456:	fe b6       	in	r15, 0x3e	; 62
    1458:	f8 e0       	ldi	r31, 0x08	; 8
    145a:	ef 0e       	add	r14, r31
    145c:	f1 1c       	adc	r15, r1
    145e:	38 ef       	ldi	r19, 0xF8	; 248
    1460:	e3 22       	and	r14, r19
	int error=0;
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
    1462:	0f b6       	in	r0, 0x3f	; 63
    1464:	f8 94       	cli
    1466:	0f 92       	push	r0
	canMsg.can_id=id | CAN_EFF_FLAG;
    1468:	dc 01       	movw	r26, r24
    146a:	cb 01       	movw	r24, r22
    146c:	b0 68       	ori	r27, 0x80	; 128
    146e:	f7 01       	movw	r30, r14
    1470:	80 83       	st	Z, r24
    1472:	91 83       	std	Z+1, r25	; 0x01
    1474:	a2 83       	std	Z+2, r26	; 0x02
    1476:	b3 83       	std	Z+3, r27	; 0x03
	canMsg.can_dlc=dlc;
    1478:	24 83       	std	Z+4, r18	; 0x04
	for (int i=0;i<dlc;i++) {
    147a:	22 23       	and	r18, r18
    147c:	09 f4       	brne	.+2      	; 0x1480 <can_send+0x54>
    147e:	3f c0       	rjmp	.+126    	; 0x14fe <can_send+0xd2>
    1480:	a4 2f       	mov	r26, r20
    1482:	b5 2f       	mov	r27, r21
    1484:	38 96       	adiw	r30, 0x08	; 8
    1486:	30 e0       	ldi	r19, 0x00	; 0
    1488:	28 5f       	subi	r18, 0xF8	; 248
    148a:	3f 4f       	sbci	r19, 0xFF	; 255
    148c:	2e 0d       	add	r18, r14
    148e:	3f 1d       	adc	r19, r15
	
		canMsg.data[i]=*(data+i);
    1490:	8d 91       	ld	r24, X+
    1492:	81 93       	st	Z+, r24
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
	canMsg.can_id=id | CAN_EFF_FLAG;
	canMsg.can_dlc=dlc;
	for (int i=0;i<dlc;i++) {
    1494:	e2 17       	cp	r30, r18
    1496:	f3 07       	cpc	r31, r19
    1498:	d9 f7       	brne	.-10     	; 0x1490 <can_send+0x64>
    149a:	31 c0       	rjmp	.+98     	; 0x14fe <can_send+0xd2>
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
	if(mcp2515.checktxava()==MCP2515::ERROR_OK){
    149c:	80 ef       	ldi	r24, 0xF0	; 240
    149e:	93 e0       	ldi	r25, 0x03	; 3
    14a0:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7MCP251510checktxavaEv>
    14a4:	81 11       	cpse	r24, r1
    14a6:	16 c0       	rjmp	.+44     	; 0x14d4 <can_send+0xa8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14a8:	8f e8       	ldi	r24, 0x8F	; 143
    14aa:	91 e0       	ldi	r25, 0x01	; 1
    14ac:	01 97       	sbiw	r24, 0x01	; 1
    14ae:	f1 f7       	brne	.-4      	; 0x14ac <can_send+0x80>
    14b0:	00 c0       	rjmp	.+0      	; 0x14b2 <can_send+0x86>
    14b2:	00 00       	nop
		_delay_us(100); //magic number because even if the MCP2515 reports complete tx it can ignore if data written too quickly
			errorfunc(mcp2515.sendMessage(tx0,&canMsg),error);
    14b4:	a7 01       	movw	r20, r14
    14b6:	60 e0       	ldi	r22, 0x00	; 0
    14b8:	80 ef       	ldi	r24, 0xF0	; 240
    14ba:	93 e0       	ldi	r25, 0x03	; 3
    14bc:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    14c0:	01 e0       	ldi	r16, 0x01	; 1
    14c2:	10 e0       	ldi	r17, 0x00	; 0
    14c4:	81 11       	cpse	r24, r1
    14c6:	02 c0       	rjmp	.+4      	; 0x14cc <can_send+0xa0>
    14c8:	00 e0       	ldi	r16, 0x00	; 0
    14ca:	10 e0       	ldi	r17, 0x00	; 0
    14cc:	11 95       	neg	r17
    14ce:	01 95       	neg	r16
    14d0:	11 09       	sbc	r17, r1
    14d2:	05 c0       	rjmp	.+10     	; 0x14de <can_send+0xb2>
    14d4:	01 50       	subi	r16, 0x01	; 1
    14d6:	11 09       	sbc	r17, r1
	for (int i=0;i<dlc;i++) {
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
    14d8:	09 f7       	brne	.-62     	; 0x149c <can_send+0x70>
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
	int error=0;
    14da:	00 e0       	ldi	r16, 0x00	; 0
    14dc:	10 e0       	ldi	r17, 0x00	; 0
		break;
		}
	}*/
	
	
	portEXIT_CRITICAL();
    14de:	0f 90       	pop	r0
    14e0:	0f be       	out	0x3f, r0	; 63
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
    14e2:	01 15       	cp	r16, r1
    14e4:	11 05       	cpc	r17, r1
    14e6:	71 f0       	breq	.+28     	; 0x1504 <can_send+0xd8>
    14e8:	81 ee       	ldi	r24, 0xE1	; 225
    14ea:	91 e0       	ldi	r25, 0x01	; 1
    14ec:	9f 93       	push	r25
    14ee:	8f 93       	push	r24
    14f0:	1f 92       	push	r1
    14f2:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	0f 90       	pop	r0
	return error;
    14fc:	03 c0       	rjmp	.+6      	; 0x1504 <can_send+0xd8>
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    14fe:	08 e0       	ldi	r16, 0x08	; 8
    1500:	10 e0       	ldi	r17, 0x00	; 0
    1502:	cc cf       	rjmp	.-104    	; 0x149c <can_send+0x70>
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    1504:	c8 01       	movw	r24, r16
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	de be       	out	0x3e, r13	; 62
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	cd be       	out	0x3d, r12	; 61
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	df 90       	pop	r13
    151e:	cf 90       	pop	r12
    1520:	08 95       	ret

00001522 <CanRxFunc>:


void CanRxFunc(void* pvParameters) {
	

	DDRD&=~(1<<PD2);
    1522:	52 98       	cbi	0x0a, 2	; 10
	EICRA|=(2<<ISC20);
    1524:	e9 e6       	ldi	r30, 0x69	; 105
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	80 81       	ld	r24, Z
    152a:	80 62       	ori	r24, 0x20	; 32
    152c:	80 83       	st	Z, r24
	EIMSK|=(1<<INT2);
    152e:	ea 9a       	sbi	0x1d, 2	; 29
	
	mcp2515.clearInterrupts();
    1530:	80 ef       	ldi	r24, 0xF0	; 240
    1532:	93 e0       	ldi	r25, 0x03	; 3
    1534:	0e 94 76 14 	call	0x28ec	; 0x28ec <_ZN7MCP251515clearInterruptsEv>

	for(;;){
		

		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1538:	0f 2e       	mov	r0, r31
    153a:	fa ed       	ldi	r31, 0xDA	; 218
    153c:	2f 2e       	mov	r2, r31
    153e:	f1 e0       	ldi	r31, 0x01	; 1
    1540:	3f 2e       	mov	r3, r31
    1542:	f0 2d       	mov	r31, r0
    1544:	68 94       	set
    1546:	88 24       	eor	r8, r8
    1548:	81 f8       	bld	r8, 1
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
    154a:	0f 2e       	mov	r0, r31
    154c:	f6 e0       	ldi	r31, 0x06	; 6
    154e:	9f 2e       	mov	r9, r31
    1550:	f0 2d       	mov	r31, r0
    1552:	0f 2e       	mov	r0, r31
    1554:	f9 e7       	ldi	r31, 0x79	; 121
    1556:	cf 2e       	mov	r12, r31
    1558:	f3 e0       	ldi	r31, 0x03	; 3
    155a:	df 2e       	mov	r13, r31
    155c:	f0 2d       	mov	r31, r0
	

	for(;;){
		

		mcp2515.clearInterrupts();
    155e:	80 ef       	ldi	r24, 0xF0	; 240
    1560:	93 e0       	ldi	r25, 0x03	; 3
    1562:	0e 94 76 14 	call	0x28ec	; 0x28ec <_ZN7MCP251515clearInterruptsEv>
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	0e 94 b6 3b 	call	0x776c	; 0x776c <uxTaskGetStackHighWaterMark2>
    156e:	c8 2f       	mov	r28, r24
    1570:	d9 2f       	mov	r29, r25
    1572:	80 e0       	ldi	r24, 0x00	; 0
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    157a:	df 93       	push	r29
    157c:	cf 93       	push	r28
    157e:	9f 93       	push	r25
    1580:	8f 93       	push	r24
    1582:	3f 92       	push	r3
    1584:	2f 92       	push	r2
    1586:	8f 92       	push	r8
    1588:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		vTaskSuspend(NULL);
    158c:	80 e0       	ldi	r24, 0x00	; 0
    158e:	90 e0       	ldi	r25, 0x00	; 0
    1590:	0e 94 59 3e 	call	0x7cb2	; 0x7cb2 <vTaskSuspend>
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int dlcsum=0;
			portENTER_CRITICAL();
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	0f 92       	push	r0
			timeoutstart(MAX_DELAY); // 256*n/16M for time
    159a:	8e e3       	ldi	r24, 0x3E	; 62
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	7a d1       	rcall	.+756    	; 0x1894 <_Z12timeoutstarti>
    15a0:	8d b7       	in	r24, 0x3d	; 61
    15a2:	9e b7       	in	r25, 0x3e	; 62
    15a4:	07 96       	adiw	r24, 0x07	; 7
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	f8 94       	cli
    15aa:	9e bf       	out	0x3e, r25	; 62
    15ac:	0f be       	out	0x3f, r0	; 63
    15ae:	8d bf       	out	0x3d, r24	; 61
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int dlcsum=0;
    15b0:	a1 2c       	mov	r10, r1
    15b2:	b1 2c       	mov	r11, r1
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
    15b4:	e1 2c       	mov	r14, r1
		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
    15b6:	f1 2c       	mov	r15, r1

		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
    15b8:	09 2d       	mov	r16, r9
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int dlcsum=0;
			portENTER_CRITICAL();
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
    15ba:	10 e0       	ldi	r17, 0x00	; 0
    15bc:	8d d1       	rcall	.+794    	; 0x18d8 <_Z12timeoutcheckv>
    15be:	89 2b       	or	r24, r25
    15c0:	61 f5       	brne	.+88     	; 0x161a <CanRxFunc+0xf8>
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
    15c2:	c1 2f       	mov	r28, r17
    15c4:	d0 e0       	ldi	r29, 0x00	; 0
    15c6:	be 01       	movw	r22, r28
    15c8:	62 95       	swap	r22
    15ca:	72 95       	swap	r23
    15cc:	70 7f       	andi	r23, 0xF0	; 240
    15ce:	76 27       	eor	r23, r22
    15d0:	60 7f       	andi	r22, 0xF0	; 240
    15d2:	76 27       	eor	r23, r22
    15d4:	60 58       	subi	r22, 0x80	; 128
    15d6:	7c 4f       	sbci	r23, 0xFC	; 252
    15d8:	80 ef       	ldi	r24, 0xF0	; 240
    15da:	93 e0       	ldi	r25, 0x03	; 3
    15dc:	0e 94 42 14 	call	0x2884	; 0x2884 <_ZN7MCP251511readMessageEP9can_frame>
    15e0:	81 11       	cpse	r24, r1
    15e2:	19 c0       	rjmp	.+50     	; 0x1616 <CanRxFunc+0xf4>
    15e4:	e1 14       	cp	r14, r1
    15e6:	f1 04       	cpc	r15, r1
    15e8:	09 f4       	brne	.+2      	; 0x15ec <CanRxFunc+0xca>
    15ea:	df c0       	rjmp	.+446    	; 0x17aa <CanRxFunc+0x288>
    15ec:	14 c0       	rjmp	.+40     	; 0x1616 <CanRxFunc+0xf4>
					dlcsum+=frame[count].can_dlc;
					 uint32_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
						//csp_log_info("t= %lx\n",test);
						if (begin!=1||count==0) { //if it is a begin frame
    15ee:	11 11       	cpse	r17, r1
    15f0:	10 c0       	rjmp	.+32     	; 0x1612 <CanRxFunc+0xf0>
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
    15f2:	07 2e       	mov	r0, r23
    15f4:	7a e0       	ldi	r23, 0x0A	; 10
    15f6:	b6 95       	lsr	r27
    15f8:	a7 95       	ror	r26
    15fa:	97 95       	ror	r25
    15fc:	87 95       	ror	r24
    15fe:	7a 95       	dec	r23
    1600:	d1 f7       	brne	.-12     	; 0x15f6 <CanRxFunc+0xd4>
    1602:	70 2d       	mov	r23, r0
    1604:	08 2f       	mov	r16, r24
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
    1606:	87 30       	cpi	r24, 0x07	; 7
    1608:	20 f0       	brcs	.+8      	; 0x1612 <CanRxFunc+0xf0>
								error=1;
    160a:	ee 24       	eor	r14, r14
    160c:	e3 94       	inc	r14
							}

					
						} else if (count==0) { break;} // if its the first frame received and not a begin frame, break
						if (error==1) {count=1;}
    160e:	f1 2c       	mov	r15, r1

						count++; // increment number of messages received
    1610:	11 e0       	ldi	r17, 0x01	; 1
						timeoutreset(); //if there is a new message, reset the timer
    1612:	1f 5f       	subi	r17, 0xFF	; 255
    1614:	5c d1       	rcall	.+696    	; 0x18ce <_Z12timeoutresetv>
					}		
					if (count>remain){break;} // this is used to break out of the timeout if we've received all frames or if there's too many
    1616:	01 17       	cp	r16, r17
    1618:	88 f6       	brcc	.-94     	; 0x15bc <CanRxFunc+0x9a>
			}
			portEXIT_CRITICAL();
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
			csp_log_info("DLC = %d",dlcsum);
    161e:	bf 92       	push	r11
    1620:	af 92       	push	r10
    1622:	a1 ed       	ldi	r26, 0xD1	; 209
    1624:	b1 e0       	ldi	r27, 0x01	; 1
    1626:	bf 93       	push	r27
    1628:	af 93       	push	r26
    162a:	8f 92       	push	r8
    162c:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			if(error!=0) { // if too many frames come it, it wont process them. saves time handling these useless requests
    1630:	0f 90       	pop	r0
    1632:	0f 90       	pop	r0
    1634:	0f 90       	pop	r0
    1636:	0f 90       	pop	r0
    1638:	0f 90       	pop	r0
    163a:	ef 28       	or	r14, r15
    163c:	59 f0       	breq	.+22     	; 0x1654 <CanRxFunc+0x132>
 				csp_log_error("Too Many Frames");
    163e:	81 ec       	ldi	r24, 0xC1	; 193
    1640:	91 e0       	ldi	r25, 0x01	; 1
    1642:	9f 93       	push	r25
    1644:	8f 93       	push	r24
    1646:	1f 92       	push	r1
    1648:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	85 cf       	rjmp	.-246    	; 0x155e <CanRxFunc+0x3c>
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
    1654:	c1 2f       	mov	r28, r17
    1656:	d0 e0       	ldi	r29, 0x00	; 0
    1658:	1f 92       	push	r1
    165a:	1f 93       	push	r17
    165c:	e4 eb       	ldi	r30, 0xB4	; 180
    165e:	f1 e0       	ldi	r31, 0x01	; 1
    1660:	ff 93       	push	r31
    1662:	ef 93       	push	r30
    1664:	8f 92       	push	r8
    1666:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			for (int i=0;i<count;i++){
    166a:	0f 90       	pop	r0
    166c:	0f 90       	pop	r0
    166e:	0f 90       	pop	r0
    1670:	0f 90       	pop	r0
    1672:	0f 90       	pop	r0
    1674:	1c 16       	cp	r1, r28
    1676:	1d 06       	cpc	r1, r29
    1678:	e4 f5       	brge	.+120    	; 0x16f2 <CanRxFunc+0x1d0>
    167a:	20 e8       	ldi	r18, 0x80	; 128
    167c:	33 e0       	ldi	r19, 0x03	; 3
    167e:	80 e1       	ldi	r24, 0x10	; 16
    1680:	18 9f       	mul	r17, r24
    1682:	a0 01       	movw	r20, r0
    1684:	11 24       	eor	r1, r1
    1686:	40 58       	subi	r20, 0x80	; 128
    1688:	5c 4f       	sbci	r21, 0xFC	; 252
				
				//csp_log_info("pos = %d",pos);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    168a:	7d e0       	ldi	r23, 0x0D	; 13
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
				uint8_t pos = count-((uint8_t)((frame[i].can_id >> 10) & 0xFF))-1;
    168c:	d9 01       	movw	r26, r18
    168e:	4d 90       	ld	r4, X+
    1690:	5d 90       	ld	r5, X+
    1692:	6d 90       	ld	r6, X+
    1694:	7c 90       	ld	r7, X
    1696:	d3 01       	movw	r26, r6
    1698:	c2 01       	movw	r24, r4
    169a:	07 2e       	mov	r0, r23
    169c:	7a e0       	ldi	r23, 0x0A	; 10
    169e:	b6 95       	lsr	r27
    16a0:	a7 95       	ror	r26
    16a2:	97 95       	ror	r25
    16a4:	87 95       	ror	r24
    16a6:	7a 95       	dec	r23
    16a8:	d1 f7       	brne	.-12     	; 0x169e <CanRxFunc+0x17c>
    16aa:	70 2d       	mov	r23, r0
    16ac:	80 95       	com	r24
    16ae:	81 0f       	add	r24, r17
				
				//csp_log_info("pos = %d",pos);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    16b0:	78 9f       	mul	r23, r24
    16b2:	f0 01       	movw	r30, r0
    16b4:	11 24       	eor	r1, r1
    16b6:	e2 5e       	subi	r30, 0xE2	; 226
    16b8:	fc 4f       	sbci	r31, 0xFC	; 252
    16ba:	40 82       	st	Z, r4
    16bc:	51 82       	std	Z+1, r5	; 0x01
    16be:	62 82       	std	Z+2, r6	; 0x02
    16c0:	73 82       	std	Z+3, r7	; 0x03
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
    16c2:	d9 01       	movw	r26, r18
    16c4:	14 96       	adiw	r26, 0x04	; 4
    16c6:	6c 91       	ld	r22, X
    16c8:	14 97       	sbiw	r26, 0x04	; 4
    16ca:	64 83       	std	Z+4, r22	; 0x04
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    16cc:	66 23       	and	r22, r22
    16ce:	61 f0       	breq	.+24     	; 0x16e8 <CanRxFunc+0x1c6>
    16d0:	18 96       	adiw	r26, 0x08	; 8
    16d2:	78 9f       	mul	r23, r24
    16d4:	f0 01       	movw	r30, r0
    16d6:	11 24       	eor	r1, r1
    16d8:	ed 5d       	subi	r30, 0xDD	; 221
    16da:	fc 4f       	sbci	r31, 0xFC	; 252
    16dc:	80 e0       	ldi	r24, 0x00	; 0
						frameo[pos].data[a]=frame[i].data[a];
    16de:	9d 91       	ld	r25, X+
    16e0:	91 93       	st	Z+, r25
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    16e2:	8f 5f       	subi	r24, 0xFF	; 255
    16e4:	68 13       	cpse	r22, r24
    16e6:	fb cf       	rjmp	.-10     	; 0x16de <CanRxFunc+0x1bc>
    16e8:	20 5f       	subi	r18, 0xF0	; 240
    16ea:	3f 4f       	sbci	r19, 0xFF	; 255
 				csp_log_error("Too Many Frames");
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
    16ec:	24 17       	cp	r18, r20
    16ee:	35 07       	cpc	r19, r21
    16f0:	69 f6       	brne	.-102    	; 0x168c <CanRxFunc+0x16a>
						csp_log_info(" %x",frameo[count].data[a]);
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	0f 92       	push	r0
			for (int i=0;i<count;i++){ //send of the frames to be processed
    16f8:	1c 16       	cp	r1, r28
    16fa:	1d 06       	cpc	r1, r29
    16fc:	b4 f5       	brge	.+108    	; 0x176a <CanRxFunc+0x248>
    16fe:	0e e1       	ldi	r16, 0x1E	; 30
    1700:	13 e0       	ldi	r17, 0x03	; 3
    1702:	a1 2c       	mov	r10, r1
    1704:	b1 2c       	mov	r11, r1
				if(i==count-1){
    1706:	7e 01       	movw	r14, r28
    1708:	b1 e0       	ldi	r27, 0x01	; 1
    170a:	eb 1a       	sub	r14, r27
    170c:	f1 08       	sbc	r15, r1
    170e:	ea 14       	cp	r14, r10
    1710:	fb 04       	cpc	r15, r11
    1712:	91 f4       	brne	.+36     	; 0x1738 <CanRxFunc+0x216>
					if(csp_can_rx_frame(&frameo[i],"CAN")!=0) {csp_log_reset("queue fail");}
    1714:	66 e8       	ldi	r22, 0x86	; 134
    1716:	72 e0       	ldi	r23, 0x02	; 2
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 0c 21 	call	0x4218	; 0x4218 <csp_can_rx_frame>
    171e:	89 2b       	or	r24, r25
    1720:	e1 f0       	breq	.+56     	; 0x175a <CanRxFunc+0x238>
    1722:	e9 ea       	ldi	r30, 0xA9	; 169
    1724:	f1 e0       	ldi	r31, 0x01	; 1
    1726:	ff 93       	push	r31
    1728:	ef 93       	push	r30
    172a:	9f 92       	push	r9
    172c:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	0f 90       	pop	r0
    1736:	11 c0       	rjmp	.+34     	; 0x175a <CanRxFunc+0x238>
				} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
    1738:	60 e0       	ldi	r22, 0x00	; 0
    173a:	70 e0       	ldi	r23, 0x00	; 0
    173c:	c8 01       	movw	r24, r16
    173e:	0e 94 0c 21 	call	0x4218	; 0x4218 <csp_can_rx_frame>
    1742:	89 2b       	or	r24, r25
    1744:	51 f0       	breq	.+20     	; 0x175a <CanRxFunc+0x238>
    1746:	8e e9       	ldi	r24, 0x9E	; 158
    1748:	91 e0       	ldi	r25, 0x01	; 1
    174a:	9f 93       	push	r25
    174c:	8f 93       	push	r24
    174e:	9f 92       	push	r9
    1750:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    1754:	0f 90       	pop	r0
    1756:	0f 90       	pop	r0
    1758:	0f 90       	pop	r0
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
			for (int i=0;i<count;i++){ //send of the frames to be processed
    175a:	bf ef       	ldi	r27, 0xFF	; 255
    175c:	ab 1a       	sub	r10, r27
    175e:	bb 0a       	sbc	r11, r27
    1760:	03 5f       	subi	r16, 0xF3	; 243
    1762:	1f 4f       	sbci	r17, 0xFF	; 255
    1764:	ca 15       	cp	r28, r10
    1766:	db 05       	cpc	r29, r11
    1768:	91 f6       	brne	.-92     	; 0x170e <CanRxFunc+0x1ec>
				} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
				}
				
			}
			portEXIT_CRITICAL();
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63
    176e:	8e e1       	ldi	r24, 0x1E	; 30
    1770:	93 e0       	ldi	r25, 0x03	; 3
    1772:	c0 e8       	ldi	r28, 0x80	; 128
    1774:	d3 e0       	ldi	r29, 0x03	; 3
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
    1776:	fc 01       	movw	r30, r24
    1778:	10 82       	st	Z, r1
    177a:	11 82       	std	Z+1, r1	; 0x01
    177c:	12 82       	std	Z+2, r1	; 0x02
    177e:	13 82       	std	Z+3, r1	; 0x03
				frame[i].can_id=0;
    1780:	18 82       	st	Y, r1
    1782:	19 82       	std	Y+1, r1	; 0x01
    1784:	1a 82       	std	Y+2, r1	; 0x02
    1786:	1b 82       	std	Y+3, r1	; 0x03
				frameo[i].dlc=0;
    1788:	14 82       	std	Z+4, r1	; 0x04
				frame[i].can_dlc=0;
    178a:	1c 82       	std	Y+4, r1	; 0x04
    178c:	dc 01       	movw	r26, r24
    178e:	15 96       	adiw	r26, 0x05	; 5
    1790:	fe 01       	movw	r30, r28
    1792:	38 96       	adiw	r30, 0x08	; 8
    1794:	60 96       	adiw	r28, 0x10	; 16
				for (int a=0;a<8;a++) {
					frameo[i].data[a]=0;
    1796:	1d 92       	st	X+, r1
					frame[i].data[a]=0;
    1798:	11 92       	st	Z+, r1
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
				frame[i].can_id=0;
				frameo[i].dlc=0;
				frame[i].can_dlc=0;
				for (int a=0;a<8;a++) {
    179a:	ec 17       	cp	r30, r28
    179c:	fd 07       	cpc	r31, r29
    179e:	d9 f7       	brne	.-10     	; 0x1796 <CanRxFunc+0x274>
    17a0:	0d 96       	adiw	r24, 0x0d	; 13
				}
				
			}
			portEXIT_CRITICAL();
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
    17a2:	8c 15       	cp	r24, r12
    17a4:	9d 05       	cpc	r25, r13
    17a6:	39 f7       	brne	.-50     	; 0x1776 <CanRxFunc+0x254>
    17a8:	da ce       	rjmp	.-588    	; 0x155e <CanRxFunc+0x3c>
			portENTER_CRITICAL();
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
					dlcsum+=frame[count].can_dlc;
    17aa:	c2 95       	swap	r28
    17ac:	d2 95       	swap	r29
    17ae:	d0 7f       	andi	r29, 0xF0	; 240
    17b0:	dc 27       	eor	r29, r28
    17b2:	c0 7f       	andi	r28, 0xF0	; 240
    17b4:	dc 27       	eor	r29, r28
    17b6:	c0 58       	subi	r28, 0x80	; 128
    17b8:	dc 4f       	sbci	r29, 0xFC	; 252
    17ba:	8c 81       	ldd	r24, Y+4	; 0x04
    17bc:	a8 0e       	add	r10, r24
    17be:	b1 1c       	adc	r11, r1
					 uint32_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
    17c0:	88 81       	ld	r24, Y
    17c2:	99 81       	ldd	r25, Y+1	; 0x01
    17c4:	aa 81       	ldd	r26, Y+2	; 0x02
    17c6:	bb 81       	ldd	r27, Y+3	; 0x03
						//csp_log_info("t= %lx\n",test);
						if (begin!=1||count==0) { //if it is a begin frame
    17c8:	ac 01       	movw	r20, r24
    17ca:	bd 01       	movw	r22, r26
    17cc:	03 2e       	mov	r0, r19
    17ce:	32 e1       	ldi	r19, 0x12	; 18
    17d0:	76 95       	lsr	r23
    17d2:	67 95       	ror	r22
    17d4:	57 95       	ror	r21
    17d6:	47 95       	ror	r20
    17d8:	3a 95       	dec	r19
    17da:	d1 f7       	brne	.-12     	; 0x17d0 <CanRxFunc+0x2ae>
    17dc:	30 2d       	mov	r19, r0
    17de:	40 ff       	sbrs	r20, 0
    17e0:	08 cf       	rjmp	.-496    	; 0x15f2 <CanRxFunc+0xd0>

//static csp_queue_handle_t csp_can_rx_queue;



MCP2515 mcp2515;
    17e2:	05 cf       	rjmp	.-502    	; 0x15ee <CanRxFunc+0xcc>

000017e4 <_GLOBAL__sub_I_mcp2515>:
    17e4:	80 ef       	ldi	r24, 0xF0	; 240
    17e6:	93 e0       	ldi	r25, 0x03	; 3
    17e8:	b1 c2       	rjmp	.+1378   	; 0x1d4c <_ZN7MCP2515C1Ev>
    17ea:	08 95       	ret

000017ec <_Z10enableledsv>:
#include <avr/interrupt.h>

int leden=0;

void enableleds(void) {
	DDRD|= (1<<PD5) | (1<<PD6) | (1<<PD7);
    17ec:	8a b1       	in	r24, 0x0a	; 10
    17ee:	80 6e       	ori	r24, 0xE0	; 224
    17f0:	8a b9       	out	0x0a, r24	; 10
	leden=1;
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	90 93 75 06 	sts	0x0675, r25	; 0x800675 <leden+0x1>
    17fa:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <leden>
    17fe:	08 95       	ret

00001800 <_Z7contledii>:
}

void contled(int con, int led) {
	if (leden==0) {return;}
    1800:	20 91 74 06 	lds	r18, 0x0674	; 0x800674 <leden>
    1804:	30 91 75 06 	lds	r19, 0x0675	; 0x800675 <leden+0x1>
    1808:	23 2b       	or	r18, r19
    180a:	c1 f1       	breq	.+112    	; 0x187c <_Z7contledii+0x7c>
	char tarled = 0;
	switch (led)
    180c:	61 30       	cpi	r22, 0x01	; 1
    180e:	71 05       	cpc	r23, r1
    1810:	39 f0       	breq	.+14     	; 0x1820 <_Z7contledii+0x20>
    1812:	62 30       	cpi	r22, 0x02	; 2
    1814:	71 05       	cpc	r23, r1
    1816:	31 f0       	breq	.+12     	; 0x1824 <_Z7contledii+0x24>
    1818:	67 2b       	or	r22, r23
    181a:	31 f4       	brne	.+12     	; 0x1828 <_Z7contledii+0x28>
	{
	case 0 : tarled = PD5;
    181c:	25 e0       	ldi	r18, 0x05	; 5
    181e:	05 c0       	rjmp	.+10     	; 0x182a <_Z7contledii+0x2a>
		break;
	case 1 : tarled = PD6;
    1820:	26 e0       	ldi	r18, 0x06	; 6
		break;
    1822:	03 c0       	rjmp	.+6      	; 0x182a <_Z7contledii+0x2a>
	case 2 : tarled = PD7;
    1824:	27 e0       	ldi	r18, 0x07	; 7
		break;
    1826:	01 c0       	rjmp	.+2      	; 0x182a <_Z7contledii+0x2a>
	leden=1;
}

void contled(int con, int led) {
	if (leden==0) {return;}
	char tarled = 0;
    1828:	20 e0       	ldi	r18, 0x00	; 0
	case 1 : tarled = PD6;
		break;
	case 2 : tarled = PD7;
		break;
	}
		switch (con)
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	91 05       	cpc	r25, r1
    182e:	81 f0       	breq	.+32     	; 0x1850 <_Z7contledii+0x50>
    1830:	82 30       	cpi	r24, 0x02	; 2
    1832:	91 05       	cpc	r25, r1
    1834:	c1 f0       	breq	.+48     	; 0x1866 <_Z7contledii+0x66>
    1836:	89 2b       	or	r24, r25
    1838:	09 f5       	brne	.+66     	; 0x187c <_Z7contledii+0x7c>
		{
	case 0 : PORTD ^= (1<<tarled);
    183a:	3b b1       	in	r19, 0x0b	; 11
    183c:	81 e0       	ldi	r24, 0x01	; 1
    183e:	90 e0       	ldi	r25, 0x00	; 0
    1840:	02 c0       	rjmp	.+4      	; 0x1846 <_Z7contledii+0x46>
    1842:	88 0f       	add	r24, r24
    1844:	99 1f       	adc	r25, r25
    1846:	2a 95       	dec	r18
    1848:	e2 f7       	brpl	.-8      	; 0x1842 <_Z7contledii+0x42>
    184a:	83 27       	eor	r24, r19
    184c:	8b b9       	out	0x0b, r24	; 11
		break;
    184e:	08 95       	ret
	case 1 : PORTD |= (1<<tarled);
    1850:	3b b1       	in	r19, 0x0b	; 11
    1852:	81 e0       	ldi	r24, 0x01	; 1
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	02 c0       	rjmp	.+4      	; 0x185c <_Z7contledii+0x5c>
    1858:	88 0f       	add	r24, r24
    185a:	99 1f       	adc	r25, r25
    185c:	2a 95       	dec	r18
    185e:	e2 f7       	brpl	.-8      	; 0x1858 <_Z7contledii+0x58>
    1860:	83 2b       	or	r24, r19
    1862:	8b b9       	out	0x0b, r24	; 11
		break;
    1864:	08 95       	ret
	case 2 : PORTD &= ~(1<<tarled);
    1866:	3b b1       	in	r19, 0x0b	; 11
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	02 c0       	rjmp	.+4      	; 0x1872 <_Z7contledii+0x72>
    186e:	88 0f       	add	r24, r24
    1870:	99 1f       	adc	r25, r25
    1872:	2a 95       	dec	r18
    1874:	e2 f7       	brpl	.-8      	; 0x186e <_Z7contledii+0x6e>
    1876:	80 95       	com	r24
    1878:	83 23       	and	r24, r19
    187a:	8b b9       	out	0x0b, r24	; 11
    187c:	08 95       	ret

0000187e <_Z10pwrredinitv>:
	}
	
}

void pwrredinit(void) {
	PRR0|=0b01100000; //shuts down TIM0 and 2
    187e:	e4 e6       	ldi	r30, 0x64	; 100
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	80 81       	ld	r24, Z
    1884:	80 66       	ori	r24, 0x60	; 96
    1886:	80 83       	st	Z, r24
	PRR1|=0b00111111; //shuts down TIM3-5 and USART1-3
    1888:	e5 e6       	ldi	r30, 0x65	; 101
    188a:	f0 e0       	ldi	r31, 0x00	; 0
    188c:	80 81       	ld	r24, Z
    188e:	8f 63       	ori	r24, 0x3F	; 63
    1890:	80 83       	st	Z, r24
    1892:	08 95       	ret

00001894 <_Z12timeoutstarti>:
	
}

void timeoutstart(int tim) {
    1894:	9c 01       	movw	r18, r24
	// remember power save
	cli();
    1896:	f8 94       	cli
	PRR1&=~(1<<PRTIM3);
    1898:	e5 e6       	ldi	r30, 0x65	; 101
    189a:	f0 e0       	ldi	r31, 0x00	; 0
    189c:	90 81       	ld	r25, Z
    189e:	97 7f       	andi	r25, 0xF7	; 247
    18a0:	90 83       	st	Z, r25
	
	TCCR3A = 0;
    18a2:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
	TCCR3B = 0;
    18a6:	e1 e9       	ldi	r30, 0x91	; 145
    18a8:	f0 e0       	ldi	r31, 0x00	; 0
    18aa:	10 82       	st	Z, r1
	TCNT3 = 0;
    18ac:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    18b0:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	
	OCR3A=tim;
    18b4:	30 93 99 00 	sts	0x0099, r19	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    18b8:	20 93 98 00 	sts	0x0098, r18	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	
	TCCR3B|=(1<<WGM32);	
    18bc:	80 81       	ld	r24, Z
    18be:	88 60       	ori	r24, 0x08	; 8
    18c0:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS32);
    18c2:	80 81       	ld	r24, Z
    18c4:	84 60       	ori	r24, 0x04	; 4
    18c6:	80 83       	st	Z, r24
	TIFR3|=(1<<OCF3A);
    18c8:	c1 9a       	sbi	0x18, 1	; 24
	sei();
    18ca:	78 94       	sei
    18cc:	08 95       	ret

000018ce <_Z12timeoutresetv>:
	
}

void timeoutreset(void) {
		TCNT3 = 0;
    18ce:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    18d2:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
    18d6:	08 95       	ret

000018d8 <_Z12timeoutcheckv>:
}

int timeoutcheck(void) {
	
	if((TIFR3&2)>>OCF3A) {
    18d8:	28 b3       	in	r18, 0x18	; 24
    18da:	21 fb       	bst	r18, 1
    18dc:	88 27       	eor	r24, r24
    18de:	80 f9       	bld	r24, 0
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	21 ff       	sbrs	r18, 1
    18e4:	11 c0       	rjmp	.+34     	; 0x1908 <_Z12timeoutcheckv+0x30>
		cli();
    18e6:	f8 94       	cli
			TCCR3A = 0;
    18e8:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
			TCCR3B = 0;
    18ec:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x7c0091>
			TCNT3 = 0;
    18f0:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    18f4:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
			TIFR3&=~(1<<OCF3A);
    18f8:	c1 98       	cbi	0x18, 1	; 24
			PRR1|=(1<<PRTIM3);
    18fa:	e5 e6       	ldi	r30, 0x65	; 101
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	88 60       	ori	r24, 0x08	; 8
    1902:	80 83       	st	Z, r24
			sei();
    1904:	78 94       	sei
		return 1;
    1906:	81 e0       	ldi	r24, 0x01	; 1
	} else {
		return 0;
		}
return 0;
}
    1908:	08 95       	ret

0000190a <_ZL4wdtrPv>:
	return 0;
}
/*-----------------------------------------------------------*/

static void wdtr(void* pvParameters) {
	 wdt_reset();
    190a:	a8 95       	wdr
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
    190c:	9d e0       	ldi	r25, 0x0D	; 13
    190e:	88 e1       	ldi	r24, 0x18	; 24
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	a8 95       	wdr
    1916:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
	 wdt_enable(WDTO_500MS);
	 
	 int a =0;
	 
	for(;;) {
	wdt_reset();
    1920:	a8 95       	wdr
	vTaskDelay(200/ portTICK_PERIOD_MS);
    1922:	84 e1       	ldi	r24, 0x14	; 20
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	0e 94 c3 39 	call	0x7386	; 0x7386 <vTaskDelay>
	contled(TOGCON,0);
    192a:	60 e0       	ldi	r22, 0x00	; 0
    192c:	70 e0       	ldi	r23, 0x00	; 0
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	66 df       	rcall	.-308    	; 0x1800 <_Z7contledii>
    1934:	f5 cf       	rjmp	.-22     	; 0x1920 <_ZL4wdtrPv+0x16>

00001936 <_Z11task_serverPv>:


CSP_DEFINE_TASK(task_server) {

	/* Create socket without any socket options */
	csp_socket_t *sock = csp_socket(CSP_SO_NONE);
    1936:	60 e0       	ldi	r22, 0x00	; 0
    1938:	70 e0       	ldi	r23, 0x00	; 0
    193a:	cb 01       	movw	r24, r22
    193c:	0e 94 50 22 	call	0x44a0	; 0x44a0 <csp_socket>
    1940:	7c 01       	movw	r14, r24
	//usart_pstr_p(PSTR("server task init"),1);
	/* Bind all ports to socket */
	csp_bind(sock, CSP_ANY);
    1942:	60 e2       	ldi	r22, 0x20	; 32
    1944:	0e 94 b5 24 	call	0x496a	; 0x496a <csp_bind>

	/* Create 10 connections backlog queue */
	csp_listen(sock, 10);
    1948:	6a e0       	ldi	r22, 0x0A	; 10
    194a:	70 e0       	ldi	r23, 0x00	; 0
    194c:	c7 01       	movw	r24, r14
    194e:	0e 94 99 24 	call	0x4932	; 0x4932 <csp_listen>
	csp_conn_t *conn;
	csp_packet_t *packet;

	/* Process incoming connections */
	for(;;) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1952:	0e eb       	ldi	r16, 0xBE	; 190
    1954:	12 e1       	ldi	r17, 0x12	; 18
    1956:	68 94       	set
    1958:	99 24       	eor	r9, r9
    195a:	91 f8       	bld	r9, 1
		while ((packet = csp_read(conn, 100)) != NULL) {
			
			switch (csp_conn_dport(conn)) {
			case MY_PORT:
				/* Process packet here */
				printf("Packet received on MY_PORT: %s\r\n", (char *) packet->data);
    195c:	0f 2e       	mov	r0, r31
    195e:	fd e9       	ldi	r31, 0x9D	; 157
    1960:	cf 2e       	mov	r12, r31
    1962:	f2 e1       	ldi	r31, 0x12	; 18
    1964:	df 2e       	mov	r13, r31
    1966:	f0 2d       	mov	r31, r0
	csp_conn_t *conn;
	csp_packet_t *packet;

	/* Process incoming connections */
	for(;;) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1968:	80 e0       	ldi	r24, 0x00	; 0
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	0e 94 b6 3b 	call	0x776c	; 0x776c <uxTaskGetStackHighWaterMark2>
    1970:	c8 2f       	mov	r28, r24
    1972:	d9 2f       	mov	r29, r25
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    197c:	df 93       	push	r29
    197e:	cf 93       	push	r28
    1980:	9f 93       	push	r25
    1982:	8f 93       	push	r24
    1984:	1f 93       	push	r17
    1986:	0f 93       	push	r16
    1988:	9f 92       	push	r9
    198a:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>

		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
    198e:	40 e1       	ldi	r20, 0x10	; 16
    1990:	57 e2       	ldi	r21, 0x27	; 39
    1992:	60 e0       	ldi	r22, 0x00	; 0
    1994:	70 e0       	ldi	r23, 0x00	; 0
    1996:	c7 01       	movw	r24, r14
    1998:	0e 94 bd 22 	call	0x457a	; 0x457a <csp_accept>
    199c:	ec 01       	movw	r28, r24
    199e:	8d b7       	in	r24, 0x3d	; 61
    19a0:	9e b7       	in	r25, 0x3e	; 62
    19a2:	07 96       	adiw	r24, 0x07	; 7
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	9e bf       	out	0x3e, r25	; 62
    19aa:	0f be       	out	0x3f, r0	; 63
    19ac:	8d bf       	out	0x3d, r24	; 61
    19ae:	20 97       	sbiw	r28, 0x00	; 0
    19b0:	d9 f2       	breq	.-74     	; 0x1968 <_Z11task_serverPv+0x32>
			continue;

		/* Read packets. Timout is 100 ms */
		while ((packet = csp_read(conn, 100)) != NULL) {
    19b2:	44 e6       	ldi	r20, 0x64	; 100
    19b4:	50 e0       	ldi	r21, 0x00	; 0
    19b6:	60 e0       	ldi	r22, 0x00	; 0
    19b8:	70 e0       	ldi	r23, 0x00	; 0
    19ba:	ce 01       	movw	r24, r28
    19bc:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <csp_read>
    19c0:	5c 01       	movw	r10, r24
    19c2:	89 2b       	or	r24, r25
    19c4:	d1 f0       	breq	.+52     	; 0x19fa <_Z11task_serverPv+0xc4>
			
			switch (csp_conn_dport(conn)) {
    19c6:	ce 01       	movw	r24, r28
    19c8:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <csp_conn_dport>
    19cc:	0a 97       	sbiw	r24, 0x0a	; 10
    19ce:	81 f4       	brne	.+32     	; 0x19f0 <_Z11task_serverPv+0xba>
			case MY_PORT:
				/* Process packet here */
				printf("Packet received on MY_PORT: %s\r\n", (char *) packet->data);
    19d0:	c5 01       	movw	r24, r10
    19d2:	0e 96       	adiw	r24, 0x0e	; 14
    19d4:	9f 93       	push	r25
    19d6:	8f 93       	push	r24
    19d8:	df 92       	push	r13
    19da:	cf 92       	push	r12
    19dc:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
				
				
				
				csp_buffer_free(packet);
    19e0:	c5 01       	movw	r24, r10
    19e2:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
				break;
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	0f 90       	pop	r0
    19ec:	0f 90       	pop	r0
    19ee:	e1 cf       	rjmp	.-62     	; 0x19b2 <_Z11task_serverPv+0x7c>

			default:
				/* Let the service handler reply pings, buffer use, etc. */
			
				csp_service_handler(conn, packet);
    19f0:	b5 01       	movw	r22, r10
    19f2:	ce 01       	movw	r24, r28
    19f4:	0e 94 a5 2a 	call	0x554a	; 0x554a <csp_service_handler>
				break;
    19f8:	dc cf       	rjmp	.-72     	; 0x19b2 <_Z11task_serverPv+0x7c>
			}
		}

		/* Close current connection, and handle next */
		csp_close(conn);
    19fa:	ce 01       	movw	r24, r28
    19fc:	0e 94 c7 18 	call	0x318e	; 0x318e <csp_close>
    1a00:	b3 cf       	rjmp	.-154    	; 0x1968 <_Z11task_serverPv+0x32>

00001a02 <_Z11task_clientPv>:
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1a02:	0f 2e       	mov	r0, r31
    1a04:	f6 e9       	ldi	r31, 0x96	; 150
    1a06:	af 2e       	mov	r10, r31
    1a08:	f2 e1       	ldi	r31, 0x12	; 18
    1a0a:	bf 2e       	mov	r11, r31
    1a0c:	f0 2d       	mov	r31, r0
    1a0e:	12 e0       	ldi	r17, 0x02	; 2
		volatile unsigned int *sp=(volatile unsigned int *)SP;
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
		csp_log_info("SP = 0x%04x\n",StackP);;
    1a10:	0f 2e       	mov	r0, r31
    1a12:	f9 e8       	ldi	r31, 0x89	; 137
    1a14:	cf 2e       	mov	r12, r31
    1a16:	f2 e1       	ldi	r31, 0x12	; 18
    1a18:	df 2e       	mov	r13, r31
    1a1a:	f0 2d       	mov	r31, r0
		int result = csp_ping(1, 100, 10, CSP_O_NONE);

		if (result==-1) {csp_log_error("Ping Failed\n");}
    1a1c:	0f 2e       	mov	r0, r31
    1a1e:	fc e7       	ldi	r31, 0x7C	; 124
    1a20:	8f 2e       	mov	r8, r31
    1a22:	f2 e1       	ldi	r31, 0x12	; 18
    1a24:	9f 2e       	mov	r9, r31
    1a26:	f0 2d       	mov	r31, r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    1a28:	0f 2e       	mov	r0, r31
    1a2a:	f6 e6       	ldi	r31, 0x66	; 102
    1a2c:	ef 2e       	mov	r14, r31
    1a2e:	f2 e1       	ldi	r31, 0x12	; 18
    1a30:	ff 2e       	mov	r15, r31
    1a32:	f0 2d       	mov	r31, r0
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	0e 94 b6 3b 	call	0x776c	; 0x776c <uxTaskGetStackHighWaterMark2>
    1a3c:	c8 2f       	mov	r28, r24
    1a3e:	d9 2f       	mov	r29, r25
    1a40:	80 e0       	ldi	r24, 0x00	; 0
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    1a48:	df 93       	push	r29
    1a4a:	cf 93       	push	r28
    1a4c:	9f 93       	push	r25
    1a4e:	8f 93       	push	r24
    1a50:	bf 92       	push	r11
    1a52:	af 92       	push	r10
    1a54:	1f 93       	push	r17
    1a56:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		csp_sleep_ms(1000);
    1a5a:	84 e6       	ldi	r24, 0x64	; 100
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	0e 94 c3 39 	call	0x7386	; 0x7386 <vTaskDelay>
		
		//int *sph = 0x3E;
		//volatile unsigned int *sph = (volatile unsigned int *)0x5E;
		//volatile unsigned int *spl = (volatile unsigned int *)0x5D;
		volatile unsigned int *sp=(volatile unsigned int *)SP;
    1a62:	ed b7       	in	r30, 0x3d	; 61
    1a64:	fe b7       	in	r31, 0x3e	; 62
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
    1a66:	80 81       	ld	r24, Z
    1a68:	91 81       	ldd	r25, Z+1	; 0x01
		csp_log_info("SP = 0x%04x\n",StackP);;
    1a6a:	9f 93       	push	r25
    1a6c:	8f 93       	push	r24
    1a6e:	df 92       	push	r13
    1a70:	cf 92       	push	r12
    1a72:	1f 93       	push	r17
    1a74:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		int result = csp_ping(1, 100, 10, CSP_O_NONE);
    1a78:	00 e0       	ldi	r16, 0x00	; 0
    1a7a:	2a e0       	ldi	r18, 0x0A	; 10
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	44 e6       	ldi	r20, 0x64	; 100
    1a80:	50 e0       	ldi	r21, 0x00	; 0
    1a82:	60 e0       	ldi	r22, 0x00	; 0
    1a84:	70 e0       	ldi	r23, 0x00	; 0
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <csp_ping>
    1a8c:	ec 01       	movw	r28, r24

		if (result==-1) {csp_log_error("Ping Failed\n");}
    1a8e:	8d b7       	in	r24, 0x3d	; 61
    1a90:	9e b7       	in	r25, 0x3e	; 62
    1a92:	0c 96       	adiw	r24, 0x0c	; 12
    1a94:	0f b6       	in	r0, 0x3f	; 63
    1a96:	f8 94       	cli
    1a98:	9e bf       	out	0x3e, r25	; 62
    1a9a:	0f be       	out	0x3f, r0	; 63
    1a9c:	8d bf       	out	0x3d, r24	; 61
    1a9e:	cf 3f       	cpi	r28, 0xFF	; 255
    1aa0:	9f ef       	ldi	r25, 0xFF	; 255
    1aa2:	d9 07       	cpc	r29, r25
    1aa4:	41 f4       	brne	.+16     	; 0x1ab6 <_Z11task_clientPv+0xb4>
    1aa6:	9f 92       	push	r9
    1aa8:	8f 92       	push	r8
    1aaa:	1f 92       	push	r1
    1aac:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    1ab0:	0f 90       	pop	r0
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    1ab6:	df 93       	push	r29
    1ab8:	cf 93       	push	r28
    1aba:	ff 92       	push	r15
    1abc:	ef 92       	push	r14
    1abe:	1f 93       	push	r17
    1ac0:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>

		csp_sleep_ms(1000);
    1ac4:	84 e6       	ldi	r24, 0x64	; 100
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	0e 94 c3 39 	call	0x7386	; 0x7386 <vTaskDelay>

	csp_packet_t * packet;
	csp_conn_t * conn;
	//usart_pstr_p(PSTR("client task init"),1);

	for(;;) {
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	0f 90       	pop	r0
    1ad4:	0f 90       	pop	r0
    1ad6:	ae cf       	rjmp	.-164    	; 0x1a34 <_Z11task_clientPv+0x32>

00001ad8 <main>:
	};
	
	static void wdtr(void* pvParameters);

int main( void )
{
    1ad8:	cf 92       	push	r12
    1ada:	df 92       	push	r13
    1adc:	ef 92       	push	r14
    1ade:	ff 92       	push	r15
    1ae0:	0f 93       	push	r16
    1ae2:	1f 93       	push	r17
    1ae4:	cf 93       	push	r28
    1ae6:	df 93       	push	r29
    1ae8:	00 d0       	rcall	.+0      	; 0x1aea <main+0x12>
    1aea:	1f 92       	push	r1
    1aec:	cd b7       	in	r28, 0x3d	; 61
    1aee:	de b7       	in	r29, 0x3e	; 62
    1af0:	9d e0       	ldi	r25, 0x0D	; 13
    1af2:	88 e1       	ldi	r24, 0x18	; 24
    1af4:	0f b6       	in	r0, 0x3f	; 63
    1af6:	f8 94       	cli
    1af8:	a8 95       	wdr
    1afa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
	
	
	
	wdt_enable(WDTO_500MS); // set watchdog up to reset if not called after 2s
	//pwrredinit();
	enableleds();
    1b04:	73 de       	rcall	.-794    	; 0x17ec <_Z10enableledsv>

fdevopen( &usart_putchar_printf,0);
    1b06:	60 e0       	ldi	r22, 0x00	; 0
    1b08:	70 e0       	ldi	r23, 0x00	; 0
    1b0a:	80 e4       	ldi	r24, 0x40	; 64
    1b0c:	95 e1       	ldi	r25, 0x15	; 21
    1b0e:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fdevopen>

usart_init(MYUBRR);
    1b12:	83 e0       	ldi	r24, 0x03	; 3
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	9c d7       	rcall	.+3896   	; 0x2a50 <usart_init>


		int error=0;
		
		error+=csp_buffer_init(4, MSGMAX);
    1b18:	62 e3       	ldi	r22, 0x32	; 50
    1b1a:	70 e0       	ldi	r23, 0x00	; 0
    1b1c:	84 e0       	ldi	r24, 0x04	; 4
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	bb d7       	rcall	.+3958   	; 0x2a98 <csp_buffer_init>
    1b22:	6c 01       	movw	r12, r24

	
		// Init CSP with address MY_ADDRESS 
		error+=csp_init(MY_ADDRESS);
    1b24:	86 e0       	ldi	r24, 0x06	; 6
    1b26:	0e 94 2a 22 	call	0x4454	; 0x4454 <csp_init>
    1b2a:	c8 0e       	add	r12, r24
    1b2c:	d9 1e       	adc	r13, r25
		
		error+=csp_can_init(0,&can_conf);
    1b2e:	6c e7       	ldi	r22, 0x7C	; 124
    1b30:	72 e0       	ldi	r23, 0x02	; 2
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	0e 94 1e 21 	call	0x423c	; 0x423c <csp_can_init>
    1b38:	c8 0e       	add	r12, r24
    1b3a:	d9 1e       	adc	r13, r25
		
		error+=csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_can, 0xFF);
    1b3c:	2f ef       	ldi	r18, 0xFF	; 255
    1b3e:	42 e1       	ldi	r20, 0x12	; 18
    1b40:	52 e0       	ldi	r21, 0x02	; 2
    1b42:	65 e0       	ldi	r22, 0x05	; 5
    1b44:	80 e2       	ldi	r24, 0x20	; 32
    1b46:	0e 94 2c 29 	call	0x5258	; 0x5258 <csp_rtable_set>
    1b4a:	c8 0e       	add	r12, r24
    1b4c:	d9 1e       	adc	r13, r25

		// Start router task with 500 word stack, OS task priority 1 		
		error+=csp_route_start_task(180, 1);
    1b4e:	61 e0       	ldi	r22, 0x01	; 1
    1b50:	70 e0       	ldi	r23, 0x00	; 0
    1b52:	84 eb       	ldi	r24, 0xB4	; 180
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	0e 94 c2 28 	call	0x5184	; 0x5184 <csp_route_start_task>
    1b5a:	c8 0e       	add	r12, r24
    1b5c:	d9 1e       	adc	r13, r25
	
		
		csp_thread_handle_t handle_server;
		error+=csp_thread_create(task_server, "SERVER", 220, NULL, 2, &handle_server);
    1b5e:	ce 01       	movw	r24, r28
    1b60:	01 96       	adiw	r24, 0x01	; 1
    1b62:	7c 01       	movw	r14, r24
    1b64:	02 e0       	ldi	r16, 0x02	; 2
    1b66:	10 e0       	ldi	r17, 0x00	; 0
    1b68:	20 e0       	ldi	r18, 0x00	; 0
    1b6a:	30 e0       	ldi	r19, 0x00	; 0
    1b6c:	4c ed       	ldi	r20, 0xDC	; 220
    1b6e:	50 e0       	ldi	r21, 0x00	; 0
    1b70:	6d ec       	ldi	r22, 0xCD	; 205
    1b72:	72 e0       	ldi	r23, 0x02	; 2
    1b74:	8b e9       	ldi	r24, 0x9B	; 155
    1b76:	9c e0       	ldi	r25, 0x0C	; 12
    1b78:	0e 94 01 2e 	call	0x5c02	; 0x5c02 <csp_thread_create>
    1b7c:	c8 0e       	add	r12, r24
    1b7e:	d9 1e       	adc	r13, r25

		// Client 
		
		csp_thread_handle_t handle_client;
		error+=csp_thread_create(task_client, "CLIENT", 220, NULL, 1, &handle_client);
    1b80:	ce 01       	movw	r24, r28
    1b82:	03 96       	adiw	r24, 0x03	; 3
    1b84:	7c 01       	movw	r14, r24
    1b86:	01 e0       	ldi	r16, 0x01	; 1
    1b88:	10 e0       	ldi	r17, 0x00	; 0
    1b8a:	20 e0       	ldi	r18, 0x00	; 0
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	4c ed       	ldi	r20, 0xDC	; 220
    1b90:	50 e0       	ldi	r21, 0x00	; 0
    1b92:	64 ed       	ldi	r22, 0xD4	; 212
    1b94:	72 e0       	ldi	r23, 0x02	; 2
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	9d e0       	ldi	r25, 0x0D	; 13
    1b9a:	0e 94 01 2e 	call	0x5c02	; 0x5c02 <csp_thread_create>
    1b9e:	c8 0e       	add	r12, r24
    1ba0:	d9 1e       	adc	r13, r25
		
		//csp_log_reset("test");
		error+=csp_thread_create(CanRxFunc,"CANRX",180,NULL,3,&handle_canrx);
    1ba2:	0f 2e       	mov	r0, r31
    1ba4:	f6 ee       	ldi	r31, 0xE6	; 230
    1ba6:	ef 2e       	mov	r14, r31
    1ba8:	ff e1       	ldi	r31, 0x1F	; 31
    1baa:	ff 2e       	mov	r15, r31
    1bac:	f0 2d       	mov	r31, r0
    1bae:	03 e0       	ldi	r16, 0x03	; 3
    1bb0:	10 e0       	ldi	r17, 0x00	; 0
    1bb2:	20 e0       	ldi	r18, 0x00	; 0
    1bb4:	30 e0       	ldi	r19, 0x00	; 0
    1bb6:	44 eb       	ldi	r20, 0xB4	; 180
    1bb8:	50 e0       	ldi	r21, 0x00	; 0
    1bba:	6b ed       	ldi	r22, 0xDB	; 219
    1bbc:	72 e0       	ldi	r23, 0x02	; 2
    1bbe:	81 e9       	ldi	r24, 0x91	; 145
    1bc0:	9a e0       	ldi	r25, 0x0A	; 10
    1bc2:	0e 94 01 2e 	call	0x5c02	; 0x5c02 <csp_thread_create>
		
		if(error!=0) {
    1bc6:	8c 0d       	add	r24, r12
    1bc8:	9d 1d       	adc	r25, r13
    1bca:	89 2b       	or	r24, r25
    1bcc:	81 f0       	breq	.+32     	; 0x1bee <main+0x116>
			contled(ONCON,2);
    1bce:	62 e0       	ldi	r22, 0x02	; 2
    1bd0:	70 e0       	ldi	r23, 0x00	; 0
    1bd2:	81 e0       	ldi	r24, 0x01	; 1
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	14 de       	rcall	.-984    	; 0x1800 <_Z7contledii>
			FORCERESET
    1bd8:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
    1bdc:	82 ed       	ldi	r24, 0xD2	; 210
    1bde:	92 e1       	ldi	r25, 0x12	; 18
    1be0:	9f 93       	push	r25
    1be2:	8f 93       	push	r24
    1be4:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	ff cf       	rjmp	.-2      	; 0x1bec <main+0x114>
		//csp_conn_print_table();

		//printf("Route table\r\n");
		//csp_route_print_table();

		printf("Interfaces\r\n");
    1bee:	85 ec       	ldi	r24, 0xC5	; 197
    1bf0:	92 e1       	ldi	r25, 0x12	; 18
    1bf2:	9f 93       	push	r25
    1bf4:	8f 93       	push	r24
    1bf6:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
		csp_route_print_interfaces();
    1bfa:	0e 94 40 1c 	call	0x3880	; 0x3880 <csp_iflist_print>
		
		
		xTaskCreate(wdtr,"WDT",configMINIMAL_STACK_SIZE,NULL,3,NULL);
    1bfe:	e1 2c       	mov	r14, r1
    1c00:	f1 2c       	mov	r15, r1
    1c02:	03 e0       	ldi	r16, 0x03	; 3
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	30 e0       	ldi	r19, 0x00	; 0
    1c08:	44 e6       	ldi	r20, 0x64	; 100
    1c0a:	50 e0       	ldi	r21, 0x00	; 0
    1c0c:	61 ee       	ldi	r22, 0xE1	; 225
    1c0e:	72 e0       	ldi	r23, 0x02	; 2
    1c10:	85 e8       	ldi	r24, 0x85	; 133
    1c12:	9c e0       	ldi	r25, 0x0C	; 12
    1c14:	0e 94 af 36 	call	0x6d5e	; 0x6d5e <xTaskCreate>
		//while(1);
	 	 //xTaskCreate(TaskBlinkserial, "blinks", 128, NULL, 3, NULL);
	// usart_pstr_p(PSTR("LED init"),1);


	vTaskStartScheduler();
    1c18:	0e 94 5e 38 	call	0x70bc	; 0x70bc <vTaskStartScheduler>
	
	

	return 0;
}
    1c1c:	80 e0       	ldi	r24, 0x00	; 0
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	0f 90       	pop	r0
    1c22:	0f 90       	pop	r0
    1c24:	0f 90       	pop	r0
    1c26:	0f 90       	pop	r0
    1c28:	0f 90       	pop	r0
    1c2a:	0f 90       	pop	r0
    1c2c:	df 91       	pop	r29
    1c2e:	cf 91       	pop	r28
    1c30:	1f 91       	pop	r17
    1c32:	0f 91       	pop	r16
    1c34:	ff 90       	pop	r15
    1c36:	ef 90       	pop	r14
    1c38:	df 90       	pop	r13
    1c3a:	cf 90       	pop	r12
    1c3c:	08 95       	ret

00001c3e <__vector_3>:
	vTaskDelete(NULL);
}



ISR(INT2_vect){
    1c3e:	1f 92       	push	r1
    1c40:	0f 92       	push	r0
    1c42:	0f b6       	in	r0, 0x3f	; 63
    1c44:	0f 92       	push	r0
    1c46:	11 24       	eor	r1, r1
    1c48:	0b b6       	in	r0, 0x3b	; 59
    1c4a:	0f 92       	push	r0
    1c4c:	2f 93       	push	r18
    1c4e:	3f 93       	push	r19
    1c50:	4f 93       	push	r20
    1c52:	5f 93       	push	r21
    1c54:	6f 93       	push	r22
    1c56:	7f 93       	push	r23
    1c58:	8f 93       	push	r24
    1c5a:	9f 93       	push	r25
    1c5c:	af 93       	push	r26
    1c5e:	bf 93       	push	r27
    1c60:	ef 93       	push	r30
    1c62:	ff 93       	push	r31
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	1f 92       	push	r1
    1c6a:	cd b7       	in	r28, 0x3d	; 61
    1c6c:	de b7       	in	r29, 0x3e	; 62
	//if((PORTB&PB5)>>PB5) return;
		
	PCIFR&=~(1<<PCIF0);
    1c6e:	d8 98       	cbi	0x1b, 0	; 27
	//while(1);

	volatile BaseType_t xYieldRequired;

	 // Resume the suspended task.
	 xYieldRequired = xTaskResumeFromISR(handle_canrx);
    1c70:	80 91 e6 1f 	lds	r24, 0x1FE6	; 0x801fe6 <handle_canrx>
    1c74:	90 91 e7 1f 	lds	r25, 0x1FE7	; 0x801fe7 <handle_canrx+0x1>
    1c78:	0e 94 07 38 	call	0x700e	; 0x700e <xTaskResumeFromISR>
    1c7c:	89 83       	std	Y+1, r24	; 0x01

	 if( xYieldRequired == pdTRUE )
    1c7e:	89 81       	ldd	r24, Y+1	; 0x01
    1c80:	81 30       	cpi	r24, 0x01	; 1
    1c82:	11 f4       	brne	.+4      	; 0x1c88 <__vector_3+0x4a>
	 {
		 // We should switch context so the ISR returns to a different task.
		 // NOTE:  How this is done depends on the port you are using.  Check
		 // the documentation and examples for your port.
		 taskYIELD();
    1c84:	0e 94 fb 30 	call	0x61f6	; 0x61f6 <vPortYield>
	 }

}
    1c88:	0f 90       	pop	r0
    1c8a:	df 91       	pop	r29
    1c8c:	cf 91       	pop	r28
    1c8e:	ff 91       	pop	r31
    1c90:	ef 91       	pop	r30
    1c92:	bf 91       	pop	r27
    1c94:	af 91       	pop	r26
    1c96:	9f 91       	pop	r25
    1c98:	8f 91       	pop	r24
    1c9a:	7f 91       	pop	r23
    1c9c:	6f 91       	pop	r22
    1c9e:	5f 91       	pop	r21
    1ca0:	4f 91       	pop	r20
    1ca2:	3f 91       	pop	r19
    1ca4:	2f 91       	pop	r18
    1ca6:	0f 90       	pop	r0
    1ca8:	0b be       	out	0x3b, r0	; 59
    1caa:	0f 90       	pop	r0
    1cac:	0f be       	out	0x3f, r0	; 63
    1cae:	0f 90       	pop	r0
    1cb0:	1f 90       	pop	r1
    1cb2:	18 95       	reti

00001cb4 <__vector_default>:
}



ISR(BADISR_vect)
{
    1cb4:	1f 92       	push	r1
    1cb6:	0f 92       	push	r0
    1cb8:	0f b6       	in	r0, 0x3f	; 63
    1cba:	0f 92       	push	r0
    1cbc:	11 24       	eor	r1, r1
	//FORCERESET
 printf("Unex Vector");
    1cbe:	8a e5       	ldi	r24, 0x5A	; 90
    1cc0:	92 e1       	ldi	r25, 0x12	; 18
    1cc2:	9f 93       	push	r25
    1cc4:	8f 93       	push	r24
    1cc6:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
	FORCERESET
    1cca:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
    1cce:	8d e4       	ldi	r24, 0x4D	; 77
    1cd0:	92 e1       	ldi	r25, 0x12	; 18
    1cd2:	9f 93       	push	r25
    1cd4:	8f 93       	push	r24
    1cd6:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	0f 90       	pop	r0
    1ce0:	0f 90       	pop	r0
    1ce2:	ff cf       	rjmp	.-2      	; 0x1ce2 <__vector_default+0x2e>

00001ce4 <_ZN7MCP25158startSPIEv>:
    // Compensate for the duplicate fosc/64
    if (clockDiv == 6)
    clockDiv = 7;

    // Invert the SPI2X bit
    clockDiv ^= 0x1;
    1ce4:	81 e0       	ldi	r24, 0x01	; 1
    1ce6:	80 93 e8 1f 	sts	0x1FE8, r24	; 0x801fe8 <_ZZN11SPISettings17init_AlwaysInlineEmhhE8clockDiv>

  // Before using SPI.transfer() or asserting chip select pins,
  // this function is used to gain exclusive access to the SPI bus
  // and configure the correct settings.
  inline static void beginTransaction(SPISettings settings) {
    if (interruptMode > 0) {
    1cea:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    1cee:	88 23       	and	r24, r24
    1cf0:	99 f0       	breq	.+38     	; 0x1d18 <_ZN7MCP25158startSPIEv+0x34>
      uint8_t sreg = SREG;
    1cf2:	8f b7       	in	r24, 0x3f	; 63
      cli();
    1cf4:	f8 94       	cli

      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    1cf6:	90 91 ef 1f 	lds	r25, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    1cfa:	91 30       	cpi	r25, 0x01	; 1
    1cfc:	59 f4       	brne	.+22     	; 0x1d14 <_ZN7MCP25158startSPIEv+0x30>
        interruptSave = SPI_AVR_EIMSK;
    1cfe:	9d b3       	in	r25, 0x1d	; 29
    1d00:	90 93 ed 1f 	sts	0x1FED, r25	; 0x801fed <_ZN8SPIClass13interruptSaveE>
        SPI_AVR_EIMSK &= ~interruptMask;
    1d04:	2d b3       	in	r18, 0x1d	; 29
    1d06:	90 91 ee 1f 	lds	r25, 0x1FEE	; 0x801fee <_ZN8SPIClass13interruptMaskE>
    1d0a:	90 95       	com	r25
    1d0c:	92 23       	and	r25, r18
    1d0e:	9d bb       	out	0x1d, r25	; 29
        SREG = sreg;
    1d10:	8f bf       	out	0x3f, r24	; 63
    1d12:	02 c0       	rjmp	.+4      	; 0x1d18 <_ZN7MCP25158startSPIEv+0x34>
      } else
      #endif
      {
        interruptSave = sreg;
    1d14:	80 93 ed 1f 	sts	0x1FED, r24	; 0x801fed <_ZN8SPIClass13interruptSaveE>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
    1d18:	80 e5       	ldi	r24, 0x50	; 80
    1d1a:	8c bd       	out	0x2c, r24	; 44
    SPSR = settings.spsr;
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	8d bd       	out	0x2d, r24	; 45
}

void MCP2515::startSPI(void) {
    SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0));
   // digitalWrite(SPICS, LOW);
   PORTB&=~(1<<PB4);
    1d20:	2c 98       	cbi	0x05, 4	; 5
    1d22:	08 95       	ret

00001d24 <_ZN7MCP25156endSPIEv>:
}

void MCP2515::endSPI() {
     PORTB|=(1<<PB4);
    1d24:	2c 9a       	sbi	0x05, 4	; 5
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
    1d26:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    1d2a:	88 23       	and	r24, r24
    1d2c:	71 f0       	breq	.+28     	; 0x1d4a <_ZN7MCP25156endSPIEv+0x26>
      #ifdef SPI_AVR_EIMSK
      uint8_t sreg = SREG;
    1d2e:	9f b7       	in	r25, 0x3f	; 63
      #endif
      cli();
    1d30:	f8 94       	cli
      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    1d32:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    1d36:	81 30       	cpi	r24, 0x01	; 1
    1d38:	29 f4       	brne	.+10     	; 0x1d44 <_ZN7MCP25156endSPIEv+0x20>
        SPI_AVR_EIMSK = interruptSave;
    1d3a:	80 91 ed 1f 	lds	r24, 0x1FED	; 0x801fed <_ZN8SPIClass13interruptSaveE>
    1d3e:	8d bb       	out	0x1d, r24	; 29
        SREG = sreg;
    1d40:	9f bf       	out	0x3f, r25	; 63
    1d42:	08 95       	ret
      } else
      #endif
      {
        SREG = interruptSave;
    1d44:	80 91 ed 1f 	lds	r24, 0x1FED	; 0x801fed <_ZN8SPIClass13interruptSaveE>
    1d48:	8f bf       	out	0x3f, r24	; 63
    1d4a:	08 95       	ret

00001d4c <_ZN7MCP2515C1Ev>:
const struct MCP2515::RXBn_REGS MCP2515::RXB[N_RXBUFFERS] = {
    {MCP_RXB0CTRL, MCP_RXB0SIDH, MCP_RXB0DATA, CANINTF_RX0IF},
    {MCP_RXB1CTRL, MCP_RXB1SIDH, MCP_RXB1DATA, CANINTF_RX1IF}
};

MCP2515::MCP2515(void)
    1d4c:	cf 93       	push	r28
    1d4e:	df 93       	push	r29
    1d50:	ec 01       	movw	r28, r24
{
    SPI.begin();
    1d52:	f3 d5       	rcall	.+3046   	; 0x293a <_ZN8SPIClass5beginEv>

   //SPICS = _CS;
    //pinMode(SPICS, OUTPUT);
	DDRB|=(1<<PB4);
    1d54:	24 9a       	sbi	0x04, 4	; 4
    endSPI();
    1d56:	ce 01       	movw	r24, r28
    1d58:	e5 df       	rcall	.-54     	; 0x1d24 <_ZN7MCP25156endSPIEv>
}
    1d5a:	df 91       	pop	r29
    1d5c:	cf 91       	pop	r28
    1d5e:	08 95       	ret

00001d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>:

    return ERROR_OK;
}

uint8_t MCP2515::readRegister(const REGISTER reg)
{
    1d60:	1f 93       	push	r17
    1d62:	cf 93       	push	r28
    1d64:	df 93       	push	r29
    1d66:	ec 01       	movw	r28, r24
    startSPI();
    1d68:	16 2f       	mov	r17, r22
    1d6a:	bc df       	rcall	.-136    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1d6c:	83 e0       	ldi	r24, 0x03	; 3
    1d6e:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1d70:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1d72:	0d b4       	in	r0, 0x2d	; 45
    1d74:	07 fe       	sbrs	r0, 7
    1d76:	fd cf       	rjmp	.-6      	; 0x1d72 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x12>
    return SPDR;
    1d78:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1d7a:	1e bd       	out	0x2e, r17	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1d7c:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1d7e:	0d b4       	in	r0, 0x2d	; 45
    1d80:	07 fe       	sbrs	r0, 7
    1d82:	fd cf       	rjmp	.-6      	; 0x1d7e <_ZN7MCP251512readRegisterENS_8REGISTERE+0x1e>
    return SPDR;
    1d84:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1d86:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1d88:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1d8a:	0d b4       	in	r0, 0x2d	; 45
    1d8c:	07 fe       	sbrs	r0, 7
    return SPDR;
    1d8e:	fd cf       	rjmp	.-6      	; 0x1d8a <_ZN7MCP251512readRegisterENS_8REGISTERE+0x2a>
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    uint8_t ret = SPI.transfer(0x00);
    endSPI();
    1d90:	1e b5       	in	r17, 0x2e	; 46
    1d92:	ce 01       	movw	r24, r28
    1d94:	c7 df       	rcall	.-114    	; 0x1d24 <_ZN7MCP25156endSPIEv>

    return ret;
}
    1d96:	81 2f       	mov	r24, r17
    1d98:	df 91       	pop	r29
    1d9a:	cf 91       	pop	r28
    1d9c:	1f 91       	pop	r17
    1d9e:	08 95       	ret

00001da0 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>:

void MCP2515::readRegisters(const REGISTER reg, uint8_t values[], const uint8_t n)
{
    1da0:	ef 92       	push	r14
    1da2:	ff 92       	push	r15
    1da4:	0f 93       	push	r16
    1da6:	1f 93       	push	r17
    1da8:	cf 93       	push	r28
    1daa:	df 93       	push	r29
    1dac:	ec 01       	movw	r28, r24
    1dae:	06 2f       	mov	r16, r22
    1db0:	7a 01       	movw	r14, r20
    startSPI();
    1db2:	12 2f       	mov	r17, r18
    1db4:	97 df       	rcall	.-210    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1db6:	83 e0       	ldi	r24, 0x03	; 3
    1db8:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1dba:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1dbc:	0d b4       	in	r0, 0x2d	; 45
    1dbe:	07 fe       	sbrs	r0, 7
    1dc0:	fd cf       	rjmp	.-6      	; 0x1dbc <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x1c>
    return SPDR;
    1dc2:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1dc4:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1dc6:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1dc8:	0d b4       	in	r0, 0x2d	; 45
    1dca:	07 fe       	sbrs	r0, 7
    1dcc:	fd cf       	rjmp	.-6      	; 0x1dc8 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x28>
    return SPDR;
    1dce:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    // mcp2515 has auto-increment of address-pointer
    for (uint8_t i=0; i<n; i++) {
    1dd0:	11 23       	and	r17, r17
    1dd2:	91 f0       	breq	.+36     	; 0x1df8 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x58>
    1dd4:	f7 01       	movw	r30, r14
    1dd6:	11 50       	subi	r17, 0x01	; 1
    1dd8:	41 2f       	mov	r20, r17
    1dda:	50 e0       	ldi	r21, 0x00	; 0
    1ddc:	4f 5f       	subi	r20, 0xFF	; 255
    1dde:	5f 4f       	sbci	r21, 0xFF	; 255
    1de0:	4e 0d       	add	r20, r14
    1de2:	5f 1d       	adc	r21, r15
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1de4:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1de6:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1de8:	0d b4       	in	r0, 0x2d	; 45
    1dea:	07 fe       	sbrs	r0, 7
    1dec:	fd cf       	rjmp	.-6      	; 0x1de8 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x48>
    return SPDR;
    1dee:	8e b5       	in	r24, 0x2e	; 46
    1df0:	81 93       	st	Z+, r24
    1df2:	e4 17       	cp	r30, r20
    1df4:	f5 07       	cpc	r31, r21
        values[i] = SPI.transfer(0x00);
    }
    endSPI();
    1df6:	b1 f7       	brne	.-20     	; 0x1de4 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x44>
    1df8:	ce 01       	movw	r24, r28
    1dfa:	94 df       	rcall	.-216    	; 0x1d24 <_ZN7MCP25156endSPIEv>
}
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	ff 90       	pop	r15
    1e06:	ef 90       	pop	r14
    1e08:	08 95       	ret

00001e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>:

void MCP2515::setRegister(const REGISTER reg, const uint8_t value)
{
    1e0a:	0f 93       	push	r16
    1e0c:	1f 93       	push	r17
    1e0e:	cf 93       	push	r28
    1e10:	df 93       	push	r29
    1e12:	ec 01       	movw	r28, r24
    1e14:	06 2f       	mov	r16, r22
    startSPI();
    1e16:	14 2f       	mov	r17, r20
    1e18:	65 df       	rcall	.-310    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1e1a:	82 e0       	ldi	r24, 0x02	; 2
    1e1c:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1e1e:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e20:	0d b4       	in	r0, 0x2d	; 45
    1e22:	07 fe       	sbrs	r0, 7
    1e24:	fd cf       	rjmp	.-6      	; 0x1e20 <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x16>
    return SPDR;
    1e26:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1e28:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1e2a:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e2c:	0d b4       	in	r0, 0x2d	; 45
    1e2e:	07 fe       	sbrs	r0, 7
    1e30:	fd cf       	rjmp	.-6      	; 0x1e2c <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x22>
    return SPDR;
    1e32:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1e34:	1e bd       	out	0x2e, r17	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e36:	00 00       	nop
    1e38:	0d b4       	in	r0, 0x2d	; 45
    1e3a:	07 fe       	sbrs	r0, 7
    return SPDR;
    1e3c:	fd cf       	rjmp	.-6      	; 0x1e38 <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x2e>
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    SPI.transfer(value);
    endSPI();
    1e3e:	8e b5       	in	r24, 0x2e	; 46
    1e40:	ce 01       	movw	r24, r28
    1e42:	70 df       	rcall	.-288    	; 0x1d24 <_ZN7MCP25156endSPIEv>
}
    1e44:	df 91       	pop	r29
    1e46:	cf 91       	pop	r28
    1e48:	1f 91       	pop	r17
    1e4a:	0f 91       	pop	r16
    1e4c:	08 95       	ret

00001e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>:

void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
    1e52:	0f 93       	push	r16
    1e54:	1f 93       	push	r17
    1e56:	cf 93       	push	r28
    1e58:	df 93       	push	r29
    1e5a:	ec 01       	movw	r28, r24
    1e5c:	06 2f       	mov	r16, r22
    1e5e:	7a 01       	movw	r14, r20
    startSPI();
    1e60:	12 2f       	mov	r17, r18
    1e62:	40 df       	rcall	.-384    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1e64:	82 e0       	ldi	r24, 0x02	; 2
    1e66:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1e68:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e6a:	0d b4       	in	r0, 0x2d	; 45
    1e6c:	07 fe       	sbrs	r0, 7
    1e6e:	fd cf       	rjmp	.-6      	; 0x1e6a <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x1c>
    return SPDR;
    1e70:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1e72:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1e74:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e76:	0d b4       	in	r0, 0x2d	; 45
    1e78:	07 fe       	sbrs	r0, 7
    1e7a:	fd cf       	rjmp	.-6      	; 0x1e76 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x28>
    return SPDR;
    1e7c:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    1e7e:	11 23       	and	r17, r17
    1e80:	91 f0       	breq	.+36     	; 0x1ea6 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x58>
    1e82:	f7 01       	movw	r30, r14
    1e84:	11 50       	subi	r17, 0x01	; 1
    1e86:	41 2f       	mov	r20, r17
    1e88:	50 e0       	ldi	r21, 0x00	; 0
    1e8a:	4f 5f       	subi	r20, 0xFF	; 255
    1e8c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e8e:	4e 0d       	add	r20, r14
    1e90:	5f 1d       	adc	r21, r15
        SPI.transfer(values[i]);
    1e92:	81 91       	ld	r24, Z+
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1e94:	8e bd       	out	0x2e, r24	; 46
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1e96:	00 00       	nop
    1e98:	0d b4       	in	r0, 0x2d	; 45
    1e9a:	07 fe       	sbrs	r0, 7
    return SPDR;
    1e9c:	fd cf       	rjmp	.-6      	; 0x1e98 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x4a>
void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    startSPI();
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    1e9e:	8e b5       	in	r24, 0x2e	; 46
    1ea0:	e4 17       	cp	r30, r20
    1ea2:	f5 07       	cpc	r31, r21
        SPI.transfer(values[i]);
    }
    endSPI();
    1ea4:	b1 f7       	brne	.-20     	; 0x1e92 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x44>
    1ea6:	ce 01       	movw	r24, r28
    1ea8:	3d df       	rcall	.-390    	; 0x1d24 <_ZN7MCP25156endSPIEv>
}
    1eaa:	df 91       	pop	r29
    1eac:	cf 91       	pop	r28
    1eae:	1f 91       	pop	r17
    1eb0:	0f 91       	pop	r16
    1eb2:	ff 90       	pop	r15
    1eb4:	ef 90       	pop	r14

void MCP2515::modifyRegister(const REGISTER reg, const uint8_t mask, const uint8_t data)
{
    1eb6:	08 95       	ret

00001eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>:
    1eb8:	ff 92       	push	r15
    1eba:	0f 93       	push	r16
    1ebc:	1f 93       	push	r17
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	ec 01       	movw	r28, r24
    1ec4:	f6 2e       	mov	r15, r22
    1ec6:	04 2f       	mov	r16, r20
    startSPI();
    1ec8:	12 2f       	mov	r17, r18
    1eca:	0c df       	rcall	.-488    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1ecc:	85 e0       	ldi	r24, 0x05	; 5
    1ece:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1ed0:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1ed2:	0d b4       	in	r0, 0x2d	; 45
    1ed4:	07 fe       	sbrs	r0, 7
    1ed6:	fd cf       	rjmp	.-6      	; 0x1ed2 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x1a>
    return SPDR;
    1ed8:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1eda:	fe bc       	out	0x2e, r15	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1edc:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1ede:	0d b4       	in	r0, 0x2d	; 45
    1ee0:	07 fe       	sbrs	r0, 7
    1ee2:	fd cf       	rjmp	.-6      	; 0x1ede <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x26>
    return SPDR;
    1ee4:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1ee6:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1ee8:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1eea:	0d b4       	in	r0, 0x2d	; 45
    1eec:	07 fe       	sbrs	r0, 7
    return SPDR;
    1eee:	fd cf       	rjmp	.-6      	; 0x1eea <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x32>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1ef0:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1ef2:	1e bd       	out	0x2e, r17	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1ef4:	00 00       	nop
    1ef6:	0d b4       	in	r0, 0x2d	; 45
    1ef8:	07 fe       	sbrs	r0, 7
    return SPDR;
    1efa:	fd cf       	rjmp	.-6      	; 0x1ef6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x3e>
    SPI.transfer(INSTRUCTION_BITMOD);
    SPI.transfer(reg);
    SPI.transfer(mask);
    SPI.transfer(data);
    endSPI();
    1efc:	8e b5       	in	r24, 0x2e	; 46
    1efe:	ce 01       	movw	r24, r28
    1f00:	11 df       	rcall	.-478    	; 0x1d24 <_ZN7MCP25156endSPIEv>
}
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	08 95       	ret

00001f0e <_ZN7MCP25155resetEv>:
     PORTB|=(1<<PB4);
    SPI.endTransaction();
}

MCP2515::ERROR MCP2515::reset(void)
{
    1f0e:	ef 92       	push	r14
    1f10:	ff 92       	push	r15
    1f12:	0f 93       	push	r16
    1f14:	1f 93       	push	r17
    1f16:	cf 93       	push	r28
    1f18:	df 93       	push	r29
    1f1a:	cd b7       	in	r28, 0x3d	; 61
    1f1c:	de b7       	in	r29, 0x3e	; 62
    1f1e:	2e 97       	sbiw	r28, 0x0e	; 14
    1f20:	0f b6       	in	r0, 0x3f	; 63
    1f22:	f8 94       	cli
    1f24:	de bf       	out	0x3e, r29	; 62
    1f26:	0f be       	out	0x3f, r0	; 63
    startSPI();
    1f28:	cd bf       	out	0x3d, r28	; 61
    1f2a:	8c 01       	movw	r16, r24
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1f2c:	db de       	rcall	.-586    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    1f2e:	80 ec       	ldi	r24, 0xC0	; 192
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1f30:	8e bd       	out	0x2e, r24	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1f32:	00 00       	nop
    1f34:	0d b4       	in	r0, 0x2d	; 45
    1f36:	07 fe       	sbrs	r0, 7
    return SPDR;
    1f38:	fd cf       	rjmp	.-6      	; 0x1f34 <_ZN7MCP25155resetEv+0x26>
    SPI.transfer(INSTRUCTION_RESET);
    endSPI();
    1f3a:	8e b5       	in	r24, 0x2e	; 46
    1f3c:	c8 01       	movw	r24, r16
    1f3e:	f2 de       	rcall	.-540    	; 0x1d24 <_ZN7MCP25156endSPIEv>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f40:	8f e3       	ldi	r24, 0x3F	; 63
    1f42:	9c e9       	ldi	r25, 0x9C	; 156
    1f44:	01 97       	sbiw	r24, 0x01	; 1
    1f46:	f1 f7       	brne	.-4      	; 0x1f44 <_ZN7MCP25155resetEv+0x36>
    1f48:	00 c0       	rjmp	.+0      	; 0x1f4a <_ZN7MCP25155resetEv+0x3c>

    _delay_ms(10);

    uint8_t zeros[14];
    memset(zeros, 0, sizeof(zeros));
    1f4a:	00 00       	nop
    1f4c:	fe 01       	movw	r30, r28
    1f4e:	31 96       	adiw	r30, 0x01	; 1
    1f50:	7f 01       	movw	r14, r30
    1f52:	8e e0       	ldi	r24, 0x0E	; 14
    1f54:	11 92       	st	Z+, r1
    setRegisters(MCP_TXB0CTRL, zeros, 14);
    1f56:	8a 95       	dec	r24
    1f58:	e9 f7       	brne	.-6      	; 0x1f54 <_ZN7MCP25155resetEv+0x46>
    1f5a:	2e e0       	ldi	r18, 0x0E	; 14
    1f5c:	a7 01       	movw	r20, r14
    setRegisters(MCP_TXB1CTRL, zeros, 14);
    1f5e:	60 e3       	ldi	r22, 0x30	; 48
    1f60:	c8 01       	movw	r24, r16
    1f62:	75 df       	rcall	.-278    	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1f64:	2e e0       	ldi	r18, 0x0E	; 14
    1f66:	a7 01       	movw	r20, r14
    setRegisters(MCP_TXB2CTRL, zeros, 14);
    1f68:	60 e4       	ldi	r22, 0x40	; 64
    1f6a:	c8 01       	movw	r24, r16
    1f6c:	70 df       	rcall	.-288    	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1f6e:	2e e0       	ldi	r18, 0x0E	; 14
    1f70:	a7 01       	movw	r20, r14

    setRegister(MCP_RXB0CTRL, 0);
    1f72:	60 e5       	ldi	r22, 0x50	; 80
    1f74:	c8 01       	movw	r24, r16
    1f76:	6b df       	rcall	.-298    	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1f78:	40 e0       	ldi	r20, 0x00	; 0
    setRegister(MCP_RXB1CTRL, 0);
    1f7a:	60 e6       	ldi	r22, 0x60	; 96
    1f7c:	c8 01       	movw	r24, r16
    1f7e:	45 df       	rcall	.-374    	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1f80:	40 e0       	ldi	r20, 0x00	; 0
    1f82:	60 e7       	ldi	r22, 0x70	; 112

    setRegister(MCP_CANINTE, CANINTF_RX0IF | CANINTF_RX1IF); // | CANINTF_ERRIF | CANINTF_MERRF
    1f84:	c8 01       	movw	r24, r16
    1f86:	41 df       	rcall	.-382    	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1f88:	43 e0       	ldi	r20, 0x03	; 3
    1f8a:	6b e2       	ldi	r22, 0x2B	; 43
    1f8c:	c8 01       	movw	r24, r16

    modifyRegister(MCP_RXB0CTRL,
                   RXBnCTRL_RXM_MASK | RXB0CTRL_BUKT,
                   RXBnCTRL_RXM_STDEXT | RXB0CTRL_BUKT);
    1f8e:	3d df       	rcall	.-390    	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1f90:	24 e0       	ldi	r18, 0x04	; 4
    1f92:	44 e6       	ldi	r20, 0x64	; 100
    1f94:	60 e6       	ldi	r22, 0x60	; 96
    1f96:	c8 01       	movw	r24, r16
    1f98:	8f df       	rcall	.-226    	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    modifyRegister(MCP_RXB1CTRL, RXBnCTRL_RXM_MASK, RXBnCTRL_RXM_STDEXT);
    1f9a:	20 e0       	ldi	r18, 0x00	; 0
    1f9c:	40 e6       	ldi	r20, 0x60	; 96
    1f9e:	60 e7       	ldi	r22, 0x70	; 112
    1fa0:	c8 01       	movw	r24, r16
    1fa2:	8a df       	rcall	.-236    	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
            return result;
        }
    }*/

    return ERROR_OK;
}
    1fa4:	80 e0       	ldi	r24, 0x00	; 0
    1fa6:	2e 96       	adiw	r28, 0x0e	; 14
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	ff 90       	pop	r15
    1fbc:	ef 90       	pop	r14
    SPI.transfer(data);
    endSPI();
}

uint8_t MCP2515::getStatus(void)
{
    1fbe:	08 95       	ret

00001fc0 <_ZN7MCP25159getStatusEv>:
    1fc0:	1f 93       	push	r17
    1fc2:	cf 93       	push	r28
    1fc4:	df 93       	push	r29
    startSPI();
    1fc6:	ec 01       	movw	r28, r24
    1fc8:	8d de       	rcall	.-742    	; 0x1ce4 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1fca:	80 ea       	ldi	r24, 0xA0	; 160
    1fcc:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1fce:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1fd0:	0d b4       	in	r0, 0x2d	; 45
    1fd2:	07 fe       	sbrs	r0, 7
    1fd4:	fd cf       	rjmp	.-6      	; 0x1fd0 <_ZN7MCP25159getStatusEv+0x10>
    return SPDR;
    1fd6:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1fd8:	1e bc       	out	0x2e, r1	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1fda:	00 00       	nop
    1fdc:	0d b4       	in	r0, 0x2d	; 45
    SPI.transfer(INSTRUCTION_READ_STATUS);
    uint8_t i = SPI.transfer(0x00);
    endSPI();
    1fde:	07 fe       	sbrs	r0, 7
    1fe0:	fd cf       	rjmp	.-6      	; 0x1fdc <_ZN7MCP25159getStatusEv+0x1c>
    1fe2:	1e b5       	in	r17, 0x2e	; 46

    return i;
}
    1fe4:	ce 01       	movw	r24, r28
    1fe6:	9e de       	rcall	.-708    	; 0x1d24 <_ZN7MCP25156endSPIEv>
    1fe8:	81 2f       	mov	r24, r17
    1fea:	df 91       	pop	r29
{
    return setMode(CANCTRL_REQOP_NORMAL);
}

MCP2515::ERROR MCP2515::setMode(const CANCTRL_REQOP_MODE mode)
{
    1fec:	cf 91       	pop	r28
    1fee:	1f 91       	pop	r17
    1ff0:	08 95       	ret

00001ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>:
    1ff2:	0f 93       	push	r16
    1ff4:	1f 93       	push	r17
    1ff6:	cf 93       	push	r28
	uint8_t sreg = SREG;
    1ff8:	df 93       	push	r29
    modifyRegister(MCP_CANCTRL, CANCTRL_REQOP, mode);
    1ffa:	ec 01       	movw	r28, r24
    1ffc:	16 2f       	mov	r17, r22
    1ffe:	0f b7       	in	r16, 0x3f	; 63
    2000:	26 2f       	mov	r18, r22
    2002:	40 ee       	ldi	r20, 0xE0	; 224
	sei();
    timeoutstart(624);
    2004:	6f e0       	ldi	r22, 0x0F	; 15
    2006:	58 df       	rcall	.-336    	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2008:	78 94       	sei
    bool modeMatch = false;
    while (~timeoutcheck()) {
    200a:	80 e7       	ldi	r24, 0x70	; 112
    200c:	92 e0       	ldi	r25, 0x02	; 2
    200e:	42 dc       	rcall	.-1916   	; 0x1894 <_Z12timeoutstarti>
        uint8_t newmode = readRegister(MCP_CANSTAT);
    2010:	63 dc       	rcall	.-1850   	; 0x18d8 <_Z12timeoutcheckv>
    2012:	01 96       	adiw	r24, 0x01	; 1
    2014:	41 f0       	breq	.+16     	; 0x2026 <__DATA_REGION_LENGTH__+0x26>
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;

        if (modeMatch) {
    2016:	6e e0       	ldi	r22, 0x0E	; 14
    2018:	ce 01       	movw	r24, r28
    201a:	a2 de       	rcall	.-700    	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    bool modeMatch = false;
    while (~timeoutcheck()) {
        uint8_t newmode = readRegister(MCP_CANSTAT);
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;
    201c:	80 7e       	andi	r24, 0xE0	; 224
    201e:	18 13       	cpse	r17, r24
    2020:	f7 cf       	rjmp	.-18     	; 0x2010 <__DATA_REGION_LENGTH__+0x10>

        if (modeMatch) {
            break;
        }
    }
	SREG = sreg;
    2022:	91 e0       	ldi	r25, 0x01	; 1

    return modeMatch ? ERROR_OK : ERROR_FAIL;

}
    2024:	01 c0       	rjmp	.+2      	; 0x2028 <__DATA_REGION_LENGTH__+0x28>
    2026:	90 e0       	ldi	r25, 0x00	; 0
    2028:	0f bf       	out	0x3f, r16	; 63
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	89 27       	eor	r24, r25
    202e:	df 91       	pop	r29
    return i;
}

MCP2515::ERROR MCP2515::setConfigMode()
{
    return setMode(CANCTRL_REQOP_CONFIG);
    2030:	cf 91       	pop	r28
    2032:	1f 91       	pop	r17
    2034:	0f 91       	pop	r16
}
    2036:	08 95       	ret

00002038 <_ZN7MCP251513setConfigModeEv>:

MCP2515::ERROR MCP2515::setListenOnlyMode()
{
    return setMode(CANCTRL_REQOP_LISTENONLY);
    2038:	60 e8       	ldi	r22, 0x80	; 128
    203a:	db cf       	rjmp	.-74     	; 0x1ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    203c:	08 95       	ret

0000203e <_ZN7MCP251517setListenOnlyModeEv>:
}
    203e:	60 e6       	ldi	r22, 0x60	; 96

MCP2515::ERROR MCP2515::setSleepMode()
{
    return setMode(CANCTRL_REQOP_SLEEP);
    2040:	d8 cf       	rjmp	.-80     	; 0x1ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    2042:	08 95       	ret

00002044 <_ZN7MCP251512setSleepModeEv>:
    2044:	60 e2       	ldi	r22, 0x20	; 32
}
    2046:	d5 cf       	rjmp	.-86     	; 0x1ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>

MCP2515::ERROR MCP2515::setLoopbackMode()
{
    return setMode(CANCTRL_REQOP_LOOPBACK);
    2048:	08 95       	ret

0000204a <_ZN7MCP251515setLoopbackModeEv>:
    204a:	60 e4       	ldi	r22, 0x40	; 64
    204c:	d2 cf       	rjmp	.-92     	; 0x1ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
}
    204e:	08 95       	ret

00002050 <_ZN7MCP251513setNormalModeEv>:

MCP2515::ERROR MCP2515::setNormalMode()
{
    return setMode(CANCTRL_REQOP_NORMAL);
    2050:	60 e0       	ldi	r22, 0x00	; 0
    2052:	cf cf       	rjmp	.-98     	; 0x1ff2 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    2054:	08 95       	ret

00002056 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>:
}
    2056:	ef 92       	push	r14
{
    return setBitrate(canSpeed, MCP_16MHZ);
}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed, CAN_CLOCK canClock)
{
    2058:	ff 92       	push	r15
    205a:	0f 93       	push	r16
    205c:	1f 93       	push	r17
    205e:	cf 93       	push	r28
    2060:	df 93       	push	r29
    2062:	ec 01       	movw	r28, r24
    2064:	16 2f       	mov	r17, r22
    2066:	04 2f       	mov	r16, r20
    2068:	e7 df       	rcall	.-50     	; 0x2038 <_ZN7MCP251513setConfigModeEv>
    ERROR error = setConfigMode();
    206a:	81 11       	cpse	r24, r1
    206c:	98 c1       	rjmp	.+816    	; 0x239e <__stack+0x19f>
    if (error != ERROR_OK) {
    206e:	01 30       	cpi	r16, 0x01	; 1
    2070:	09 f4       	brne	.+2      	; 0x2074 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1e>
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    switch (canClock)
    2072:	6d c0       	rjmp	.+218    	; 0x214e <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0xf8>
    2074:	08 f4       	brcc	.+2      	; 0x2078 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x22>
    2076:	e2 c0       	rjmp	.+452    	; 0x223c <__stack+0x3d>
    2078:	02 30       	cpi	r16, 0x02	; 2
    207a:	09 f0       	breq	.+2      	; 0x207e <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x28>
    207c:	38 c1       	rjmp	.+624    	; 0x22ee <__stack+0xef>
    207e:	81 2f       	mov	r24, r17
    2080:	90 e0       	ldi	r25, 0x00	; 0
    {
        case (MCP_8MHZ):
        switch (canSpeed)
    2082:	80 31       	cpi	r24, 0x10	; 16
    2084:	91 05       	cpc	r25, r1
    2086:	08 f0       	brcs	.+2      	; 0x208a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x34>
    2088:	5e c1       	rjmp	.+700    	; 0x2346 <__stack+0x147>
    208a:	fc 01       	movw	r30, r24
    208c:	88 27       	eor	r24, r24
    208e:	e7 57       	subi	r30, 0x77	; 119
    2090:	ff 4f       	sbci	r31, 0xFF	; 255
    2092:	8f 4f       	sbci	r24, 0xFF	; 255
    2094:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
    2098:	17 e8       	ldi	r17, 0x87	; 135
    209a:	0f 2e       	mov	r0, r31
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
    209c:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
    209e:	ef 2e       	mov	r14, r31
    20a0:	f0 2d       	mov	r31, r0
    20a2:	0f 2e       	mov	r0, r31
    20a4:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
    20a6:	ff 2e       	mov	r15, r31
    20a8:	f0 2d       	mov	r31, r0
    20aa:	3f c1       	rjmp	.+638    	; 0x232a <__stack+0x12b>
    20ac:	15 e8       	ldi	r17, 0x85	; 133
    20ae:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
    20b0:	f2 ee       	ldi	r31, 0xE2	; 226
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
    20b2:	ef 2e       	mov	r14, r31
    20b4:	f0 2d       	mov	r31, r0
    20b6:	0f 2e       	mov	r0, r31
    20b8:	f7 e4       	ldi	r31, 0x47	; 71
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
    20ba:	ff 2e       	mov	r15, r31
    20bc:	f0 2d       	mov	r31, r0
    20be:	35 c1       	rjmp	.+618    	; 0x232a <__stack+0x12b>
    20c0:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;
    20c2:	0f 2e       	mov	r0, r31

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
    20c4:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
    20c6:	ef 2e       	mov	r14, r31
    20c8:	f0 2d       	mov	r31, r0
    20ca:	0f 2e       	mov	r0, r31
    20cc:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
    20ce:	ff 2e       	mov	r15, r31
    20d0:	f0 2d       	mov	r31, r0
    20d2:	2b c1       	rjmp	.+598    	; 0x232a <__stack+0x12b>
    20d4:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;
    20d6:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
    20d8:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
    20da:	ef 2e       	mov	r14, r31
    20dc:	f0 2d       	mov	r31, r0
    20de:	0f 2e       	mov	r0, r31
    20e0:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
    20e2:	ff 2e       	mov	r15, r31
    20e4:	f0 2d       	mov	r31, r0
    20e6:	21 c1       	rjmp	.+578    	; 0x232a <__stack+0x12b>
    20e8:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;
    20ea:	0f 2e       	mov	r0, r31

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
    20ec:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
    20ee:	ef 2e       	mov	r14, r31
    20f0:	f0 2d       	mov	r31, r0
    20f2:	ff 24       	eor	r15, r15
    20f4:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
    20f6:	19 c1       	rjmp	.+562    	; 0x232a <__stack+0x12b>
    20f8:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;
    20fa:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
    20fc:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
    20fe:	ef 2e       	mov	r14, r31
    2100:	f0 2d       	mov	r31, r0
    2102:	ff 24       	eor	r15, r15
    2104:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
    2106:	11 c1       	rjmp	.+546    	; 0x232a <__stack+0x12b>
    2108:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;
    210a:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
    210c:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
    210e:	ef 2e       	mov	r14, r31
    2110:	f0 2d       	mov	r31, r0
    2112:	ff 24       	eor	r15, r15
    2114:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
    2116:	09 c1       	rjmp	.+530    	; 0x232a <__stack+0x12b>
    2118:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;
    211a:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
    211c:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
    211e:	ef 2e       	mov	r14, r31
    2120:	f0 2d       	mov	r31, r0
    2122:	f1 2c       	mov	r15, r1
    2124:	02 c1       	rjmp	.+516    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
    2126:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;
    2128:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
    212a:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
    212c:	ef 2e       	mov	r14, r31
    212e:	f0 2d       	mov	r31, r0
    2130:	f1 2c       	mov	r15, r1
    2132:	fb c0       	rjmp	.+502    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
    2134:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;
    2136:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
    2138:	f0 e9       	ldi	r31, 0x90	; 144
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
    213a:	ef 2e       	mov	r14, r31
    213c:	f0 2d       	mov	r31, r0
    213e:	f1 2c       	mov	r15, r1
    2140:	f4 c0       	rjmp	.+488    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
    2142:	10 e8       	ldi	r17, 0x80	; 128
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;
    2144:	68 94       	set

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
    2146:	ee 24       	eor	r14, r14
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
    2148:	e7 f8       	bld	r14, 7
    214a:	f1 2c       	mov	r15, r1
    214c:	ee c0       	rjmp	.+476    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
    214e:	81 2f       	mov	r24, r17
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
            break;
    2150:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_16MHZ):
        switch (canSpeed)
    2152:	80 31       	cpi	r24, 0x10	; 16
    2154:	91 05       	cpc	r25, r1
    2156:	08 f0       	brcs	.+2      	; 0x215a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x104>
    2158:	f8 c0       	rjmp	.+496    	; 0x234a <__stack+0x14b>
    215a:	fc 01       	movw	r30, r24
    215c:	88 27       	eor	r24, r24
    215e:	e7 56       	subi	r30, 0x67	; 103
    2160:	ff 4f       	sbci	r31, 0xFF	; 255
    2162:	8f 4f       	sbci	r24, 0xFF	; 255
    2164:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
    2168:	17 e8       	ldi	r17, 0x87	; 135
    216a:	ee 24       	eor	r14, r14
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
    216c:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
    216e:	0f 2e       	mov	r0, r31
    2170:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_16MHz_10kBPS_CFG2;
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
    2172:	ff 2e       	mov	r15, r31
    2174:	f0 2d       	mov	r31, r0
    2176:	d9 c0       	rjmp	.+434    	; 0x232a <__stack+0x12b>
    2178:	15 e8       	ldi	r17, 0x85	; 133
    217a:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
    217c:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
    217e:	ef 2e       	mov	r14, r31
    2180:	f0 2d       	mov	r31, r0
    2182:	0f 2e       	mov	r0, r31
    2184:	fe e4       	ldi	r31, 0x4E	; 78
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
    2186:	ff 2e       	mov	r15, r31
    2188:	f0 2d       	mov	r31, r0
    218a:	cf c0       	rjmp	.+414    	; 0x232a <__stack+0x12b>
    218c:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;
    218e:	ee 24       	eor	r14, r14

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
    2190:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
    2192:	0f 2e       	mov	r0, r31
    2194:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
    2196:	ff 2e       	mov	r15, r31
    2198:	f0 2d       	mov	r31, r0
    219a:	c7 c0       	rjmp	.+398    	; 0x232a <__stack+0x12b>
    219c:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;
    219e:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
    21a0:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
    21a2:	ef 2e       	mov	r14, r31
    21a4:	f0 2d       	mov	r31, r0
    21a6:	0f 2e       	mov	r0, r31
    21a8:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
    21aa:	ff 2e       	mov	r15, r31
    21ac:	f0 2d       	mov	r31, r0
    21ae:	bd c0       	rjmp	.+378    	; 0x232a <__stack+0x12b>
    21b0:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;
    21b2:	ee 24       	eor	r14, r14

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
    21b4:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
    21b6:	0f 2e       	mov	r0, r31
    21b8:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
    21ba:	ff 2e       	mov	r15, r31
    21bc:	f0 2d       	mov	r31, r0
    21be:	b5 c0       	rjmp	.+362    	; 0x232a <__stack+0x12b>
    21c0:	17 e0       	ldi	r17, 0x07	; 7
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;
    21c2:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
    21c4:	fe eb       	ldi	r31, 0xBE	; 190
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
    21c6:	ef 2e       	mov	r14, r31
    21c8:	f0 2d       	mov	r31, r0
    21ca:	0f 2e       	mov	r0, r31
    21cc:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
    21ce:	ff 2e       	mov	r15, r31
    21d0:	f0 2d       	mov	r31, r0
    21d2:	ab c0       	rjmp	.+342    	; 0x232a <__stack+0x12b>
    21d4:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 
    21d6:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
    21d8:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
    21da:	ef 2e       	mov	r14, r31
    21dc:	f0 2d       	mov	r31, r0
    21de:	0f 2e       	mov	r0, r31
    21e0:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
    21e2:	ff 2e       	mov	r15, r31
    21e4:	f0 2d       	mov	r31, r0
    21e6:	a1 c0       	rjmp	.+322    	; 0x232a <__stack+0x12b>
    21e8:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;
    21ea:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
    21ec:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
    21ee:	ef 2e       	mov	r14, r31
    21f0:	f0 2d       	mov	r31, r0
    21f2:	0f 2e       	mov	r0, r31
    21f4:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
    21f6:	ff 2e       	mov	r15, r31
    21f8:	f0 2d       	mov	r31, r0
    21fa:	97 c0       	rjmp	.+302    	; 0x232a <__stack+0x12b>
    21fc:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;
    21fe:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
    2200:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
    2202:	ef 2e       	mov	r14, r31
    2204:	f0 2d       	mov	r31, r0
    2206:	ff 24       	eor	r15, r15
    2208:	f3 94       	inc	r15
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
    220a:	8f c0       	rjmp	.+286    	; 0x232a <__stack+0x12b>
    220c:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;
    220e:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
    2210:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
    2212:	ef 2e       	mov	r14, r31
    2214:	f0 2d       	mov	r31, r0
    2216:	0f 2e       	mov	r0, r31
    2218:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
    221a:	ff 2e       	mov	r15, r31
    221c:	f0 2d       	mov	r31, r0
    221e:	85 c0       	rjmp	.+266    	; 0x232a <__stack+0x12b>
    2220:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;
    2222:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
    2224:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
    2226:	ef 2e       	mov	r14, r31
    2228:	f0 2d       	mov	r31, r0
    222a:	f1 2c       	mov	r15, r1
    222c:	7e c0       	rjmp	.+252    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
    222e:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;
    2230:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
    2232:	f0 ed       	ldi	r31, 0xD0	; 208
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
    2234:	ef 2e       	mov	r14, r31
    2236:	f0 2d       	mov	r31, r0
    2238:	f1 2c       	mov	r15, r1
    223a:	77 c0       	rjmp	.+238    	; 0x232a <__stack+0x12b>
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
    223c:	81 2f       	mov	r24, r17
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
            break;
    223e:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_20MHZ):
        switch (canSpeed)
    2240:	fc 01       	movw	r30, r24
    2242:	34 97       	sbiw	r30, 0x04	; 4
    2244:	ec 30       	cpi	r30, 0x0C	; 12
    2246:	f1 05       	cpc	r31, r1
    2248:	08 f0       	brcs	.+2      	; 0x224c <__stack+0x4d>
    224a:	81 c0       	rjmp	.+258    	; 0x234e <__stack+0x14f>
    224c:	88 27       	eor	r24, r24
    224e:	e7 55       	subi	r30, 0x57	; 87
    2250:	ff 4f       	sbci	r31, 0xFF	; 255
    2252:	8f 4f       	sbci	r24, 0xFF	; 255
    2254:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
    2258:	17 e8       	ldi	r17, 0x87	; 135
    225a:	0f 2e       	mov	r0, r31
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
    225c:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
    225e:	ef 2e       	mov	r14, r31
    2260:	f0 2d       	mov	r31, r0
    2262:	0f 2e       	mov	r0, r31
    2264:	f9 e0       	ldi	r31, 0x09	; 9
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
    2266:	ff 2e       	mov	r15, r31
    2268:	f0 2d       	mov	r31, r0
    226a:	5f c0       	rjmp	.+190    	; 0x232a <__stack+0x12b>
    226c:	17 e8       	ldi	r17, 0x87	; 135
    226e:	ee 24       	eor	r14, r14
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
    2270:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
    2272:	68 94       	set
    2274:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
    2276:	f2 f8       	bld	r15, 2
    2278:	58 c0       	rjmp	.+176    	; 0x232a <__stack+0x12b>
    227a:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;
    227c:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
    227e:	fe ef       	ldi	r31, 0xFE	; 254
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
    2280:	ef 2e       	mov	r14, r31
    2282:	f0 2d       	mov	r31, r0
    2284:	68 94       	set
    2286:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
    2288:	f2 f8       	bld	r15, 2
    228a:	4f c0       	rjmp	.+158    	; 0x232a <__stack+0x12b>
    228c:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;
    228e:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
    2290:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
    2292:	ef 2e       	mov	r14, r31
    2294:	f0 2d       	mov	r31, r0
    2296:	68 94       	set
    2298:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
    229a:	f2 f8       	bld	r15, 2
    229c:	46 c0       	rjmp	.+140    	; 0x232a <__stack+0x12b>
    229e:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;
    22a0:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
    22a2:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
    22a4:	ef 2e       	mov	r14, r31
    22a6:	f0 2d       	mov	r31, r0
    22a8:	0f 2e       	mov	r0, r31
    22aa:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
    22ac:	ff 2e       	mov	r15, r31
    22ae:	f0 2d       	mov	r31, r0
    22b0:	3c c0       	rjmp	.+120    	; 0x232a <__stack+0x12b>
    22b2:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;
    22b4:	ee 24       	eor	r14, r14

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
    22b6:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
    22b8:	ff 24       	eor	r15, r15
    22ba:	f3 94       	inc	r15
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
    22bc:	36 c0       	rjmp	.+108    	; 0x232a <__stack+0x12b>
    22be:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;
    22c0:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
    22c2:	fb ef       	ldi	r31, 0xFB	; 251
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
    22c4:	ef 2e       	mov	r14, r31
    22c6:	f0 2d       	mov	r31, r0
    22c8:	0f 2e       	mov	r0, r31
    22ca:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
    22cc:	ff 2e       	mov	r15, r31
    22ce:	f0 2d       	mov	r31, r0
    22d0:	2c c0       	rjmp	.+88     	; 0x232a <__stack+0x12b>
    22d2:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;
    22d4:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
    22d6:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
    22d8:	ef 2e       	mov	r14, r31
    22da:	f0 2d       	mov	r31, r0
    22dc:	f1 2c       	mov	r15, r1
    22de:	25 c0       	rjmp	.+74     	; 0x232a <__stack+0x12b>
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
    22e0:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;
    22e2:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
            cfg3 = MCP_20MHz_1000kBPS_CFG3;
    22e4:	f9 ed       	ldi	r31, 0xD9	; 217
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
    22e6:	ef 2e       	mov	r14, r31
    22e8:	f0 2d       	mov	r31, r0
    22ea:	f1 2c       	mov	r15, r1
    22ec:	1e c0       	rjmp	.+60     	; 0x232a <__stack+0x12b>
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
    22ee:	80 e0       	ldi	r24, 0x00	; 0
            break;
        }
        break;

        default:
        set = 0;
    22f0:	19 c0       	rjmp	.+50     	; 0x2324 <__stack+0x125>
    22f2:	0f 2e       	mov	r0, r31
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
            cfg2 = MCP_8MHz_5kBPS_CFG2;
    22f4:	ff eb       	ldi	r31, 0xBF	; 191
    22f6:	ef 2e       	mov	r14, r31
    22f8:	f0 2d       	mov	r31, r0
    {
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
    22fa:	0f 2e       	mov	r0, r31
    22fc:	ff e1       	ldi	r31, 0x1F	; 31
    22fe:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2300:	f0 2d       	mov	r31, r0
    2302:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
            cfg2 = MCP_16MHz_5kBPS_CFG2;
    2304:	0f c0       	rjmp	.+30     	; 0x2324 <__stack+0x125>
    2306:	ee 24       	eor	r14, r14

        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
    2308:	ea 94       	dec	r14
    230a:	0f 2e       	mov	r0, r31
    230c:	ff e3       	ldi	r31, 0x3F	; 63
    230e:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2310:	f0 2d       	mov	r31, r0
    2312:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
    2314:	07 c0       	rjmp	.+14     	; 0x2324 <__stack+0x125>
    2316:	ee 24       	eor	r14, r14

        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
    2318:	ea 94       	dec	r14
    231a:	0f 2e       	mov	r0, r31
    231c:	fb e0       	ldi	r31, 0x0B	; 11
    231e:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2320:	f0 2d       	mov	r31, r0
        default:
        set = 0;
        break;
    }

    if (set) {
    2322:	81 e0       	ldi	r24, 0x01	; 1
    2324:	88 23       	and	r24, r24
    2326:	a9 f0       	breq	.+42     	; 0x2352 <__stack+0x153>
        setRegister(MCP_CNF1, cfg1);
    2328:	17 e8       	ldi	r17, 0x87	; 135
    232a:	4f 2d       	mov	r20, r15
    232c:	6a e2       	ldi	r22, 0x2A	; 42
    232e:	ce 01       	movw	r24, r28
    2330:	6c dd       	rcall	.-1320   	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
        setRegister(MCP_CNF2, cfg2);
    2332:	4e 2d       	mov	r20, r14
    2334:	69 e2       	ldi	r22, 0x29	; 41
    2336:	ce 01       	movw	r24, r28
    2338:	68 dd       	rcall	.-1328   	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    233a:	41 2f       	mov	r20, r17
        setRegister(MCP_CNF3, cfg3);
    233c:	68 e2       	ldi	r22, 0x28	; 40
    233e:	ce 01       	movw	r24, r28
    2340:	64 dd       	rcall	.-1336   	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	2c c0       	rjmp	.+88     	; 0x239e <__stack+0x19f>
        return ERROR_OK;
    2346:	81 e0       	ldi	r24, 0x01	; 1
    2348:	2a c0       	rjmp	.+84     	; 0x239e <__stack+0x19f>
    }
    else {
        return ERROR_FAIL;
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	28 c0       	rjmp	.+80     	; 0x239e <__stack+0x19f>
    234e:	81 e0       	ldi	r24, 0x01	; 1
    2350:	26 c0       	rjmp	.+76     	; 0x239e <__stack+0x19f>
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	24 c0       	rjmp	.+72     	; 0x239e <__stack+0x19f>
    2356:	17 e8       	ldi	r17, 0x87	; 135
    2358:	0f 2e       	mov	r0, r31
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
    235a:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
    235c:	ef 2e       	mov	r14, r31
    235e:	f0 2d       	mov	r31, r0
    2360:	0f 2e       	mov	r0, r31
    2362:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_8MHz_5kBPS_CFG2;
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
    2364:	ff 2e       	mov	r15, r31
    2366:	f0 2d       	mov	r31, r0
    2368:	e0 cf       	rjmp	.-64     	; 0x232a <__stack+0x12b>
    236a:	14 e8       	ldi	r17, 0x84	; 132
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
    236c:	0f 2e       	mov	r0, r31
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
    236e:	f4 ea       	ldi	r31, 0xA4	; 164
    2370:	ef 2e       	mov	r14, r31
    2372:	f0 2d       	mov	r31, r0
    2374:	0f 2e       	mov	r0, r31
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
    2376:	f7 e0       	ldi	r31, 0x07	; 7
    2378:	ff 2e       	mov	r15, r31
    237a:	f0 2d       	mov	r31, r0
    237c:	d6 cf       	rjmp	.-84     	; 0x232a <__stack+0x12b>
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
            cfg2 = MCP_16MHz_10kBPS_CFG2;
            cfg3 = MCP_16MHz_10kBPS_CFG3;
    237e:	17 e8       	ldi	r17, 0x87	; 135
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
            cfg2 = MCP_16MHz_10kBPS_CFG2;
    2380:	ee 24       	eor	r14, r14
            cfg2 = MCP_16MHz_5kBPS_CFG2;
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
    2382:	ea 94       	dec	r14
    2384:	0f 2e       	mov	r0, r31
    2386:	ff e1       	ldi	r31, 0x1F	; 31
    2388:	ff 2e       	mov	r15, r31
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
    238a:	f0 2d       	mov	r31, r0
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
    238c:	ce cf       	rjmp	.-100    	; 0x232a <__stack+0x12b>
    238e:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
    2390:	ee 24       	eor	r14, r14
    2392:	ea 94       	dec	r14
    2394:	0f 2e       	mov	r0, r31
    2396:	f9 e0       	ldi	r31, 0x09	; 9
        return ERROR_OK;
    }
    else {
        return ERROR_FAIL;
    }
}
    2398:	ff 2e       	mov	r15, r31
    239a:	f0 2d       	mov	r31, r0
    239c:	c6 cf       	rjmp	.-116    	; 0x232a <__stack+0x12b>
    239e:	df 91       	pop	r29
    23a0:	cf 91       	pop	r28
    23a2:	1f 91       	pop	r17

}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed)
{
    return setBitrate(canSpeed, MCP_16MHZ);
    23a4:	0f 91       	pop	r16
    23a6:	ff 90       	pop	r15
    23a8:	ef 90       	pop	r14
}
    23aa:	08 95       	ret

000023ac <_ZN7MCP251510setBitrateE9CAN_SPEED>:
        return ERROR_FAIL;
    }
}

MCP2515::ERROR MCP2515::setClkOut(const CAN_CLKOUT divisor)
{
    23ac:	41 e0       	ldi	r20, 0x01	; 1
    23ae:	53 ce       	rjmp	.-858    	; 0x2056 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>
    23b0:	08 95       	ret

000023b2 <_ZN7MCP25159setClkOutE10CAN_CLKOUT>:
    ERROR res;
    uint8_t cfg3;

    if (divisor == CLKOUT_DISABLE) {
    23b2:	cf 93       	push	r28
    23b4:	df 93       	push	r29
	/* Turn off CLKEN */
	modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, 0x00);
    23b6:	ec 01       	movw	r28, r24
    23b8:	6f 3f       	cpi	r22, 0xFF	; 255
    23ba:	51 f4       	brne	.+20     	; 0x23d0 <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x1e>
    23bc:	20 e0       	ldi	r18, 0x00	; 0
    23be:	44 e0       	ldi	r20, 0x04	; 4

	/* Turn on CLKOUT for SOF */
	modifyRegister(MCP_CNF3, CNF3_SOF, CNF3_SOF);
    23c0:	6f e0       	ldi	r22, 0x0F	; 15
    23c2:	7a dd       	rcall	.-1292   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    23c4:	20 e8       	ldi	r18, 0x80	; 128
    23c6:	40 e8       	ldi	r20, 0x80	; 128
    23c8:	68 e2       	ldi	r22, 0x28	; 40
    23ca:	ce 01       	movw	r24, r28
        return ERROR_OK;
    23cc:	75 dd       	rcall	.-1302   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    }

    /* Set the prescaler (CLKPRE) */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKPRE, divisor);
    23ce:	0e c0       	rjmp	.+28     	; 0x23ec <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x3a>
    23d0:	26 2f       	mov	r18, r22
    23d2:	43 e0       	ldi	r20, 0x03	; 3
    23d4:	6f e0       	ldi	r22, 0x0F	; 15
    23d6:	70 dd       	rcall	.-1312   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>

    /* Turn on CLKEN */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, CANCTRL_CLKEN);
    23d8:	24 e0       	ldi	r18, 0x04	; 4
    23da:	44 e0       	ldi	r20, 0x04	; 4
    23dc:	6f e0       	ldi	r22, 0x0F	; 15
    23de:	ce 01       	movw	r24, r28
    23e0:	6b dd       	rcall	.-1322   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    23e2:	20 e0       	ldi	r18, 0x00	; 0

    /* Turn off CLKOUT for SOF */
    modifyRegister(MCP_CNF3, CNF3_SOF, 0x00);
    23e4:	40 e8       	ldi	r20, 0x80	; 128
    23e6:	68 e2       	ldi	r22, 0x28	; 40
    23e8:	ce 01       	movw	r24, r28
    23ea:	66 dd       	rcall	.-1332   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    23ec:	80 e0       	ldi	r24, 0x00	; 0
    23ee:	df 91       	pop	r29
    return ERROR_OK;
}
    23f0:	cf 91       	pop	r28
    23f2:	08 95       	ret

000023f4 <_ZN7MCP25159prepareIdEPhbm>:
    23f4:	0f 93       	push	r16
    23f6:	1f 93       	push	r17

void MCP2515::prepareId(uint8_t *buffer, const bool ext, const uint32_t id)
{
    23f8:	fb 01       	movw	r30, r22
    23fa:	44 23       	and	r20, r20
    23fc:	c9 f0       	breq	.+50     	; 0x2430 <_ZN7MCP25159prepareIdEPhbm+0x3c>
    uint16_t canid = (uint16_t)(id & 0x0FFFF);

    if (ext) {
    23fe:	03 83       	std	Z+3, r16	; 0x03
    2400:	12 83       	std	Z+2, r17	; 0x02
        buffer[MCP_EID0] = (uint8_t) (canid & 0xFF);
    2402:	89 01       	movw	r16, r18
        buffer[MCP_EID8] = (uint8_t) (canid >> 8);
    2404:	22 27       	eor	r18, r18
        canid = (uint16_t)(id >> 16);
    2406:	33 27       	eor	r19, r19
    2408:	80 2f       	mov	r24, r16
    240a:	8c 71       	andi	r24, 0x1C	; 28
        buffer[MCP_SIDL] = (uint8_t) (canid & 0x03);
        buffer[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
        buffer[MCP_SIDL] |= TXB_EXIDE_MASK;
    240c:	88 0f       	add	r24, r24
    240e:	88 0f       	add	r24, r24
    2410:	88 0f       	add	r24, r24
    2412:	90 2f       	mov	r25, r16
    2414:	93 70       	andi	r25, 0x03	; 3
    2416:	89 0f       	add	r24, r25
    2418:	88 60       	ori	r24, 0x08	; 8
    241a:	81 83       	std	Z+1, r24	; 0x01
    241c:	16 95       	lsr	r17
    241e:	07 95       	ror	r16
        buffer[MCP_SIDH] = (uint8_t) (canid >> 5);
    2420:	12 95       	swap	r17
    2422:	02 95       	swap	r16
    2424:	0f 70       	andi	r16, 0x0F	; 15
    2426:	01 27       	eor	r16, r17
    2428:	1f 70       	andi	r17, 0x0F	; 15
    242a:	01 27       	eor	r16, r17
    242c:	00 83       	st	Z, r16
    242e:	0e c0       	rjmp	.+28     	; 0x244c <_ZN7MCP25159prepareIdEPhbm+0x58>
    2430:	c8 01       	movw	r24, r16
    } else {
        buffer[MCP_SIDH] = (uint8_t) (canid >> 3);
    2432:	96 95       	lsr	r25
    2434:	87 95       	ror	r24
    2436:	96 95       	lsr	r25
    2438:	87 95       	ror	r24
    243a:	96 95       	lsr	r25
    243c:	87 95       	ror	r24
    243e:	80 83       	st	Z, r24
        buffer[MCP_SIDL] = (uint8_t) ((canid & 0x07 ) << 5);
    2440:	02 95       	swap	r16
    2442:	00 0f       	add	r16, r16
    2444:	00 7e       	andi	r16, 0xE0	; 224
    2446:	01 83       	std	Z+1, r16	; 0x01
        buffer[MCP_EID0] = 0;
    2448:	13 82       	std	Z+3, r1	; 0x03
        buffer[MCP_EID8] = 0;
    244a:	12 82       	std	Z+2, r1	; 0x02
    }
}
    244c:	1f 91       	pop	r17
    244e:	0f 91       	pop	r16
    2450:	08 95       	ret

00002452 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>:

MCP2515::ERROR MCP2515::setFilterMask(const MASK mask, const bool ext, const uint32_t ulData)
{
    2452:	8f 92       	push	r8
    2454:	9f 92       	push	r9
    2456:	af 92       	push	r10
    2458:	bf 92       	push	r11
    245a:	cf 92       	push	r12
    245c:	df 92       	push	r13
    245e:	ef 92       	push	r14
    2460:	ff 92       	push	r15
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	cf 93       	push	r28
    2468:	df 93       	push	r29
    246a:	00 d0       	rcall	.+0      	; 0x246c <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x1a>
    246c:	1f 92       	push	r1
    246e:	cd b7       	in	r28, 0x3d	; 61
    2470:	de b7       	in	r29, 0x3e	; 62
    2472:	7c 01       	movw	r14, r24
    2474:	d6 2e       	mov	r13, r22
    2476:	c4 2e       	mov	r12, r20
    2478:	48 01       	movw	r8, r16
    ERROR res = setConfigMode();
    247a:	59 01       	movw	r10, r18
    247c:	dd dd       	rcall	.-1094   	; 0x2038 <_ZN7MCP251513setConfigModeEv>
    if (res != ERROR_OK) {
    247e:	81 11       	cpse	r24, r1
    2480:	19 c0       	rjmp	.+50     	; 0x24b4 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
        return res;
    }
    
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    2482:	95 01       	movw	r18, r10
    2484:	84 01       	movw	r16, r8
    2486:	4c 2d       	mov	r20, r12
    2488:	be 01       	movw	r22, r28
    248a:	6f 5f       	subi	r22, 0xFF	; 255
    248c:	7f 4f       	sbci	r23, 0xFF	; 255
    248e:	c7 01       	movw	r24, r14
    2490:	b1 df       	rcall	.-158    	; 0x23f4 <_ZN7MCP25159prepareIdEPhbm>
    2492:	dd 20       	and	r13, r13

    REGISTER reg;
    switch (mask) {
    2494:	29 f0       	breq	.+10     	; 0x24a0 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x4e>
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	d8 12       	cpse	r13, r24
    249a:	0b c0       	rjmp	.+22     	; 0x24b2 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x60>
    249c:	64 e2       	ldi	r22, 0x24	; 36
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
    249e:	01 c0       	rjmp	.+2      	; 0x24a2 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x50>
    24a0:	60 e2       	ldi	r22, 0x20	; 32
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);

    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
    24a2:	24 e0       	ldi	r18, 0x04	; 4
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    }

    setRegisters(reg, tbufdata, 4);
    24a4:	ae 01       	movw	r20, r28
    24a6:	4f 5f       	subi	r20, 0xFF	; 255
    24a8:	5f 4f       	sbci	r21, 0xFF	; 255
    24aa:	c7 01       	movw	r24, r14
    24ac:	d0 dc       	rcall	.-1632   	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    24ae:	80 e0       	ldi	r24, 0x00	; 0
    
    return ERROR_OK;
    24b0:	01 c0       	rjmp	.+2      	; 0x24b4 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
    24b2:	81 e0       	ldi	r24, 0x01	; 1
    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    24b4:	0f 90       	pop	r0
    }

    setRegisters(reg, tbufdata, 4);
    
    return ERROR_OK;
}
    24b6:	0f 90       	pop	r0
    24b8:	0f 90       	pop	r0
    24ba:	0f 90       	pop	r0
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	1f 91       	pop	r17
    24c2:	0f 91       	pop	r16
    24c4:	ff 90       	pop	r15
    24c6:	ef 90       	pop	r14
    24c8:	df 90       	pop	r13
    24ca:	cf 90       	pop	r12
    24cc:	bf 90       	pop	r11
    24ce:	af 90       	pop	r10
    24d0:	9f 90       	pop	r9
    24d2:	8f 90       	pop	r8
    24d4:	08 95       	ret

000024d6 <_ZN7MCP25159setFilterENS_3RXFEbm>:
    24d6:	8f 92       	push	r8

MCP2515::ERROR MCP2515::setFilter(const RXF num, const bool ext, const uint32_t ulData)
{
    24d8:	9f 92       	push	r9
    24da:	af 92       	push	r10
    24dc:	bf 92       	push	r11
    24de:	cf 92       	push	r12
    24e0:	df 92       	push	r13
    24e2:	ef 92       	push	r14
    24e4:	ff 92       	push	r15
    24e6:	0f 93       	push	r16
    24e8:	1f 93       	push	r17
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
    24ee:	00 d0       	rcall	.+0      	; 0x24f0 <_ZN7MCP25159setFilterENS_3RXFEbm+0x1a>
    24f0:	1f 92       	push	r1
    24f2:	cd b7       	in	r28, 0x3d	; 61
    24f4:	de b7       	in	r29, 0x3e	; 62
    24f6:	6c 01       	movw	r12, r24
    24f8:	f6 2e       	mov	r15, r22
    24fa:	e4 2e       	mov	r14, r20
    24fc:	48 01       	movw	r8, r16
    24fe:	59 01       	movw	r10, r18
    2500:	9b dd       	rcall	.-1226   	; 0x2038 <_ZN7MCP251513setConfigModeEv>
    ERROR res = setConfigMode();
    2502:	81 11       	cpse	r24, r1
    2504:	3d c0       	rjmp	.+122    	; 0x2580 <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>
    if (res != ERROR_OK) {
    2506:	82 e0       	ldi	r24, 0x02	; 2
    2508:	f8 16       	cp	r15, r24
        return res;
    }

    REGISTER reg;

    switch (num) {
    250a:	a9 f0       	breq	.+42     	; 0x2536 <_ZN7MCP25159setFilterENS_3RXFEbm+0x60>
    250c:	8f 15       	cp	r24, r15
    250e:	30 f0       	brcs	.+12     	; 0x251c <_ZN7MCP25159setFilterENS_3RXFEbm+0x46>
    2510:	ff 20       	and	r15, r15
    2512:	19 f1       	breq	.+70     	; 0x255a <_ZN7MCP25159setFilterENS_3RXFEbm+0x84>
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	f8 16       	cp	r15, r24
    2518:	51 f0       	breq	.+20     	; 0x252e <_ZN7MCP25159setFilterENS_3RXFEbm+0x58>
    251a:	31 c0       	rjmp	.+98     	; 0x257e <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
    251c:	84 e0       	ldi	r24, 0x04	; 4
    251e:	f8 16       	cp	r15, r24
    2520:	91 f0       	breq	.+36     	; 0x2546 <_ZN7MCP25159setFilterENS_3RXFEbm+0x70>
    2522:	f8 16       	cp	r15, r24
    2524:	60 f0       	brcs	.+24     	; 0x253e <_ZN7MCP25159setFilterENS_3RXFEbm+0x68>
    2526:	85 e0       	ldi	r24, 0x05	; 5
    2528:	f8 16       	cp	r15, r24
    252a:	91 f0       	breq	.+36     	; 0x2550 <_ZN7MCP25159setFilterENS_3RXFEbm+0x7a>
    252c:	28 c0       	rjmp	.+80     	; 0x257e <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
        case RXF0: reg = MCP_RXF0SIDH; break;
        case RXF1: reg = MCP_RXF1SIDH; break;
    252e:	68 94       	set
    2530:	ff 24       	eor	r15, r15
    2532:	f2 f8       	bld	r15, 2
    2534:	13 c0       	rjmp	.+38     	; 0x255c <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF2: reg = MCP_RXF2SIDH; break;
    2536:	68 94       	set
    2538:	ff 24       	eor	r15, r15
    253a:	f3 f8       	bld	r15, 3
    253c:	0f c0       	rjmp	.+30     	; 0x255c <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF3: reg = MCP_RXF3SIDH; break;
    253e:	68 94       	set
    2540:	ff 24       	eor	r15, r15
    2542:	f4 f8       	bld	r15, 4
    2544:	0b c0       	rjmp	.+22     	; 0x255c <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF4: reg = MCP_RXF4SIDH; break;
    2546:	0f 2e       	mov	r0, r31
    2548:	f4 e1       	ldi	r31, 0x14	; 20
    254a:	ff 2e       	mov	r15, r31
    254c:	f0 2d       	mov	r31, r0
    254e:	06 c0       	rjmp	.+12     	; 0x255c <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF5: reg = MCP_RXF5SIDH; break;
    2550:	0f 2e       	mov	r0, r31
    2552:	f8 e1       	ldi	r31, 0x18	; 24
    2554:	ff 2e       	mov	r15, r31
    2556:	f0 2d       	mov	r31, r0
    2558:	01 c0       	rjmp	.+2      	; 0x255c <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
    }

    REGISTER reg;

    switch (num) {
        case RXF0: reg = MCP_RXF0SIDH; break;
    255a:	f1 2c       	mov	r15, r1
        default:
            return ERROR_FAIL;
    }

    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    255c:	95 01       	movw	r18, r10
    255e:	84 01       	movw	r16, r8
    2560:	4e 2d       	mov	r20, r14
    2562:	be 01       	movw	r22, r28
    2564:	6f 5f       	subi	r22, 0xFF	; 255
    2566:	7f 4f       	sbci	r23, 0xFF	; 255
    2568:	c6 01       	movw	r24, r12
    256a:	44 df       	rcall	.-376    	; 0x23f4 <_ZN7MCP25159prepareIdEPhbm>
    256c:	24 e0       	ldi	r18, 0x04	; 4
    setRegisters(reg, tbufdata, 4);
    256e:	ae 01       	movw	r20, r28
    2570:	4f 5f       	subi	r20, 0xFF	; 255
    2572:	5f 4f       	sbci	r21, 0xFF	; 255
    2574:	6f 2d       	mov	r22, r15
    2576:	c6 01       	movw	r24, r12
    2578:	6a dc       	rcall	.-1836   	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    257a:	80 e0       	ldi	r24, 0x00	; 0
    257c:	01 c0       	rjmp	.+2      	; 0x2580 <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>

    return ERROR_OK;
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	0f 90       	pop	r0
        case RXF2: reg = MCP_RXF2SIDH; break;
        case RXF3: reg = MCP_RXF3SIDH; break;
        case RXF4: reg = MCP_RXF4SIDH; break;
        case RXF5: reg = MCP_RXF5SIDH; break;
        default:
            return ERROR_FAIL;
    2582:	0f 90       	pop	r0
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    setRegisters(reg, tbufdata, 4);

    return ERROR_OK;
}
    2584:	0f 90       	pop	r0
    2586:	0f 90       	pop	r0
    2588:	df 91       	pop	r29
    258a:	cf 91       	pop	r28
    258c:	1f 91       	pop	r17
    258e:	0f 91       	pop	r16
    2590:	ff 90       	pop	r15
    2592:	ef 90       	pop	r14
    2594:	df 90       	pop	r13
    2596:	cf 90       	pop	r12
    2598:	bf 90       	pop	r11
    259a:	af 90       	pop	r10
    259c:	9f 90       	pop	r9
    259e:	8f 90       	pop	r8
    25a0:	08 95       	ret

000025a2 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>:
    25a2:	4f 92       	push	r4
    25a4:	5f 92       	push	r5

MCP2515::ERROR MCP2515::sendMessage(const TXBn txbn, const struct can_frame *frame)
{
    25a6:	6f 92       	push	r6
    25a8:	7f 92       	push	r7
    25aa:	af 92       	push	r10
    25ac:	bf 92       	push	r11
    25ae:	cf 92       	push	r12
    25b0:	df 92       	push	r13
    25b2:	ef 92       	push	r14
    25b4:	ff 92       	push	r15
    25b6:	0f 93       	push	r16
    25b8:	1f 93       	push	r17
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
    25be:	cd b7       	in	r28, 0x3d	; 61
    25c0:	de b7       	in	r29, 0x3e	; 62
    25c2:	2d 97       	sbiw	r28, 0x0d	; 13
    25c4:	0f b6       	in	r0, 0x3f	; 63
    25c6:	f8 94       	cli
    25c8:	de bf       	out	0x3e, r29	; 62
    25ca:	0f be       	out	0x3f, r0	; 63
    25cc:	cd bf       	out	0x3d, r28	; 61
    25ce:	5c 01       	movw	r10, r24
    25d0:	6a 01       	movw	r12, r20
    25d2:	e6 2e       	mov	r14, r22
    const struct TXBn_REGS *txbuf = &TXB[txbn];
    25d4:	f1 2c       	mov	r15, r1
    25d6:	fa 01       	movw	r30, r20

    uint8_t data[13];

    bool ext = (frame->can_id & CAN_EFF_FLAG);
    25d8:	00 81       	ld	r16, Z
    25da:	11 81       	ldd	r17, Z+1	; 0x01
    25dc:	22 81       	ldd	r18, Z+2	; 0x02
    25de:	33 81       	ldd	r19, Z+3	; 0x03
    25e0:	b9 01       	movw	r22, r18
    25e2:	a8 01       	movw	r20, r16
    25e4:	44 27       	eor	r20, r20
    25e6:	77 fd       	sbrc	r23, 7
    25e8:	43 95       	inc	r20
    25ea:	55 27       	eor	r21, r21
    25ec:	66 27       	eor	r22, r22
    25ee:	77 27       	eor	r23, r23
    25f0:	28 01       	movw	r4, r16
    bool rtr = (frame->can_id & CAN_RTR_FLAG);
    25f2:	39 01       	movw	r6, r18
    25f4:	44 24       	eor	r4, r4
    25f6:	55 24       	eor	r5, r5
    25f8:	66 24       	eor	r6, r6
    25fa:	f0 e4       	ldi	r31, 0x40	; 64
    25fc:	7f 22       	and	r7, r31
    25fe:	33 23       	and	r19, r19
    uint32_t id = (frame->can_id & (ext ? CAN_EFF_MASK : CAN_SFF_MASK));
    2600:	2c f0       	brlt	.+10     	; 0x260c <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x6a>
    2602:	8f ef       	ldi	r24, 0xFF	; 255
    2604:	97 e0       	ldi	r25, 0x07	; 7
    2606:	a0 e0       	ldi	r26, 0x00	; 0
    2608:	b0 e0       	ldi	r27, 0x00	; 0
    260a:	04 c0       	rjmp	.+8      	; 0x2614 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x72>
    260c:	8f ef       	ldi	r24, 0xFF	; 255
    260e:	9f ef       	ldi	r25, 0xFF	; 255
    2610:	af ef       	ldi	r26, 0xFF	; 255
    2612:	bf e1       	ldi	r27, 0x1F	; 31

    prepareId(data, ext, id);
    2614:	08 23       	and	r16, r24
    2616:	19 23       	and	r17, r25
    2618:	2a 23       	and	r18, r26
    261a:	3b 23       	and	r19, r27
    261c:	be 01       	movw	r22, r28
    261e:	6f 5f       	subi	r22, 0xFF	; 255
    2620:	7f 4f       	sbci	r23, 0xFF	; 255
    2622:	c5 01       	movw	r24, r10
    2624:	e7 de       	rcall	.-562    	; 0x23f4 <_ZN7MCP25159prepareIdEPhbm>

    data[MCP_DLC] = rtr ? (frame->can_dlc | RTR_MASK) : frame->can_dlc;
    2626:	45 28       	or	r4, r5
    2628:	46 28       	or	r4, r6
    262a:	47 28       	or	r4, r7
    262c:	21 f0       	breq	.+8      	; 0x2636 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x94>
    262e:	f6 01       	movw	r30, r12
    2630:	84 81       	ldd	r24, Z+4	; 0x04
    2632:	80 64       	ori	r24, 0x40	; 64
    2634:	02 c0       	rjmp	.+4      	; 0x263a <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x98>
    2636:	f6 01       	movw	r30, r12
    2638:	84 81       	ldd	r24, Z+4	; 0x04
    263a:	8d 83       	std	Y+5, r24	; 0x05

    memcpy(&data[MCP_DATA], frame->data, frame->can_dlc);
    263c:	f6 01       	movw	r30, r12
    263e:	14 81       	ldd	r17, Z+4	; 0x04
    2640:	41 2f       	mov	r20, r17
    2642:	50 e0       	ldi	r21, 0x00	; 0
    2644:	b6 01       	movw	r22, r12
    2646:	68 5f       	subi	r22, 0xF8	; 248
    2648:	7f 4f       	sbci	r23, 0xFF	; 255
    264a:	ce 01       	movw	r24, r28
    264c:	06 96       	adiw	r24, 0x06	; 6
    264e:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>

    setRegisters(txbuf->SIDH, data, 5 + frame->can_dlc);
    2652:	25 e0       	ldi	r18, 0x05	; 5
    2654:	21 0f       	add	r18, r17
    2656:	87 01       	movw	r16, r14
    2658:	00 0f       	add	r16, r16
    265a:	11 1f       	adc	r17, r17
    265c:	0e 0d       	add	r16, r14
    265e:	1f 1d       	adc	r17, r15
    2660:	0e 50       	subi	r16, 0x0E	; 14
    2662:	1d 4f       	sbci	r17, 0xFD	; 253
    2664:	ae 01       	movw	r20, r28
    2666:	4f 5f       	subi	r20, 0xFF	; 255
    2668:	5f 4f       	sbci	r21, 0xFF	; 255
    266a:	f8 01       	movw	r30, r16
    266c:	61 81       	ldd	r22, Z+1	; 0x01
    266e:	c5 01       	movw	r24, r10
    2670:	ee db       	rcall	.-2084   	; 0x1e4e <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    2672:	28 e0       	ldi	r18, 0x08	; 8

    modifyRegister(txbuf->CTRL, TXB_TXREQ, TXB_TXREQ);
    2674:	48 e0       	ldi	r20, 0x08	; 8
    2676:	f8 01       	movw	r30, r16
    2678:	60 81       	ld	r22, Z
    267a:	c5 01       	movw	r24, r10
    267c:	1d dc       	rcall	.-1990   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    267e:	80 e0       	ldi	r24, 0x00	; 0
    2680:	2d 96       	adiw	r28, 0x0d	; 13

    return ERROR_OK;
}
    2682:	0f b6       	in	r0, 0x3f	; 63
    2684:	f8 94       	cli
    2686:	de bf       	out	0x3e, r29	; 62
    2688:	0f be       	out	0x3f, r0	; 63
    268a:	cd bf       	out	0x3d, r28	; 61
    268c:	df 91       	pop	r29
    268e:	cf 91       	pop	r28
    2690:	1f 91       	pop	r17
    2692:	0f 91       	pop	r16
    2694:	ff 90       	pop	r15
    2696:	ef 90       	pop	r14
    2698:	df 90       	pop	r13
    269a:	cf 90       	pop	r12
    269c:	bf 90       	pop	r11
    269e:	af 90       	pop	r10
    26a0:	7f 90       	pop	r7
    26a2:	6f 90       	pop	r6
    26a4:	5f 90       	pop	r5
    26a6:	4f 90       	pop	r4
    26a8:	08 95       	ret

000026aa <_ZN7MCP251511sendMessageEPK9can_frame>:
    26aa:	9f 92       	push	r9

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    26ac:	af 92       	push	r10
    26ae:	bf 92       	push	r11
    26b0:	cf 92       	push	r12
    26b2:	df 92       	push	r13
    26b4:	ef 92       	push	r14
    26b6:	ff 92       	push	r15
    26b8:	0f 93       	push	r16
    26ba:	1f 93       	push	r17
    26bc:	cf 93       	push	r28
    26be:	df 93       	push	r29
    26c0:	00 d0       	rcall	.+0      	; 0x26c2 <_ZN7MCP251511sendMessageEPK9can_frame+0x18>
    26c2:	cd b7       	in	r28, 0x3d	; 61
    26c4:	de b7       	in	r29, 0x3e	; 62
    26c6:	6c 01       	movw	r12, r24
    if (frame->can_dlc > CAN_MAX_DLEN) {
    26c8:	fb 01       	movw	r30, r22
    26ca:	94 81       	ldd	r25, Z+4	; 0x04
    26cc:	99 30       	cpi	r25, 0x09	; 9
    26ce:	48 f5       	brcc	.+82     	; 0x2722 <_ZN7MCP251511sendMessageEPK9can_frame+0x78>
    26d0:	7b 01       	movw	r14, r22
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};
    26d2:	19 82       	std	Y+1, r1	; 0x01
    26d4:	81 e0       	ldi	r24, 0x01	; 1
    26d6:	8a 83       	std	Y+2, r24	; 0x02
    26d8:	82 e0       	ldi	r24, 0x02	; 2
    26da:	8b 83       	std	Y+3, r24	; 0x03
    26dc:	8e 01       	movw	r16, r28
    26de:	0f 5f       	subi	r16, 0xFF	; 255
    26e0:	1f 4f       	sbci	r17, 0xFF	; 255
    26e2:	5e 01       	movw	r10, r28
    26e4:	f4 e0       	ldi	r31, 0x04	; 4
    26e6:	af 0e       	add	r10, r31
    26e8:	b1 1c       	adc	r11, r1

    for (int i=0; i<N_TXBUFFERS; i++) {
        const struct TXBn_REGS *txbuf = &TXB[txBuffers[i]];
    26ea:	f8 01       	movw	r30, r16
    26ec:	91 90       	ld	r9, Z+
    26ee:	8f 01       	movw	r16, r30
        uint8_t ctrlval = readRegister(txbuf->CTRL);
    26f0:	29 2d       	mov	r18, r9
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	f9 01       	movw	r30, r18
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	2e 0f       	add	r18, r30
    26fc:	3f 1f       	adc	r19, r31
    26fe:	f9 01       	movw	r30, r18
    2700:	ee 50       	subi	r30, 0x0E	; 14
    2702:	fd 4f       	sbci	r31, 0xFD	; 253
    2704:	60 81       	ld	r22, Z
    2706:	c6 01       	movw	r24, r12
    2708:	2b db       	rcall	.-2474   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    270a:	83 fd       	sbrc	r24, 3
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
    270c:	05 c0       	rjmp	.+10     	; 0x2718 <_ZN7MCP251511sendMessageEPK9can_frame+0x6e>
    270e:	a7 01       	movw	r20, r14
            return sendMessage(txBuffers[i], frame);
    2710:	69 2d       	mov	r22, r9
    2712:	c6 01       	movw	r24, r12
    2714:	46 df       	rcall	.-372    	; 0x25a2 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    2716:	06 c0       	rjmp	.+12     	; 0x2724 <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
    2718:	0a 15       	cp	r16, r10
    271a:	1b 05       	cpc	r17, r11
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};

    for (int i=0; i<N_TXBUFFERS; i++) {
    271c:	31 f7       	brne	.-52     	; 0x26ea <_ZN7MCP251511sendMessageEPK9can_frame+0x40>
    271e:	84 e0       	ldi	r24, 0x04	; 4
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
    2720:	01 c0       	rjmp	.+2      	; 0x2724 <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
    2722:	84 e0       	ldi	r24, 0x04	; 4
}

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    if (frame->can_dlc > CAN_MAX_DLEN) {
        return ERROR_FAILTX;
    2724:	0f 90       	pop	r0
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
}
    2726:	0f 90       	pop	r0
    2728:	0f 90       	pop	r0
    272a:	df 91       	pop	r29
    272c:	cf 91       	pop	r28
    272e:	1f 91       	pop	r17
    2730:	0f 91       	pop	r16
    2732:	ff 90       	pop	r15
    2734:	ef 90       	pop	r14
    2736:	df 90       	pop	r13
    2738:	cf 90       	pop	r12
    273a:	bf 90       	pop	r11
    273c:	af 90       	pop	r10
    273e:	9f 90       	pop	r9
    2740:	08 95       	ret

00002742 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>:
    2742:	7f 92       	push	r7

MCP2515::ERROR MCP2515::readMessage(const RXBn rxbn, struct can_frame *frame)
{
    2744:	8f 92       	push	r8
    2746:	9f 92       	push	r9
    2748:	af 92       	push	r10
    274a:	bf 92       	push	r11
    274c:	cf 92       	push	r12
    274e:	df 92       	push	r13
    2750:	ef 92       	push	r14
    2752:	ff 92       	push	r15
    2754:	0f 93       	push	r16
    2756:	1f 93       	push	r17
    2758:	cf 93       	push	r28
    275a:	df 93       	push	r29
    275c:	00 d0       	rcall	.+0      	; 0x275e <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x1c>
    275e:	1f 92       	push	r1
    2760:	1f 92       	push	r1
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
    2766:	5c 01       	movw	r10, r24
    2768:	4a 01       	movw	r8, r20
    276a:	06 2f       	mov	r16, r22
    const struct RXBn_REGS *rxb = &RXB[rxbn];
    276c:	10 e0       	ldi	r17, 0x00	; 0
    276e:	f8 01       	movw	r30, r16

    uint8_t tbufdata[5];

    readRegisters(rxb->SIDH, tbufdata, 5);
    2770:	ee 0f       	add	r30, r30
    2772:	ff 1f       	adc	r31, r31
    2774:	ee 0f       	add	r30, r30
    2776:	ff 1f       	adc	r31, r31
    2778:	e6 51       	subi	r30, 0x16	; 22
    277a:	fd 4f       	sbci	r31, 0xFD	; 253
    277c:	25 e0       	ldi	r18, 0x05	; 5
    277e:	ae 01       	movw	r20, r28
    2780:	4f 5f       	subi	r20, 0xFF	; 255
    2782:	5f 4f       	sbci	r21, 0xFF	; 255
    2784:	61 81       	ldd	r22, Z+1	; 0x01
    2786:	0c db       	rcall	.-2536   	; 0x1da0 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    2788:	8a 81       	ldd	r24, Y+2	; 0x02
    278a:	99 81       	ldd	r25, Y+1	; 0x01

    uint32_t id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    278c:	c8 2e       	mov	r12, r24
    278e:	d1 2c       	mov	r13, r1
    2790:	d5 94       	asr	r13
    2792:	c7 94       	ror	r12
    2794:	d5 94       	asr	r13
    2796:	c7 94       	ror	r12
    2798:	d5 94       	asr	r13
    279a:	c7 94       	ror	r12
    279c:	d5 94       	asr	r13
    279e:	c7 94       	ror	r12
    27a0:	d5 94       	asr	r13
    27a2:	c7 94       	ror	r12
    27a4:	28 e0       	ldi	r18, 0x08	; 8
    27a6:	92 9f       	mul	r25, r18
    27a8:	c0 0c       	add	r12, r0
    27aa:	d1 1c       	adc	r13, r1
    27ac:	11 24       	eor	r1, r1
    27ae:	0d 2c       	mov	r0, r13
    27b0:	00 0c       	add	r0, r0
    27b2:	ee 08       	sbc	r14, r14
    27b4:	ff 08       	sbc	r15, r15
    27b6:	83 ff       	sbrs	r24, 3
	//printf("%lx	",id);
    if ( (tbufdata[MCP_SIDL] & TXB_EXIDE_MASK) ==  TXB_EXIDE_MASK ) {
    27b8:	21 c0       	rjmp	.+66     	; 0x27fc <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xba>
    27ba:	cc 0c       	add	r12, r12
        id = (id<<2) + (tbufdata[MCP_SIDL] & 0x03);
    27bc:	dd 1c       	adc	r13, r13
    27be:	ee 1c       	adc	r14, r14
    27c0:	ff 1c       	adc	r15, r15
    27c2:	cc 0c       	add	r12, r12
    27c4:	dd 1c       	adc	r13, r13
    27c6:	ee 1c       	adc	r14, r14
    27c8:	ff 1c       	adc	r15, r15
    27ca:	83 70       	andi	r24, 0x03	; 3
        id = (id<<8) + tbufdata[MCP_EID8];
    27cc:	c8 0e       	add	r12, r24
    27ce:	d1 1c       	adc	r13, r1
    27d0:	e1 1c       	adc	r14, r1
    27d2:	f1 1c       	adc	r15, r1
    27d4:	fe 2c       	mov	r15, r14
    27d6:	ed 2c       	mov	r14, r13
    27d8:	dc 2c       	mov	r13, r12
    27da:	cc 24       	eor	r12, r12
    27dc:	8b 81       	ldd	r24, Y+3	; 0x03
        id = (id<<8) + tbufdata[MCP_EID0];
    27de:	c8 0e       	add	r12, r24
    27e0:	d1 1c       	adc	r13, r1
    27e2:	e1 1c       	adc	r14, r1
    27e4:	f1 1c       	adc	r15, r1
    27e6:	fe 2c       	mov	r15, r14
    27e8:	ed 2c       	mov	r14, r13
    27ea:	dc 2c       	mov	r13, r12
    27ec:	cc 24       	eor	r12, r12
    27ee:	8c 81       	ldd	r24, Y+4	; 0x04
    27f0:	c8 0e       	add	r12, r24
    27f2:	d1 1c       	adc	r13, r1
    27f4:	e1 1c       	adc	r14, r1
        id |= CAN_EFF_FLAG;
    27f6:	f1 1c       	adc	r15, r1
    27f8:	68 94       	set
    }

    uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
    27fa:	f7 f8       	bld	r15, 7
    27fc:	8d 81       	ldd	r24, Y+5	; 0x05
    27fe:	8f 70       	andi	r24, 0x0F	; 15
    if (dlc > CAN_MAX_DLEN) {
    2800:	78 2e       	mov	r7, r24
    2802:	88 e0       	ldi	r24, 0x08	; 8
    2804:	87 15       	cp	r24, r7
        return ERROR_FAIL;
    }

    uint8_t ctrl = readRegister(rxb->CTRL);
    2806:	50 f1       	brcs	.+84     	; 0x285c <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11a>
    2808:	f8 01       	movw	r30, r16
    280a:	ee 0f       	add	r30, r30
    280c:	ff 1f       	adc	r31, r31
    280e:	ee 0f       	add	r30, r30
    2810:	ff 1f       	adc	r31, r31
    2812:	e6 51       	subi	r30, 0x16	; 22
    2814:	fd 4f       	sbci	r31, 0xFD	; 253
    2816:	60 81       	ld	r22, Z
    2818:	c5 01       	movw	r24, r10
    281a:	a2 da       	rcall	.-2748   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    if (ctrl & RXBnCTRL_RTR) {
    281c:	83 ff       	sbrs	r24, 3
    281e:	02 c0       	rjmp	.+4      	; 0x2824 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xe2>
        id |= CAN_RTR_FLAG;
    2820:	68 94       	set
    }

    frame->can_id = id;
    2822:	f6 f8       	bld	r15, 6
    2824:	f4 01       	movw	r30, r8
    2826:	c0 82       	st	Z, r12
    2828:	d1 82       	std	Z+1, r13	; 0x01
    frame->can_dlc = dlc;
    282a:	e2 82       	std	Z+2, r14	; 0x02


    readRegisters(rxb->DATA, frame->data, dlc);
    282c:	f3 82       	std	Z+3, r15	; 0x03
    282e:	74 82       	std	Z+4, r7	; 0x04
    2830:	a4 01       	movw	r20, r8
    2832:	48 5f       	subi	r20, 0xF8	; 248
    2834:	5f 4f       	sbci	r21, 0xFF	; 255
    2836:	00 0f       	add	r16, r16
    2838:	11 1f       	adc	r17, r17
    283a:	00 0f       	add	r16, r16
    283c:	11 1f       	adc	r17, r17
    283e:	06 51       	subi	r16, 0x16	; 22
    2840:	1d 4f       	sbci	r17, 0xFD	; 253
    2842:	27 2d       	mov	r18, r7
    2844:	f8 01       	movw	r30, r16

    modifyRegister(MCP_CANINTF, rxb->CANINTF_RXnIF, 0);
    2846:	62 81       	ldd	r22, Z+2	; 0x02
    2848:	c5 01       	movw	r24, r10
    284a:	aa da       	rcall	.-2732   	; 0x1da0 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    284c:	20 e0       	ldi	r18, 0x00	; 0
    284e:	f8 01       	movw	r30, r16
    2850:	43 81       	ldd	r20, Z+3	; 0x03

    return ERROR_OK;
    2852:	6c e2       	ldi	r22, 0x2C	; 44
        id |= CAN_EFF_FLAG;
    }

    uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
    if (dlc > CAN_MAX_DLEN) {
        return ERROR_FAIL;
    2854:	c5 01       	movw	r24, r10
    readRegisters(rxb->DATA, frame->data, dlc);

    modifyRegister(MCP_CANINTF, rxb->CANINTF_RXnIF, 0);

    return ERROR_OK;
}
    2856:	30 db       	rcall	.-2464   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	01 c0       	rjmp	.+2      	; 0x285e <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11c>
    285c:	81 e0       	ldi	r24, 0x01	; 1
    285e:	0f 90       	pop	r0
    2860:	0f 90       	pop	r0
    2862:	0f 90       	pop	r0
    2864:	0f 90       	pop	r0
    2866:	0f 90       	pop	r0
    2868:	df 91       	pop	r29
    286a:	cf 91       	pop	r28
    286c:	1f 91       	pop	r17
    286e:	0f 91       	pop	r16
    2870:	ff 90       	pop	r15
    2872:	ef 90       	pop	r14
    2874:	df 90       	pop	r13

MCP2515::ERROR MCP2515::readMessage(struct can_frame *frame)
{
    2876:	cf 90       	pop	r12
    2878:	bf 90       	pop	r11
    287a:	af 90       	pop	r10
    287c:	9f 90       	pop	r9
    287e:	8f 90       	pop	r8
    ERROR rc;
    uint8_t stat = getStatus();
    2880:	7f 90       	pop	r7
    2882:	08 95       	ret

00002884 <_ZN7MCP251511readMessageEP9can_frame>:

    if ( stat & STAT_RX0IF ) {
    2884:	0f 93       	push	r16
        rc = readMessage(RXB0, frame);
    2886:	1f 93       	push	r17
    2888:	cf 93       	push	r28
    288a:	df 93       	push	r29
    288c:	ec 01       	movw	r28, r24
    288e:	8b 01       	movw	r16, r22
    } else if ( stat & STAT_RX1IF ) {
    2890:	97 db       	rcall	.-2258   	; 0x1fc0 <_ZN7MCP25159getStatusEv>
    2892:	80 ff       	sbrs	r24, 0
        rc = readMessage(RXB1, frame);
    2894:	05 c0       	rjmp	.+10     	; 0x28a0 <_ZN7MCP251511readMessageEP9can_frame+0x1c>
    2896:	a8 01       	movw	r20, r16
    2898:	60 e0       	ldi	r22, 0x00	; 0
    289a:	ce 01       	movw	r24, r28
    289c:	52 df       	rcall	.-348    	; 0x2742 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    } else {
        rc = ERROR_NOMSG;
    289e:	08 c0       	rjmp	.+16     	; 0x28b0 <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    }

    return rc;
}
    28a0:	81 ff       	sbrs	r24, 1
    28a2:	05 c0       	rjmp	.+10     	; 0x28ae <_ZN7MCP251511readMessageEP9can_frame+0x2a>
    28a4:	a8 01       	movw	r20, r16
    28a6:	61 e0       	ldi	r22, 0x01	; 1

bool MCP2515::checkReceive(void)
{
    uint8_t res = getStatus();
    28a8:	ce 01       	movw	r24, r28
    28aa:	4b df       	rcall	.-362    	; 0x2742 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    28ac:	01 c0       	rjmp	.+2      	; 0x28b0 <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    28ae:	85 e0       	ldi	r24, 0x05	; 5
    28b0:	df 91       	pop	r29
    28b2:	cf 91       	pop	r28
    if ( res & STAT_RXIF_MASK ) {
        return true;
    } else {
        return false;
    }
}
    28b4:	1f 91       	pop	r17
    }
}

uint8_t MCP2515::getErrorFlags(void)
{
    return readRegister(MCP_EFLG);
    28b6:	0f 91       	pop	r16
    28b8:	08 95       	ret

000028ba <_ZN7MCP251512checkReceiveEv>:
    28ba:	82 db       	rcall	.-2300   	; 0x1fc0 <_ZN7MCP25159getStatusEv>
}
    28bc:	98 2f       	mov	r25, r24
    }
}

bool MCP2515::checkError(void)
{
    uint8_t eflg = getErrorFlags();
    28be:	93 70       	andi	r25, 0x03	; 3
    28c0:	81 e0       	ldi	r24, 0x01	; 1
    28c2:	09 f4       	brne	.+2      	; 0x28c6 <_ZN7MCP251512checkReceiveEv+0xc>
    28c4:	80 e0       	ldi	r24, 0x00	; 0
    28c6:	08 95       	ret

000028c8 <_ZN7MCP251513getErrorFlagsEv>:
    28c8:	6d e2       	ldi	r22, 0x2D	; 45
    28ca:	4a ca       	rjmp	.-2924   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    if ( eflg & EFLG_ERRORMASK ) {
        return true;
    } else {
        return false;
    }
}
    28cc:	08 95       	ret

000028ce <_ZN7MCP251510checkErrorEv>:
    return readRegister(MCP_EFLG);
}

void MCP2515::clearRXnOVRFlags(void)
{
	modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    28ce:	fc df       	rcall	.-8      	; 0x28c8 <_ZN7MCP251513getErrorFlagsEv>
    28d0:	98 2f       	mov	r25, r24
    28d2:	98 7f       	andi	r25, 0xF8	; 248
    28d4:	81 e0       	ldi	r24, 0x01	; 1
    28d6:	09 f4       	brne	.+2      	; 0x28da <_ZN7MCP251510checkErrorEv+0xc>
    28d8:	80 e0       	ldi	r24, 0x00	; 0
}

uint8_t MCP2515::getInterrupts(void)
{
    return readRegister(MCP_CANINTF);
    28da:	08 95       	ret

000028dc <_ZN7MCP251516clearRXnOVRFlagsEv>:
    28dc:	20 e0       	ldi	r18, 0x00	; 0
    28de:	40 ec       	ldi	r20, 0xC0	; 192
}
    28e0:	6d e2       	ldi	r22, 0x2D	; 45

void MCP2515::clearInterrupts(void)
{
    setRegister(MCP_CANINTF, 0);
    28e2:	ea ca       	rjmp	.-2604   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    28e4:	08 95       	ret

000028e6 <_ZN7MCP251513getInterruptsEv>:
    28e6:	6c e2       	ldi	r22, 0x2C	; 44
    28e8:	3b ca       	rjmp	.-2954   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    28ea:	08 95       	ret

000028ec <_ZN7MCP251515clearInterruptsEv>:
}

uint8_t MCP2515::getInterruptMask(void)
{
    return readRegister(MCP_CANINTE);
    28ec:	40 e0       	ldi	r20, 0x00	; 0
    28ee:	6c e2       	ldi	r22, 0x2C	; 44
    28f0:	8c ca       	rjmp	.-2792   	; 0x1e0a <_ZN7MCP251511setRegisterENS_8REGISTEREh>
}
    28f2:	08 95       	ret

000028f4 <_ZN7MCP251516getInterruptMaskEv>:

void MCP2515::clearTXInterrupts(void)
{
    modifyRegister(MCP_CANINTF, (CANINTF_TX0IF | CANINTF_TX1IF | CANINTF_TX2IF), 0);
    28f4:	6b e2       	ldi	r22, 0x2B	; 43
    28f6:	34 ca       	rjmp	.-2968   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    28f8:	08 95       	ret

000028fa <_ZN7MCP251517clearTXInterruptsEv>:
    28fa:	20 e0       	ldi	r18, 0x00	; 0
    28fc:	4c e1       	ldi	r20, 0x1C	; 28
    28fe:	6c e2       	ldi	r22, 0x2C	; 44
}

void MCP2515::clearRXnOVR(void)
{
    2900:	db ca       	rjmp	.-2634   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2902:	08 95       	ret

00002904 <_ZN7MCP251511clearRXnOVREv>:
    2904:	cf 93       	push	r28
	uint8_t eflg = getErrorFlags();
    2906:	df 93       	push	r29
    2908:	ec 01       	movw	r28, r24
	if (eflg != 0) {
    290a:	de df       	rcall	.-68     	; 0x28c8 <_ZN7MCP251513getErrorFlagsEv>
    290c:	88 23       	and	r24, r24
		clearRXnOVRFlags();
    290e:	21 f0       	breq	.+8      	; 0x2918 <_ZN7MCP251511clearRXnOVREv+0x14>
    2910:	ce 01       	movw	r24, r28
    2912:	e4 df       	rcall	.-56     	; 0x28dc <_ZN7MCP251516clearRXnOVRFlagsEv>
		clearInterrupts();
    2914:	ce 01       	movw	r24, r28
    2916:	ea df       	rcall	.-44     	; 0x28ec <_ZN7MCP251515clearInterruptsEv>
    2918:	df 91       	pop	r29
		//modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
	}
	
}
    291a:	cf 91       	pop	r28
    291c:	08 95       	ret

0000291e <_ZN7MCP25159clearMERREv>:
    291e:	20 e0       	ldi	r18, 0x00	; 0

void MCP2515::clearMERR()
{
	//modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
	//clearInterrupts();
	modifyRegister(MCP_CANINTF, CANINTF_MERRF, 0);
    2920:	40 e8       	ldi	r20, 0x80	; 128
    2922:	6c e2       	ldi	r22, 0x2C	; 44
    2924:	c9 ca       	rjmp	.-2670   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2926:	08 95       	ret

00002928 <_ZN7MCP251510clearERRIFEv>:
    2928:	20 e0       	ldi	r18, 0x00	; 0
    292a:	40 e2       	ldi	r20, 0x20	; 32

void MCP2515::clearERRIF()
{
    //modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    //clearInterrupts();
    modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
    292c:	6c e2       	ldi	r22, 0x2C	; 44
    292e:	c4 ca       	rjmp	.-2680   	; 0x1eb8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2930:	08 95       	ret

00002932 <_ZN7MCP251510checktxavaEv>:
    2932:	60 e3       	ldi	r22, 0x30	; 48
    2934:	15 da       	rcall	.-3030   	; 0x1d60 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2936:	80 e0       	ldi	r24, 0x00	; 0
}

MCP2515::ERROR MCP2515::checktxava(void) {
	if(((readRegister(MCP_TXB0CTRL)&TXB_TXREQ)>>TXB_TXREQ)==0) {
    2938:	08 95       	ret

0000293a <_ZN8SPIClass5beginEv>:

//PB4 is CS pin for CAN controller

void SPIClass::begin()
{
  uint8_t sreg = SREG;
    293a:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    293c:	f8 94       	cli
  if (!initialized) {
    293e:	80 91 f0 1f 	lds	r24, 0x1FF0	; 0x801ff0 <_ZN8SPIClass11initializedE>
    2942:	81 11       	cpse	r24, r1
    2944:	0f c0       	rjmp	.+30     	; 0x2964 <_ZN8SPIClass5beginEv+0x2a>
    // Set SS to high so a connected chip will be "deselected" by default
   // uint8_t port = digitalPinToPort(SS);
    //uint8_t bit = digitalPinToBitMask(SS);
    //volatile uint8_t *reg = portModeRegister(port);
	
	DDRB|=(1<<PB4); // sets SS to output
    2946:	24 9a       	sbi	0x04, 4	; 4
	DDRB|=(1<<PB0);
    2948:	20 9a       	sbi	0x04, 0	; 4
	PORTB|=(1<<PB0);
    294a:	28 9a       	sbi	0x05, 0	; 5

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
	
	PORTB|=(1<<PB4); // then set SS high
    294c:	2c 9a       	sbi	0x05, 4	; 5
   // pinMode(SS, OUTPUT);

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
		DDRB|=(1<<PB1); //set SCK out
    294e:	21 9a       	sbi	0x04, 1	; 4
		DDRB|=(1<<PB2); // set MOSI out
    2950:	22 9a       	sbi	0x04, 2	; 4

	
	
    SPCR |= (1<<(MSTR));
    2952:	8c b5       	in	r24, 0x2c	; 44
    2954:	80 61       	ori	r24, 0x10	; 16
    2956:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<(SPE));
    2958:	8c b5       	in	r24, 0x2c	; 44
    295a:	80 64       	ori	r24, 0x40	; 64
    295c:	8c bd       	out	0x2c, r24	; 44
	SPCR |= (1<<(SPR0)) | (1<<SPR1);
    295e:	8c b5       	in	r24, 0x2c	; 44
    2960:	83 60       	ori	r24, 0x03	; 3
    2962:	8c bd       	out	0x2c, r24	; 44


    //pinMode(SCK, OUTPUT);
    //pinMode(MOSI, OUTPUT);
  }
  initialized++; // reference count
    2964:	80 91 f0 1f 	lds	r24, 0x1FF0	; 0x801ff0 <_ZN8SPIClass11initializedE>
    2968:	8f 5f       	subi	r24, 0xFF	; 255
    296a:	80 93 f0 1f 	sts	0x1FF0, r24	; 0x801ff0 <_ZN8SPIClass11initializedE>
  SREG = sreg;
    296e:	9f bf       	out	0x3f, r25	; 63
    2970:	08 95       	ret

00002972 <_ZN8SPIClass3endEv>:
}

void SPIClass::end() {
  uint8_t sreg = SREG;
    2972:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2974:	f8 94       	cli
  // Decrease the reference counter
  if (initialized)
    2976:	80 91 f0 1f 	lds	r24, 0x1FF0	; 0x801ff0 <_ZN8SPIClass11initializedE>
    297a:	88 23       	and	r24, r24
    297c:	29 f0       	breq	.+10     	; 0x2988 <_ZN8SPIClass3endEv+0x16>
    initialized--;
    297e:	81 50       	subi	r24, 0x01	; 1
    2980:	80 93 f0 1f 	sts	0x1FF0, r24	; 0x801ff0 <_ZN8SPIClass11initializedE>
  // If there are no more references disable SPI
  if (!initialized) {
    2984:	81 11       	cpse	r24, r1
    2986:	05 c0       	rjmp	.+10     	; 0x2992 <_ZN8SPIClass3endEv+0x20>
    SPCR &= ~(1<<(SPE));
    2988:	8c b5       	in	r24, 0x2c	; 44
    298a:	8f 7b       	andi	r24, 0xBF	; 191
    298c:	8c bd       	out	0x2c, r24	; 44
    interruptMode = 0;
    298e:	10 92 ef 1f 	sts	0x1FEF, r1	; 0x801fef <_ZN8SPIClass13interruptModeE>
    #ifdef SPI_TRANSACTION_MISMATCH_LED
    inTransactionFlag = 0;
    #endif
  }
  SREG = sreg;
    2992:	9f bf       	out	0x3f, r25	; 63
    2994:	08 95       	ret

00002996 <_ZN8SPIClass14usingInterruptEh>:
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    2996:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2998:	f8 94       	cli
  switch (interruptNumber) {
    299a:	90 e0       	ldi	r25, 0x00	; 0
    299c:	88 30       	cpi	r24, 0x08	; 8
    299e:	91 05       	cpc	r25, r1
    29a0:	a8 f4       	brcc	.+42     	; 0x29cc <_ZN8SPIClass14usingInterruptEh+0x36>
    29a2:	fc 01       	movw	r30, r24
    29a4:	88 27       	eor	r24, r24
    29a6:	eb 54       	subi	r30, 0x4B	; 75
    29a8:	ff 4f       	sbci	r31, 0xFF	; 255
    29aa:	8f 4f       	sbci	r24, 0xFF	; 255
    29ac:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    29b0:	80 e2       	ldi	r24, 0x20	; 32
    29b2:	12 c0       	rjmp	.+36     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    29b4:	81 e0       	ldi	r24, 0x01	; 1
    29b6:	10 c0       	rjmp	.+32     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    29b8:	82 e0       	ldi	r24, 0x02	; 2
    29ba:	0e c0       	rjmp	.+28     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    29bc:	84 e0       	ldi	r24, 0x04	; 4
    29be:	0c c0       	rjmp	.+24     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    29c0:	88 e0       	ldi	r24, 0x08	; 8
    29c2:	0a c0       	rjmp	.+20     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    29c4:	80 e4       	ldi	r24, 0x40	; 64
    29c6:	08 c0       	rjmp	.+16     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    29c8:	80 e8       	ldi	r24, 0x80	; 128
    29ca:	06 c0       	rjmp	.+12     	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  default:
    interruptMode = 2;
    29cc:	82 e0       	ldi	r24, 0x02	; 2
    29ce:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <_ZN8SPIClass13interruptModeE>
  #endif
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
    29d2:	80 e0       	ldi	r24, 0x00	; 0
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
  #endif
  default:
    interruptMode = 2;
    break;
    29d4:	01 c0       	rjmp	.+2      	; 0x29d8 <_ZN8SPIClass14usingInterruptEh+0x42>
  uint8_t mask = 0;
  uint8_t sreg = SREG;
  cli(); // Protect from a scheduler and prevent transactionBegin
  switch (interruptNumber) {
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    29d6:	80 e1       	ldi	r24, 0x10	; 16
  #endif
  default:
    interruptMode = 2;
    break;
  }
  interruptMask |= mask;
    29d8:	90 91 ee 1f 	lds	r25, 0x1FEE	; 0x801fee <_ZN8SPIClass13interruptMaskE>
    29dc:	89 2b       	or	r24, r25
    29de:	80 93 ee 1f 	sts	0x1FEE, r24	; 0x801fee <_ZN8SPIClass13interruptMaskE>
  if (!interruptMode)
    29e2:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    29e6:	81 11       	cpse	r24, r1
    29e8:	03 c0       	rjmp	.+6      	; 0x29f0 <_ZN8SPIClass14usingInterruptEh+0x5a>
    interruptMode = 1;
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    29f0:	2f bf       	out	0x3f, r18	; 63
    29f2:	08 95       	ret

000029f4 <_ZN8SPIClass17notUsingInterruptEh>:
}

void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    29f4:	90 91 ef 1f 	lds	r25, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptModeE>
    29f8:	92 30       	cpi	r25, 0x02	; 2
    29fa:	49 f1       	breq	.+82     	; 0x2a4e <_ZN8SPIClass17notUsingInterruptEh+0x5a>
    return;
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    29fc:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    29fe:	f8 94       	cli
  switch (interruptNumber) {
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	88 30       	cpi	r24, 0x08	; 8
    2a04:	91 05       	cpc	r25, r1
    2a06:	b8 f4       	brcc	.+46     	; 0x2a36 <_ZN8SPIClass17notUsingInterruptEh+0x42>
    2a08:	fc 01       	movw	r30, r24
    2a0a:	88 27       	eor	r24, r24
    2a0c:	e3 54       	subi	r30, 0x43	; 67
    2a0e:	ff 4f       	sbci	r31, 0xFF	; 255
    2a10:	8f 4f       	sbci	r24, 0xFF	; 255
    2a12:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    2a16:	80 e1       	ldi	r24, 0x10	; 16
    2a18:	0f c0       	rjmp	.+30     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    2a1a:	80 e2       	ldi	r24, 0x20	; 32
    2a1c:	0d c0       	rjmp	.+26     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    2a1e:	81 e0       	ldi	r24, 0x01	; 1
    2a20:	0b c0       	rjmp	.+22     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    2a22:	82 e0       	ldi	r24, 0x02	; 2
    2a24:	09 c0       	rjmp	.+18     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    2a26:	84 e0       	ldi	r24, 0x04	; 4
    2a28:	07 c0       	rjmp	.+14     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    2a2a:	88 e0       	ldi	r24, 0x08	; 8
    2a2c:	05 c0       	rjmp	.+10     	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    2a2e:	80 e4       	ldi	r24, 0x40	; 64
    2a30:	03 c0       	rjmp	.+6      	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    2a32:	80 e8       	ldi	r24, 0x80	; 128
    2a34:	01 c0       	rjmp	.+2      	; 0x2a38 <_ZN8SPIClass17notUsingInterruptEh+0x44>
void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    return;
  uint8_t mask = 0;
    2a36:	80 e0       	ldi	r24, 0x00	; 0
  #endif
  default:
    break;
    // this case can't be reached
  }
  interruptMask &= ~mask;
    2a38:	80 95       	com	r24
    2a3a:	90 91 ee 1f 	lds	r25, 0x1FEE	; 0x801fee <_ZN8SPIClass13interruptMaskE>
    2a3e:	89 23       	and	r24, r25
    2a40:	80 93 ee 1f 	sts	0x1FEE, r24	; 0x801fee <_ZN8SPIClass13interruptMaskE>
  if (!interruptMask)
    2a44:	81 11       	cpse	r24, r1
    2a46:	02 c0       	rjmp	.+4      	; 0x2a4c <_ZN8SPIClass17notUsingInterruptEh+0x58>
    interruptMode = 0;
    2a48:	10 92 ef 1f 	sts	0x1FEF, r1	; 0x801fef <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    2a4c:	2f bf       	out	0x3f, r18	; 63
    2a4e:	08 95       	ret

00002a50 <usart_init>:
	return b;
}

void usart_nl(void) {
			usart_putchar('\r');
			usart_putchar('\n');
    2a50:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
    2a54:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
    2a58:	e0 ec       	ldi	r30, 0xC0	; 192
    2a5a:	f0 e0       	ldi	r31, 0x00	; 0
    2a5c:	80 81       	ld	r24, Z
    2a5e:	82 60       	ori	r24, 0x02	; 2
    2a60:	80 83       	st	Z, r24
    2a62:	88 e0       	ldi	r24, 0x08	; 8
    2a64:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
    2a68:	86 e0       	ldi	r24, 0x06	; 6
    2a6a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
    2a6e:	08 95       	ret

00002a70 <usart_putchar>:
    2a70:	e0 ec       	ldi	r30, 0xC0	; 192
    2a72:	f0 e0       	ldi	r31, 0x00	; 0
    2a74:	90 81       	ld	r25, Z
    2a76:	95 ff       	sbrs	r25, 5
    2a78:	fd cf       	rjmp	.-6      	; 0x2a74 <usart_putchar+0x4>
    2a7a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    2a7e:	08 95       	ret

00002a80 <usart_putchar_printf>:
}

int usart_putchar_printf(char var, FILE *stream) {
    2a80:	cf 93       	push	r28
    2a82:	c8 2f       	mov	r28, r24
	if (var == '\n') usart_putchar('\r');
    2a84:	8a 30       	cpi	r24, 0x0A	; 10
    2a86:	11 f4       	brne	.+4      	; 0x2a8c <usart_putchar_printf+0xc>
    2a88:	8d e0       	ldi	r24, 0x0D	; 13
    2a8a:	f2 df       	rcall	.-28     	; 0x2a70 <usart_putchar>
	usart_putchar(var);
    2a8c:	8c 2f       	mov	r24, r28
    2a8e:	f0 df       	rcall	.-32     	; 0x2a70 <usart_putchar>
	return 0;
}
    2a90:	80 e0       	ldi	r24, 0x00	; 0
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	cf 91       	pop	r28
    2a96:	08 95       	ret

00002a98 <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    2a98:	cf 92       	push	r12
    2a9a:	df 92       	push	r13
    2a9c:	ef 92       	push	r14
    2a9e:	ff 92       	push	r15
    2aa0:	0f 93       	push	r16
    2aa2:	1f 93       	push	r17
    2aa4:	cf 93       	push	r28
    2aa6:	df 93       	push	r29
    2aa8:	1f 92       	push	r1
    2aaa:	1f 92       	push	r1
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	90 93 f4 03 	sts	0x03F4, r25	; 0x8003f4 <count+0x1>
    2ab4:	80 93 f3 03 	sts	0x03F3, r24	; 0x8003f3 <count>
    2ab8:	9b 01       	movw	r18, r22
    2aba:	22 5f       	subi	r18, 0xF2	; 242
    2abc:	3f 4f       	sbci	r19, 0xFF	; 255
    2abe:	30 93 f2 03 	sts	0x03F2, r19	; 0x8003f2 <size+0x1>
    2ac2:	20 93 f1 03 	sts	0x03F1, r18	; 0x8003f1 <size>
    2ac6:	6b 01       	movw	r12, r22
    2ac8:	22 e1       	ldi	r18, 0x12	; 18
    2aca:	c2 0e       	add	r12, r18
    2acc:	d1 1c       	adc	r13, r1
    2ace:	8c 9d       	mul	r24, r12
    2ad0:	80 01       	movw	r16, r0
    2ad2:	8d 9d       	mul	r24, r13
    2ad4:	10 0d       	add	r17, r0
    2ad6:	9c 9d       	mul	r25, r12
    2ad8:	10 0d       	add	r17, r0
    2ada:	11 24       	eor	r1, r1
    2adc:	c8 01       	movw	r24, r16
    2ade:	0e 94 62 24 	call	0x48c4	; 0x48c4 <csp_malloc>
    2ae2:	90 93 f6 03 	sts	0x03F6, r25	; 0x8003f6 <csp_buffer_pool+0x1>
    2ae6:	80 93 f5 03 	sts	0x03F5, r24	; 0x8003f5 <csp_buffer_pool>
    2aea:	89 2b       	or	r24, r25
    2aec:	09 f4       	brne	.+2      	; 0x2af0 <csp_buffer_init+0x58>
    2aee:	52 c0       	rjmp	.+164    	; 0x2b94 <csp_buffer_init+0xfc>
    2af0:	62 e0       	ldi	r22, 0x02	; 2
    2af2:	70 e0       	ldi	r23, 0x00	; 0
    2af4:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2af8:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2afc:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <csp_queue_create>
    2b00:	90 93 f8 03 	sts	0x03F8, r25	; 0x8003f8 <csp_buffers+0x1>
    2b04:	80 93 f7 03 	sts	0x03F7, r24	; 0x8003f7 <csp_buffers>
    2b08:	89 2b       	or	r24, r25
    2b0a:	d9 f1       	breq	.+118    	; 0x2b82 <csp_buffer_init+0xea>
    2b0c:	a8 01       	movw	r20, r16
    2b0e:	60 e0       	ldi	r22, 0x00	; 0
    2b10:	70 e0       	ldi	r23, 0x00	; 0
    2b12:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2b16:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2b1a:	0e 94 ac 42 	call	0x8558	; 0x8558 <memset>
    2b1e:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2b22:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2b26:	89 2b       	or	r24, r25
    2b28:	c1 f1       	breq	.+112    	; 0x2b9a <csp_buffer_init+0x102>
    2b2a:	e1 2c       	mov	r14, r1
    2b2c:	f1 2c       	mov	r15, r1
    2b2e:	00 e0       	ldi	r16, 0x00	; 0
    2b30:	10 e0       	ldi	r17, 0x00	; 0
    2b32:	e0 91 f5 03 	lds	r30, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2b36:	f0 91 f6 03 	lds	r31, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2b3a:	ee 0d       	add	r30, r14
    2b3c:	ff 1d       	adc	r31, r15
    2b3e:	fa 83       	std	Y+2, r31	; 0x02
    2b40:	e9 83       	std	Y+1, r30	; 0x01
    2b42:	11 82       	std	Z+1, r1	; 0x01
    2b44:	10 82       	st	Z, r1
    2b46:	e9 81       	ldd	r30, Y+1	; 0x01
    2b48:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4a:	f3 83       	std	Z+3, r31	; 0x03
    2b4c:	e2 83       	std	Z+2, r30	; 0x02
    2b4e:	20 e0       	ldi	r18, 0x00	; 0
    2b50:	30 e0       	ldi	r19, 0x00	; 0
    2b52:	a9 01       	movw	r20, r18
    2b54:	be 01       	movw	r22, r28
    2b56:	6f 5f       	subi	r22, 0xFF	; 255
    2b58:	7f 4f       	sbci	r23, 0xFF	; 255
    2b5a:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2b5e:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2b62:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <csp_queue_enqueue>
    2b66:	0f 5f       	subi	r16, 0xFF	; 255
    2b68:	1f 4f       	sbci	r17, 0xFF	; 255
    2b6a:	ec 0c       	add	r14, r12
    2b6c:	fd 1c       	adc	r15, r13
    2b6e:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2b72:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2b76:	08 17       	cp	r16, r24
    2b78:	19 07       	cpc	r17, r25
    2b7a:	d8 f2       	brcs	.-74     	; 0x2b32 <csp_buffer_init+0x9a>
    2b7c:	80 e0       	ldi	r24, 0x00	; 0
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	0e c0       	rjmp	.+28     	; 0x2b9e <csp_buffer_init+0x106>
    2b82:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2b86:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2b8a:	0e 94 65 24 	call	0x48ca	; 0x48ca <csp_free>
    2b8e:	8f ef       	ldi	r24, 0xFF	; 255
    2b90:	9f ef       	ldi	r25, 0xFF	; 255
    2b92:	05 c0       	rjmp	.+10     	; 0x2b9e <csp_buffer_init+0x106>
    2b94:	8f ef       	ldi	r24, 0xFF	; 255
    2b96:	9f ef       	ldi	r25, 0xFF	; 255
    2b98:	02 c0       	rjmp	.+4      	; 0x2b9e <csp_buffer_init+0x106>
    2b9a:	80 e0       	ldi	r24, 0x00	; 0
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	df 91       	pop	r29
    2ba4:	cf 91       	pop	r28
    2ba6:	1f 91       	pop	r17
    2ba8:	0f 91       	pop	r16
    2baa:	ff 90       	pop	r15
    2bac:	ef 90       	pop	r14
    2bae:	df 90       	pop	r13
    2bb0:	cf 90       	pop	r12
    2bb2:	08 95       	ret

00002bb4 <csp_buffer_get>:
    2bb4:	cf 93       	push	r28
    2bb6:	df 93       	push	r29
    2bb8:	1f 92       	push	r1
    2bba:	1f 92       	push	r1
    2bbc:	cd b7       	in	r28, 0x3d	; 61
    2bbe:	de b7       	in	r29, 0x3e	; 62
    2bc0:	1a 82       	std	Y+2, r1	; 0x02
    2bc2:	19 82       	std	Y+1, r1	; 0x01
    2bc4:	ac 01       	movw	r20, r24
    2bc6:	42 5f       	subi	r20, 0xF2	; 242
    2bc8:	5f 4f       	sbci	r21, 0xFF	; 255
    2bca:	20 91 f1 03 	lds	r18, 0x03F1	; 0x8003f1 <size>
    2bce:	30 91 f2 03 	lds	r19, 0x03F2	; 0x8003f2 <size+0x1>
    2bd2:	24 17       	cp	r18, r20
    2bd4:	35 07       	cpc	r19, r21
    2bd6:	80 f4       	brcc	.+32     	; 0x2bf8 <csp_buffer_get+0x44>
    2bd8:	9f 93       	push	r25
    2bda:	8f 93       	push	r24
    2bdc:	85 ea       	ldi	r24, 0xA5	; 165
    2bde:	92 e0       	ldi	r25, 0x02	; 2
    2be0:	9f 93       	push	r25
    2be2:	8f 93       	push	r24
    2be4:	1f 92       	push	r1
    2be6:	cc d4       	rcall	.+2456   	; 0x3580 <do_csp_debug>
    2be8:	0f 90       	pop	r0
    2bea:	0f 90       	pop	r0
    2bec:	0f 90       	pop	r0
    2bee:	0f 90       	pop	r0
    2bf0:	0f 90       	pop	r0
    2bf2:	80 e0       	ldi	r24, 0x00	; 0
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	58 c0       	rjmp	.+176    	; 0x2ca8 <csp_buffer_get+0xf4>
    2bf8:	20 e0       	ldi	r18, 0x00	; 0
    2bfa:	30 e0       	ldi	r19, 0x00	; 0
    2bfc:	a9 01       	movw	r20, r18
    2bfe:	be 01       	movw	r22, r28
    2c00:	6f 5f       	subi	r22, 0xFF	; 255
    2c02:	7f 4f       	sbci	r23, 0xFF	; 255
    2c04:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2c08:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2c0c:	0e 94 23 26 	call	0x4c46	; 0x4c46 <csp_queue_dequeue>
    2c10:	e9 81       	ldd	r30, Y+1	; 0x01
    2c12:	fa 81       	ldd	r31, Y+2	; 0x02
    2c14:	30 97       	sbiw	r30, 0x00	; 0
    2c16:	61 f4       	brne	.+24     	; 0x2c30 <csp_buffer_get+0x7c>
    2c18:	86 e9       	ldi	r24, 0x96	; 150
    2c1a:	92 e0       	ldi	r25, 0x02	; 2
    2c1c:	9f 93       	push	r25
    2c1e:	8f 93       	push	r24
    2c20:	1f 92       	push	r1
    2c22:	ae d4       	rcall	.+2396   	; 0x3580 <do_csp_debug>
    2c24:	0f 90       	pop	r0
    2c26:	0f 90       	pop	r0
    2c28:	0f 90       	pop	r0
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	3c c0       	rjmp	.+120    	; 0x2ca8 <csp_buffer_get+0xf4>
    2c30:	83 81       	ldd	r24, Z+3	; 0x03
    2c32:	8f 93       	push	r24
    2c34:	82 81       	ldd	r24, Z+2	; 0x02
    2c36:	8f 93       	push	r24
    2c38:	ff 93       	push	r31
    2c3a:	ef 93       	push	r30
    2c3c:	8b e8       	ldi	r24, 0x8B	; 139
    2c3e:	92 e0       	ldi	r25, 0x02	; 2
    2c40:	9f 93       	push	r25
    2c42:	8f 93       	push	r24
    2c44:	83 e0       	ldi	r24, 0x03	; 3
    2c46:	8f 93       	push	r24
    2c48:	9b d4       	rcall	.+2358   	; 0x3580 <do_csp_debug>
    2c4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c4e:	0f b6       	in	r0, 0x3f	; 63
    2c50:	f8 94       	cli
    2c52:	de bf       	out	0x3e, r29	; 62
    2c54:	0f be       	out	0x3f, r0	; 63
    2c56:	cd bf       	out	0x3d, r28	; 61
    2c58:	82 81       	ldd	r24, Z+2	; 0x02
    2c5a:	93 81       	ldd	r25, Z+3	; 0x03
    2c5c:	e8 17       	cp	r30, r24
    2c5e:	f9 07       	cpc	r31, r25
    2c60:	d9 f0       	breq	.+54     	; 0x2c98 <csp_buffer_get+0xe4>
    2c62:	88 e7       	ldi	r24, 0x78	; 120
    2c64:	92 e0       	ldi	r25, 0x02	; 2
    2c66:	9f 93       	push	r25
    2c68:	8f 93       	push	r24
    2c6a:	1f 92       	push	r1
    2c6c:	89 d4       	rcall	.+2322   	; 0x3580 <do_csp_debug>
    2c6e:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2c72:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2c76:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <vPortFree>
    2c7a:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <size>
    2c7e:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <size+0x1>
    2c82:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2c86:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2c8a:	06 df       	rcall	.-500    	; 0x2a98 <csp_buffer_init>
    2c8c:	0f 90       	pop	r0
    2c8e:	0f 90       	pop	r0
    2c90:	0f 90       	pop	r0
    2c92:	80 e0       	ldi	r24, 0x00	; 0
    2c94:	90 e0       	ldi	r25, 0x00	; 0
    2c96:	08 c0       	rjmp	.+16     	; 0x2ca8 <csp_buffer_get+0xf4>
    2c98:	80 81       	ld	r24, Z
    2c9a:	91 81       	ldd	r25, Z+1	; 0x01
    2c9c:	01 96       	adiw	r24, 0x01	; 1
    2c9e:	91 83       	std	Z+1, r25	; 0x01
    2ca0:	80 83       	st	Z, r24
    2ca2:	89 81       	ldd	r24, Y+1	; 0x01
    2ca4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca6:	04 96       	adiw	r24, 0x04	; 4
    2ca8:	0f 90       	pop	r0
    2caa:	0f 90       	pop	r0
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	08 95       	ret

00002cb2 <csp_buffer_free_isr>:
    2cb2:	cf 93       	push	r28
    2cb4:	df 93       	push	r29
    2cb6:	00 d0       	rcall	.+0      	; 0x2cb8 <csp_buffer_free_isr+0x6>
    2cb8:	cd b7       	in	r28, 0x3d	; 61
    2cba:	de b7       	in	r29, 0x3e	; 62
    2cbc:	19 82       	std	Y+1, r1	; 0x01
    2cbe:	00 97       	sbiw	r24, 0x00	; 0
    2cc0:	31 f1       	breq	.+76     	; 0x2d0e <csp_buffer_free_isr+0x5c>
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	34 97       	sbiw	r30, 0x04	; 4
    2cc6:	fb 83       	std	Y+3, r31	; 0x03
    2cc8:	ea 83       	std	Y+2, r30	; 0x02
    2cca:	22 81       	ldd	r18, Z+2	; 0x02
    2ccc:	33 81       	ldd	r19, Z+3	; 0x03
    2cce:	e2 17       	cp	r30, r18
    2cd0:	f3 07       	cpc	r31, r19
    2cd2:	e9 f4       	brne	.+58     	; 0x2d0e <csp_buffer_free_isr+0x5c>
    2cd4:	20 81       	ld	r18, Z
    2cd6:	31 81       	ldd	r19, Z+1	; 0x01
    2cd8:	21 15       	cp	r18, r1
    2cda:	31 05       	cpc	r19, r1
    2cdc:	c1 f0       	breq	.+48     	; 0x2d0e <csp_buffer_free_isr+0x5c>
    2cde:	22 30       	cpi	r18, 0x02	; 2
    2ce0:	31 05       	cpc	r19, r1
    2ce2:	28 f0       	brcs	.+10     	; 0x2cee <csp_buffer_free_isr+0x3c>
    2ce4:	21 50       	subi	r18, 0x01	; 1
    2ce6:	31 09       	sbc	r19, r1
    2ce8:	31 83       	std	Z+1, r19	; 0x01
    2cea:	20 83       	st	Z, r18
    2cec:	10 c0       	rjmp	.+32     	; 0x2d0e <csp_buffer_free_isr+0x5c>
    2cee:	fc 01       	movw	r30, r24
    2cf0:	34 97       	sbiw	r30, 0x04	; 4
    2cf2:	11 82       	std	Z+1, r1	; 0x01
    2cf4:	10 82       	st	Z, r1
    2cf6:	ae 01       	movw	r20, r28
    2cf8:	4f 5f       	subi	r20, 0xFF	; 255
    2cfa:	5f 4f       	sbci	r21, 0xFF	; 255
    2cfc:	be 01       	movw	r22, r28
    2cfe:	6e 5f       	subi	r22, 0xFE	; 254
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2d06:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2d0a:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <csp_queue_enqueue_isr>
    2d0e:	0f 90       	pop	r0
    2d10:	0f 90       	pop	r0
    2d12:	0f 90       	pop	r0
    2d14:	df 91       	pop	r29
    2d16:	cf 91       	pop	r28
    2d18:	08 95       	ret

00002d1a <csp_buffer_free>:
    2d1a:	cf 93       	push	r28
    2d1c:	df 93       	push	r29
    2d1e:	1f 92       	push	r1
    2d20:	1f 92       	push	r1
    2d22:	cd b7       	in	r28, 0x3d	; 61
    2d24:	de b7       	in	r29, 0x3e	; 62
    2d26:	00 97       	sbiw	r24, 0x00	; 0
    2d28:	51 f4       	brne	.+20     	; 0x2d3e <csp_buffer_free+0x24>
    2d2a:	8b e5       	ldi	r24, 0x5B	; 91
    2d2c:	92 e0       	ldi	r25, 0x02	; 2
    2d2e:	9f 93       	push	r25
    2d30:	8f 93       	push	r24
    2d32:	1f 92       	push	r1
    2d34:	25 d4       	rcall	.+2122   	; 0x3580 <do_csp_debug>
    2d36:	0f 90       	pop	r0
    2d38:	0f 90       	pop	r0
    2d3a:	0f 90       	pop	r0
    2d3c:	63 c0       	rjmp	.+198    	; 0x2e04 <csp_buffer_free+0xea>
    2d3e:	fc 01       	movw	r30, r24
    2d40:	34 97       	sbiw	r30, 0x04	; 4
    2d42:	fa 83       	std	Y+2, r31	; 0x02
    2d44:	e9 83       	std	Y+1, r30	; 0x01
    2d46:	22 81       	ldd	r18, Z+2	; 0x02
    2d48:	33 81       	ldd	r19, Z+3	; 0x03
    2d4a:	e2 17       	cp	r30, r18
    2d4c:	f3 07       	cpc	r31, r19
    2d4e:	71 f0       	breq	.+28     	; 0x2d6c <csp_buffer_free+0x52>
    2d50:	9f 93       	push	r25
    2d52:	8f 93       	push	r24
    2d54:	87 e3       	ldi	r24, 0x37	; 55
    2d56:	92 e0       	ldi	r25, 0x02	; 2
    2d58:	9f 93       	push	r25
    2d5a:	8f 93       	push	r24
    2d5c:	1f 92       	push	r1
    2d5e:	10 d4       	rcall	.+2080   	; 0x3580 <do_csp_debug>
    2d60:	0f 90       	pop	r0
    2d62:	0f 90       	pop	r0
    2d64:	0f 90       	pop	r0
    2d66:	0f 90       	pop	r0
    2d68:	0f 90       	pop	r0
    2d6a:	4c c0       	rjmp	.+152    	; 0x2e04 <csp_buffer_free+0xea>
    2d6c:	dc 01       	movw	r26, r24
    2d6e:	14 97       	sbiw	r26, 0x04	; 4
    2d70:	2d 91       	ld	r18, X+
    2d72:	3c 91       	ld	r19, X
    2d74:	21 15       	cp	r18, r1
    2d76:	31 05       	cpc	r19, r1
    2d78:	71 f4       	brne	.+28     	; 0x2d96 <csp_buffer_free+0x7c>
    2d7a:	ff 93       	push	r31
    2d7c:	ef 93       	push	r30
    2d7e:	8a e1       	ldi	r24, 0x1A	; 26
    2d80:	92 e0       	ldi	r25, 0x02	; 2
    2d82:	9f 93       	push	r25
    2d84:	8f 93       	push	r24
    2d86:	1f 92       	push	r1
    2d88:	fb d3       	rcall	.+2038   	; 0x3580 <do_csp_debug>
    2d8a:	0f 90       	pop	r0
    2d8c:	0f 90       	pop	r0
    2d8e:	0f 90       	pop	r0
    2d90:	0f 90       	pop	r0
    2d92:	0f 90       	pop	r0
    2d94:	37 c0       	rjmp	.+110    	; 0x2e04 <csp_buffer_free+0xea>
    2d96:	22 30       	cpi	r18, 0x02	; 2
    2d98:	31 05       	cpc	r19, r1
    2d9a:	b0 f0       	brcs	.+44     	; 0x2dc8 <csp_buffer_free+0xae>
    2d9c:	21 50       	subi	r18, 0x01	; 1
    2d9e:	31 09       	sbc	r19, r1
    2da0:	dc 01       	movw	r26, r24
    2da2:	14 97       	sbiw	r26, 0x04	; 4
    2da4:	2d 93       	st	X+, r18
    2da6:	3c 93       	st	X, r19
    2da8:	3f 93       	push	r19
    2daa:	2f 93       	push	r18
    2dac:	ff 93       	push	r31
    2dae:	ef 93       	push	r30
    2db0:	87 ef       	ldi	r24, 0xF7	; 247
    2db2:	91 e0       	ldi	r25, 0x01	; 1
    2db4:	9f 93       	push	r25
    2db6:	8f 93       	push	r24
    2db8:	1f 92       	push	r1
    2dba:	e2 d3       	rcall	.+1988   	; 0x3580 <do_csp_debug>
    2dbc:	0f b6       	in	r0, 0x3f	; 63
    2dbe:	f8 94       	cli
    2dc0:	de bf       	out	0x3e, r29	; 62
    2dc2:	0f be       	out	0x3f, r0	; 63
    2dc4:	cd bf       	out	0x3d, r28	; 61
    2dc6:	1e c0       	rjmp	.+60     	; 0x2e04 <csp_buffer_free+0xea>
    2dc8:	dc 01       	movw	r26, r24
    2dca:	14 97       	sbiw	r26, 0x04	; 4
    2dcc:	1d 92       	st	X+, r1
    2dce:	1c 92       	st	X, r1
    2dd0:	ff 93       	push	r31
    2dd2:	ef 93       	push	r30
    2dd4:	8e ee       	ldi	r24, 0xEE	; 238
    2dd6:	91 e0       	ldi	r25, 0x01	; 1
    2dd8:	9f 93       	push	r25
    2dda:	8f 93       	push	r24
    2ddc:	83 e0       	ldi	r24, 0x03	; 3
    2dde:	8f 93       	push	r24
    2de0:	cf d3       	rcall	.+1950   	; 0x3580 <do_csp_debug>
    2de2:	20 e0       	ldi	r18, 0x00	; 0
    2de4:	30 e0       	ldi	r19, 0x00	; 0
    2de6:	a9 01       	movw	r20, r18
    2de8:	be 01       	movw	r22, r28
    2dea:	6f 5f       	subi	r22, 0xFF	; 255
    2dec:	7f 4f       	sbci	r23, 0xFF	; 255
    2dee:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2df2:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2df6:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <csp_queue_enqueue>
    2dfa:	0f 90       	pop	r0
    2dfc:	0f 90       	pop	r0
    2dfe:	0f 90       	pop	r0
    2e00:	0f 90       	pop	r0
    2e02:	0f 90       	pop	r0
    2e04:	0f 90       	pop	r0
    2e06:	0f 90       	pop	r0
    2e08:	df 91       	pop	r29
    2e0a:	cf 91       	pop	r28
    2e0c:	08 95       	ret

00002e0e <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    2e0e:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2e12:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2e16:	0c 94 44 26 	jmp	0x4c88	; 0x4c88 <csp_queue_size>
}
    2e1a:	08 95       	ret

00002e1c <csp_conn_flush_rx_queue>:

	csp_mutex_unlock(&conn->lock);

	return CSP_ERR_NONE;

}
    2e1c:	0f 93       	push	r16
    2e1e:	1f 93       	push	r17
    2e20:	cf 93       	push	r28
    2e22:	df 93       	push	r29
    2e24:	1f 92       	push	r1
    2e26:	1f 92       	push	r1
    2e28:	cd b7       	in	r28, 0x3d	; 61
    2e2a:	de b7       	in	r29, 0x3e	; 62
    2e2c:	8c 01       	movw	r16, r24
    2e2e:	05 c0       	rjmp	.+10     	; 0x2e3a <csp_conn_flush_rx_queue+0x1e>
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
    2e32:	9a 81       	ldd	r25, Y+2	; 0x02
    2e34:	00 97       	sbiw	r24, 0x00	; 0
    2e36:	09 f0       	breq	.+2      	; 0x2e3a <csp_conn_flush_rx_queue+0x1e>
    2e38:	70 df       	rcall	.-288    	; 0x2d1a <csp_buffer_free>
    2e3a:	20 e0       	ldi	r18, 0x00	; 0
    2e3c:	30 e0       	ldi	r19, 0x00	; 0
    2e3e:	a9 01       	movw	r20, r18
    2e40:	be 01       	movw	r22, r28
    2e42:	6f 5f       	subi	r22, 0xFF	; 255
    2e44:	7f 4f       	sbci	r23, 0xFF	; 255
    2e46:	f8 01       	movw	r30, r16
    2e48:	84 85       	ldd	r24, Z+12	; 0x0c
    2e4a:	95 85       	ldd	r25, Z+13	; 0x0d
    2e4c:	0e 94 23 26 	call	0x4c46	; 0x4c46 <csp_queue_dequeue>
    2e50:	01 97       	sbiw	r24, 0x01	; 1
    2e52:	71 f3       	breq	.-36     	; 0x2e30 <csp_conn_flush_rx_queue+0x14>
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	0f 90       	pop	r0
    2e5a:	0f 90       	pop	r0
    2e5c:	df 91       	pop	r29
    2e5e:	cf 91       	pop	r28
    2e60:	1f 91       	pop	r17
    2e62:	0f 91       	pop	r16
    2e64:	08 95       	ret

00002e66 <csp_conn_enqueue_packet>:

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {
    2e66:	0f 93       	push	r16
    2e68:	1f 93       	push	r17
    2e6a:	cf 93       	push	r28
    2e6c:	df 93       	push	r29
    2e6e:	1f 92       	push	r1
    2e70:	1f 92       	push	r1
    2e72:	cd b7       	in	r28, 0x3d	; 61
    2e74:	de b7       	in	r29, 0x3e	; 62
    2e76:	7a 83       	std	Y+2, r23	; 0x02
    2e78:	69 83       	std	Y+1, r22	; 0x01

	if (!conn)
    2e7a:	00 97       	sbiw	r24, 0x00	; 0
    2e7c:	41 f1       	breq	.+80     	; 0x2ece <csp_conn_enqueue_packet+0x68>
    2e7e:	8c 01       	movw	r16, r24
		rxq = csp_conn_get_rxq(packet->id.pri);
	} else {
		rxq = CSP_RX_QUEUES - 1;
	}

	if (csp_queue_enqueue(conn->rx_queue[rxq], &packet, 0) != CSP_QUEUE_OK) {
    2e80:	20 e0       	ldi	r18, 0x00	; 0
    2e82:	30 e0       	ldi	r19, 0x00	; 0
    2e84:	a9 01       	movw	r20, r18
    2e86:	be 01       	movw	r22, r28
    2e88:	6f 5f       	subi	r22, 0xFF	; 255
    2e8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	84 85       	ldd	r24, Z+12	; 0x0c
    2e90:	95 85       	ldd	r25, Z+13	; 0x0d
    2e92:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <csp_queue_enqueue>
    2e96:	01 97       	sbiw	r24, 0x01	; 1
    2e98:	e9 f0       	breq	.+58     	; 0x2ed4 <csp_conn_enqueue_packet+0x6e>
		csp_log_error("RX queue %p full with %u items", conn->rx_queue[rxq], csp_queue_size(conn->rx_queue[rxq]));
    2e9a:	f8 01       	movw	r30, r16
    2e9c:	84 85       	ldd	r24, Z+12	; 0x0c
    2e9e:	95 85       	ldd	r25, Z+13	; 0x0d
    2ea0:	0e 94 44 26 	call	0x4c88	; 0x4c88 <csp_queue_size>
    2ea4:	9f 93       	push	r25
    2ea6:	8f 93       	push	r24
    2ea8:	f8 01       	movw	r30, r16
    2eaa:	85 85       	ldd	r24, Z+13	; 0x0d
    2eac:	8f 93       	push	r24
    2eae:	84 85       	ldd	r24, Z+12	; 0x0c
    2eb0:	8f 93       	push	r24
    2eb2:	80 eb       	ldi	r24, 0xB0	; 176
    2eb4:	94 e0       	ldi	r25, 0x04	; 4
    2eb6:	9f 93       	push	r25
    2eb8:	8f 93       	push	r24
    2eba:	1f 92       	push	r1
    2ebc:	61 d3       	rcall	.+1730   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    2ebe:	0f b6       	in	r0, 0x3f	; 63
    2ec0:	f8 94       	cli
    2ec2:	de bf       	out	0x3e, r29	; 62
    2ec4:	0f be       	out	0x3f, r0	; 63
    2ec6:	cd bf       	out	0x3d, r28	; 61
    2ec8:	8f ef       	ldi	r24, 0xFF	; 255
    2eca:	9f ef       	ldi	r25, 0xFF	; 255
    2ecc:	05 c0       	rjmp	.+10     	; 0x2ed8 <csp_conn_enqueue_packet+0x72>
}

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {

	if (!conn)
		return CSP_ERR_INVAL;
    2ece:	8e ef       	ldi	r24, 0xFE	; 254
    2ed0:	9f ef       	ldi	r25, 0xFF	; 255
    2ed2:	02 c0       	rjmp	.+4      	; 0x2ed8 <csp_conn_enqueue_packet+0x72>
		csp_log_error("QOS event queue full");
		return CSP_ERR_NOMEM;
	}
#endif

	return CSP_ERR_NONE;
    2ed4:	80 e0       	ldi	r24, 0x00	; 0
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
}
    2ed8:	0f 90       	pop	r0
    2eda:	0f 90       	pop	r0
    2edc:	df 91       	pop	r29
    2ede:	cf 91       	pop	r28
    2ee0:	1f 91       	pop	r17
    2ee2:	0f 91       	pop	r16
    2ee4:	08 95       	ret

00002ee6 <csp_conn_init>:

int csp_conn_init(void) {
    2ee6:	0f 93       	push	r16
    2ee8:	1f 93       	push	r17
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29

	/* Initialize source port */
	srand(csp_get_ms());
    2eee:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
    2ef2:	cb 01       	movw	r24, r22
    2ef4:	0e 94 8b 42 	call	0x8516	; 0x8516 <srand>
	sport = (rand() % (CSP_ID_PORT_MAX - CSP_MAX_BIND_PORT)) + (CSP_MAX_BIND_PORT + 1);
    2ef8:	0e 94 88 42 	call	0x8510	; 0x8510 <rand>
    2efc:	8f 71       	andi	r24, 0x1F	; 31
    2efe:	90 78       	andi	r25, 0x80	; 128
    2f00:	99 23       	and	r25, r25
    2f02:	24 f4       	brge	.+8      	; 0x2f0c <csp_conn_init+0x26>
    2f04:	01 97       	sbiw	r24, 0x01	; 1
    2f06:	80 6e       	ori	r24, 0xE0	; 224
    2f08:	9f 6f       	ori	r25, 0xFF	; 255
    2f0a:	01 96       	adiw	r24, 0x01	; 1
    2f0c:	80 5e       	subi	r24, 0xE0	; 224
    2f0e:	80 93 fc 03 	sts	0x03FC, r24	; 0x8003fc <sport>

	if (csp_bin_sem_create(&sport_lock) != CSP_SEMAPHORE_OK) {
    2f12:	8a ef       	ldi	r24, 0xFA	; 250
    2f14:	93 e0       	ldi	r25, 0x03	; 3
    2f16:	0e 94 74 29 	call	0x52e8	; 0x52e8 <csp_bin_sem_create>
    2f1a:	01 97       	sbiw	r24, 0x01	; 1
    2f1c:	29 f4       	brne	.+10     	; 0x2f28 <csp_conn_init+0x42>
    2f1e:	c1 e0       	ldi	r28, 0x01	; 1
    2f20:	d4 e0       	ldi	r29, 0x04	; 4
    2f22:	01 ef       	ldi	r16, 0xF1	; 241
    2f24:	14 e0       	ldi	r17, 0x04	; 4
    2f26:	1c c0       	rjmp	.+56     	; 0x2f60 <csp_conn_init+0x7a>
		csp_log_error("No more memory for sport semaphore");
    2f28:	8d e8       	ldi	r24, 0x8D	; 141
    2f2a:	94 e0       	ldi	r25, 0x04	; 4
    2f2c:	9f 93       	push	r25
    2f2e:	8f 93       	push	r24
    2f30:	1f 92       	push	r1
    2f32:	26 d3       	rcall	.+1612   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    2f34:	0f 90       	pop	r0
    2f36:	0f 90       	pop	r0
    2f38:	0f 90       	pop	r0
    2f3a:	8f ef       	ldi	r24, 0xFF	; 255
    2f3c:	9f ef       	ldi	r25, 0xFF	; 255
    2f3e:	35 c0       	rjmp	.+106    	; 0x2faa <csp_conn_init+0xc4>
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
			csp_log_error("Failed to create connection lock");
    2f40:	8c e6       	ldi	r24, 0x6C	; 108
    2f42:	94 e0       	ldi	r25, 0x04	; 4
    2f44:	9f 93       	push	r25
    2f46:	8f 93       	push	r24
    2f48:	1f 92       	push	r1
    2f4a:	1a d3       	rcall	.+1588   	; 0x3580 <do_csp_debug>
			return CSP_ERR_NOMEM;
    2f4c:	0f 90       	pop	r0
    2f4e:	0f 90       	pop	r0
    2f50:	0f 90       	pop	r0
    2f52:	8f ef       	ldi	r24, 0xFF	; 255
    2f54:	9f ef       	ldi	r25, 0xFF	; 255
    2f56:	29 c0       	rjmp	.+82     	; 0x2faa <csp_conn_init+0xc4>
    2f58:	68 96       	adiw	r28, 0x18	; 24
		csp_log_error("No more memory for sport semaphore");
		return CSP_ERR_NOMEM;
	}

	int i, prio;
	for (i = 0; i < CSP_CONN_MAX; i++) {
    2f5a:	0c 17       	cp	r16, r28
    2f5c:	1d 07       	cpc	r17, r29
    2f5e:	89 f0       	breq	.+34     	; 0x2f82 <csp_conn_init+0x9c>
		for (prio = 0; prio < CSP_RX_QUEUES; prio++)
			arr_conn[i].rx_queue[prio] = csp_queue_create(CSP_RX_QUEUE_LENGTH, sizeof(csp_packet_t *));
    2f60:	62 e0       	ldi	r22, 0x02	; 2
    2f62:	70 e0       	ldi	r23, 0x00	; 0
    2f64:	84 e6       	ldi	r24, 0x64	; 100
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <csp_queue_create>
    2f6c:	9b 87       	std	Y+11, r25	; 0x0b
    2f6e:	8a 87       	std	Y+10, r24	; 0x0a

#ifdef CSP_USE_QOS
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;
    2f70:	fe 01       	movw	r30, r28
    2f72:	31 97       	sbiw	r30, 0x01	; 1
    2f74:	10 82       	st	Z, r1

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
    2f76:	ce 01       	movw	r24, r28
    2f78:	0e 94 62 29 	call	0x52c4	; 0x52c4 <csp_mutex_create>
    2f7c:	01 97       	sbiw	r24, 0x01	; 1
    2f7e:	61 f3       	breq	.-40     	; 0x2f58 <csp_conn_init+0x72>
    2f80:	df cf       	rjmp	.-66     	; 0x2f40 <csp_conn_init+0x5a>
			return CSP_ERR_NOMEM;
		}
#endif
	}

	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
    2f82:	8d ef       	ldi	r24, 0xFD	; 253
    2f84:	93 e0       	ldi	r25, 0x03	; 3
    2f86:	0e 94 74 29 	call	0x52e8	; 0x52e8 <csp_bin_sem_create>
    2f8a:	01 97       	sbiw	r24, 0x01	; 1
    2f8c:	61 f0       	breq	.+24     	; 0x2fa6 <csp_conn_init+0xc0>
		csp_log_error("No more memory for conn semaphore");
    2f8e:	8a e4       	ldi	r24, 0x4A	; 74
    2f90:	94 e0       	ldi	r25, 0x04	; 4
    2f92:	9f 93       	push	r25
    2f94:	8f 93       	push	r24
    2f96:	1f 92       	push	r1
    2f98:	f3 d2       	rcall	.+1510   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    2f9a:	0f 90       	pop	r0
    2f9c:	0f 90       	pop	r0
    2f9e:	0f 90       	pop	r0
    2fa0:	8f ef       	ldi	r24, 0xFF	; 255
    2fa2:	9f ef       	ldi	r25, 0xFF	; 255
    2fa4:	02 c0       	rjmp	.+4      	; 0x2faa <csp_conn_init+0xc4>
	}

	return CSP_ERR_NONE;
    2fa6:	80 e0       	ldi	r24, 0x00	; 0
    2fa8:	90 e0       	ldi	r25, 0x00	; 0

}
    2faa:	df 91       	pop	r29
    2fac:	cf 91       	pop	r28
    2fae:	1f 91       	pop	r17
    2fb0:	0f 91       	pop	r16
    2fb2:	08 95       	ret

00002fb4 <csp_conn_find>:

csp_conn_t * csp_conn_find(uint32_t id, uint32_t mask) {
    2fb4:	8f 92       	push	r8
    2fb6:	9f 92       	push	r9
    2fb8:	af 92       	push	r10
    2fba:	bf 92       	push	r11
    2fbc:	cf 92       	push	r12
    2fbe:	df 92       	push	r13
    2fc0:	ef 92       	push	r14
    2fc2:	ff 92       	push	r15
    2fc4:	6b 01       	movw	r12, r22
    2fc6:	7c 01       	movw	r14, r24
    2fc8:	49 01       	movw	r8, r18
    2fca:	5a 01       	movw	r10, r20
    2fcc:	ef ef       	ldi	r30, 0xFF	; 255
    2fce:	f3 e0       	ldi	r31, 0x03	; 3

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    2fd0:	80 e0       	ldi	r24, 0x00	; 0
    2fd2:	90 e0       	ldi	r25, 0x00	; 0
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
    2fd4:	31 81       	ldd	r19, Z+1	; 0x01
    2fd6:	33 23       	and	r19, r19
    2fd8:	09 f1       	breq	.+66     	; 0x301c <csp_conn_find+0x68>
    2fda:	20 81       	ld	r18, Z
    2fdc:	21 11       	cpse	r18, r1
    2fde:	1e c0       	rjmp	.+60     	; 0x301c <csp_conn_find+0x68>
    2fe0:	44 81       	ldd	r20, Z+4	; 0x04
    2fe2:	55 81       	ldd	r21, Z+5	; 0x05
    2fe4:	66 81       	ldd	r22, Z+6	; 0x06
    2fe6:	77 81       	ldd	r23, Z+7	; 0x07
    2fe8:	4c 25       	eor	r20, r12
    2fea:	5d 25       	eor	r21, r13
    2fec:	6e 25       	eor	r22, r14
    2fee:	7f 25       	eor	r23, r15
    2ff0:	48 21       	and	r20, r8
    2ff2:	59 21       	and	r21, r9
    2ff4:	6a 21       	and	r22, r10
    2ff6:	7b 21       	and	r23, r11
    2ff8:	45 2b       	or	r20, r21
    2ffa:	46 2b       	or	r20, r22
    2ffc:	47 2b       	or	r20, r23
    2ffe:	71 f4       	brne	.+28     	; 0x301c <csp_conn_find+0x68>
	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
		conn = &arr_conn[i];
    3000:	9c 01       	movw	r18, r24
    3002:	22 0f       	add	r18, r18
    3004:	33 1f       	adc	r19, r19
    3006:	82 0f       	add	r24, r18
    3008:	93 1f       	adc	r25, r19
    300a:	88 0f       	add	r24, r24
    300c:	99 1f       	adc	r25, r25
    300e:	88 0f       	add	r24, r24
    3010:	99 1f       	adc	r25, r25
    3012:	88 0f       	add	r24, r24
    3014:	99 1f       	adc	r25, r25
    3016:	81 50       	subi	r24, 0x01	; 1
    3018:	9c 4f       	sbci	r25, 0xFC	; 252
    301a:	07 c0       	rjmp	.+14     	; 0x302a <csp_conn_find+0x76>

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    301c:	01 96       	adiw	r24, 0x01	; 1
    301e:	78 96       	adiw	r30, 0x18	; 24
    3020:	8a 30       	cpi	r24, 0x0A	; 10
    3022:	91 05       	cpc	r25, r1
    3024:	b9 f6       	brne	.-82     	; 0x2fd4 <csp_conn_find+0x20>
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
			return conn;
	}
	
	return NULL;
    3026:	80 e0       	ldi	r24, 0x00	; 0
    3028:	90 e0       	ldi	r25, 0x00	; 0

}
    302a:	ff 90       	pop	r15
    302c:	ef 90       	pop	r14
    302e:	df 90       	pop	r13
    3030:	cf 90       	pop	r12
    3032:	bf 90       	pop	r11
    3034:	af 90       	pop	r10
    3036:	9f 90       	pop	r9
    3038:	8f 90       	pop	r8
    303a:	08 95       	ret

0000303c <csp_conn_allocate>:

	return CSP_ERR_NONE;

}

csp_conn_t * csp_conn_allocate(csp_conn_type_t type) {
    303c:	1f 93       	push	r17
    303e:	cf 93       	push	r28
    3040:	df 93       	push	r29
    3042:	18 2f       	mov	r17, r24

	int i, j;
	static uint8_t csp_conn_last_given = 0;
	csp_conn_t * conn;

	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    3044:	44 e6       	ldi	r20, 0x64	; 100
    3046:	50 e0       	ldi	r21, 0x00	; 0
    3048:	60 e0       	ldi	r22, 0x00	; 0
    304a:	70 e0       	ldi	r23, 0x00	; 0
    304c:	8d ef       	ldi	r24, 0xFD	; 253
    304e:	93 e0       	ldi	r25, 0x03	; 3
    3050:	0e 94 8c 29 	call	0x5318	; 0x5318 <csp_bin_sem_wait>
    3054:	01 97       	sbiw	r24, 0x01	; 1
    3056:	61 f0       	breq	.+24     	; 0x3070 <csp_conn_allocate+0x34>
		csp_log_error("Failed to lock conn array");
    3058:	80 e3       	ldi	r24, 0x30	; 48
    305a:	94 e0       	ldi	r25, 0x04	; 4
    305c:	9f 93       	push	r25
    305e:	8f 93       	push	r24
    3060:	1f 92       	push	r1
    3062:	8e d2       	rcall	.+1308   	; 0x3580 <do_csp_debug>
		return NULL;
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	0f 90       	pop	r0
    306a:	80 e0       	ldi	r24, 0x00	; 0
    306c:	90 e0       	ldi	r25, 0x00	; 0
    306e:	5c c0       	rjmp	.+184    	; 0x3128 <csp_conn_allocate+0xec>
	}

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;
    3070:	80 91 f9 03 	lds	r24, 0x03F9	; 0x8003f9 <csp_conn_last_given.3263>
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	01 96       	adiw	r24, 0x01	; 1
    3078:	6a e0       	ldi	r22, 0x0A	; 10
    307a:	70 e0       	ldi	r23, 0x00	; 0
    307c:	0e 94 c5 41 	call	0x838a	; 0x838a <__divmodhi4>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
    3080:	fc 01       	movw	r30, r24
    3082:	ee 0f       	add	r30, r30
    3084:	ff 1f       	adc	r31, r31
    3086:	e8 0f       	add	r30, r24
    3088:	f9 1f       	adc	r31, r25
    308a:	ee 0f       	add	r30, r30
    308c:	ff 1f       	adc	r31, r31
    308e:	ee 0f       	add	r30, r30
    3090:	ff 1f       	adc	r31, r31
    3092:	ee 0f       	add	r30, r30
    3094:	ff 1f       	adc	r31, r31
    3096:	e1 50       	subi	r30, 0x01	; 1
    3098:	fc 4f       	sbci	r31, 0xFC	; 252
    309a:	41 81       	ldd	r20, Z+1	; 0x01
    309c:	41 11       	cpse	r20, r1
    309e:	3a c0       	rjmp	.+116    	; 0x3114 <csp_conn_allocate+0xd8>
	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
    30a0:	ef 01       	movw	r28, r30
    30a2:	17 c0       	rjmp	.+46     	; 0x30d2 <csp_conn_allocate+0x96>
    30a4:	ec 01       	movw	r28, r24
    30a6:	cc 0f       	add	r28, r28
    30a8:	dd 1f       	adc	r29, r29
    30aa:	c8 0f       	add	r28, r24
    30ac:	d9 1f       	adc	r29, r25
    30ae:	cc 0f       	add	r28, r28
    30b0:	dd 1f       	adc	r29, r29
    30b2:	cc 0f       	add	r28, r28
    30b4:	dd 1f       	adc	r29, r29
    30b6:	cc 0f       	add	r28, r28
    30b8:	dd 1f       	adc	r29, r29
    30ba:	c1 50       	subi	r28, 0x01	; 1
    30bc:	dc 4f       	sbci	r29, 0xFC	; 252
		if (conn->state == CONN_CLOSED)
    30be:	49 81       	ldd	r20, Y+1	; 0x01
    30c0:	44 23       	and	r20, r20
    30c2:	39 f0       	breq	.+14     	; 0x30d2 <csp_conn_allocate+0x96>
			break;
		i = (i + 1) % CSP_CONN_MAX;
    30c4:	01 96       	adiw	r24, 0x01	; 1
    30c6:	bf 01       	movw	r22, r30
    30c8:	0e 94 c5 41 	call	0x838a	; 0x838a <__divmodhi4>
    30cc:	21 50       	subi	r18, 0x01	; 1
    30ce:	31 09       	sbc	r19, r1

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
    30d0:	49 f7       	brne	.-46     	; 0x30a4 <csp_conn_allocate+0x68>
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
	}

	if (conn->state == CONN_OPEN) {
    30d2:	29 81       	ldd	r18, Y+1	; 0x01
    30d4:	21 30       	cpi	r18, 0x01	; 1
    30d6:	81 f4       	brne	.+32     	; 0x30f8 <csp_conn_allocate+0xbc>
		csp_log_error("No more free connections");
    30d8:	87 e1       	ldi	r24, 0x17	; 23
    30da:	94 e0       	ldi	r25, 0x04	; 4
    30dc:	9f 93       	push	r25
    30de:	8f 93       	push	r24
    30e0:	1f 92       	push	r1
    30e2:	4e d2       	rcall	.+1180   	; 0x3580 <do_csp_debug>
		csp_bin_sem_post(&conn_lock);
    30e4:	8d ef       	ldi	r24, 0xFD	; 253
    30e6:	93 e0       	ldi	r25, 0x03	; 3
    30e8:	0e 94 c7 29 	call	0x538e	; 0x538e <csp_bin_sem_post>
		return NULL;
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	80 e0       	ldi	r24, 0x00	; 0
    30f4:	90 e0       	ldi	r25, 0x00	; 0
    30f6:	18 c0       	rjmp	.+48     	; 0x3128 <csp_conn_allocate+0xec>
	}

	conn->state = CONN_OPEN;
    30f8:	91 e0       	ldi	r25, 0x01	; 1
    30fa:	99 83       	std	Y+1, r25	; 0x01
	conn->socket = NULL;
    30fc:	1f 86       	std	Y+15, r1	; 0x0f
    30fe:	1e 86       	std	Y+14, r1	; 0x0e
	conn->type = type;
    3100:	18 83       	st	Y, r17
	csp_conn_last_given = i;
    3102:	80 93 f9 03 	sts	0x03F9, r24	; 0x8003f9 <csp_conn_last_given.3263>
	csp_bin_sem_post(&conn_lock);
    3106:	8d ef       	ldi	r24, 0xFD	; 253
    3108:	93 e0       	ldi	r25, 0x03	; 3
    310a:	0e 94 c7 29 	call	0x538e	; 0x538e <csp_bin_sem_post>

	return conn;
    310e:	8c 2f       	mov	r24, r28
    3110:	9d 2f       	mov	r25, r29
    3112:	0a c0       	rjmp	.+20     	; 0x3128 <csp_conn_allocate+0xec>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
    3114:	01 96       	adiw	r24, 0x01	; 1
    3116:	6a e0       	ldi	r22, 0x0A	; 10
    3118:	70 e0       	ldi	r23, 0x00	; 0
    311a:	0e 94 c5 41 	call	0x838a	; 0x838a <__divmodhi4>
    311e:	29 e0       	ldi	r18, 0x09	; 9
    3120:	30 e0       	ldi	r19, 0x00	; 0
    3122:	ea e0       	ldi	r30, 0x0A	; 10
    3124:	f0 e0       	ldi	r31, 0x00	; 0
    3126:	be cf       	rjmp	.-132    	; 0x30a4 <csp_conn_allocate+0x68>
	csp_conn_last_given = i;
	csp_bin_sem_post(&conn_lock);

	return conn;

}
    3128:	df 91       	pop	r29
    312a:	cf 91       	pop	r28
    312c:	1f 91       	pop	r17
    312e:	08 95       	ret

00003130 <csp_conn_new>:

csp_conn_t * csp_conn_new(csp_id_t idin, csp_id_t idout) {
    3130:	8f 92       	push	r8
    3132:	9f 92       	push	r9
    3134:	af 92       	push	r10
    3136:	bf 92       	push	r11
    3138:	cf 92       	push	r12
    313a:	df 92       	push	r13
    313c:	ef 92       	push	r14
    313e:	ff 92       	push	r15
    3140:	cf 93       	push	r28
    3142:	df 93       	push	r29
    3144:	4b 01       	movw	r8, r22
    3146:	5c 01       	movw	r10, r24
    3148:	69 01       	movw	r12, r18
    314a:	7a 01       	movw	r14, r20

	/* Allocate connection structure */
	csp_conn_t * conn = csp_conn_allocate(CONN_CLIENT);
    314c:	80 e0       	ldi	r24, 0x00	; 0
    314e:	76 df       	rcall	.-276    	; 0x303c <csp_conn_allocate>
    3150:	ec 01       	movw	r28, r24

	if (conn) {
    3152:	89 2b       	or	r24, r25
    3154:	81 f0       	breq	.+32     	; 0x3176 <csp_conn_new+0x46>
		/* No lock is needed here, because nobody else *
		 * has a reference to this connection yet.     */
		conn->idin.ext = idin.ext;
    3156:	8c 82       	std	Y+4, r8	; 0x04
    3158:	9d 82       	std	Y+5, r9	; 0x05
    315a:	ae 82       	std	Y+6, r10	; 0x06
    315c:	bf 82       	std	Y+7, r11	; 0x07
		conn->idout.ext = idout.ext;
    315e:	c8 86       	std	Y+8, r12	; 0x08
    3160:	d9 86       	std	Y+9, r13	; 0x09
    3162:	ea 86       	std	Y+10, r14	; 0x0a
    3164:	fb 86       	std	Y+11, r15	; 0x0b
		conn->timestamp = csp_get_ms();
    3166:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
    316a:	68 8b       	std	Y+16, r22	; 0x10
    316c:	79 8b       	std	Y+17, r23	; 0x11
    316e:	8a 8b       	std	Y+18, r24	; 0x12
    3170:	9b 8b       	std	Y+19, r25	; 0x13

		/* Ensure connection queue is empty */
		csp_conn_flush_rx_queue(conn);
    3172:	ce 01       	movw	r24, r28
    3174:	53 de       	rcall	.-858    	; 0x2e1c <csp_conn_flush_rx_queue>
	}

	return conn;

}
    3176:	ce 01       	movw	r24, r28
    3178:	df 91       	pop	r29
    317a:	cf 91       	pop	r28
    317c:	ff 90       	pop	r15
    317e:	ef 90       	pop	r14
    3180:	df 90       	pop	r13
    3182:	cf 90       	pop	r12
    3184:	bf 90       	pop	r11
    3186:	af 90       	pop	r10
    3188:	9f 90       	pop	r9
    318a:	8f 90       	pop	r8
    318c:	08 95       	ret

0000318e <csp_close>:

int csp_close(csp_conn_t * conn) {
    318e:	cf 93       	push	r28
    3190:	df 93       	push	r29
    3192:	ec 01       	movw	r28, r24

	if (conn == NULL) {
    3194:	89 2b       	or	r24, r25
    3196:	61 f4       	brne	.+24     	; 0x31b0 <csp_close+0x22>
		csp_log_error("NULL Pointer given to csp_close");
    3198:	87 ef       	ldi	r24, 0xF7	; 247
    319a:	93 e0       	ldi	r25, 0x03	; 3
    319c:	9f 93       	push	r25
    319e:	8f 93       	push	r24
    31a0:	1f 92       	push	r1
    31a2:	ee d1       	rcall	.+988    	; 0x3580 <do_csp_debug>
		return CSP_ERR_INVAL;
    31a4:	0f 90       	pop	r0
    31a6:	0f 90       	pop	r0
    31a8:	0f 90       	pop	r0
    31aa:	8e ef       	ldi	r24, 0xFE	; 254
    31ac:	9f ef       	ldi	r25, 0xFF	; 255
    31ae:	2f c0       	rjmp	.+94     	; 0x320e <csp_close+0x80>
	}

	if (conn->state == CONN_CLOSED) {
    31b0:	89 81       	ldd	r24, Y+1	; 0x01
    31b2:	81 11       	cpse	r24, r1
    31b4:	0d c0       	rjmp	.+26     	; 0x31d0 <csp_close+0x42>
		csp_log_protocol("Conn already closed");
    31b6:	83 ee       	ldi	r24, 0xE3	; 227
    31b8:	93 e0       	ldi	r25, 0x03	; 3
    31ba:	9f 93       	push	r25
    31bc:	8f 93       	push	r24
    31be:	85 e0       	ldi	r24, 0x05	; 5
    31c0:	8f 93       	push	r24
    31c2:	de d1       	rcall	.+956    	; 0x3580 <do_csp_debug>
		return CSP_ERR_NONE;
    31c4:	0f 90       	pop	r0
    31c6:	0f 90       	pop	r0
    31c8:	0f 90       	pop	r0
    31ca:	80 e0       	ldi	r24, 0x00	; 0
    31cc:	90 e0       	ldi	r25, 0x00	; 0
    31ce:	1f c0       	rjmp	.+62     	; 0x320e <csp_close+0x80>
		if (csp_rdp_close(conn) == CSP_ERR_AGAIN)
			return CSP_ERR_NONE;
#endif

	/* Lock connection array while closing connection */
	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    31d0:	44 e6       	ldi	r20, 0x64	; 100
    31d2:	50 e0       	ldi	r21, 0x00	; 0
    31d4:	60 e0       	ldi	r22, 0x00	; 0
    31d6:	70 e0       	ldi	r23, 0x00	; 0
    31d8:	8d ef       	ldi	r24, 0xFD	; 253
    31da:	93 e0       	ldi	r25, 0x03	; 3
    31dc:	0e 94 8c 29 	call	0x5318	; 0x5318 <csp_bin_sem_wait>
    31e0:	01 97       	sbiw	r24, 0x01	; 1
    31e2:	61 f0       	breq	.+24     	; 0x31fc <csp_close+0x6e>
		csp_log_error("Failed to lock conn array");
    31e4:	89 ec       	ldi	r24, 0xC9	; 201
    31e6:	93 e0       	ldi	r25, 0x03	; 3
    31e8:	9f 93       	push	r25
    31ea:	8f 93       	push	r24
    31ec:	1f 92       	push	r1
    31ee:	c8 d1       	rcall	.+912    	; 0x3580 <do_csp_debug>
		return CSP_ERR_TIMEDOUT;
    31f0:	0f 90       	pop	r0
    31f2:	0f 90       	pop	r0
    31f4:	0f 90       	pop	r0
    31f6:	8d ef       	ldi	r24, 0xFD	; 253
    31f8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Set to closed */
	conn->state = CONN_CLOSED;
    31fa:	09 c0       	rjmp	.+18     	; 0x320e <csp_close+0x80>

	/* Ensure connection queue is empty */
	csp_conn_flush_rx_queue(conn);
    31fc:	19 82       	std	Y+1, r1	; 0x01
    31fe:	ce 01       	movw	r24, r28
    3200:	0d de       	rcall	.-998    	; 0x2e1c <csp_conn_flush_rx_queue>
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_flush_all(conn);
#endif

	/* Unlock connection array */
	csp_bin_sem_post(&conn_lock);
    3202:	8d ef       	ldi	r24, 0xFD	; 253
    3204:	93 e0       	ldi	r25, 0x03	; 3
    3206:	0e 94 c7 29 	call	0x538e	; 0x538e <csp_bin_sem_post>

	return CSP_ERR_NONE;
    320a:	80 e0       	ldi	r24, 0x00	; 0
    320c:	90 e0       	ldi	r25, 0x00	; 0
}
    320e:	df 91       	pop	r29
    3210:	cf 91       	pop	r28
    3212:	08 95       	ret

00003214 <csp_connect>:

csp_conn_t * csp_connect(uint8_t prio, uint8_t dest, uint8_t dport, uint32_t timeout, uint32_t opts) {
    3214:	6f 92       	push	r6
    3216:	7f 92       	push	r7
    3218:	8f 92       	push	r8
    321a:	9f 92       	push	r9
    321c:	af 92       	push	r10
    321e:	bf 92       	push	r11
    3220:	cf 92       	push	r12
    3222:	df 92       	push	r13
    3224:	ef 92       	push	r14
    3226:	ff 92       	push	r15
    3228:	0f 93       	push	r16
    322a:	1f 93       	push	r17
    322c:	cf 93       	push	r28
    322e:	df 93       	push	r29
    3230:	86 2e       	mov	r8, r22
    3232:	14 2f       	mov	r17, r20
	/* Force options on all connections */
	opts |= CSP_CONNECTION_SO;

	/* Generate identifier */
	csp_id_t incoming_id, outgoing_id;
	incoming_id.pri = prio;
    3234:	98 2e       	mov	r9, r24
    3236:	99 0c       	add	r9, r9
    3238:	99 0c       	add	r9, r9
    323a:	99 0c       	add	r9, r9
    323c:	99 0c       	add	r9, r9
    323e:	99 0c       	add	r9, r9
    3240:	99 0c       	add	r9, r9
    3242:	09 2d       	mov	r16, r9
	incoming_id.dst = csp_get_address();
    3244:	0e 94 18 22 	call	0x4430	; 0x4430 <csp_get_address>
    3248:	c8 2f       	mov	r28, r24
    324a:	c2 95       	swap	r28
    324c:	c0 7f       	andi	r28, 0xF0	; 240
    324e:	82 95       	swap	r24
    3250:	81 70       	andi	r24, 0x01	; 1
    3252:	08 2b       	or	r16, r24
	incoming_id.src = dest;
    3254:	88 2d       	mov	r24, r8
    3256:	8f 71       	andi	r24, 0x1F	; 31
    3258:	98 2f       	mov	r25, r24
    325a:	99 0f       	add	r25, r25
    325c:	09 2b       	or	r16, r25
	incoming_id.sport = dport;
    325e:	91 2f       	mov	r25, r17
    3260:	9f 73       	andi	r25, 0x3F	; 63
    3262:	a9 2e       	mov	r10, r25
    3264:	d9 2f       	mov	r29, r25
	incoming_id.flags = 0;
    3266:	b1 2c       	mov	r11, r1
	outgoing_id.pri = prio;
	outgoing_id.dst = dest;
    3268:	88 0c       	add	r8, r8
    326a:	88 0c       	add	r8, r8
    326c:	88 0c       	add	r8, r8
    326e:	88 0c       	add	r8, r8
    3270:	82 95       	swap	r24
    3272:	8f 70       	andi	r24, 0x0F	; 15
    3274:	98 2a       	or	r9, r24
	outgoing_id.src = csp_get_address();
    3276:	0e 94 18 22 	call	0x4430	; 0x4430 <csp_get_address>
    327a:	8f 71       	andi	r24, 0x1F	; 31
    327c:	88 0f       	add	r24, r24
    327e:	98 2a       	or	r9, r24
	outgoing_id.dport = dport;
    3280:	12 95       	swap	r17
    3282:	11 0f       	add	r17, r17
    3284:	11 0f       	add	r17, r17
    3286:	10 7c       	andi	r17, 0xC0	; 192
    3288:	a6 94       	lsr	r10
    328a:	a6 94       	lsr	r10
    328c:	8a 28       	or	r8, r10
	outgoing_id.flags = 0;

	/* Set connection options */
	if (opts & CSP_O_RDP) {
    328e:	c0 fe       	sbrs	r12, 0
    3290:	0c c0       	rjmp	.+24     	; 0x32aa <csp_connect+0x96>
#ifdef CSP_USE_RDP
		incoming_id.flags |= CSP_FRDP;
		outgoing_id.flags |= CSP_FRDP;
#else
		csp_log_error("Attempt to create RDP connection, but CSP was compiled without RDP support");
    3292:	8e e7       	ldi	r24, 0x7E	; 126
    3294:	93 e0       	ldi	r25, 0x03	; 3
    3296:	9f 93       	push	r25
    3298:	8f 93       	push	r24
    329a:	1f 92       	push	r1
    329c:	71 d1       	rcall	.+738    	; 0x3580 <do_csp_debug>
		return NULL;
    329e:	0f 90       	pop	r0
    32a0:	0f 90       	pop	r0
    32a2:	0f 90       	pop	r0
    32a4:	80 e0       	ldi	r24, 0x00	; 0
    32a6:	90 e0       	ldi	r25, 0x00	; 0
    32a8:	7c c0       	rjmp	.+248    	; 0x33a2 <csp_connect+0x18e>
#endif
	}

	if (opts & CSP_O_HMAC) {
    32aa:	c2 fe       	sbrs	r12, 2
    32ac:	0c c0       	rjmp	.+24     	; 0x32c6 <csp_connect+0xb2>
#ifdef CSP_USE_HMAC
		outgoing_id.flags |= CSP_FHMAC;
		incoming_id.flags |= CSP_FHMAC;
#else
		csp_log_error("Attempt to create HMAC authenticated connection, but CSP was compiled without HMAC support");
    32ae:	83 e2       	ldi	r24, 0x23	; 35
    32b0:	93 e0       	ldi	r25, 0x03	; 3
    32b2:	9f 93       	push	r25
    32b4:	8f 93       	push	r24
    32b6:	1f 92       	push	r1
    32b8:	63 d1       	rcall	.+710    	; 0x3580 <do_csp_debug>
		return NULL;
    32ba:	0f 90       	pop	r0
    32bc:	0f 90       	pop	r0
    32be:	0f 90       	pop	r0
    32c0:	80 e0       	ldi	r24, 0x00	; 0
    32c2:	90 e0       	ldi	r25, 0x00	; 0
    32c4:	6e c0       	rjmp	.+220    	; 0x33a2 <csp_connect+0x18e>
#endif
	}

	if (opts & CSP_O_XTEA) {
    32c6:	c4 fe       	sbrs	r12, 4
    32c8:	0c c0       	rjmp	.+24     	; 0x32e2 <csp_connect+0xce>
#ifdef CSP_USE_XTEA
		outgoing_id.flags |= CSP_FXTEA;
		incoming_id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted connection, but CSP was compiled without XTEA support");
    32ca:	8c ec       	ldi	r24, 0xCC	; 204
    32cc:	92 e0       	ldi	r25, 0x02	; 2
    32ce:	9f 93       	push	r25
    32d0:	8f 93       	push	r24
    32d2:	1f 92       	push	r1
    32d4:	55 d1       	rcall	.+682    	; 0x3580 <do_csp_debug>
		return NULL;
    32d6:	0f 90       	pop	r0
    32d8:	0f 90       	pop	r0
    32da:	0f 90       	pop	r0
    32dc:	80 e0       	ldi	r24, 0x00	; 0
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	60 c0       	rjmp	.+192    	; 0x33a2 <csp_connect+0x18e>
#endif
	}

	if (opts & CSP_O_CRC32) {
    32e2:	c6 fe       	sbrs	r12, 6
    32e4:	05 c0       	rjmp	.+10     	; 0x32f0 <csp_connect+0xdc>
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
		incoming_id.flags |= CSP_FCRC32;
    32e6:	bb 24       	eor	r11, r11
    32e8:	b3 94       	inc	r11
#endif
	}

	if (opts & CSP_O_CRC32) {
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
    32ea:	66 24       	eor	r6, r6
    32ec:	63 94       	inc	r6
    32ee:	01 c0       	rjmp	.+2      	; 0x32f2 <csp_connect+0xde>
	incoming_id.flags = 0;
	outgoing_id.pri = prio;
	outgoing_id.dst = dest;
	outgoing_id.src = csp_get_address();
	outgoing_id.dport = dport;
	outgoing_id.flags = 0;
    32f0:	61 2c       	mov	r6, r1
	
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
    32f2:	48 ee       	ldi	r20, 0xE8	; 232
    32f4:	53 e0       	ldi	r21, 0x03	; 3
    32f6:	60 e0       	ldi	r22, 0x00	; 0
    32f8:	70 e0       	ldi	r23, 0x00	; 0
    32fa:	8a ef       	ldi	r24, 0xFA	; 250
    32fc:	93 e0       	ldi	r25, 0x03	; 3
    32fe:	0e 94 8c 29 	call	0x5318	; 0x5318 <csp_bin_sem_wait>
    3302:	01 97       	sbiw	r24, 0x01	; 1
    3304:	09 f0       	breq	.+2      	; 0x3308 <csp_connect+0xf4>
    3306:	46 c0       	rjmp	.+140    	; 0x3394 <csp_connect+0x180>
		return NULL;

	uint8_t start = sport;
    3308:	a0 90 fc 03 	lds	r10, 0x03FC	; 0x8003fc <sport>
	while (++sport != start) {
		if (sport > CSP_ID_PORT_MAX)
			sport = CSP_MAX_BIND_PORT + 1;
    330c:	68 94       	set
    330e:	77 24       	eor	r7, r7
    3310:	75 f8       	bld	r7, 5
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    3312:	1f c0       	rjmp	.+62     	; 0x3352 <csp_connect+0x13e>
		if (sport > CSP_ID_PORT_MAX)
    3314:	90 34       	cpi	r25, 0x40	; 64
    3316:	10 f0       	brcs	.+4      	; 0x331c <csp_connect+0x108>
			sport = CSP_MAX_BIND_PORT + 1;
    3318:	70 92 fc 03 	sts	0x03FC, r7	; 0x8003fc <sport>

		outgoing_id.sport = sport;
    331c:	80 91 fc 03 	lds	r24, 0x03FC	; 0x8003fc <sport>
    3320:	98 2f       	mov	r25, r24
    3322:	9f 73       	andi	r25, 0x3F	; 63
    3324:	10 7c       	andi	r17, 0xC0	; 192
    3326:	19 2b       	or	r17, r25
		incoming_id.dport = sport;
    3328:	82 95       	swap	r24
    332a:	88 0f       	add	r24, r24
    332c:	88 0f       	add	r24, r24
    332e:	80 7c       	andi	r24, 0xC0	; 192
    3330:	df 73       	andi	r29, 0x3F	; 63
    3332:	d8 2b       	or	r29, r24
    3334:	96 95       	lsr	r25
    3336:	96 95       	lsr	r25
    3338:	c0 7f       	andi	r28, 0xF0	; 240
    333a:	c9 2b       	or	r28, r25
		
		/* Match on destination port of _incoming_ identifier */
		conn = csp_conn_find(incoming_id.ext, CSP_ID_DPORT_MASK);
    333c:	20 e0       	ldi	r18, 0x00	; 0
    333e:	30 ec       	ldi	r19, 0xC0	; 192
    3340:	4f e0       	ldi	r20, 0x0F	; 15
    3342:	50 e0       	ldi	r21, 0x00	; 0
    3344:	6b 2d       	mov	r22, r11
    3346:	7d 2f       	mov	r23, r29
    3348:	8c 2f       	mov	r24, r28
    334a:	90 2f       	mov	r25, r16
    334c:	33 de       	rcall	.-922    	; 0x2fb4 <csp_conn_find>

		/* Break if we found an unused ephemeral port */
		if (conn == NULL)
    334e:	89 2b       	or	r24, r25
    3350:	39 f0       	breq	.+14     	; 0x3360 <csp_connect+0x14c>
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    3352:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <sport>
    3356:	9f 5f       	subi	r25, 0xFF	; 255
    3358:	90 93 fc 03 	sts	0x03FC, r25	; 0x8003fc <sport>
    335c:	a9 12       	cpse	r10, r25
    335e:	da cf       	rjmp	.-76     	; 0x3314 <csp_connect+0x100>
		if (conn == NULL)
			break;
	}

	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);
    3360:	8a ef       	ldi	r24, 0xFA	; 250
    3362:	93 e0       	ldi	r25, 0x03	; 3
    3364:	0e 94 c7 29 	call	0x538e	; 0x538e <csp_bin_sem_post>

	/* If no available ephemeral port was found */
	if (sport == start)
    3368:	80 91 fc 03 	lds	r24, 0x03FC	; 0x8003fc <sport>
    336c:	a8 16       	cp	r10, r24
    336e:	a9 f0       	breq	.+42     	; 0x339a <csp_connect+0x186>
		return NULL;

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
    3370:	26 2d       	mov	r18, r6
    3372:	31 2f       	mov	r19, r17
    3374:	48 2d       	mov	r20, r8
    3376:	59 2d       	mov	r21, r9
    3378:	6b 2d       	mov	r22, r11
    337a:	7d 2f       	mov	r23, r29
    337c:	8c 2f       	mov	r24, r28
    337e:	90 2f       	mov	r25, r16
    3380:	d7 de       	rcall	.-594    	; 0x3130 <csp_conn_new>
    3382:	fc 01       	movw	r30, r24
	if (conn == NULL)
    3384:	00 97       	sbiw	r24, 0x00	; 0
    3386:	61 f0       	breq	.+24     	; 0x33a0 <csp_connect+0x18c>
		return NULL;

	/* Set connection options */
	conn->opts = opts;
    3388:	c4 8a       	std	Z+20, r12	; 0x14
    338a:	d5 8a       	std	Z+21, r13	; 0x15
    338c:	e6 8a       	std	Z+22, r14	; 0x16
    338e:	f7 8a       	std	Z+23, r15	; 0x17
		}
	}
#endif

	/* We have a successful connection */
	return conn;
    3390:	9f 2f       	mov	r25, r31
    3392:	07 c0       	rjmp	.+14     	; 0x33a2 <csp_connect+0x18e>
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	04 c0       	rjmp	.+8      	; 0x33a2 <csp_connect+0x18e>
	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);

	/* If no available ephemeral port was found */
	if (sport == start)
		return NULL;
    339a:	80 e0       	ldi	r24, 0x00	; 0
    339c:	90 e0       	ldi	r25, 0x00	; 0
    339e:	01 c0       	rjmp	.+2      	; 0x33a2 <csp_connect+0x18e>

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
	if (conn == NULL)
		return NULL;
    33a0:	9f 2f       	mov	r25, r31
#endif

	/* We have a successful connection */
	return conn;

}
    33a2:	df 91       	pop	r29
    33a4:	cf 91       	pop	r28
    33a6:	1f 91       	pop	r17
    33a8:	0f 91       	pop	r16
    33aa:	ff 90       	pop	r15
    33ac:	ef 90       	pop	r14
    33ae:	df 90       	pop	r13
    33b0:	cf 90       	pop	r12
    33b2:	bf 90       	pop	r11
    33b4:	af 90       	pop	r10
    33b6:	9f 90       	pop	r9
    33b8:	8f 90       	pop	r8
    33ba:	7f 90       	pop	r7
    33bc:	6f 90       	pop	r6
    33be:	08 95       	ret

000033c0 <csp_conn_dport>:

inline int csp_conn_dport(csp_conn_t * conn) {
    33c0:	fc 01       	movw	r30, r24

	return conn->idin.dport;
    33c2:	95 81       	ldd	r25, Z+5	; 0x05
    33c4:	92 95       	swap	r25
    33c6:	96 95       	lsr	r25
    33c8:	96 95       	lsr	r25
    33ca:	93 70       	andi	r25, 0x03	; 3
    33cc:	86 81       	ldd	r24, Z+6	; 0x06
    33ce:	8f 70       	andi	r24, 0x0F	; 15
    33d0:	88 0f       	add	r24, r24
    33d2:	88 0f       	add	r24, r24
    33d4:	89 2b       	or	r24, r25

}
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	08 95       	ret

000033da <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    33da:	cf 92       	push	r12
    33dc:	df 92       	push	r13
    33de:	ef 92       	push	r14
    33e0:	ff 92       	push	r15
    33e2:	0f 93       	push	r16
    33e4:	1f 93       	push	r17
    33e6:	cf 93       	push	r28
    33e8:	df 93       	push	r29
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    33ea:	8a 01       	movw	r16, r20
    33ec:	9b 01       	movw	r18, r22
    33ee:	01 50       	subi	r16, 0x01	; 1
    33f0:	11 09       	sbc	r17, r1
    33f2:	21 09       	sbc	r18, r1
    33f4:	31 09       	sbc	r19, r1
    33f6:	45 2b       	or	r20, r21
    33f8:	46 2b       	or	r20, r22
    33fa:	47 2b       	or	r20, r23
    33fc:	39 f1       	breq	.+78     	; 0x344c <csp_crc32_memory+0x72>
    33fe:	c8 2f       	mov	r28, r24
    3400:	d9 2f       	mov	r29, r25
    3402:	4f ef       	ldi	r20, 0xFF	; 255
    3404:	5f ef       	ldi	r21, 0xFF	; 255
    3406:	ba 01       	movw	r22, r20
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    3408:	89 91       	ld	r24, Y+
    340a:	6a 01       	movw	r12, r20
    340c:	7b 01       	movw	r14, r22
    340e:	c8 26       	eor	r12, r24
    3410:	d7 01       	movw	r26, r14
    3412:	c6 01       	movw	r24, r12
    3414:	99 27       	eor	r25, r25
    3416:	aa 27       	eor	r26, r26
    3418:	bb 27       	eor	r27, r27
    341a:	fc 01       	movw	r30, r24
    341c:	ee 0f       	add	r30, r30
    341e:	ff 1f       	adc	r31, r31
    3420:	ee 0f       	add	r30, r30
    3422:	ff 1f       	adc	r31, r31
    3424:	e1 53       	subi	r30, 0x31	; 49
    3426:	fb 4f       	sbci	r31, 0xFB	; 251
    3428:	85 91       	lpm	r24, Z+
    342a:	95 91       	lpm	r25, Z+
    342c:	a5 91       	lpm	r26, Z+
    342e:	b4 91       	lpm	r27, Z
    3430:	45 2f       	mov	r20, r21
    3432:	56 2f       	mov	r21, r22
    3434:	67 2f       	mov	r22, r23
    3436:	77 27       	eor	r23, r23
    3438:	48 27       	eor	r20, r24
    343a:	59 27       	eor	r21, r25
    343c:	6a 27       	eor	r22, r26
    343e:	7b 27       	eor	r23, r27

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    3440:	01 50       	subi	r16, 0x01	; 1
    3442:	11 09       	sbc	r17, r1
    3444:	21 09       	sbc	r18, r1
    3446:	31 09       	sbc	r19, r1
    3448:	f8 f6       	brcc	.-66     	; 0x3408 <csp_crc32_memory+0x2e>
    344a:	03 c0       	rjmp	.+6      	; 0x3452 <csp_crc32_memory+0x78>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    344c:	4f ef       	ldi	r20, 0xFF	; 255
    344e:	5f ef       	ldi	r21, 0xFF	; 255
    3450:	ba 01       	movw	r22, r20
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    3452:	cb 01       	movw	r24, r22
    3454:	ba 01       	movw	r22, r20
    3456:	60 95       	com	r22
    3458:	70 95       	com	r23
    345a:	80 95       	com	r24
    345c:	90 95       	com	r25
}
    345e:	df 91       	pop	r29
    3460:	cf 91       	pop	r28
    3462:	1f 91       	pop	r17
    3464:	0f 91       	pop	r16
    3466:	ff 90       	pop	r15
    3468:	ef 90       	pop	r14
    346a:	df 90       	pop	r13
    346c:	cf 90       	pop	r12
    346e:	08 95       	ret

00003470 <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet, bool include_header) {
    3470:	cf 93       	push	r28
    3472:	df 93       	push	r29

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    3474:	00 97       	sbiw	r24, 0x00	; 0
    3476:	19 f1       	breq	.+70     	; 0x34be <csp_crc32_append+0x4e>
    3478:	ec 01       	movw	r28, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    347a:	66 23       	and	r22, r22
    347c:	49 f0       	breq	.+18     	; 0x3490 <csp_crc32_append+0x20>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id));
    347e:	48 85       	ldd	r20, Y+8	; 0x08
    3480:	59 85       	ldd	r21, Y+9	; 0x09
    3482:	4c 5f       	subi	r20, 0xFC	; 252
    3484:	5f 4f       	sbci	r21, 0xFF	; 255
    3486:	60 e0       	ldi	r22, 0x00	; 0
    3488:	70 e0       	ldi	r23, 0x00	; 0
    348a:	0a 96       	adiw	r24, 0x0a	; 10
    348c:	a6 df       	rcall	.-180    	; 0x33da <csp_crc32_memory>
    348e:	06 c0       	rjmp	.+12     	; 0x349c <csp_crc32_append+0x2c>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length);
    3490:	48 85       	ldd	r20, Y+8	; 0x08
    3492:	59 85       	ldd	r21, Y+9	; 0x09
    3494:	60 e0       	ldi	r22, 0x00	; 0
    3496:	70 e0       	ldi	r23, 0x00	; 0
    3498:	0e 96       	adiw	r24, 0x0e	; 14
	}
	crc = csp_hton32(crc);
    349a:	9f df       	rcall	.-194    	; 0x33da <csp_crc32_memory>
    349c:	f0 d0       	rcall	.+480    	; 0x367e <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    349e:	e8 85       	ldd	r30, Y+8	; 0x08
    34a0:	f9 85       	ldd	r31, Y+9	; 0x09
    34a2:	ec 0f       	add	r30, r28
    34a4:	fd 1f       	adc	r31, r29
    34a6:	66 87       	std	Z+14, r22	; 0x0e
    34a8:	77 87       	std	Z+15, r23	; 0x0f
    34aa:	80 8b       	std	Z+16, r24	; 0x10
    34ac:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    34ae:	88 85       	ldd	r24, Y+8	; 0x08
    34b0:	99 85       	ldd	r25, Y+9	; 0x09
    34b2:	04 96       	adiw	r24, 0x04	; 4
    34b4:	99 87       	std	Y+9, r25	; 0x09
    34b6:	88 87       	std	Y+8, r24	; 0x08

	return CSP_ERR_NONE;
    34b8:	80 e0       	ldi	r24, 0x00	; 0
    34ba:	90 e0       	ldi	r25, 0x00	; 0
    34bc:	02 c0       	rjmp	.+4      	; 0x34c2 <csp_crc32_append+0x52>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    34be:	8e ef       	ldi	r24, 0xFE	; 254
    34c0:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    34c2:	df 91       	pop	r29
    34c4:	cf 91       	pop	r28
    34c6:	08 95       	ret

000034c8 <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet, bool include_header) {
    34c8:	ef 92       	push	r14
    34ca:	ff 92       	push	r15
    34cc:	0f 93       	push	r16
    34ce:	1f 93       	push	r17
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	00 d0       	rcall	.+0      	; 0x34d6 <csp_crc32_verify+0xe>
    34d6:	1f 92       	push	r1
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    34dc:	00 97       	sbiw	r24, 0x00	; 0
    34de:	09 f4       	brne	.+2      	; 0x34e2 <csp_crc32_verify+0x1a>
    34e0:	3c c0       	rjmp	.+120    	; 0x355a <csp_crc32_verify+0x92>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    34e2:	fc 01       	movw	r30, r24
    34e4:	40 85       	ldd	r20, Z+8	; 0x08
    34e6:	51 85       	ldd	r21, Z+9	; 0x09
    34e8:	44 30       	cpi	r20, 0x04	; 4
    34ea:	51 05       	cpc	r21, r1
    34ec:	c8 f1       	brcs	.+114    	; 0x3560 <csp_crc32_verify+0x98>
    34ee:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    34f0:	66 23       	and	r22, r22
    34f2:	49 f0       	breq	.+18     	; 0x3506 <csp_crc32_verify+0x3e>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id) - sizeof(uint32_t));
    34f4:	60 e0       	ldi	r22, 0x00	; 0
    34f6:	70 e0       	ldi	r23, 0x00	; 0
    34f8:	0a 96       	adiw	r24, 0x0a	; 10
    34fa:	6f df       	rcall	.-290    	; 0x33da <csp_crc32_memory>
    34fc:	69 83       	std	Y+1, r22	; 0x01
    34fe:	7a 83       	std	Y+2, r23	; 0x02
    3500:	8b 83       	std	Y+3, r24	; 0x03
    3502:	9c 83       	std	Y+4, r25	; 0x04
    3504:	0a c0       	rjmp	.+20     	; 0x351a <csp_crc32_verify+0x52>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    3506:	44 50       	subi	r20, 0x04	; 4
    3508:	51 09       	sbc	r21, r1
    350a:	60 e0       	ldi	r22, 0x00	; 0
    350c:	70 e0       	ldi	r23, 0x00	; 0
    350e:	0e 96       	adiw	r24, 0x0e	; 14
    3510:	64 df       	rcall	.-312    	; 0x33da <csp_crc32_memory>
    3512:	69 83       	std	Y+1, r22	; 0x01
    3514:	7a 83       	std	Y+2, r23	; 0x02
    3516:	8b 83       	std	Y+3, r24	; 0x03
    3518:	9c 83       	std	Y+4, r25	; 0x04
	}
	crc = csp_hton32(crc);
    351a:	69 81       	ldd	r22, Y+1	; 0x01
    351c:	7a 81       	ldd	r23, Y+2	; 0x02
    351e:	8b 81       	ldd	r24, Y+3	; 0x03
    3520:	9c 81       	ldd	r25, Y+4	; 0x04
    3522:	ad d0       	rcall	.+346    	; 0x367e <csp_hton32>
    3524:	69 83       	std	Y+1, r22	; 0x01
    3526:	7a 83       	std	Y+2, r23	; 0x02
    3528:	8b 83       	std	Y+3, r24	; 0x03
    352a:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    352c:	f8 01       	movw	r30, r16
    352e:	e0 84       	ldd	r14, Z+8	; 0x08
    3530:	f1 84       	ldd	r15, Z+9	; 0x09
    3532:	c8 01       	movw	r24, r16
    3534:	8e 0d       	add	r24, r14
    3536:	9f 1d       	adc	r25, r15
    3538:	44 e0       	ldi	r20, 0x04	; 4
    353a:	50 e0       	ldi	r21, 0x00	; 0
    353c:	be 01       	movw	r22, r28
    353e:	6f 5f       	subi	r22, 0xFF	; 255
    3540:	7f 4f       	sbci	r23, 0xFF	; 255
    3542:	0a 96       	adiw	r24, 0x0a	; 10
    3544:	0e 94 96 42 	call	0x852c	; 0x852c <memcmp>
    3548:	00 97       	sbiw	r24, 0x00	; 0
    354a:	69 f4       	brne	.+26     	; 0x3566 <csp_crc32_verify+0x9e>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    354c:	f4 e0       	ldi	r31, 0x04	; 4
    354e:	ef 1a       	sub	r14, r31
    3550:	f1 08       	sbc	r15, r1
    3552:	f8 01       	movw	r30, r16
    3554:	f1 86       	std	Z+9, r15	; 0x09
    3556:	e0 86       	std	Z+8, r14	; 0x08
		return CSP_ERR_NONE;
    3558:	08 c0       	rjmp	.+16     	; 0x356a <csp_crc32_verify+0xa2>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    355a:	8e ef       	ldi	r24, 0xFE	; 254
    355c:	9f ef       	ldi	r25, 0xFF	; 255
    355e:	05 c0       	rjmp	.+10     	; 0x356a <csp_crc32_verify+0xa2>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    3560:	8e ef       	ldi	r24, 0xFE	; 254
    3562:	9f ef       	ldi	r25, 0xFF	; 255
    3564:	02 c0       	rjmp	.+4      	; 0x356a <csp_crc32_verify+0xa2>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    3566:	8e ef       	ldi	r24, 0xFE	; 254
    3568:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    356a:	0f 90       	pop	r0
    356c:	0f 90       	pop	r0
    356e:	0f 90       	pop	r0
    3570:	0f 90       	pop	r0
    3572:	df 91       	pop	r29
    3574:	cf 91       	pop	r28
    3576:	1f 91       	pop	r17
    3578:	0f 91       	pop	r16
    357a:	ff 90       	pop	r15
    357c:	ef 90       	pop	r14
    357e:	08 95       	ret

00003580 <do_csp_debug>:
{
	csp_debug_hook_func = f;
}

void do_csp_debug(csp_debug_level_t level, const char *format, ...)
{
    3580:	ff 92       	push	r15
    3582:	0f 93       	push	r16
    3584:	1f 93       	push	r17
    3586:	cf 93       	push	r28
    3588:	df 93       	push	r29
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	19 85       	ldd	r17, Y+9	; 0x09
	int color = COLOR_RESET;
	va_list args;

	/* Don't print anything if log level is disabled */
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
    3590:	18 30       	cpi	r17, 0x08	; 8
    3592:	08 f0       	brcs	.+2      	; 0x3596 <do_csp_debug+0x16>
    3594:	66 c0       	rjmp	.+204    	; 0x3662 <do_csp_debug+0xe2>
    3596:	e1 2f       	mov	r30, r17
    3598:	f0 e0       	ldi	r31, 0x00	; 0
    359a:	e6 5f       	subi	r30, 0xF6	; 246
    359c:	fd 4f       	sbci	r31, 0xFD	; 253
    359e:	80 81       	ld	r24, Z
    35a0:	88 23       	and	r24, r24
    35a2:	09 f4       	brne	.+2      	; 0x35a6 <do_csp_debug+0x26>
    35a4:	5e c0       	rjmp	.+188    	; 0x3662 <do_csp_debug+0xe2>
		return;

	switch(level) {
    35a6:	81 2f       	mov	r24, r17
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	88 30       	cpi	r24, 0x08	; 8
    35ac:	91 05       	cpc	r25, r1
    35ae:	08 f0       	brcs	.+2      	; 0x35b2 <do_csp_debug+0x32>
    35b0:	58 c0       	rjmp	.+176    	; 0x3662 <do_csp_debug+0xe2>
    35b2:	fc 01       	movw	r30, r24
    35b4:	88 27       	eor	r24, r24
    35b6:	ee 58       	subi	r30, 0x8E	; 142
    35b8:	ff 4f       	sbci	r31, 0xFF	; 255
    35ba:	8f 4f       	sbci	r24, 0xFF	; 255
    35bc:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
		break;
	case CSP_ERROR:
		color = COLOR_RED | COLOR_BOLD;
    35c0:	82 e1       	ldi	r24, 0x12	; 18
    35c2:	0b c0       	rjmp	.+22     	; 0x35da <do_csp_debug+0x5a>
		break;
	case CSP_WARN:
		color = COLOR_YELLOW | COLOR_BOLD;
    35c4:	84 e1       	ldi	r24, 0x14	; 20
		break;
    35c6:	09 c0       	rjmp	.+18     	; 0x35da <do_csp_debug+0x5a>
	case CSP_RESET:
		color = COLOR_RED | COLOR_BOLD;
		break;
	case CSP_BUFFER:
		color = COLOR_MAGENTA;
    35c8:	86 e0       	ldi	r24, 0x06	; 6
		break;
    35ca:	07 c0       	rjmp	.+14     	; 0x35da <do_csp_debug+0x5a>
	case CSP_PACKET:
		color = COLOR_GREEN;
    35cc:	83 e0       	ldi	r24, 0x03	; 3
		break;
    35ce:	05 c0       	rjmp	.+10     	; 0x35da <do_csp_debug+0x5a>
	case CSP_PROTOCOL:
		color = COLOR_BLUE;
    35d0:	85 e0       	ldi	r24, 0x05	; 5
		break;
    35d2:	03 c0       	rjmp	.+6      	; 0x35da <do_csp_debug+0x5a>
	case CSP_LOCK:
		color = COLOR_CYAN;
    35d4:	87 e0       	ldi	r24, 0x07	; 7
		break;
    35d6:	01 c0       	rjmp	.+2      	; 0x35da <do_csp_debug+0x5a>
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
		return;

	switch(level) {
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
    35d8:	83 e1       	ldi	r24, 0x13	; 19
		break;
	default:
		return;
	}

	va_start(args, format);
    35da:	ae 01       	movw	r20, r28
    35dc:	44 5f       	subi	r20, 0xF4	; 244
    35de:	5f 4f       	sbci	r21, 0xFF	; 255
    35e0:	f4 2e       	mov	r15, r20
    35e2:	05 2f       	mov	r16, r21

	/* If csp_debug_hook symbol is defined, pass on the message.
	 * Otherwise, just print with pretty colors ... */
	if (csp_debug_hook_func) {
    35e4:	e0 91 ef 04 	lds	r30, 0x04EF	; 0x8004ef <csp_debug_hook_func>
    35e8:	f0 91 f0 04 	lds	r31, 0x04F0	; 0x8004f0 <csp_debug_hook_func+0x1>
    35ec:	30 97       	sbiw	r30, 0x00	; 0
    35ee:	29 f0       	breq	.+10     	; 0x35fa <do_csp_debug+0x7a>
		csp_debug_hook_func(level, format, args);
    35f0:	6a 85       	ldd	r22, Y+10	; 0x0a
    35f2:	7b 85       	ldd	r23, Y+11	; 0x0b
    35f4:	81 2f       	mov	r24, r17
    35f6:	19 95       	eicall
    35f8:	17 c0       	rjmp	.+46     	; 0x3628 <do_csp_debug+0xa8>
	} else {
		csp_sys_set_color(color);
    35fa:	0e 94 ab 2d 	call	0x5b56	; 0x5b56 <csp_sys_set_color>
#ifdef __AVR__
		vfprintf_P(stdout, format, args);
    35fe:	4f 2d       	mov	r20, r15
    3600:	50 2f       	mov	r21, r16
    3602:	6a 85       	ldd	r22, Y+10	; 0x0a
    3604:	7b 85       	ldd	r23, Y+11	; 0x0b
    3606:	80 91 75 20 	lds	r24, 0x2075	; 0x802075 <__iob+0x2>
    360a:	90 91 76 20 	lds	r25, 0x2076	; 0x802076 <__iob+0x3>
    360e:	0e 94 00 44 	call	0x8800	; 0x8800 <vfprintf_P>
#else
		vprintf(format, args);
#endif
		printf("\r\n");
    3612:	89 ee       	ldi	r24, 0xE9	; 233
    3614:	98 e0       	ldi	r25, 0x08	; 8
    3616:	9f 93       	push	r25
    3618:	8f 93       	push	r24
    361a:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
		csp_sys_set_color(COLOR_RESET);
    361e:	80 ef       	ldi	r24, 0xF0	; 240
    3620:	0e 94 ab 2d 	call	0x5b56	; 0x5b56 <csp_sys_set_color>
    3624:	0f 90       	pop	r0
    3626:	0f 90       	pop	r0
	}

	va_end(args);
	if(level==CSP_RESET){
    3628:	16 30       	cpi	r17, 0x06	; 6
    362a:	d9 f4       	brne	.+54     	; 0x3662 <do_csp_debug+0xe2>
		printf("CSP RESET %s",pcTaskGetName(NULL));
    362c:	80 e0       	ldi	r24, 0x00	; 0
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    3634:	9f 93       	push	r25
    3636:	8f 93       	push	r24
    3638:	8c ed       	ldi	r24, 0xDC	; 220
    363a:	98 e0       	ldi	r25, 0x08	; 8
    363c:	9f 93       	push	r25
    363e:	8f 93       	push	r24
    3640:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
	FORCERESET
    3644:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
    3648:	8f ec       	ldi	r24, 0xCF	; 207
    364a:	98 e0       	ldi	r25, 0x08	; 8
    364c:	9f 93       	push	r25
    364e:	8f 93       	push	r24
    3650:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	0f 90       	pop	r0
    365c:	0f 90       	pop	r0
    365e:	0f 90       	pop	r0
    3660:	ff cf       	rjmp	.-2      	; 0x3660 <do_csp_debug+0xe0>
	}
}
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	1f 91       	pop	r17
    3668:	0f 91       	pop	r16
    366a:	ff 90       	pop	r15
    366c:	08 95       	ret

0000366e <csp_hton16>:
	return h16;
#else
	return (((h16 & 0xff00) >> 8) |
			((h16 & 0x00ff) << 8));
#endif
}
    366e:	98 27       	eor	r25, r24
    3670:	89 27       	eor	r24, r25
    3672:	98 27       	eor	r25, r24
    3674:	08 95       	ret

00003676 <csp_ntoh16>:

/* Convert 16-bit number from network byte order to host byte order */
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}
    3676:	98 27       	eor	r25, r24
    3678:	89 27       	eor	r24, r25
    367a:	98 27       	eor	r25, r24
    367c:	08 95       	ret

0000367e <csp_hton32>:

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    367e:	cf 92       	push	r12
    3680:	df 92       	push	r13
    3682:	ef 92       	push	r14
    3684:	ff 92       	push	r15
    3686:	0f 93       	push	r16
    3688:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    368a:	c9 2e       	mov	r12, r25
    368c:	dd 24       	eor	r13, r13
    368e:	ee 24       	eor	r14, r14
    3690:	ff 24       	eor	r15, r15
    3692:	36 2f       	mov	r19, r22
    3694:	22 27       	eor	r18, r18
    3696:	11 27       	eor	r17, r17
    3698:	00 27       	eor	r16, r16
    369a:	0c 29       	or	r16, r12
    369c:	1d 29       	or	r17, r13
    369e:	2e 29       	or	r18, r14
    36a0:	3f 29       	or	r19, r15
    36a2:	6b 01       	movw	r12, r22
    36a4:	7c 01       	movw	r14, r24
    36a6:	cc 24       	eor	r12, r12
    36a8:	ee 24       	eor	r14, r14
    36aa:	ff 24       	eor	r15, r15
    36ac:	fe 2c       	mov	r15, r14
    36ae:	ed 2c       	mov	r14, r13
    36b0:	dc 2c       	mov	r13, r12
    36b2:	cc 24       	eor	r12, r12
    36b4:	0c 29       	or	r16, r12
    36b6:	1d 29       	or	r17, r13
    36b8:	2e 29       	or	r18, r14
    36ba:	3f 29       	or	r19, r15
    36bc:	dc 01       	movw	r26, r24
    36be:	cb 01       	movw	r24, r22
    36c0:	88 27       	eor	r24, r24
    36c2:	99 27       	eor	r25, r25
    36c4:	bb 27       	eor	r27, r27
    36c6:	89 2f       	mov	r24, r25
    36c8:	9a 2f       	mov	r25, r26
    36ca:	ab 2f       	mov	r26, r27
    36cc:	bb 27       	eor	r27, r27
    36ce:	bc 01       	movw	r22, r24
    36d0:	cd 01       	movw	r24, r26
    36d2:	60 2b       	or	r22, r16
    36d4:	71 2b       	or	r23, r17
    36d6:	82 2b       	or	r24, r18
    36d8:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    36da:	1f 91       	pop	r17
    36dc:	0f 91       	pop	r16
    36de:	ff 90       	pop	r15
    36e0:	ef 90       	pop	r14
    36e2:	df 90       	pop	r13
    36e4:	cf 90       	pop	r12
    36e6:	08 95       	ret

000036e8 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    36e8:	cf 92       	push	r12
    36ea:	df 92       	push	r13
    36ec:	ef 92       	push	r14
    36ee:	ff 92       	push	r15
    36f0:	0f 93       	push	r16
    36f2:	1f 93       	push	r17
	return csp_hton32(n32);
    36f4:	c9 2e       	mov	r12, r25
    36f6:	dd 24       	eor	r13, r13
    36f8:	ee 24       	eor	r14, r14
    36fa:	ff 24       	eor	r15, r15
    36fc:	36 2f       	mov	r19, r22
    36fe:	22 27       	eor	r18, r18
    3700:	11 27       	eor	r17, r17
    3702:	00 27       	eor	r16, r16
    3704:	0c 29       	or	r16, r12
    3706:	1d 29       	or	r17, r13
    3708:	2e 29       	or	r18, r14
    370a:	3f 29       	or	r19, r15
    370c:	6b 01       	movw	r12, r22
    370e:	7c 01       	movw	r14, r24
    3710:	cc 24       	eor	r12, r12
    3712:	ee 24       	eor	r14, r14
    3714:	ff 24       	eor	r15, r15
    3716:	fe 2c       	mov	r15, r14
    3718:	ed 2c       	mov	r14, r13
    371a:	dc 2c       	mov	r13, r12
    371c:	cc 24       	eor	r12, r12
    371e:	0c 29       	or	r16, r12
    3720:	1d 29       	or	r17, r13
    3722:	2e 29       	or	r18, r14
    3724:	3f 29       	or	r19, r15
    3726:	dc 01       	movw	r26, r24
    3728:	cb 01       	movw	r24, r22
    372a:	88 27       	eor	r24, r24
    372c:	99 27       	eor	r25, r25
    372e:	bb 27       	eor	r27, r27
    3730:	89 2f       	mov	r24, r25
    3732:	9a 2f       	mov	r25, r26
    3734:	ab 2f       	mov	r26, r27
    3736:	bb 27       	eor	r27, r27
    3738:	bc 01       	movw	r22, r24
    373a:	cd 01       	movw	r24, r26
    373c:	60 2b       	or	r22, r16
    373e:	71 2b       	or	r23, r17
    3740:	82 2b       	or	r24, r18
    3742:	93 2b       	or	r25, r19
}
    3744:	1f 91       	pop	r17
    3746:	0f 91       	pop	r16
    3748:	ff 90       	pop	r15
    374a:	ef 90       	pop	r14
    374c:	df 90       	pop	r13
    374e:	cf 90       	pop	r12
    3750:	08 95       	ret

00003752 <csp_bytesize>:
	}

}

#ifdef CSP_DEBUG
static int csp_bytesize(char *buf, int len, unsigned long int n) {
    3752:	0f 93       	push	r16
    3754:	1f 93       	push	r17
    3756:	cf 93       	push	r28
    3758:	df 93       	push	r29
    375a:	c8 2f       	mov	r28, r24
    375c:	d9 2f       	mov	r29, r25
    375e:	16 2f       	mov	r17, r22
    3760:	07 2f       	mov	r16, r23
	char postfix;
	double size;

	if (n >= 1048576) {
    3762:	21 15       	cp	r18, r1
    3764:	31 05       	cpc	r19, r1
    3766:	80 e1       	ldi	r24, 0x10	; 16
    3768:	48 07       	cpc	r20, r24
    376a:	51 05       	cpc	r21, r1
    376c:	60 f0       	brcs	.+24     	; 0x3786 <csp_bytesize+0x34>
		size = n/1048576.0;
    376e:	ca 01       	movw	r24, r20
    3770:	b9 01       	movw	r22, r18
    3772:	0e 94 d4 40 	call	0x81a8	; 0x81a8 <__floatunsisf>
    3776:	20 e0       	ldi	r18, 0x00	; 0
    3778:	30 e0       	ldi	r19, 0x00	; 0
    377a:	40 e8       	ldi	r20, 0x80	; 128
    377c:	55 e3       	ldi	r21, 0x35	; 53
    377e:	0e 94 11 41 	call	0x8222	; 0x8222 <__mulsf3>
		postfix = 'M';
    3782:	2d e4       	ldi	r18, 0x4D	; 77
    3784:	17 c0       	rjmp	.+46     	; 0x37b4 <csp_bytesize+0x62>
	} else if (n >= 1024) {
    3786:	21 15       	cp	r18, r1
    3788:	84 e0       	ldi	r24, 0x04	; 4
    378a:	38 07       	cpc	r19, r24
    378c:	41 05       	cpc	r20, r1
    378e:	51 05       	cpc	r21, r1
    3790:	60 f0       	brcs	.+24     	; 0x37aa <csp_bytesize+0x58>
		size = n/1024.;
    3792:	ca 01       	movw	r24, r20
    3794:	b9 01       	movw	r22, r18
    3796:	0e 94 d4 40 	call	0x81a8	; 0x81a8 <__floatunsisf>
    379a:	20 e0       	ldi	r18, 0x00	; 0
    379c:	30 e0       	ldi	r19, 0x00	; 0
    379e:	40 e8       	ldi	r20, 0x80	; 128
    37a0:	5a e3       	ldi	r21, 0x3A	; 58
    37a2:	0e 94 11 41 	call	0x8222	; 0x8222 <__mulsf3>
		postfix = 'K';
    37a6:	2b e4       	ldi	r18, 0x4B	; 75
    37a8:	05 c0       	rjmp	.+10     	; 0x37b4 <csp_bytesize+0x62>
	} else {
		size = n;
    37aa:	ca 01       	movw	r24, r20
    37ac:	b9 01       	movw	r22, r18
    37ae:	0e 94 d4 40 	call	0x81a8	; 0x81a8 <__floatunsisf>
		postfix = 'B';
    37b2:	22 e4       	ldi	r18, 0x42	; 66
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
    37b4:	1f 92       	push	r1
    37b6:	2f 93       	push	r18
    37b8:	9f 93       	push	r25
    37ba:	8f 93       	push	r24
    37bc:	7f 93       	push	r23
    37be:	6f 93       	push	r22
    37c0:	8c ee       	ldi	r24, 0xEC	; 236
    37c2:	98 e0       	ldi	r25, 0x08	; 8
    37c4:	9f 93       	push	r25
    37c6:	8f 93       	push	r24
    37c8:	0f 93       	push	r16
    37ca:	1f 93       	push	r17
    37cc:	df 93       	push	r29
    37ce:	cf 93       	push	r28
    37d0:	0e 94 96 43 	call	0x872c	; 0x872c <snprintf_P>
    37d4:	2d b7       	in	r18, 0x3d	; 61
    37d6:	3e b7       	in	r19, 0x3e	; 62
    37d8:	24 5f       	subi	r18, 0xF4	; 244
    37da:	3f 4f       	sbci	r19, 0xFF	; 255
    37dc:	0f b6       	in	r0, 0x3f	; 63
    37de:	f8 94       	cli
    37e0:	3e bf       	out	0x3e, r19	; 62
    37e2:	0f be       	out	0x3f, r0	; 63
    37e4:	2d bf       	out	0x3d, r18	; 61
}
    37e6:	df 91       	pop	r29
    37e8:	cf 91       	pop	r28
    37ea:	1f 91       	pop	r17
    37ec:	0f 91       	pop	r16
    37ee:	08 95       	ret

000037f0 <csp_iflist_get_by_name>:
#include "csp.h"

/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
    37f0:	0f 93       	push	r16
    37f2:	1f 93       	push	r17
    37f4:	cf 93       	push	r28
    37f6:	df 93       	push	r29
    37f8:	8c 01       	movw	r16, r24
	csp_iface_t *ifc = interfaces;
    37fa:	c0 91 f1 04 	lds	r28, 0x04F1	; 0x8004f1 <interfaces>
    37fe:	d0 91 f2 04 	lds	r29, 0x04F2	; 0x8004f2 <interfaces+0x1>
	while(ifc) {
    3802:	20 97       	sbiw	r28, 0x00	; 0
    3804:	71 f0       	breq	.+28     	; 0x3822 <csp_iflist_get_by_name+0x32>
		if (strncmp(ifc->name, name, 10) == 0)
    3806:	4a e0       	ldi	r20, 0x0A	; 10
    3808:	50 e0       	ldi	r21, 0x00	; 0
    380a:	b8 01       	movw	r22, r16
    380c:	88 81       	ld	r24, Y
    380e:	99 81       	ldd	r25, Y+1	; 0x01
    3810:	0e 94 ba 42 	call	0x8574	; 0x8574 <strncmp>
    3814:	89 2b       	or	r24, r25
    3816:	29 f0       	breq	.+10     	; 0x3822 <csp_iflist_get_by_name+0x32>
			break;
		ifc = ifc->next;
    3818:	09 a8       	ldd	r0, Y+49	; 0x31
    381a:	da a9       	ldd	r29, Y+50	; 0x32
    381c:	c0 2d       	mov	r28, r0
/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
	csp_iface_t *ifc = interfaces;
	while(ifc) {
    381e:	20 97       	sbiw	r28, 0x00	; 0
    3820:	91 f7       	brne	.-28     	; 0x3806 <csp_iflist_get_by_name+0x16>
		if (strncmp(ifc->name, name, 10) == 0)
			break;
		ifc = ifc->next;
	}
	return ifc;
}
    3822:	ce 01       	movw	r24, r28
    3824:	df 91       	pop	r29
    3826:	cf 91       	pop	r28
    3828:	1f 91       	pop	r17
    382a:	0f 91       	pop	r16
    382c:	08 95       	ret

0000382e <csp_iflist_add>:

void csp_iflist_add(csp_iface_t *ifc) {

	/* Add interface to pool */
	if (interfaces == NULL) {
    382e:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <interfaces>
    3832:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <interfaces+0x1>
    3836:	10 97       	sbiw	r26, 0x00	; 0
    3838:	41 f4       	brne	.+16     	; 0x384a <csp_iflist_add+0x1c>
		/* This is the first interface to be added */
		interfaces = ifc;
    383a:	90 93 f2 04 	sts	0x04F2, r25	; 0x8004f2 <interfaces+0x1>
    383e:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <interfaces>
		ifc->next = NULL;
    3842:	fc 01       	movw	r30, r24
    3844:	12 aa       	std	Z+50, r1	; 0x32
    3846:	11 aa       	std	Z+49, r1	; 0x31
    3848:	08 95       	ret
	} else {
		/* One or more interfaces were already added */
		csp_iface_t * i = interfaces;
		while (i != ifc && i->next)
    384a:	a8 17       	cp	r26, r24
    384c:	b9 07       	cpc	r27, r25
    384e:	b9 f0       	breq	.+46     	; 0x387e <csp_iflist_add+0x50>
    3850:	d1 96       	adiw	r26, 0x31	; 49
    3852:	ed 91       	ld	r30, X+
    3854:	fc 91       	ld	r31, X
    3856:	d2 97       	sbiw	r26, 0x32	; 50
    3858:	30 97       	sbiw	r30, 0x00	; 0
    385a:	41 f4       	brne	.+16     	; 0x386c <csp_iflist_add+0x3e>
    385c:	fd 01       	movw	r30, r26
    385e:	0a c0       	rjmp	.+20     	; 0x3874 <csp_iflist_add+0x46>
    3860:	21 a9       	ldd	r18, Z+49	; 0x31
    3862:	32 a9       	ldd	r19, Z+50	; 0x32
    3864:	21 15       	cp	r18, r1
    3866:	31 05       	cpc	r19, r1
    3868:	29 f0       	breq	.+10     	; 0x3874 <csp_iflist_add+0x46>
    386a:	f9 01       	movw	r30, r18
    386c:	8e 17       	cp	r24, r30
    386e:	9f 07       	cpc	r25, r31
    3870:	b9 f7       	brne	.-18     	; 0x3860 <csp_iflist_add+0x32>
    3872:	08 95       	ret
			i = i->next;

		/* Insert interface last if not already in pool */
		if (i != ifc && i->next == NULL) {
			i->next = ifc;
    3874:	92 ab       	std	Z+50, r25	; 0x32
    3876:	81 ab       	std	Z+49, r24	; 0x31
			ifc->next = NULL;
    3878:	fc 01       	movw	r30, r24
    387a:	12 aa       	std	Z+50, r1	; 0x32
    387c:	11 aa       	std	Z+49, r1	; 0x31
    387e:	08 95       	ret

00003880 <csp_iflist_print>:
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
}

void csp_iflist_print(void) {
    3880:	af 92       	push	r10
    3882:	bf 92       	push	r11
    3884:	cf 92       	push	r12
    3886:	df 92       	push	r13
    3888:	ef 92       	push	r14
    388a:	ff 92       	push	r15
    388c:	0f 93       	push	r16
    388e:	1f 93       	push	r17
    3890:	cf 93       	push	r28
    3892:	df 93       	push	r29
    3894:	cd b7       	in	r28, 0x3d	; 61
    3896:	de b7       	in	r29, 0x3e	; 62
    3898:	e2 97       	sbiw	r28, 0x32	; 50
    389a:	0f b6       	in	r0, 0x3f	; 63
    389c:	f8 94       	cli
    389e:	de bf       	out	0x3e, r29	; 62
    38a0:	0f be       	out	0x3f, r0	; 63
    38a2:	cd bf       	out	0x3d, r28	; 61
	csp_iface_t * i = interfaces;
    38a4:	00 91 f1 04 	lds	r16, 0x04F1	; 0x8004f1 <interfaces>
    38a8:	10 91 f2 04 	lds	r17, 0x04F2	; 0x8004f2 <interfaces+0x1>
	char txbuf[25], rxbuf[25];

	while (i) {
    38ac:	01 15       	cp	r16, r1
    38ae:	11 05       	cpc	r17, r1
    38b0:	09 f4       	brne	.+2      	; 0x38b4 <csp_iflist_print+0x34>
    38b2:	80 c0       	rjmp	.+256    	; 0x39b4 <csp_iflist_print+0x134>
		csp_bytesize(txbuf, 25, i->txbytes);
    38b4:	ce 01       	movw	r24, r28
    38b6:	01 96       	adiw	r24, 0x01	; 1
    38b8:	5c 01       	movw	r10, r24
		csp_bytesize(rxbuf, 25, i->rxbytes);
    38ba:	7e 01       	movw	r14, r28
    38bc:	9a e1       	ldi	r25, 0x1A	; 26
    38be:	e9 0e       	add	r14, r25
    38c0:	f1 1c       	adc	r15, r1
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    38c2:	0f 2e       	mov	r0, r31
    38c4:	f3 ef       	ldi	r31, 0xF3	; 243
    38c6:	cf 2e       	mov	r12, r31
    38c8:	f8 e0       	ldi	r31, 0x08	; 8
    38ca:	df 2e       	mov	r13, r31
    38cc:	f0 2d       	mov	r31, r0
void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
		csp_bytesize(txbuf, 25, i->txbytes);
    38ce:	f8 01       	movw	r30, r16
    38d0:	25 a1       	ldd	r18, Z+37	; 0x25
    38d2:	36 a1       	ldd	r19, Z+38	; 0x26
    38d4:	47 a1       	ldd	r20, Z+39	; 0x27
    38d6:	50 a5       	ldd	r21, Z+40	; 0x28
    38d8:	69 e1       	ldi	r22, 0x19	; 25
    38da:	70 e0       	ldi	r23, 0x00	; 0
    38dc:	c5 01       	movw	r24, r10
    38de:	39 df       	rcall	.-398    	; 0x3752 <csp_bytesize>
		csp_bytesize(rxbuf, 25, i->rxbytes);
    38e0:	f8 01       	movw	r30, r16
    38e2:	21 a5       	ldd	r18, Z+41	; 0x29
    38e4:	32 a5       	ldd	r19, Z+42	; 0x2a
    38e6:	43 a5       	ldd	r20, Z+43	; 0x2b
    38e8:	54 a5       	ldd	r21, Z+44	; 0x2c
    38ea:	69 e1       	ldi	r22, 0x19	; 25
    38ec:	70 e0       	ldi	r23, 0x00	; 0
    38ee:	c7 01       	movw	r24, r14
    38f0:	30 df       	rcall	.-416    	; 0x3752 <csp_bytesize>
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    38f2:	ff 92       	push	r15
    38f4:	ef 92       	push	r14
    38f6:	f8 01       	movw	r30, r16
    38f8:	84 a5       	ldd	r24, Z+44	; 0x2c
    38fa:	8f 93       	push	r24
    38fc:	83 a5       	ldd	r24, Z+43	; 0x2b
    38fe:	8f 93       	push	r24
    3900:	82 a5       	ldd	r24, Z+42	; 0x2a
    3902:	8f 93       	push	r24
    3904:	81 a5       	ldd	r24, Z+41	; 0x29
    3906:	8f 93       	push	r24
    3908:	bf 92       	push	r11
    390a:	af 92       	push	r10
    390c:	80 a5       	ldd	r24, Z+40	; 0x28
    390e:	8f 93       	push	r24
    3910:	87 a1       	ldd	r24, Z+39	; 0x27
    3912:	8f 93       	push	r24
    3914:	86 a1       	ldd	r24, Z+38	; 0x26
    3916:	8f 93       	push	r24
    3918:	85 a1       	ldd	r24, Z+37	; 0x25
    391a:	8f 93       	push	r24
    391c:	84 a1       	ldd	r24, Z+36	; 0x24
    391e:	8f 93       	push	r24
    3920:	83 a1       	ldd	r24, Z+35	; 0x23
    3922:	8f 93       	push	r24
    3924:	82 a1       	ldd	r24, Z+34	; 0x22
    3926:	8f 93       	push	r24
    3928:	81 a1       	ldd	r24, Z+33	; 0x21
    392a:	8f 93       	push	r24
    392c:	80 a1       	ldd	r24, Z+32	; 0x20
    392e:	8f 93       	push	r24
    3930:	87 8d       	ldd	r24, Z+31	; 0x1f
    3932:	8f 93       	push	r24
    3934:	86 8d       	ldd	r24, Z+30	; 0x1e
    3936:	8f 93       	push	r24
    3938:	85 8d       	ldd	r24, Z+29	; 0x1d
    393a:	8f 93       	push	r24
    393c:	84 8d       	ldd	r24, Z+28	; 0x1c
    393e:	8f 93       	push	r24
    3940:	83 8d       	ldd	r24, Z+27	; 0x1b
    3942:	8f 93       	push	r24
    3944:	82 8d       	ldd	r24, Z+26	; 0x1a
    3946:	8f 93       	push	r24
    3948:	81 8d       	ldd	r24, Z+25	; 0x19
    394a:	8f 93       	push	r24
    394c:	80 8d       	ldd	r24, Z+24	; 0x18
    394e:	8f 93       	push	r24
    3950:	87 89       	ldd	r24, Z+23	; 0x17
    3952:	8f 93       	push	r24
    3954:	86 89       	ldd	r24, Z+22	; 0x16
    3956:	8f 93       	push	r24
    3958:	85 89       	ldd	r24, Z+21	; 0x15
    395a:	8f 93       	push	r24
    395c:	84 89       	ldd	r24, Z+20	; 0x14
    395e:	8f 93       	push	r24
    3960:	83 89       	ldd	r24, Z+19	; 0x13
    3962:	8f 93       	push	r24
    3964:	82 89       	ldd	r24, Z+18	; 0x12
    3966:	8f 93       	push	r24
    3968:	81 89       	ldd	r24, Z+17	; 0x11
    396a:	8f 93       	push	r24
    396c:	80 89       	ldd	r24, Z+16	; 0x10
    396e:	8f 93       	push	r24
    3970:	87 85       	ldd	r24, Z+15	; 0x0f
    3972:	8f 93       	push	r24
    3974:	86 85       	ldd	r24, Z+14	; 0x0e
    3976:	8f 93       	push	r24
    3978:	85 85       	ldd	r24, Z+13	; 0x0d
    397a:	8f 93       	push	r24
    397c:	84 85       	ldd	r24, Z+12	; 0x0c
    397e:	8f 93       	push	r24
    3980:	83 85       	ldd	r24, Z+11	; 0x0b
    3982:	8f 93       	push	r24
    3984:	82 85       	ldd	r24, Z+10	; 0x0a
    3986:	8f 93       	push	r24
    3988:	81 85       	ldd	r24, Z+9	; 0x09
    398a:	8f 93       	push	r24
    398c:	81 81       	ldd	r24, Z+1	; 0x01
    398e:	8f 93       	push	r24
    3990:	80 81       	ld	r24, Z
    3992:	8f 93       	push	r24
    3994:	df 92       	push	r13
    3996:	cf 92       	push	r12
    3998:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
		       "        drop: %05"PRIu32" autherr: %05"PRIu32 " frame: %05"PRIu32"\r\n"
		       "        txb: %"PRIu32" (%s) rxb: %"PRIu32" (%s)\r\n\r\n",
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
    399c:	f8 01       	movw	r30, r16
    399e:	01 a9       	ldd	r16, Z+49	; 0x31
    39a0:	12 a9       	ldd	r17, Z+50	; 0x32

void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
    39a2:	0f b6       	in	r0, 0x3f	; 63
    39a4:	f8 94       	cli
    39a6:	de bf       	out	0x3e, r29	; 62
    39a8:	0f be       	out	0x3f, r0	; 63
    39aa:	cd bf       	out	0x3d, r28	; 61
    39ac:	01 15       	cp	r16, r1
    39ae:	11 05       	cpc	r17, r1
    39b0:	09 f0       	breq	.+2      	; 0x39b4 <csp_iflist_print+0x134>
    39b2:	8d cf       	rjmp	.-230    	; 0x38ce <csp_iflist_print+0x4e>
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
	}

}
    39b4:	e2 96       	adiw	r28, 0x32	; 50
    39b6:	0f b6       	in	r0, 0x3f	; 63
    39b8:	f8 94       	cli
    39ba:	de bf       	out	0x3e, r29	; 62
    39bc:	0f be       	out	0x3f, r0	; 63
    39be:	cd bf       	out	0x3d, r28	; 61
    39c0:	df 91       	pop	r29
    39c2:	cf 91       	pop	r28
    39c4:	1f 91       	pop	r17
    39c6:	0f 91       	pop	r16
    39c8:	ff 90       	pop	r15
    39ca:	ef 90       	pop	r14
    39cc:	df 90       	pop	r13
    39ce:	cf 90       	pop	r12
    39d0:	bf 90       	pop	r11
    39d2:	af 90       	pop	r10
    39d4:	08 95       	ret

000039d6 <csp_can_pbuf_free>:
{
	buf->last_used = csp_get_ms();
}

static int csp_can_pbuf_free(csp_can_pbuf_element_t *buf)
{
    39d6:	cf 93       	push	r28
    39d8:	df 93       	push	r29
    39da:	ec 01       	movw	r28, r24
	/* Free CSP packet */
	if (buf->packet != NULL)
    39dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    39de:	9b 85       	ldd	r25, Y+11	; 0x0b
    39e0:	00 97       	sbiw	r24, 0x00	; 0
    39e2:	09 f0       	breq	.+2      	; 0x39e6 <csp_can_pbuf_free+0x10>
		csp_buffer_free(buf->packet);
    39e4:	9a d9       	rcall	.-3276   	; 0x2d1a <csp_buffer_free>

	/* Mark buffer element free */
	buf->packet = NULL;
    39e6:	1b 86       	std	Y+11, r1	; 0x0b
    39e8:	1a 86       	std	Y+10, r1	; 0x0a
	buf->state = BUF_FREE;
    39ea:	1c 86       	std	Y+12, r1	; 0x0c
	buf->rx_count = 0;
    39ec:	19 82       	std	Y+1, r1	; 0x01
    39ee:	18 82       	st	Y, r1
	buf->cfpid = 0;
    39f0:	1e 82       	std	Y+6, r1	; 0x06
    39f2:	1f 82       	std	Y+7, r1	; 0x07
    39f4:	18 86       	std	Y+8, r1	; 0x08
    39f6:	19 86       	std	Y+9, r1	; 0x09
	buf->last_used = 0;
    39f8:	1d 86       	std	Y+13, r1	; 0x0d
    39fa:	1e 86       	std	Y+14, r1	; 0x0e
    39fc:	1f 86       	std	Y+15, r1	; 0x0f
    39fe:	18 8a       	std	Y+16, r1	; 0x10
	buf->remain = 0;
    3a00:	1a 82       	std	Y+2, r1	; 0x02
    3a02:	1b 82       	std	Y+3, r1	; 0x03
    3a04:	1c 82       	std	Y+4, r1	; 0x04
    3a06:	1d 82       	std	Y+5, r1	; 0x05

	return CSP_ERR_NONE;
}
    3a08:	80 e0       	ldi	r24, 0x00	; 0
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	df 91       	pop	r29
    3a0e:	cf 91       	pop	r28
    3a10:	08 95       	ret

00003a12 <csp_can_tx>:

	return CSP_ERR_NONE;
}

static int csp_can_tx(csp_iface_t *interface, csp_packet_t *packet, uint32_t timeout)
{
    3a12:	2f 92       	push	r2
    3a14:	3f 92       	push	r3
    3a16:	4f 92       	push	r4
    3a18:	5f 92       	push	r5
    3a1a:	6f 92       	push	r6
    3a1c:	7f 92       	push	r7
    3a1e:	8f 92       	push	r8
    3a20:	9f 92       	push	r9
    3a22:	af 92       	push	r10
    3a24:	bf 92       	push	r11
    3a26:	cf 92       	push	r12
    3a28:	df 92       	push	r13
    3a2a:	ef 92       	push	r14
    3a2c:	ff 92       	push	r15
    3a2e:	0f 93       	push	r16
    3a30:	1f 93       	push	r17
    3a32:	cf 93       	push	r28
    3a34:	df 93       	push	r29
    3a36:	cd b7       	in	r28, 0x3d	; 61
    3a38:	de b7       	in	r29, 0x3e	; 62
    3a3a:	60 97       	sbiw	r28, 0x10	; 16
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	de bf       	out	0x3e, r29	; 62
    3a42:	0f be       	out	0x3f, r0	; 63
    3a44:	cd bf       	out	0x3d, r28	; 61
    3a46:	7a 87       	std	Y+10, r23	; 0x0a
    3a48:	69 87       	std	Y+9, r22	; 0x09
}

static int csp_can_id_get(void)
{
	int id;
	if (csp_bin_sem_wait(&csp_can_id_sem, 1000) != CSP_SEMAPHORE_OK)
    3a4a:	48 ee       	ldi	r20, 0xE8	; 232
    3a4c:	53 e0       	ldi	r21, 0x03	; 3
    3a4e:	60 e0       	ldi	r22, 0x00	; 0
    3a50:	70 e0       	ldi	r23, 0x00	; 0
    3a52:	81 ea       	ldi	r24, 0xA1	; 161
    3a54:	95 e0       	ldi	r25, 0x05	; 5
    3a56:	0e 94 8c 29 	call	0x5318	; 0x5318 <csp_bin_sem_wait>
    3a5a:	01 97       	sbiw	r24, 0x01	; 1
    3a5c:	89 f4       	brne	.+34     	; 0x3a80 <csp_can_tx+0x6e>
		return CSP_ERR_TIMEDOUT;
	id = csp_can_id++;
    3a5e:	80 90 a3 05 	lds	r8, 0x05A3	; 0x8005a3 <csp_can_id>
    3a62:	90 90 a4 05 	lds	r9, 0x05A4	; 0x8005a4 <csp_can_id+0x1>
	csp_can_id = csp_can_id & ((1 << CFP_ID_SIZE) - 1);
    3a66:	c4 01       	movw	r24, r8
    3a68:	01 96       	adiw	r24, 0x01	; 1
    3a6a:	93 70       	andi	r25, 0x03	; 3
    3a6c:	90 93 a4 05 	sts	0x05A4, r25	; 0x8005a4 <csp_can_id+0x1>
    3a70:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <csp_can_id>
	csp_bin_sem_post(&csp_can_id_sem);
    3a74:	81 ea       	ldi	r24, 0xA1	; 161
    3a76:	95 e0       	ldi	r25, 0x05	; 5
    3a78:	0e 94 c7 29 	call	0x538e	; 0x538e <csp_bin_sem_post>
	uint8_t bytes, overhead, avail, dest;
	uint8_t frame_buf[8];

	/* Get CFP identification number */
	int ident = csp_can_id_get();
	if (ident < 0) {
    3a7c:	99 20       	and	r9, r9
    3a7e:	7c f4       	brge	.+30     	; 0x3a9e <csp_can_tx+0x8c>
		csp_log_warn("Failed to get CFP identification number");
    3a80:	8d ec       	ldi	r24, 0xCD	; 205
    3a82:	99 e0       	ldi	r25, 0x09	; 9
    3a84:	9f 93       	push	r25
    3a86:	8f 93       	push	r24
    3a88:	81 e0       	ldi	r24, 0x01	; 1
    3a8a:	8f 93       	push	r24
    3a8c:	79 dd       	rcall	.-1294   	; 0x3580 <do_csp_debug>
		return CSP_ERR_INVAL;
    3a8e:	0f 90       	pop	r0
    3a90:	0f 90       	pop	r0
    3a92:	0f 90       	pop	r0
    3a94:	4e ef       	ldi	r20, 0xFE	; 254
    3a96:	5f ef       	ldi	r21, 0xFF	; 255
    3a98:	58 8b       	std	Y+16, r21	; 0x10
    3a9a:	4f 87       	std	Y+15, r20	; 0x0f
    3a9c:	15 c1       	rjmp	.+554    	; 0x3cc8 <csp_can_tx+0x2b6>

	/* Calculate overhead */
	overhead = sizeof(csp_id_t) + sizeof(uint16_t);

	/* Insert destination node mac address into the CFP destination field */
	dest = csp_rtable_find_mac(packet->id.dst);
    3a9e:	a9 85       	ldd	r26, Y+9	; 0x09
    3aa0:	ba 85       	ldd	r27, Y+10	; 0x0a
    3aa2:	1c 96       	adiw	r26, 0x0c	; 12
    3aa4:	9c 91       	ld	r25, X
    3aa6:	1c 97       	sbiw	r26, 0x0c	; 12
    3aa8:	92 95       	swap	r25
    3aaa:	9f 70       	andi	r25, 0x0F	; 15
    3aac:	1d 96       	adiw	r26, 0x0d	; 13
    3aae:	8c 91       	ld	r24, X
    3ab0:	81 70       	andi	r24, 0x01	; 1
    3ab2:	82 95       	swap	r24
    3ab4:	80 7f       	andi	r24, 0xF0	; 240
    3ab6:	89 2b       	or	r24, r25
    3ab8:	0e 94 0b 29 	call	0x5216	; 0x5216 <csp_rtable_find_mac>
	if (dest == CSP_NODE_MAC)
    3abc:	8f 3f       	cpi	r24, 0xFF	; 255
    3abe:	59 f4       	brne	.+22     	; 0x3ad6 <csp_can_tx+0xc4>
		dest = packet->id.dst;
    3ac0:	e9 85       	ldd	r30, Y+9	; 0x09
    3ac2:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ac4:	84 85       	ldd	r24, Z+12	; 0x0c
    3ac6:	98 2f       	mov	r25, r24
    3ac8:	92 95       	swap	r25
    3aca:	9f 70       	andi	r25, 0x0F	; 15
    3acc:	85 85       	ldd	r24, Z+13	; 0x0d
    3ace:	81 70       	andi	r24, 0x01	; 1
    3ad0:	82 95       	swap	r24
    3ad2:	80 7f       	andi	r24, 0xF0	; 240
    3ad4:	89 2b       	or	r24, r25

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
	id |= CFP_MAKE_DST(dest);
    3ad6:	8f 71       	andi	r24, 0x1F	; 31
    3ad8:	c8 2e       	mov	r12, r24
    3ada:	d1 2c       	mov	r13, r1
    3adc:	e1 2c       	mov	r14, r1
    3ade:	f1 2c       	mov	r15, r1
    3ae0:	0b 2e       	mov	r0, r27
    3ae2:	b3 e1       	ldi	r27, 0x13	; 19
    3ae4:	cc 0c       	add	r12, r12
    3ae6:	dd 1c       	adc	r13, r13
    3ae8:	ee 1c       	adc	r14, r14
    3aea:	ff 1c       	adc	r15, r15
    3aec:	ba 95       	dec	r27
    3aee:	d1 f7       	brne	.-12     	; 0x3ae4 <csp_can_tx+0xd2>
    3af0:	b0 2d       	mov	r27, r0
	id |= CFP_MAKE_ID(ident);
    3af2:	f3 e0       	ldi	r31, 0x03	; 3
    3af4:	9f 22       	and	r9, r31
    3af6:	09 2c       	mov	r0, r9
    3af8:	00 0c       	add	r0, r0
    3afa:	aa 08       	sbc	r10, r10
    3afc:	bb 08       	sbc	r11, r11
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    3afe:	a9 85       	ldd	r26, Y+9	; 0x09
    3b00:	ba 85       	ldd	r27, Y+10	; 0x0a
    3b02:	18 96       	adiw	r26, 0x08	; 8
    3b04:	2d 91       	ld	r18, X+
    3b06:	3c 91       	ld	r19, X
    3b08:	19 97       	sbiw	r26, 0x09	; 9
    3b0a:	c9 01       	movw	r24, r18
    3b0c:	05 96       	adiw	r24, 0x05	; 5
    3b0e:	96 95       	lsr	r25
    3b10:	87 95       	ror	r24
    3b12:	96 95       	lsr	r25
    3b14:	87 95       	ror	r24
    3b16:	96 95       	lsr	r25
    3b18:	87 95       	ror	r24
    3b1a:	90 e0       	ldi	r25, 0x00	; 0
    3b1c:	a0 e0       	ldi	r26, 0x00	; 0
    3b1e:	b0 e0       	ldi	r27, 0x00	; 0
    3b20:	07 2e       	mov	r0, r23
    3b22:	7a e0       	ldi	r23, 0x0A	; 10
    3b24:	88 0f       	add	r24, r24
    3b26:	99 1f       	adc	r25, r25
    3b28:	aa 1f       	adc	r26, r26
    3b2a:	bb 1f       	adc	r27, r27
    3b2c:	7a 95       	dec	r23
    3b2e:	d1 f7       	brne	.-12     	; 0x3b24 <csp_can_tx+0x112>
    3b30:	70 2d       	mov	r23, r0
	if (dest == CSP_NODE_MAC)
		dest = packet->id.dst;

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
    3b32:	e9 85       	ldd	r30, Y+9	; 0x09
    3b34:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b36:	45 85       	ldd	r20, Z+13	; 0x0d
    3b38:	46 95       	lsr	r20
    3b3a:	4f 71       	andi	r20, 0x1F	; 31
	id |= CFP_MAKE_DST(dest);
	id |= CFP_MAKE_ID(ident);
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    3b3c:	24 01       	movw	r4, r8
    3b3e:	35 01       	movw	r6, r10
    3b40:	74 2a       	or	r7, r20
    3b42:	84 29       	or	r24, r4
    3b44:	95 29       	or	r25, r5
    3b46:	a6 29       	or	r26, r6
    3b48:	b7 29       	or	r27, r7
    3b4a:	2c 01       	movw	r4, r24
    3b4c:	3d 01       	movw	r6, r26
    3b4e:	4c 28       	or	r4, r12
    3b50:	5d 28       	or	r5, r13
    3b52:	6e 28       	or	r6, r14
    3b54:	7f 28       	or	r7, r15
    3b56:	4b 86       	std	Y+11, r4	; 0x0b
    3b58:	5c 86       	std	Y+12, r5	; 0x0c
    3b5a:	6d 86       	std	Y+13, r6	; 0x0d
    3b5c:	7e 86       	std	Y+14, r7	; 0x0e

	/* Calculate first frame data bytes */
	avail = 8 - overhead;
	bytes = (packet->length <= avail) ? packet->length : avail;
    3b5e:	39 01       	movw	r6, r18
    3b60:	23 30       	cpi	r18, 0x03	; 3
    3b62:	31 05       	cpc	r19, r1
    3b64:	20 f0       	brcs	.+8      	; 0x3b6e <csp_can_tx+0x15c>
    3b66:	68 94       	set
    3b68:	66 24       	eor	r6, r6
    3b6a:	61 f8       	bld	r6, 1
    3b6c:	71 2c       	mov	r7, r1

	/* Copy CSP headers and data */
	uint32_t csp_id_be = csp_hton32(packet->id.ext);
    3b6e:	a9 85       	ldd	r26, Y+9	; 0x09
    3b70:	ba 85       	ldd	r27, Y+10	; 0x0a
    3b72:	1a 96       	adiw	r26, 0x0a	; 10
    3b74:	6d 91       	ld	r22, X+
    3b76:	7d 91       	ld	r23, X+
    3b78:	8d 91       	ld	r24, X+
    3b7a:	9c 91       	ld	r25, X
    3b7c:	1d 97       	sbiw	r26, 0x0d	; 13
    3b7e:	7f dd       	rcall	.-1282   	; 0x367e <csp_hton32>
    3b80:	1b 01       	movw	r2, r22
    3b82:	2c 01       	movw	r4, r24
	uint16_t csp_length_be = csp_hton16(packet->length);
    3b84:	e9 85       	ldd	r30, Y+9	; 0x09
    3b86:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b88:	80 85       	ldd	r24, Z+8	; 0x08
    3b8a:	91 85       	ldd	r25, Z+9	; 0x09
    3b8c:	70 dd       	rcall	.-1312   	; 0x366e <csp_hton16>

	memcpy(frame_buf, &csp_id_be, sizeof(csp_id_be));
    3b8e:	29 82       	std	Y+1, r2	; 0x01
    3b90:	3a 82       	std	Y+2, r3	; 0x02
    3b92:	4b 82       	std	Y+3, r4	; 0x03
    3b94:	5c 82       	std	Y+4, r5	; 0x04
	memcpy(frame_buf + sizeof(csp_id_be), &csp_length_be, sizeof(csp_length_be));
    3b96:	9e 83       	std	Y+6, r25	; 0x06
    3b98:	8d 83       	std	Y+5, r24	; 0x05
    3b9a:	83 01       	movw	r16, r6
    3b9c:	11 27       	eor	r17, r17
	memcpy(frame_buf + overhead, packet->data, bytes);
    3b9e:	29 84       	ldd	r2, Y+9	; 0x09
    3ba0:	3a 84       	ldd	r3, Y+10	; 0x0a
    3ba2:	fe e0       	ldi	r31, 0x0E	; 14
    3ba4:	2f 0e       	add	r2, r31
    3ba6:	31 1c       	adc	r3, r1
    3ba8:	a8 01       	movw	r20, r16
    3baa:	b1 01       	movw	r22, r2
    3bac:	ce 01       	movw	r24, r28
    3bae:	07 96       	adiw	r24, 0x07	; 7
    3bb0:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>

	/* Increment tx counter */
	tx_count = bytes;

	/* Send first frame */
	if (can_send(id, frame_buf, overhead + bytes)) {
    3bb4:	26 e0       	ldi	r18, 0x06	; 6
    3bb6:	26 0d       	add	r18, r6
    3bb8:	ae 01       	movw	r20, r28
    3bba:	4f 5f       	subi	r20, 0xFF	; 255
    3bbc:	5f 4f       	sbci	r21, 0xFF	; 255
    3bbe:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bc0:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bc2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bc4:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bc6:	0e 94 16 0a 	call	0x142c	; 0x142c <can_send>
    3bca:	98 8b       	std	Y+16, r25	; 0x10
    3bcc:	8f 87       	std	Y+15, r24	; 0x0f
    3bce:	89 2b       	or	r24, r25
    3bd0:	09 f4       	brne	.+2      	; 0x3bd4 <csp_can_tx+0x1c2>
    3bd2:	6e c0       	rjmp	.+220    	; 0x3cb0 <csp_can_tx+0x29e>
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
    3bd4:	86 ea       	ldi	r24, 0xA6	; 166
    3bd6:	99 e0       	ldi	r25, 0x09	; 9
    3bd8:	9f 93       	push	r25
    3bda:	8f 93       	push	r24
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	8f 93       	push	r24
    3be0:	cf dc       	rcall	.-1634   	; 0x3580 <do_csp_debug>
		return CSP_ERR_DRIVER;
    3be2:	0f 90       	pop	r0
    3be4:	0f 90       	pop	r0
    3be6:	0f 90       	pop	r0
    3be8:	45 ef       	ldi	r20, 0xF5	; 245
    3bea:	5f ef       	ldi	r21, 0xFF	; 255
    3bec:	58 8b       	std	Y+16, r21	; 0x10
    3bee:	4f 87       	std	Y+15, r20	; 0x0f
    3bf0:	6b c0       	rjmp	.+214    	; 0x3cc8 <csp_can_tx+0x2b6>
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
		/* Calculate frame data bytes */
		bytes = (packet->length - tx_count >= 8) ? 8 : packet->length - tx_count;
    3bf2:	80 1b       	sub	r24, r16
    3bf4:	91 0b       	sbc	r25, r17
    3bf6:	fc 01       	movw	r30, r24
    3bf8:	89 30       	cpi	r24, 0x09	; 9
    3bfa:	91 05       	cpc	r25, r1
    3bfc:	10 f0       	brcs	.+4      	; 0x3c02 <csp_can_tx+0x1f0>
    3bfe:	e8 e0       	ldi	r30, 0x08	; 8
    3c00:	f0 e0       	ldi	r31, 0x00	; 0

		/* Prepare identifier */
		can_id_t id = 0;
		id |= CFP_MAKE_SRC(packet->id.src);
    3c02:	a9 85       	ldd	r26, Y+9	; 0x09
    3c04:	ba 85       	ldd	r27, Y+10	; 0x0a
    3c06:	1d 96       	adiw	r26, 0x0d	; 13
    3c08:	2c 91       	ld	r18, X
    3c0a:	26 95       	lsr	r18
    3c0c:	2f 71       	andi	r18, 0x1F	; 31
		id |= CFP_MAKE_DST(dest);
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
    3c0e:	24 01       	movw	r4, r8
    3c10:	35 01       	movw	r6, r10
    3c12:	72 2a       	or	r7, r18
    3c14:	68 94       	set
    3c16:	62 f8       	bld	r6, 2
    3c18:	4c 28       	or	r4, r12
    3c1a:	5d 28       	or	r5, r13
    3c1c:	6e 28       	or	r6, r14
    3c1e:	7f 28       	or	r7, r15
    3c20:	9f 01       	movw	r18, r30
    3c22:	33 27       	eor	r19, r19
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    3c24:	a8 01       	movw	r20, r16
    3c26:	42 0f       	add	r20, r18
    3c28:	53 1f       	adc	r21, r19
    3c2a:	5c 87       	std	Y+12, r21	; 0x0c
    3c2c:	4b 87       	std	Y+11, r20	; 0x0b

		/* Send frame */
		if (can_send(id, packet->data + tx_count - bytes, bytes)) {
    3c2e:	a1 01       	movw	r20, r2
    3c30:	40 0f       	add	r20, r16
    3c32:	51 1f       	adc	r21, r17
    3c34:	07 96       	adiw	r24, 0x07	; 7
    3c36:	82 1b       	sub	r24, r18
    3c38:	93 0b       	sbc	r25, r19
    3c3a:	96 95       	lsr	r25
    3c3c:	87 95       	ror	r24
    3c3e:	96 95       	lsr	r25
    3c40:	87 95       	ror	r24
    3c42:	96 95       	lsr	r25
    3c44:	87 95       	ror	r24
    3c46:	90 e0       	ldi	r25, 0x00	; 0
    3c48:	a0 e0       	ldi	r26, 0x00	; 0
    3c4a:	b0 e0       	ldi	r27, 0x00	; 0
    3c4c:	07 2e       	mov	r0, r23
    3c4e:	7a e0       	ldi	r23, 0x0A	; 10
    3c50:	88 0f       	add	r24, r24
    3c52:	99 1f       	adc	r25, r25
    3c54:	aa 1f       	adc	r26, r26
    3c56:	bb 1f       	adc	r27, r27
    3c58:	7a 95       	dec	r23
    3c5a:	d1 f7       	brne	.-12     	; 0x3c50 <csp_can_tx+0x23e>
    3c5c:	70 2d       	mov	r23, r0
    3c5e:	bc 01       	movw	r22, r24
    3c60:	cd 01       	movw	r24, r26
    3c62:	64 29       	or	r22, r4
    3c64:	75 29       	or	r23, r5
    3c66:	86 29       	or	r24, r6
    3c68:	97 29       	or	r25, r7
    3c6a:	2e 2f       	mov	r18, r30
    3c6c:	0e 94 16 0a 	call	0x142c	; 0x142c <can_send>
    3c70:	89 2b       	or	r24, r25
    3c72:	e1 f0       	breq	.+56     	; 0x3cac <csp_can_tx+0x29a>
			csp_log_warn("Failed to send CAN frame in Tx callback");
    3c74:	8e e7       	ldi	r24, 0x7E	; 126
    3c76:	99 e0       	ldi	r25, 0x09	; 9
    3c78:	9f 93       	push	r25
    3c7a:	8f 93       	push	r24
    3c7c:	81 e0       	ldi	r24, 0x01	; 1
    3c7e:	8f 93       	push	r24
    3c80:	7f dc       	rcall	.-1794   	; 0x3580 <do_csp_debug>
			csp_if_can.tx_error++;
    3c82:	e2 e1       	ldi	r30, 0x12	; 18
    3c84:	f2 e0       	ldi	r31, 0x02	; 2
    3c86:	81 89       	ldd	r24, Z+17	; 0x11
    3c88:	92 89       	ldd	r25, Z+18	; 0x12
    3c8a:	a3 89       	ldd	r26, Z+19	; 0x13
    3c8c:	b4 89       	ldd	r27, Z+20	; 0x14
    3c8e:	01 96       	adiw	r24, 0x01	; 1
    3c90:	a1 1d       	adc	r26, r1
    3c92:	b1 1d       	adc	r27, r1
    3c94:	81 8b       	std	Z+17, r24	; 0x11
    3c96:	92 8b       	std	Z+18, r25	; 0x12
    3c98:	a3 8b       	std	Z+19, r26	; 0x13
    3c9a:	b4 8b       	std	Z+20, r27	; 0x14
			return CSP_ERR_DRIVER;
    3c9c:	0f 90       	pop	r0
    3c9e:	0f 90       	pop	r0
    3ca0:	0f 90       	pop	r0
    3ca2:	65 ef       	ldi	r22, 0xF5	; 245
    3ca4:	7f ef       	ldi	r23, 0xFF	; 255
    3ca6:	78 8b       	std	Y+16, r23	; 0x10
    3ca8:	6f 87       	std	Y+15, r22	; 0x0f
    3caa:	0e c0       	rjmp	.+28     	; 0x3cc8 <csp_can_tx+0x2b6>
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    3cac:	0b 85       	ldd	r16, Y+11	; 0x0b
    3cae:	1c 85       	ldd	r17, Y+12	; 0x0c
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
		return CSP_ERR_DRIVER;
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
    3cb0:	a9 85       	ldd	r26, Y+9	; 0x09
    3cb2:	ba 85       	ldd	r27, Y+10	; 0x0a
    3cb4:	18 96       	adiw	r26, 0x08	; 8
    3cb6:	8d 91       	ld	r24, X+
    3cb8:	9c 91       	ld	r25, X
    3cba:	19 97       	sbiw	r26, 0x09	; 9
    3cbc:	08 17       	cp	r16, r24
    3cbe:	19 07       	cpc	r17, r25
    3cc0:	08 f4       	brcc	.+2      	; 0x3cc4 <csp_can_tx+0x2b2>
			csp_if_can.tx_error++;
			return CSP_ERR_DRIVER;
		}
	}

	csp_buffer_free(packet);
    3cc2:	97 cf       	rjmp	.-210    	; 0x3bf2 <csp_can_tx+0x1e0>
    3cc4:	cd 01       	movw	r24, r26
    3cc6:	29 d8       	rcall	.-4014   	; 0x2d1a <csp_buffer_free>

	return CSP_ERR_NONE;
}
    3cc8:	8f 85       	ldd	r24, Y+15	; 0x0f
    3cca:	98 89       	ldd	r25, Y+16	; 0x10
    3ccc:	60 96       	adiw	r28, 0x10	; 16
    3cce:	0f b6       	in	r0, 0x3f	; 63
    3cd0:	f8 94       	cli
    3cd2:	de bf       	out	0x3e, r29	; 62
    3cd4:	0f be       	out	0x3f, r0	; 63
    3cd6:	cd bf       	out	0x3d, r28	; 61
    3cd8:	df 91       	pop	r29
    3cda:	cf 91       	pop	r28
    3cdc:	1f 91       	pop	r17
    3cde:	0f 91       	pop	r16
    3ce0:	ff 90       	pop	r15
    3ce2:	ef 90       	pop	r14
    3ce4:	df 90       	pop	r13
    3ce6:	cf 90       	pop	r12
    3ce8:	bf 90       	pop	r11
    3cea:	af 90       	pop	r10
    3cec:	9f 90       	pop	r9
    3cee:	8f 90       	pop	r8
    3cf0:	7f 90       	pop	r7
    3cf2:	6f 90       	pop	r6
    3cf4:	5f 90       	pop	r5
    3cf6:	4f 90       	pop	r4
    3cf8:	3f 90       	pop	r3
    3cfa:	2f 90       	pop	r2
    3cfc:	08 95       	ret

00003cfe <csp_can_rx_task>:

	return CSP_ERR_NONE;
}

static CSP_DEFINE_TASK(csp_can_rx_task)
{
    3cfe:	cf 93       	push	r28
    3d00:	df 93       	push	r29
    3d02:	cd b7       	in	r28, 0x3d	; 61
    3d04:	de b7       	in	r29, 0x3e	; 62
    3d06:	2d 97       	sbiw	r28, 0x0d	; 13
    3d08:	0f b6       	in	r0, 0x3f	; 63
    3d0a:	f8 94       	cli
    3d0c:	de bf       	out	0x3e, r29	; 62
    3d0e:	0f be       	out	0x3f, r0	; 63
    3d10:	cd bf       	out	0x3d, r28	; 61
	int ret;
	can_frame_t frame;

	while (1) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    3d12:	0f 2e       	mov	r0, r31
    3d14:	f4 e2       	ldi	r31, 0x24	; 36
    3d16:	ef 2e       	mov	r14, r31
    3d18:	fb e0       	ldi	r31, 0x0B	; 11
    3d1a:	ff 2e       	mov	r15, r31
    3d1c:	f0 2d       	mov	r31, r0

	case CFP_MORE:

		/* Check 'remain' field match */
		if (CFP_REMAIN(id) != buf->remain - 1) {
			csp_log_error("CAN frame lost in CSP packet");
    3d1e:	0f 2e       	mov	r0, r31
    3d20:	f0 e5       	ldi	r31, 0x50	; 80
    3d22:	8f 2e       	mov	r8, r31
    3d24:	fa e0       	ldi	r31, 0x0A	; 10
    3d26:	9f 2e       	mov	r9, r31
    3d28:	f0 2d       	mov	r31, r0
		}

		/* Check for incomplete frame */
		if (buf->packet != NULL) {
			/* Reuse the buffer */
			csp_log_warn("Incomplete frame");
    3d2a:	0f 2e       	mov	r0, r31
    3d2c:	f7 e9       	ldi	r31, 0x97	; 151
    3d2e:	2f 2e       	mov	r2, r31
    3d30:	fa e0       	ldi	r31, 0x0A	; 10
    3d32:	3f 2e       	mov	r3, r31
    3d34:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    3d36:	0f 2e       	mov	r0, r31
    3d38:	f7 e0       	ldi	r31, 0x07	; 7
    3d3a:	cf 2e       	mov	r12, r31
    3d3c:	fb e0       	ldi	r31, 0x0B	; 11
    3d3e:	df 2e       	mov	r13, r31
    3d40:	f0 2d       	mov	r31, r0
{
	int ret;
	can_frame_t frame;

	while (1) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    3d42:	80 e0       	ldi	r24, 0x00	; 0
    3d44:	90 e0       	ldi	r25, 0x00	; 0
    3d46:	0e 94 b6 3b 	call	0x776c	; 0x776c <uxTaskGetStackHighWaterMark2>
    3d4a:	18 2f       	mov	r17, r24
    3d4c:	09 2f       	mov	r16, r25
    3d4e:	80 e0       	ldi	r24, 0x00	; 0
    3d50:	90 e0       	ldi	r25, 0x00	; 0
    3d52:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    3d56:	0f 93       	push	r16
    3d58:	1f 93       	push	r17
    3d5a:	9f 93       	push	r25
    3d5c:	8f 93       	push	r24
    3d5e:	ff 92       	push	r15
    3d60:	ef 92       	push	r14
    3d62:	82 e0       	ldi	r24, 0x02	; 2
    3d64:	8f 93       	push	r24
    3d66:	0c dc       	rcall	.-2024   	; 0x3580 <do_csp_debug>
		
		ret = csp_queue_dequeue(csp_can_rx_queue, &frame, 1000);
    3d68:	28 ee       	ldi	r18, 0xE8	; 232
    3d6a:	33 e0       	ldi	r19, 0x03	; 3
    3d6c:	40 e0       	ldi	r20, 0x00	; 0
    3d6e:	50 e0       	ldi	r21, 0x00	; 0
    3d70:	be 01       	movw	r22, r28
    3d72:	6f 5f       	subi	r22, 0xFF	; 255
    3d74:	7f 4f       	sbci	r23, 0xFF	; 255
    3d76:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <csp_can_rx_queue>
    3d7a:	90 91 9e 05 	lds	r25, 0x059E	; 0x80059e <csp_can_rx_queue+0x1>
    3d7e:	63 d7       	rcall	.+3782   	; 0x4c46 <csp_queue_dequeue>
		if (ret != CSP_QUEUE_OK) {
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	f8 94       	cli
    3d84:	de bf       	out	0x3e, r29	; 62
    3d86:	0f be       	out	0x3f, r0	; 63
    3d88:	cd bf       	out	0x3d, r28	; 61
    3d8a:	01 97       	sbiw	r24, 0x01	; 1
    3d8c:	89 f1       	breq	.+98     	; 0x3df0 <csp_can_rx_task+0xf2>
    3d8e:	03 ef       	ldi	r16, 0xF3	; 243
    3d90:	14 e0       	ldi	r17, 0x04	; 4
    3d92:	0f 2e       	mov	r0, r31
    3d94:	fd e9       	ldi	r31, 0x9D	; 157
    3d96:	af 2e       	mov	r10, r31
    3d98:	f5 e0       	ldi	r31, 0x05	; 5
    3d9a:	bf 2e       	mov	r11, r31
    3d9c:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    3d9e:	55 24       	eor	r5, r5
    3da0:	53 94       	inc	r5

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];

		/* Skip if not used */
		if (buf->state != BUF_USED)
    3da2:	d8 01       	movw	r26, r16
    3da4:	1c 96       	adiw	r26, 0x0c	; 12
    3da6:	8c 91       	ld	r24, X
    3da8:	81 30       	cpi	r24, 0x01	; 1
    3daa:	e1 f4       	brne	.+56     	; 0x3de4 <csp_can_rx_task+0xe6>
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
    3dac:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
    3db0:	f8 01       	movw	r30, r16
    3db2:	25 85       	ldd	r18, Z+13	; 0x0d
    3db4:	36 85       	ldd	r19, Z+14	; 0x0e
    3db6:	47 85       	ldd	r20, Z+15	; 0x0f
    3db8:	50 89       	ldd	r21, Z+16	; 0x10
    3dba:	dc 01       	movw	r26, r24
    3dbc:	cb 01       	movw	r24, r22
    3dbe:	82 1b       	sub	r24, r18
    3dc0:	93 0b       	sbc	r25, r19
    3dc2:	a4 0b       	sbc	r26, r20
    3dc4:	b5 0b       	sbc	r27, r21
    3dc6:	81 3d       	cpi	r24, 0xD1	; 209
    3dc8:	97 40       	sbci	r25, 0x07	; 7
    3dca:	a1 05       	cpc	r26, r1
    3dcc:	b1 05       	cpc	r27, r1
    3dce:	50 f0       	brcs	.+20     	; 0x3de4 <csp_can_rx_task+0xe6>
			csp_log_warn("CAN Buffer element timed out");
    3dd0:	df 92       	push	r13
    3dd2:	cf 92       	push	r12
    3dd4:	5f 92       	push	r5
    3dd6:	d4 db       	rcall	.-2136   	; 0x3580 <do_csp_debug>
			/* Recycle packet buffer */
			csp_can_pbuf_free(buf);
    3dd8:	80 2f       	mov	r24, r16
    3dda:	91 2f       	mov	r25, r17
    3ddc:	fc dd       	rcall	.-1032   	; 0x39d6 <csp_can_pbuf_free>
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	0f 90       	pop	r0
    3de4:	0f 5e       	subi	r16, 0xEF	; 239
    3de6:	1f 4f       	sbci	r17, 0xFF	; 255
    3de8:	a0 16       	cp	r10, r16
static void csp_can_pbuf_cleanup(void)
{
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    3dea:	b1 06       	cpc	r11, r17
    3dec:	d1 f6       	brne	.-76     	; 0x3da2 <csp_can_rx_task+0xa4>
    3dee:	a9 cf       	rjmp	.-174    	; 0x3d42 <csp_can_rx_task+0x44>
    3df0:	49 80       	ldd	r4, Y+1	; 0x01
static int csp_can_process_frame(can_frame_t *frame)
{
	csp_can_pbuf_element_t *buf;
	uint8_t offset;

	can_id_t id = frame->id;
    3df2:	5a 80       	ldd	r5, Y+2	; 0x02
    3df4:	6b 80       	ldd	r6, Y+3	; 0x03
    3df6:	7c 80       	ldd	r7, Y+4	; 0x04
    3df8:	e9 ef       	ldi	r30, 0xF9	; 249
    3dfa:	f4 e0       	ldi	r31, 0x04	; 4
    3dfc:	80 e0       	ldi	r24, 0x00	; 0
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    3dfe:	90 e0       	ldi	r25, 0x00	; 0
    3e00:	26 81       	ldd	r18, Z+6	; 0x06
		buf = &csp_can_pbuf[i];

		if ((buf->state == BUF_USED) && ((buf->cfpid & mask) == (id & mask))) {
    3e02:	21 30       	cpi	r18, 0x01	; 1
    3e04:	d1 f5       	brne	.+116    	; 0x3e7a <csp_can_rx_task+0x17c>
    3e06:	40 81       	ld	r20, Z
    3e08:	51 81       	ldd	r21, Z+1	; 0x01
    3e0a:	62 81       	ldd	r22, Z+2	; 0x02
    3e0c:	73 81       	ldd	r23, Z+3	; 0x03
    3e0e:	44 25       	eor	r20, r4
    3e10:	55 25       	eor	r21, r5
    3e12:	66 25       	eor	r22, r6
    3e14:	77 25       	eor	r23, r7
    3e16:	53 70       	andi	r21, 0x03	; 3
    3e18:	68 7f       	andi	r22, 0xF8	; 248
    3e1a:	7f 71       	andi	r23, 0x1F	; 31
    3e1c:	45 2b       	or	r20, r21
    3e1e:	46 2b       	or	r20, r22
    3e20:	47 2b       	or	r20, r23
    3e22:	59 f5       	brne	.+86     	; 0x3e7a <csp_can_rx_task+0x17c>
    3e24:	21 e1       	ldi	r18, 0x11	; 17
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    3e26:	28 9f       	mul	r18, r24
    3e28:	80 01       	movw	r16, r0
    3e2a:	29 9f       	mul	r18, r25
    3e2c:	10 0d       	add	r17, r0
    3e2e:	11 24       	eor	r1, r1
    3e30:	0d 50       	subi	r16, 0x0D	; 13
    3e32:	1b 4f       	sbci	r17, 0xFB	; 251
    3e34:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    3e38:	d8 01       	movw	r26, r16
    3e3a:	1d 96       	adiw	r26, 0x0d	; 13
    3e3c:	6d 93       	st	X+, r22
    3e3e:	7d 93       	st	X+, r23
    3e40:	8d 93       	st	X+, r24
    3e42:	9c 93       	st	X, r25
    3e44:	50 97       	sbiw	r26, 0x10	; 16
    3e46:	d3 01       	movw	r26, r6
	}

	/* Reset frame data offset */
	offset = 0;

	switch (CFP_TYPE(id)) {
    3e48:	c2 01       	movw	r24, r4
    3e4a:	07 2e       	mov	r0, r23
    3e4c:	72 e1       	ldi	r23, 0x12	; 18
    3e4e:	b6 95       	lsr	r27
    3e50:	a7 95       	ror	r26
    3e52:	97 95       	ror	r25
    3e54:	87 95       	ror	r24
    3e56:	7a 95       	dec	r23
    3e58:	d1 f7       	brne	.-12     	; 0x3e4e <csp_can_rx_task+0x150>
    3e5a:	70 2d       	mov	r23, r0
    3e5c:	ac 01       	movw	r20, r24
    3e5e:	bd 01       	movw	r22, r26
    3e60:	41 70       	andi	r20, 0x01	; 1
    3e62:	55 27       	eor	r21, r21
    3e64:	66 27       	eor	r22, r22
    3e66:	77 27       	eor	r23, r23
    3e68:	80 ff       	sbrs	r24, 0
    3e6a:	6d c0       	rjmp	.+218    	; 0x3f46 <csp_can_rx_task+0x248>
    3e6c:	41 30       	cpi	r20, 0x01	; 1
    3e6e:	51 05       	cpc	r21, r1
    3e70:	61 05       	cpc	r22, r1
    3e72:	71 05       	cpc	r23, r1
    3e74:	09 f4       	brne	.+2      	; 0x3e78 <csp_can_rx_task+0x17a>
    3e76:	11 c1       	rjmp	.+546    	; 0x409a <csp_can_rx_task+0x39c>
    3e78:	a2 c1       	rjmp	.+836    	; 0x41be <csp_can_rx_task+0x4c0>
    3e7a:	01 96       	adiw	r24, 0x01	; 1
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    3e7c:	71 96       	adiw	r30, 0x11	; 17
    3e7e:	8a 30       	cpi	r24, 0x0A	; 10
    3e80:	91 05       	cpc	r25, r1
    3e82:	09 f0       	breq	.+2      	; 0x3e86 <csp_can_rx_task+0x188>
    3e84:	bd cf       	rjmp	.-134    	; 0x3e00 <csp_can_rx_task+0x102>
    3e86:	62 fc       	sbrc	r6, 2
	/* Bind incoming frame to a packet buffer */
	buf = csp_can_pbuf_find(id, CFP_ID_CONN_MASK);

	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
    3e88:	46 c0       	rjmp	.+140    	; 0x3f16 <csp_can_rx_task+0x218>
    3e8a:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <csp_can_pbuf+0xc>
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    3e8e:	88 23       	and	r24, r24
    3e90:	09 f4       	brne	.+2      	; 0x3e94 <csp_can_rx_task+0x196>
    3e92:	a2 c1       	rjmp	.+836    	; 0x41d8 <csp_can_rx_task+0x4da>
    3e94:	e3 ef       	ldi	r30, 0xF3	; 243
    3e96:	f4 e0       	ldi	r31, 0x04	; 4
    3e98:	81 e0       	ldi	r24, 0x01	; 1
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    3e9a:	90 e0       	ldi	r25, 0x00	; 0
    3e9c:	25 8d       	ldd	r18, Z+29	; 0x1d
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    3e9e:	21 11       	cpse	r18, r1
    3ea0:	1d c0       	rjmp	.+58     	; 0x3edc <csp_can_rx_task+0x1de>
    3ea2:	21 e1       	ldi	r18, 0x11	; 17
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    3ea4:	28 9f       	mul	r18, r24
    3ea6:	80 01       	movw	r16, r0
    3ea8:	29 9f       	mul	r18, r25
    3eaa:	10 0d       	add	r17, r0
    3eac:	11 24       	eor	r1, r1
    3eae:	0d 50       	subi	r16, 0x0D	; 13
    3eb0:	1b 4f       	sbci	r17, 0xFB	; 251
    3eb2:	81 e0       	ldi	r24, 0x01	; 1
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    3eb4:	f8 01       	movw	r30, r16
    3eb6:	84 87       	std	Z+12, r24	; 0x0c
    3eb8:	46 82       	std	Z+6, r4	; 0x06
			buf->cfpid = id;
    3eba:	57 82       	std	Z+7, r5	; 0x07
    3ebc:	60 86       	std	Z+8, r6	; 0x08
    3ebe:	71 86       	std	Z+9, r7	; 0x09
    3ec0:	12 82       	std	Z+2, r1	; 0x02
			buf->remain = 0;
    3ec2:	13 82       	std	Z+3, r1	; 0x03
    3ec4:	14 82       	std	Z+4, r1	; 0x04
    3ec6:	15 82       	std	Z+5, r1	; 0x05
    3ec8:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    3ecc:	d8 01       	movw	r26, r16
    3ece:	1d 96       	adiw	r26, 0x0d	; 13
    3ed0:	6d 93       	st	X+, r22
    3ed2:	7d 93       	st	X+, r23
    3ed4:	8d 93       	st	X+, r24
    3ed6:	9c 93       	st	X, r25
    3ed8:	50 97       	sbiw	r26, 0x10	; 16
    3eda:	35 c0       	rjmp	.+106    	; 0x3f46 <csp_can_rx_task+0x248>
    3edc:	01 96       	adiw	r24, 0x01	; 1
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    3ede:	71 96       	adiw	r30, 0x11	; 17
    3ee0:	8a 30       	cpi	r24, 0x0A	; 10
    3ee2:	91 05       	cpc	r25, r1
    3ee4:	d9 f6       	brne	.-74     	; 0x3e9c <csp_can_rx_task+0x19e>
    3ee6:	84 ee       	ldi	r24, 0xE4	; 228
	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
			buf = csp_can_pbuf_new(id);
			if (buf == NULL) {
				csp_log_warn("No available packet buffer for CAN");
    3ee8:	9a e0       	ldi	r25, 0x0A	; 10
    3eea:	9f 93       	push	r25
    3eec:	8f 93       	push	r24
    3eee:	81 e0       	ldi	r24, 0x01	; 1
    3ef0:	8f 93       	push	r24
    3ef2:	46 db       	rcall	.-2420   	; 0x3580 <do_csp_debug>
    3ef4:	e2 e1       	ldi	r30, 0x12	; 18
				csp_if_can.rx_error++;
    3ef6:	f2 e0       	ldi	r31, 0x02	; 2
    3ef8:	85 89       	ldd	r24, Z+21	; 0x15
    3efa:	96 89       	ldd	r25, Z+22	; 0x16
    3efc:	a7 89       	ldd	r26, Z+23	; 0x17
    3efe:	b0 8d       	ldd	r27, Z+24	; 0x18
    3f00:	01 96       	adiw	r24, 0x01	; 1
    3f02:	a1 1d       	adc	r26, r1
    3f04:	b1 1d       	adc	r27, r1
    3f06:	85 8b       	std	Z+21, r24	; 0x15
    3f08:	96 8b       	std	Z+22, r25	; 0x16
    3f0a:	a7 8b       	std	Z+23, r26	; 0x17
    3f0c:	b0 8f       	std	Z+24, r27	; 0x18
    3f0e:	0f 90       	pop	r0
    3f10:	0f 90       	pop	r0
    3f12:	0f 90       	pop	r0
    3f14:	16 cf       	rjmp	.-468    	; 0x3d42 <csp_can_rx_task+0x44>
    3f16:	e3 ec       	ldi	r30, 0xC3	; 195
				return CSP_ERR_NOMEM;
			}
		} else {
			csp_log_warn("Out of order MORE frame received");
    3f18:	fa e0       	ldi	r31, 0x0A	; 10
    3f1a:	ff 93       	push	r31
    3f1c:	ef 93       	push	r30
    3f1e:	81 e0       	ldi	r24, 0x01	; 1
    3f20:	8f 93       	push	r24
    3f22:	2e db       	rcall	.-2468   	; 0x3580 <do_csp_debug>
    3f24:	e2 e1       	ldi	r30, 0x12	; 18
			csp_if_can.frame++;
    3f26:	f2 e0       	ldi	r31, 0x02	; 2
    3f28:	81 a1       	ldd	r24, Z+33	; 0x21
    3f2a:	92 a1       	ldd	r25, Z+34	; 0x22
    3f2c:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f2e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3f30:	01 96       	adiw	r24, 0x01	; 1
    3f32:	a1 1d       	adc	r26, r1
    3f34:	b1 1d       	adc	r27, r1
    3f36:	81 a3       	std	Z+33, r24	; 0x21
    3f38:	92 a3       	std	Z+34, r25	; 0x22
    3f3a:	a3 a3       	std	Z+35, r26	; 0x23
    3f3c:	b4 a3       	std	Z+36, r27	; 0x24
    3f3e:	0f 90       	pop	r0
    3f40:	0f 90       	pop	r0
    3f42:	0f 90       	pop	r0
    3f44:	fe ce       	rjmp	.-516    	; 0x3d42 <csp_can_rx_task+0x44>
    3f46:	8d 81       	ldd	r24, Y+5	; 0x05
	switch (CFP_TYPE(id)) {

	case CFP_BEGIN:

		/* Discard packet if DLC is less than CSP id + CSP length fields */
		if (frame->dlc < sizeof(csp_id_t) + sizeof(uint16_t)) {
    3f48:	86 30       	cpi	r24, 0x06	; 6
    3f4a:	d0 f4       	brcc	.+52     	; 0x3f80 <csp_can_rx_task+0x282>
    3f4c:	88 ea       	ldi	r24, 0xA8	; 168
			csp_log_warn("Short BEGIN frame received");
    3f4e:	9a e0       	ldi	r25, 0x0A	; 10
    3f50:	9f 93       	push	r25
    3f52:	8f 93       	push	r24
    3f54:	81 e0       	ldi	r24, 0x01	; 1
    3f56:	8f 93       	push	r24
    3f58:	13 db       	rcall	.-2522   	; 0x3580 <do_csp_debug>
    3f5a:	e2 e1       	ldi	r30, 0x12	; 18
			csp_if_can.frame++;
    3f5c:	f2 e0       	ldi	r31, 0x02	; 2
    3f5e:	81 a1       	ldd	r24, Z+33	; 0x21
    3f60:	92 a1       	ldd	r25, Z+34	; 0x22
    3f62:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f64:	b4 a1       	ldd	r27, Z+36	; 0x24
    3f66:	01 96       	adiw	r24, 0x01	; 1
    3f68:	a1 1d       	adc	r26, r1
    3f6a:	b1 1d       	adc	r27, r1
    3f6c:	81 a3       	std	Z+33, r24	; 0x21
    3f6e:	92 a3       	std	Z+34, r25	; 0x22
    3f70:	a3 a3       	std	Z+35, r26	; 0x23
    3f72:	b4 a3       	std	Z+36, r27	; 0x24
			csp_can_pbuf_free(buf);
    3f74:	c8 01       	movw	r24, r16
    3f76:	2f dd       	rcall	.-1442   	; 0x39d6 <csp_can_pbuf_free>
    3f78:	0f 90       	pop	r0
    3f7a:	0f 90       	pop	r0
    3f7c:	0f 90       	pop	r0
    3f7e:	e1 ce       	rjmp	.-574    	; 0x3d42 <csp_can_rx_task+0x44>
    3f80:	f8 01       	movw	r30, r16
			break;
		}

		/* Check for incomplete frame */
		if (buf->packet != NULL) {
    3f82:	82 85       	ldd	r24, Z+10	; 0x0a
    3f84:	93 85       	ldd	r25, Z+11	; 0x0b
    3f86:	89 2b       	or	r24, r25
    3f88:	b1 f0       	breq	.+44     	; 0x3fb6 <csp_can_rx_task+0x2b8>
			/* Reuse the buffer */
			csp_log_warn("Incomplete frame");
    3f8a:	3f 92       	push	r3
    3f8c:	2f 92       	push	r2
    3f8e:	81 e0       	ldi	r24, 0x01	; 1
    3f90:	8f 93       	push	r24
    3f92:	f6 da       	rcall	.-2580   	; 0x3580 <do_csp_debug>
    3f94:	e2 e1       	ldi	r30, 0x12	; 18
			csp_if_can.frame++;
    3f96:	f2 e0       	ldi	r31, 0x02	; 2
    3f98:	81 a1       	ldd	r24, Z+33	; 0x21
    3f9a:	92 a1       	ldd	r25, Z+34	; 0x22
    3f9c:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f9e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3fa0:	01 96       	adiw	r24, 0x01	; 1
    3fa2:	a1 1d       	adc	r26, r1
    3fa4:	b1 1d       	adc	r27, r1
    3fa6:	81 a3       	std	Z+33, r24	; 0x21
    3fa8:	92 a3       	std	Z+34, r25	; 0x22
    3faa:	a3 a3       	std	Z+35, r26	; 0x23
    3fac:	b4 a3       	std	Z+36, r27	; 0x24
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	0f 90       	pop	r0
    3fb4:	24 c0       	rjmp	.+72     	; 0x3ffe <csp_can_rx_task+0x300>
    3fb6:	82 e3       	ldi	r24, 0x32	; 50
		} else {
			/* Allocate memory for frame */
			buf->packet = csp_buffer_get(CSP_CAN_MTU);
    3fb8:	90 e0       	ldi	r25, 0x00	; 0
    3fba:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <csp_buffer_get>
    3fbe:	d8 01       	movw	r26, r16
    3fc0:	1b 96       	adiw	r26, 0x0b	; 11
    3fc2:	9c 93       	st	X, r25
    3fc4:	8e 93       	st	-X, r24
    3fc6:	1a 97       	sbiw	r26, 0x0a	; 10
			if (buf->packet == NULL) {
    3fc8:	89 2b       	or	r24, r25
    3fca:	c9 f4       	brne	.+50     	; 0x3ffe <csp_can_rx_task+0x300>
				csp_log_error("Failed to get buffer for CSP_BEGIN packet");
    3fcc:	ed e6       	ldi	r30, 0x6D	; 109
    3fce:	fa e0       	ldi	r31, 0x0A	; 10
    3fd0:	ff 93       	push	r31
    3fd2:	ef 93       	push	r30
    3fd4:	1f 92       	push	r1
    3fd6:	d4 da       	rcall	.-2648   	; 0x3580 <do_csp_debug>
    3fd8:	e2 e1       	ldi	r30, 0x12	; 18
				csp_if_can.frame++;
    3fda:	f2 e0       	ldi	r31, 0x02	; 2
    3fdc:	81 a1       	ldd	r24, Z+33	; 0x21
    3fde:	92 a1       	ldd	r25, Z+34	; 0x22
    3fe0:	a3 a1       	ldd	r26, Z+35	; 0x23
    3fe2:	b4 a1       	ldd	r27, Z+36	; 0x24
    3fe4:	01 96       	adiw	r24, 0x01	; 1
    3fe6:	a1 1d       	adc	r26, r1
    3fe8:	b1 1d       	adc	r27, r1
    3fea:	81 a3       	std	Z+33, r24	; 0x21
    3fec:	92 a3       	std	Z+34, r25	; 0x22
    3fee:	a3 a3       	std	Z+35, r26	; 0x23
    3ff0:	b4 a3       	std	Z+36, r27	; 0x24
				csp_can_pbuf_free(buf);
    3ff2:	c8 01       	movw	r24, r16
    3ff4:	f0 dc       	rcall	.-1568   	; 0x39d6 <csp_can_pbuf_free>
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	a2 ce       	rjmp	.-700    	; 0x3d42 <csp_can_rx_task+0x44>
    3ffe:	d8 01       	movw	r26, r16
				break;
			}
		}

		/* Copy CSP identifier and length*/
		memcpy(&(buf->packet->id), frame->data, sizeof(csp_id_t));
    4000:	1a 96       	adiw	r26, 0x0a	; 10
    4002:	ed 91       	ld	r30, X+
    4004:	fc 91       	ld	r31, X
    4006:	1b 97       	sbiw	r26, 0x0b	; 11
    4008:	8e 81       	ldd	r24, Y+6	; 0x06
    400a:	9f 81       	ldd	r25, Y+7	; 0x07
    400c:	93 87       	std	Z+11, r25	; 0x0b
    400e:	82 87       	std	Z+10, r24	; 0x0a
    4010:	88 85       	ldd	r24, Y+8	; 0x08
    4012:	99 85       	ldd	r25, Y+9	; 0x09
    4014:	95 87       	std	Z+13, r25	; 0x0d
    4016:	84 87       	std	Z+12, r24	; 0x0c
		buf->packet->id.ext = csp_ntoh32(buf->packet->id.ext);
    4018:	1a 96       	adiw	r26, 0x0a	; 10
    401a:	ad 90       	ld	r10, X+
    401c:	bc 90       	ld	r11, X
    401e:	1b 97       	sbiw	r26, 0x0b	; 11
    4020:	f5 01       	movw	r30, r10
    4022:	62 85       	ldd	r22, Z+10	; 0x0a
    4024:	73 85       	ldd	r23, Z+11	; 0x0b
    4026:	84 85       	ldd	r24, Z+12	; 0x0c
    4028:	95 85       	ldd	r25, Z+13	; 0x0d
    402a:	5e db       	rcall	.-2372   	; 0x36e8 <csp_ntoh32>
    402c:	d5 01       	movw	r26, r10
    402e:	1a 96       	adiw	r26, 0x0a	; 10
    4030:	6d 93       	st	X+, r22
    4032:	7d 93       	st	X+, r23
    4034:	8d 93       	st	X+, r24
    4036:	9c 93       	st	X, r25
    4038:	1d 97       	sbiw	r26, 0x0d	; 13
    403a:	d8 01       	movw	r26, r16
		memcpy(&(buf->packet->length), frame->data + sizeof(csp_id_t), sizeof(uint16_t));
    403c:	1a 96       	adiw	r26, 0x0a	; 10
    403e:	ed 91       	ld	r30, X+
    4040:	fc 91       	ld	r31, X
    4042:	1b 97       	sbiw	r26, 0x0b	; 11
    4044:	8a 85       	ldd	r24, Y+10	; 0x0a
    4046:	9b 85       	ldd	r25, Y+11	; 0x0b
    4048:	91 87       	std	Z+9, r25	; 0x09
    404a:	80 87       	std	Z+8, r24	; 0x08
		buf->packet->length = csp_ntoh16(buf->packet->length);
    404c:	1a 96       	adiw	r26, 0x0a	; 10
    404e:	ad 90       	ld	r10, X+
    4050:	bc 90       	ld	r11, X
    4052:	1b 97       	sbiw	r26, 0x0b	; 11
    4054:	f5 01       	movw	r30, r10
    4056:	80 85       	ldd	r24, Z+8	; 0x08
    4058:	91 85       	ldd	r25, Z+9	; 0x09
    405a:	0d db       	rcall	.-2534   	; 0x3676 <csp_ntoh16>
    405c:	d5 01       	movw	r26, r10
    405e:	19 96       	adiw	r26, 0x09	; 9
    4060:	9c 93       	st	X, r25
    4062:	8e 93       	st	-X, r24
    4064:	18 97       	sbiw	r26, 0x08	; 8
    4066:	f8 01       	movw	r30, r16

		/* Reset RX count */
		buf->rx_count = 0;
    4068:	11 82       	std	Z+1, r1	; 0x01
    406a:	10 82       	st	Z, r1
    406c:	d3 01       	movw	r26, r6

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);

		/* Set remain field - increment to include begin packet */
		buf->remain = CFP_REMAIN(id) + 1;
    406e:	c2 01       	movw	r24, r4
    4070:	07 2e       	mov	r0, r23
    4072:	7a e0       	ldi	r23, 0x0A	; 10
    4074:	b6 95       	lsr	r27
    4076:	a7 95       	ror	r26
    4078:	97 95       	ror	r25
    407a:	87 95       	ror	r24
    407c:	7a 95       	dec	r23
    407e:	d1 f7       	brne	.-12     	; 0x4074 <csp_can_rx_task+0x376>
    4080:	70 2d       	mov	r23, r0
    4082:	99 27       	eor	r25, r25
    4084:	aa 27       	eor	r26, r26
    4086:	bb 27       	eor	r27, r27
    4088:	01 96       	adiw	r24, 0x01	; 1
    408a:	a1 1d       	adc	r26, r1
    408c:	b1 1d       	adc	r27, r1
    408e:	82 83       	std	Z+2, r24	; 0x02
    4090:	93 83       	std	Z+3, r25	; 0x03
    4092:	a4 83       	std	Z+4, r26	; 0x04
    4094:	b5 83       	std	Z+5, r27	; 0x05
    4096:	26 e0       	ldi	r18, 0x06	; 6

		/* Reset RX count */
		buf->rx_count = 0;

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);
    4098:	01 c0       	rjmp	.+2      	; 0x409c <csp_can_rx_task+0x39e>
    409a:	20 e0       	ldi	r18, 0x00	; 0
			return CSP_ERR_INVAL;
		}
	}

	/* Reset frame data offset */
	offset = 0;
    409c:	03 2e       	mov	r0, r19
		/* FALLTHROUGH */

	case CFP_MORE:

		/* Check 'remain' field match */
		if (CFP_REMAIN(id) != buf->remain - 1) {
    409e:	3a e0       	ldi	r19, 0x0A	; 10
    40a0:	76 94       	lsr	r7
    40a2:	67 94       	ror	r6
    40a4:	57 94       	ror	r5
    40a6:	47 94       	ror	r4
    40a8:	3a 95       	dec	r19
    40aa:	d1 f7       	brne	.-12     	; 0x40a0 <csp_can_rx_task+0x3a2>
    40ac:	30 2d       	mov	r19, r0
    40ae:	55 24       	eor	r5, r5
    40b0:	66 24       	eor	r6, r6
    40b2:	77 24       	eor	r7, r7
    40b4:	f8 01       	movw	r30, r16
    40b6:	82 81       	ldd	r24, Z+2	; 0x02
    40b8:	93 81       	ldd	r25, Z+3	; 0x03
    40ba:	a4 81       	ldd	r26, Z+4	; 0x04
    40bc:	b5 81       	ldd	r27, Z+5	; 0x05
    40be:	01 97       	sbiw	r24, 0x01	; 1
    40c0:	a1 09       	sbc	r26, r1
    40c2:	b1 09       	sbc	r27, r1
    40c4:	48 16       	cp	r4, r24
    40c6:	59 06       	cpc	r5, r25
    40c8:	6a 06       	cpc	r6, r26
    40ca:	7b 06       	cpc	r7, r27
			csp_log_error("CAN frame lost in CSP packet");
    40cc:	b9 f0       	breq	.+46     	; 0x40fc <csp_can_rx_task+0x3fe>
    40ce:	9f 92       	push	r9
    40d0:	8f 92       	push	r8
    40d2:	1f 92       	push	r1
    40d4:	55 da       	rcall	.-2902   	; 0x3580 <do_csp_debug>
			csp_can_pbuf_free(buf);
    40d6:	c8 01       	movw	r24, r16
    40d8:	7e dc       	rcall	.-1796   	; 0x39d6 <csp_can_pbuf_free>
    40da:	e2 e1       	ldi	r30, 0x12	; 18
			csp_if_can.frame++;
    40dc:	f2 e0       	ldi	r31, 0x02	; 2
    40de:	81 a1       	ldd	r24, Z+33	; 0x21
    40e0:	92 a1       	ldd	r25, Z+34	; 0x22
    40e2:	a3 a1       	ldd	r26, Z+35	; 0x23
    40e4:	b4 a1       	ldd	r27, Z+36	; 0x24
    40e6:	01 96       	adiw	r24, 0x01	; 1
    40e8:	a1 1d       	adc	r26, r1
    40ea:	b1 1d       	adc	r27, r1
    40ec:	81 a3       	std	Z+33, r24	; 0x21
    40ee:	92 a3       	std	Z+34, r25	; 0x22
    40f0:	a3 a3       	std	Z+35, r26	; 0x23
    40f2:	b4 a3       	std	Z+36, r27	; 0x24
    40f4:	0f 90       	pop	r0
    40f6:	0f 90       	pop	r0
    40f8:	0f 90       	pop	r0
    40fa:	23 ce       	rjmp	.-954    	; 0x3d42 <csp_can_rx_task+0x44>
    40fc:	42 82       	std	Z+2, r4	; 0x02
			break;
		}

		/* Decrement remaining frames */
		buf->remain--;
    40fe:	53 82       	std	Z+3, r5	; 0x03
    4100:	64 82       	std	Z+4, r6	; 0x04
    4102:	75 82       	std	Z+5, r7	; 0x05
    4104:	80 81       	ld	r24, Z

		/* Check for overflow */
		if ((buf->rx_count + frame->dlc - offset) > buf->packet->length) {
    4106:	91 81       	ldd	r25, Z+1	; 0x01
    4108:	4d 81       	ldd	r20, Y+5	; 0x05
    410a:	62 2f       	mov	r22, r18
    410c:	70 e0       	ldi	r23, 0x00	; 0
    410e:	02 84       	ldd	r0, Z+10	; 0x0a
    4110:	f3 85       	ldd	r31, Z+11	; 0x0b
    4112:	e0 2d       	mov	r30, r0
    4114:	dc 01       	movw	r26, r24
    4116:	a4 0f       	add	r26, r20
    4118:	b1 1d       	adc	r27, r1
    411a:	a6 1b       	sub	r26, r22
    411c:	b7 0b       	sbc	r27, r23
    411e:	a0 84       	ldd	r10, Z+8	; 0x08
    4120:	b1 84       	ldd	r11, Z+9	; 0x09
    4122:	aa 16       	cp	r10, r26
    4124:	bb 06       	cpc	r11, r27
    4126:	c8 f4       	brcc	.+50     	; 0x415a <csp_can_rx_task+0x45c>
			csp_log_error("RX buffer overflow");
    4128:	ed e3       	ldi	r30, 0x3D	; 61
    412a:	fa e0       	ldi	r31, 0x0A	; 10
    412c:	ff 93       	push	r31
    412e:	ef 93       	push	r30
    4130:	1f 92       	push	r1
    4132:	26 da       	rcall	.-2996   	; 0x3580 <do_csp_debug>
			csp_if_can.frame++;
    4134:	e2 e1       	ldi	r30, 0x12	; 18
    4136:	f2 e0       	ldi	r31, 0x02	; 2
    4138:	81 a1       	ldd	r24, Z+33	; 0x21
    413a:	92 a1       	ldd	r25, Z+34	; 0x22
    413c:	a3 a1       	ldd	r26, Z+35	; 0x23
    413e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4140:	01 96       	adiw	r24, 0x01	; 1
    4142:	a1 1d       	adc	r26, r1
    4144:	b1 1d       	adc	r27, r1
    4146:	81 a3       	std	Z+33, r24	; 0x21
    4148:	92 a3       	std	Z+34, r25	; 0x22
    414a:	a3 a3       	std	Z+35, r26	; 0x23
    414c:	b4 a3       	std	Z+36, r27	; 0x24
			csp_can_pbuf_free(buf);
    414e:	c8 01       	movw	r24, r16
    4150:	42 dc       	rcall	.-1916   	; 0x39d6 <csp_can_pbuf_free>
    4152:	0f 90       	pop	r0
    4154:	0f 90       	pop	r0
    4156:	0f 90       	pop	r0
    4158:	f4 cd       	rjmp	.-1048   	; 0x3d42 <csp_can_rx_task+0x44>
    415a:	a2 2e       	mov	r10, r18
			break;
		}

		/* Copy dlc bytes into buffer */
		memcpy(&buf->packet->data[buf->rx_count], frame->data + offset, frame->dlc - offset);
    415c:	b1 2c       	mov	r11, r1
    415e:	0e 96       	adiw	r24, 0x0e	; 14
    4160:	50 e0       	ldi	r21, 0x00	; 0
    4162:	4a 19       	sub	r20, r10
    4164:	5b 09       	sbc	r21, r11
    4166:	a6 e0       	ldi	r26, 0x06	; 6
    4168:	b0 e0       	ldi	r27, 0x00	; 0
    416a:	ac 0f       	add	r26, r28
    416c:	bd 1f       	adc	r27, r29
    416e:	6a 0f       	add	r22, r26
    4170:	7b 1f       	adc	r23, r27
    4172:	8e 0f       	add	r24, r30
    4174:	9f 1f       	adc	r25, r31
    4176:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>
    417a:	8d 81       	ldd	r24, Y+5	; 0x05
		buf->rx_count += frame->dlc - offset;
    417c:	90 e0       	ldi	r25, 0x00	; 0
    417e:	8a 19       	sub	r24, r10
    4180:	9b 09       	sbc	r25, r11
    4182:	f8 01       	movw	r30, r16
    4184:	20 81       	ld	r18, Z
    4186:	31 81       	ldd	r19, Z+1	; 0x01
    4188:	82 0f       	add	r24, r18
    418a:	93 1f       	adc	r25, r19
    418c:	91 83       	std	Z+1, r25	; 0x01
    418e:	80 83       	st	Z, r24

		/* Check if more data is expected */
		if (buf->rx_count != buf->packet->length)
    4190:	02 84       	ldd	r0, Z+10	; 0x0a
    4192:	f3 85       	ldd	r31, Z+11	; 0x0b
    4194:	e0 2d       	mov	r30, r0
    4196:	20 85       	ldd	r18, Z+8	; 0x08
    4198:	31 85       	ldd	r19, Z+9	; 0x09
    419a:	82 17       	cp	r24, r18
    419c:	93 07       	cpc	r25, r19
    419e:	09 f0       	breq	.+2      	; 0x41a2 <csp_can_rx_task+0x4a4>
			break;

		/* Data is available */
		csp_new_packet(buf->packet, &csp_if_can, NULL);
    41a0:	d0 cd       	rjmp	.-1120   	; 0x3d42 <csp_can_rx_task+0x44>
    41a2:	40 e0       	ldi	r20, 0x00	; 0
    41a4:	50 e0       	ldi	r21, 0x00	; 0
    41a6:	62 e1       	ldi	r22, 0x12	; 18
    41a8:	72 e0       	ldi	r23, 0x02	; 2

		/* Drop packet buffer reference */
		buf->packet = NULL;
    41aa:	cf 01       	movw	r24, r30
    41ac:	69 d4       	rcall	.+2258   	; 0x4a80 <csp_qfifo_write>
    41ae:	d8 01       	movw	r26, r16
    41b0:	1b 96       	adiw	r26, 0x0b	; 11
    41b2:	1c 92       	st	X, r1

		/* Free packet buffer */
		csp_can_pbuf_free(buf);
    41b4:	1e 92       	st	-X, r1
    41b6:	1a 97       	sbiw	r26, 0x0a	; 10
    41b8:	c8 01       	movw	r24, r16
    41ba:	0d dc       	rcall	.-2022   	; 0x39d6 <csp_can_pbuf_free>

		break;

	default:
		csp_log_warn("Received unknown CFP message type");
    41bc:	c2 cd       	rjmp	.-1148   	; 0x3d42 <csp_can_rx_task+0x44>
    41be:	8b e1       	ldi	r24, 0x1B	; 27
    41c0:	9a e0       	ldi	r25, 0x0A	; 10
    41c2:	9f 93       	push	r25
    41c4:	8f 93       	push	r24
    41c6:	81 e0       	ldi	r24, 0x01	; 1
    41c8:	8f 93       	push	r24
    41ca:	da d9       	rcall	.-3148   	; 0x3580 <do_csp_debug>
		csp_can_pbuf_free(buf);
    41cc:	c8 01       	movw	r24, r16
    41ce:	03 dc       	rcall	.-2042   	; 0x39d6 <csp_can_pbuf_free>
    41d0:	0f 90       	pop	r0
    41d2:	0f 90       	pop	r0
    41d4:	0f 90       	pop	r0
    41d6:	b5 cd       	rjmp	.-1174   	; 0x3d42 <csp_can_rx_task+0x44>
    41d8:	81 e0       	ldi	r24, 0x01	; 1
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    41da:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <csp_can_pbuf+0xc>
    41de:	40 92 f9 04 	sts	0x04F9, r4	; 0x8004f9 <csp_can_pbuf+0x6>
			buf->cfpid = id;
    41e2:	50 92 fa 04 	sts	0x04FA, r5	; 0x8004fa <csp_can_pbuf+0x7>
    41e6:	60 92 fb 04 	sts	0x04FB, r6	; 0x8004fb <csp_can_pbuf+0x8>
    41ea:	70 92 fc 04 	sts	0x04FC, r7	; 0x8004fc <csp_can_pbuf+0x9>
    41ee:	10 92 f5 04 	sts	0x04F5, r1	; 0x8004f5 <csp_can_pbuf+0x2>
			buf->remain = 0;
    41f2:	10 92 f6 04 	sts	0x04F6, r1	; 0x8004f6 <csp_can_pbuf+0x3>
    41f6:	10 92 f7 04 	sts	0x04F7, r1	; 0x8004f7 <csp_can_pbuf+0x4>
    41fa:	10 92 f8 04 	sts	0x04F8, r1	; 0x8004f8 <csp_can_pbuf+0x5>
    41fe:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    4202:	60 93 00 05 	sts	0x0500, r22	; 0x800500 <csp_can_pbuf+0xd>
    4206:	70 93 01 05 	sts	0x0501, r23	; 0x800501 <csp_can_pbuf+0xe>
    420a:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <csp_can_pbuf+0xf>
    420e:	90 93 03 05 	sts	0x0503, r25	; 0x800503 <csp_can_pbuf+0x10>
    4212:	03 ef       	ldi	r16, 0xF3	; 243
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    4214:	14 e0       	ldi	r17, 0x04	; 4
    4216:	97 ce       	rjmp	.-722    	; 0x3f46 <csp_can_rx_task+0x248>

00004218 <csp_can_rx_frame>:
    4218:	ab 01       	movw	r20, r22
	csp_thread_exit();
}

int csp_can_rx_frame(can_frame_t *frame, CSP_BASE_TYPE *task_woken)
{
	if (csp_queue_enqueue_isr(csp_can_rx_queue, frame, task_woken) != CSP_QUEUE_OK)
    421a:	bc 01       	movw	r22, r24
    421c:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <csp_can_rx_queue>
    4220:	90 91 9e 05 	lds	r25, 0x059E	; 0x80059e <csp_can_rx_queue+0x1>
    4224:	09 d5       	rcall	.+2578   	; 0x4c38 <csp_queue_enqueue_isr>
    4226:	21 e0       	ldi	r18, 0x01	; 1
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	01 97       	sbiw	r24, 0x01	; 1
    422c:	11 f4       	brne	.+4      	; 0x4232 <csp_can_rx_frame+0x1a>
    422e:	20 e0       	ldi	r18, 0x00	; 0
    4230:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;
}
    4232:	88 27       	eor	r24, r24
    4234:	99 27       	eor	r25, r25
    4236:	82 1b       	sub	r24, r18
    4238:	93 0b       	sbc	r25, r19
    423a:	08 95       	ret

0000423c <csp_can_init>:

	return CSP_ERR_NONE;
}

int csp_can_init(uint8_t mode, struct csp_can_config *conf)
{
    423c:	8f 92       	push	r8
    423e:	9f 92       	push	r9
    4240:	af 92       	push	r10
    4242:	bf 92       	push	r11
    4244:	ef 92       	push	r14
    4246:	ff 92       	push	r15
    4248:	0f 93       	push	r16
    424a:	1f 93       	push	r17
    424c:	cf 93       	push	r28
    424e:	df 93       	push	r29
    4250:	18 2f       	mov	r17, r24
    4252:	eb 01       	movw	r28, r22
    4254:	e3 ef       	ldi	r30, 0xF3	; 243
    4256:	f4 e0       	ldi	r31, 0x04	; 4
    4258:	8d e9       	ldi	r24, 0x9D	; 157
    425a:	95 e0       	ldi	r25, 0x05	; 5
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		buf->rx_count = 0;
    425c:	11 82       	std	Z+1, r1	; 0x01
    425e:	10 82       	st	Z, r1
		buf->cfpid = 0;
    4260:	16 82       	std	Z+6, r1	; 0x06
    4262:	17 82       	std	Z+7, r1	; 0x07
    4264:	10 86       	std	Z+8, r1	; 0x08
    4266:	11 86       	std	Z+9, r1	; 0x09
		buf->packet = NULL;
    4268:	13 86       	std	Z+11, r1	; 0x0b
    426a:	12 86       	std	Z+10, r1	; 0x0a
		buf->state = BUF_FREE;
    426c:	14 86       	std	Z+12, r1	; 0x0c
		buf->last_used = 0;
    426e:	15 86       	std	Z+13, r1	; 0x0d
    4270:	16 86       	std	Z+14, r1	; 0x0e
    4272:	17 86       	std	Z+15, r1	; 0x0f
    4274:	10 8a       	std	Z+16, r1	; 0x10
		buf->remain = 0;
    4276:	12 82       	std	Z+2, r1	; 0x02
    4278:	13 82       	std	Z+3, r1	; 0x03
    427a:	14 82       	std	Z+4, r1	; 0x04
    427c:	15 82       	std	Z+5, r1	; 0x05
    427e:	71 96       	adiw	r30, 0x11	; 17
{
	/* Initialize packet buffers */
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    4280:	e8 17       	cp	r30, r24
    4282:	f9 07       	cpc	r31, r25
    4284:	59 f7       	brne	.-42     	; 0x425c <csp_can_init+0x20>

/* Identification number */
static int csp_can_id_init(void)
{
	/* Init ID field to random number */
	srand((int)csp_get_ms());
    4286:	0e 94 14 2e 	call	0x5c28	; 0x5c28 <csp_get_ms>
    428a:	cb 01       	movw	r24, r22
    428c:	0e 94 8b 42 	call	0x8516	; 0x8516 <srand>
	csp_can_id = rand() & ((1 << CFP_ID_SIZE) - 1);
    4290:	0e 94 88 42 	call	0x8510	; 0x8510 <rand>
    4294:	93 70       	andi	r25, 0x03	; 3
    4296:	90 93 a4 05 	sts	0x05A4, r25	; 0x8005a4 <csp_can_id+0x1>
    429a:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <csp_can_id>

	if (csp_bin_sem_create(&csp_can_id_sem) == CSP_SEMAPHORE_OK) {
    429e:	81 ea       	ldi	r24, 0xA1	; 161
    42a0:	95 e0       	ldi	r25, 0x05	; 5
    42a2:	0e 94 74 29 	call	0x52e8	; 0x52e8 <csp_bin_sem_create>
    42a6:	01 97       	sbiw	r24, 0x01	; 1
    42a8:	09 f4       	brne	.+2      	; 0x42ac <csp_can_init+0x70>
    42aa:	8e c0       	rjmp	.+284    	; 0x43c8 <csp_can_init+0x18c>
		return CSP_ERR_NONE;
	} else {
		csp_log_error("Could not initialize CFP id semaphore");
    42ac:	85 ef       	ldi	r24, 0xF5	; 245
    42ae:	99 e0       	ldi	r25, 0x09	; 9
    42b0:	9f 93       	push	r25
    42b2:	8f 93       	push	r24
    42b4:	1f 92       	push	r1
    42b6:	64 d9       	rcall	.-3384   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
	}

	/* Initialize CFP identifier */
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
    42b8:	85 e9       	ldi	r24, 0x95	; 149
    42ba:	9b e0       	ldi	r25, 0x0B	; 11
    42bc:	9f 93       	push	r25
    42be:	8f 93       	push	r24
    42c0:	1f 92       	push	r1
    42c2:	5e d9       	rcall	.-3396   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    42c4:	0f 90       	pop	r0
    42c6:	0f 90       	pop	r0
    42c8:	0f 90       	pop	r0
    42ca:	0f 90       	pop	r0
    42cc:	0f 90       	pop	r0
    42ce:	0f 90       	pop	r0
    42d0:	8f ef       	ldi	r24, 0xFF	; 255
    42d2:	9f ef       	ldi	r25, 0xFF	; 255
    42d4:	7c c0       	rjmp	.+248    	; 0x43ce <csp_can_init+0x192>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
    42d6:	11 30       	cpi	r17, 0x01	; 1
    42d8:	61 f0       	breq	.+24     	; 0x42f2 <csp_can_init+0xb6>
		mask = 0;
	} else {
		csp_log_error("Unknown CAN mode");
    42da:	84 e8       	ldi	r24, 0x84	; 132
    42dc:	9b e0       	ldi	r25, 0x0B	; 11
    42de:	9f 93       	push	r25
    42e0:	8f 93       	push	r24
    42e2:	1f 92       	push	r1
    42e4:	4d d9       	rcall	.-3430   	; 0x3580 <do_csp_debug>
		return CSP_ERR_INVAL;
    42e6:	0f 90       	pop	r0
    42e8:	0f 90       	pop	r0
    42ea:	0f 90       	pop	r0
    42ec:	8e ef       	ldi	r24, 0xFE	; 254
    42ee:	9f ef       	ldi	r25, 0xFF	; 255
    42f0:	6e c0       	rjmp	.+220    	; 0x43ce <csp_can_init+0x192>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
		mask = 0;
    42f2:	81 2c       	mov	r8, r1
    42f4:	91 2c       	mov	r9, r1
    42f6:	54 01       	movw	r10, r8
    42f8:	07 c0       	rjmp	.+14     	; 0x4308 <csp_can_init+0xcc>
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
    42fa:	0f 2e       	mov	r0, r31
    42fc:	81 2c       	mov	r8, r1
    42fe:	91 2c       	mov	r9, r1
    4300:	f8 ef       	ldi	r31, 0xF8	; 248
    4302:	af 2e       	mov	r10, r31
    4304:	b1 2c       	mov	r11, r1
    4306:	f0 2d       	mov	r31, r0
	} else {
		csp_log_error("Unknown CAN mode");
		return CSP_ERR_INVAL;
	}

	csp_can_rx_queue = csp_queue_create(CSP_CAN_RX_QUEUE_SIZE, sizeof(can_frame_t));
    4308:	6d e0       	ldi	r22, 0x0D	; 13
    430a:	70 e0       	ldi	r23, 0x00	; 0
    430c:	80 e2       	ldi	r24, 0x20	; 32
    430e:	90 e0       	ldi	r25, 0x00	; 0
    4310:	6b d4       	rcall	.+2262   	; 0x4be8 <csp_queue_create>
    4312:	90 93 9e 05 	sts	0x059E, r25	; 0x80059e <csp_can_rx_queue+0x1>
    4316:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <csp_can_rx_queue>
	if (!csp_can_rx_queue) {
    431a:	89 2b       	or	r24, r25
    431c:	61 f4       	brne	.+24     	; 0x4336 <csp_can_init+0xfa>
		csp_log_error("Failed to create CAN RX queue");
    431e:	86 e6       	ldi	r24, 0x66	; 102
    4320:	9b e0       	ldi	r25, 0x0B	; 11
    4322:	9f 93       	push	r25
    4324:	8f 93       	push	r24
    4326:	1f 92       	push	r1
    4328:	2b d9       	rcall	.-3498   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    432a:	0f 90       	pop	r0
    432c:	0f 90       	pop	r0
    432e:	0f 90       	pop	r0
    4330:	8f ef       	ldi	r24, 0xFF	; 255
    4332:	9f ef       	ldi	r25, 0xFF	; 255
    4334:	4c c0       	rjmp	.+152    	; 0x43ce <csp_can_init+0x192>
	}

	ret = csp_thread_create(csp_can_rx_task, "CAN", 200 , NULL, 3, &csp_can_rx_task_h); //6000/sizeof(int)
    4336:	0f 2e       	mov	r0, r31
    4338:	ff e9       	ldi	r31, 0x9F	; 159
    433a:	ef 2e       	mov	r14, r31
    433c:	f5 e0       	ldi	r31, 0x05	; 5
    433e:	ff 2e       	mov	r15, r31
    4340:	f0 2d       	mov	r31, r0
    4342:	03 e0       	ldi	r16, 0x03	; 3
    4344:	10 e0       	ldi	r17, 0x00	; 0
    4346:	20 e0       	ldi	r18, 0x00	; 0
    4348:	30 e0       	ldi	r19, 0x00	; 0
    434a:	48 ec       	ldi	r20, 0xC8	; 200
    434c:	50 e0       	ldi	r21, 0x00	; 0
    434e:	66 e8       	ldi	r22, 0x86	; 134
    4350:	72 e0       	ldi	r23, 0x02	; 2
    4352:	8f e7       	ldi	r24, 0x7F	; 127
    4354:	9e e1       	ldi	r25, 0x1E	; 30
    4356:	0e 94 01 2e 	call	0x5c02	; 0x5c02 <csp_thread_create>
	if (ret != 0) {
    435a:	89 2b       	or	r24, r25
    435c:	61 f0       	breq	.+24     	; 0x4376 <csp_can_init+0x13a>
		csp_log_error("Failed to init CAN RX task");
    435e:	8b e4       	ldi	r24, 0x4B	; 75
    4360:	9b e0       	ldi	r25, 0x0B	; 11
    4362:	9f 93       	push	r25
    4364:	8f 93       	push	r24
    4366:	1f 92       	push	r1
    4368:	0b d9       	rcall	.-3562   	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    436a:	0f 90       	pop	r0
    436c:	0f 90       	pop	r0
    436e:	0f 90       	pop	r0
    4370:	8f ef       	ldi	r24, 0xFF	; 255
    4372:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Initialize CAN driver */

	int driverror=can_init(CFP_MAKE_DST(csp_get_address()), mask, conf);
    4374:	2c c0       	rjmp	.+88     	; 0x43ce <csp_can_init+0x192>
    4376:	5c d0       	rcall	.+184    	; 0x4430 <csp_get_address>
    4378:	8f 71       	andi	r24, 0x1F	; 31
    437a:	90 e0       	ldi	r25, 0x00	; 0
    437c:	a0 e0       	ldi	r26, 0x00	; 0
    437e:	b0 e0       	ldi	r27, 0x00	; 0
    4380:	bc 01       	movw	r22, r24
    4382:	cd 01       	movw	r24, r26
    4384:	05 2e       	mov	r0, r21
    4386:	53 e1       	ldi	r21, 0x13	; 19
    4388:	66 0f       	add	r22, r22
    438a:	77 1f       	adc	r23, r23
    438c:	88 1f       	adc	r24, r24
    438e:	99 1f       	adc	r25, r25
    4390:	5a 95       	dec	r21
    4392:	d1 f7       	brne	.-12     	; 0x4388 <csp_can_init+0x14c>
    4394:	50 2d       	mov	r21, r0
    4396:	8e 01       	movw	r16, r28
    4398:	a5 01       	movw	r20, r10
    439a:	94 01       	movw	r18, r8
    439c:	0e 94 a2 09 	call	0x1344	; 0x1344 <can_init>
	//printf("test = %d",driverror);
	if (driverror!=0){
    43a0:	89 2b       	or	r24, r25
		csp_log_error("Failed to initialize CAN driver");
    43a2:	61 f0       	breq	.+24     	; 0x43bc <csp_can_init+0x180>
    43a4:	8b e2       	ldi	r24, 0x2B	; 43
    43a6:	9b e0       	ldi	r25, 0x0B	; 11
    43a8:	9f 93       	push	r25
    43aa:	8f 93       	push	r24
    43ac:	1f 92       	push	r1
    43ae:	e8 d8       	rcall	.-3632   	; 0x3580 <do_csp_debug>
		return CSP_ERR_DRIVER;
    43b0:	0f 90       	pop	r0
    43b2:	0f 90       	pop	r0
    43b4:	0f 90       	pop	r0
    43b6:	85 ef       	ldi	r24, 0xF5	; 245
    43b8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Register interface */
	csp_iflist_add(&csp_if_can);
    43ba:	09 c0       	rjmp	.+18     	; 0x43ce <csp_can_init+0x192>
    43bc:	82 e1       	ldi	r24, 0x12	; 18
    43be:	92 e0       	ldi	r25, 0x02	; 2
    43c0:	36 da       	rcall	.-2964   	; 0x382e <csp_iflist_add>

	return CSP_ERR_NONE;
    43c2:	80 e0       	ldi	r24, 0x00	; 0
    43c4:	90 e0       	ldi	r25, 0x00	; 0
    43c6:	03 c0       	rjmp	.+6      	; 0x43ce <csp_can_init+0x192>
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
    43c8:	11 11       	cpse	r17, r1
    43ca:	85 cf       	rjmp	.-246    	; 0x42d6 <csp_can_init+0x9a>
    43cc:	96 cf       	rjmp	.-212    	; 0x42fa <csp_can_init+0xbe>

	/* Register interface */
	csp_iflist_add(&csp_if_can);

	return CSP_ERR_NONE;
}
    43ce:	df 91       	pop	r29
    43d0:	cf 91       	pop	r28
    43d2:	1f 91       	pop	r17
    43d4:	0f 91       	pop	r16
    43d6:	ff 90       	pop	r15
    43d8:	ef 90       	pop	r14
    43da:	bf 90       	pop	r11
    43dc:	af 90       	pop	r10
    43de:	9f 90       	pop	r9
    43e0:	8f 90       	pop	r8
    43e2:	08 95       	ret

000043e4 <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
static int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    43e4:	0f 93       	push	r16
    43e6:	1f 93       	push	r17
    43e8:	cf 93       	push	r28
    43ea:	df 93       	push	r29
    43ec:	8b 01       	movw	r16, r22

	/* Drop packet silently if not destined for us. This allows
	 * blackhole routing addresses by setting their nexthop to
	 * the loopback interface.
	 */
	if (packet->id.dst != csp_get_address()) {
    43ee:	fb 01       	movw	r30, r22
    43f0:	c4 85       	ldd	r28, Z+12	; 0x0c
    43f2:	8c 2f       	mov	r24, r28
    43f4:	82 95       	swap	r24
    43f6:	8f 70       	andi	r24, 0x0F	; 15
    43f8:	c5 85       	ldd	r28, Z+13	; 0x0d
    43fa:	c1 70       	andi	r28, 0x01	; 1
    43fc:	c2 95       	swap	r28
    43fe:	c0 7f       	andi	r28, 0xF0	; 240
    4400:	c8 2b       	or	r28, r24
    4402:	d0 e0       	ldi	r29, 0x00	; 0
    4404:	15 d0       	rcall	.+42     	; 0x4430 <csp_get_address>
    4406:	90 e0       	ldi	r25, 0x00	; 0
    4408:	c8 17       	cp	r28, r24
    440a:	d9 07       	cpc	r29, r25
    440c:	21 f0       	breq	.+8      	; 0x4416 <csp_lo_tx+0x32>
		/* Consume and drop packet */
		csp_buffer_free(packet);
    440e:	c8 01       	movw	r24, r16
    4410:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
		return CSP_ERR_NONE;
    4414:	06 c0       	rjmp	.+12     	; 0x4422 <csp_lo_tx+0x3e>
	}

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_qfifo_write(packet, &csp_if_lo, NULL);
    4416:	40 e0       	ldi	r20, 0x00	; 0
    4418:	50 e0       	ldi	r21, 0x00	; 0
    441a:	65 e4       	ldi	r22, 0x45	; 69
    441c:	72 e0       	ldi	r23, 0x02	; 2
    441e:	c8 01       	movw	r24, r16
    4420:	2f d3       	rcall	.+1630   	; 0x4a80 <csp_qfifo_write>

	return CSP_ERR_NONE;

}
    4422:	80 e0       	ldi	r24, 0x00	; 0
    4424:	90 e0       	ldi	r25, 0x00	; 0
    4426:	df 91       	pop	r29
    4428:	cf 91       	pop	r28
    442a:	1f 91       	pop	r17
    442c:	0f 91       	pop	r16
    442e:	08 95       	ret

00004430 <csp_get_address>:
	return csp_model;
}

void csp_set_revision(const char *revision)
{
	csp_revision = revision;
    4430:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    4434:	08 95       	ret

00004436 <csp_get_hostname>:
    4436:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <csp_hostname>
    443a:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <csp_hostname+0x1>
    443e:	08 95       	ret

00004440 <csp_get_model>:
    4440:	80 91 a5 05 	lds	r24, 0x05A5	; 0x8005a5 <csp_model>
    4444:	90 91 a6 05 	lds	r25, 0x05A6	; 0x8005a6 <csp_model+0x1>
    4448:	08 95       	ret

0000444a <csp_get_revision>:
}

const char *csp_get_revision(void)
{
	return csp_revision;
}
    444a:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <csp_revision>
    444e:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <csp_revision+0x1>
    4452:	08 95       	ret

00004454 <csp_init>:

int csp_init(unsigned char address) {
    4454:	cf 93       	push	r28
    4456:	df 93       	push	r29
extern csp_queue_handle_t csp_promisc_queue;
#endif

void csp_set_address(uint8_t addr)
{
	csp_my_address = addr;
    4458:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <csp_my_address>
	int ret;

	/* Initialize CSP */
	csp_set_address(address);

	ret = csp_conn_init();
    445c:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <csp_conn_init>
	if (ret != CSP_ERR_NONE)
    4460:	00 97       	sbiw	r24, 0x00	; 0
    4462:	d9 f4       	brne	.+54     	; 0x449a <csp_init+0x46>
		return ret;

	ret = csp_port_init();
    4464:	5c d2       	rcall	.+1208   	; 0x491e <csp_port_init>
	if (ret != CSP_ERR_NONE)
    4466:	00 97       	sbiw	r24, 0x00	; 0
		return ret;

	ret = csp_qfifo_init();
    4468:	c1 f4       	brne	.+48     	; 0x449a <csp_init+0x46>
    446a:	e1 d2       	rcall	.+1474   	; 0x4a2e <csp_qfifo_init>
    446c:	ec 01       	movw	r28, r24
	if (ret != CSP_ERR_NONE)
    446e:	00 97       	sbiw	r24, 0x00	; 0
    4470:	99 f4       	brne	.+38     	; 0x4498 <csp_init+0x44>
		return ret;

	/* Loopback */
	csp_iflist_add(&csp_if_lo);
    4472:	85 e4       	ldi	r24, 0x45	; 69
    4474:	92 e0       	ldi	r25, 0x02	; 2
    4476:	db d9       	rcall	.-3146   	; 0x382e <csp_iflist_add>

	/* Register loopback route */
	csp_route_set(csp_get_address(), &csp_if_lo, CSP_NODE_MAC);
    4478:	2f ef       	ldi	r18, 0xFF	; 255
    447a:	45 e4       	ldi	r20, 0x45	; 69
    447c:	52 e0       	ldi	r21, 0x02	; 2
    447e:	65 e0       	ldi	r22, 0x05	; 5
    4480:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    4484:	e9 d6       	rcall	.+3538   	; 0x5258 <csp_rtable_set>

	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);
    4486:	2f ef       	ldi	r18, 0xFF	; 255
    4488:	45 e4       	ldi	r20, 0x45	; 69
    448a:	52 e0       	ldi	r21, 0x02	; 2
    448c:	65 e0       	ldi	r22, 0x05	; 5
    448e:	80 e2       	ldi	r24, 0x20	; 32
    4490:	e3 d6       	rcall	.+3526   	; 0x5258 <csp_rtable_set>

	return CSP_ERR_NONE;
    4492:	8c 2f       	mov	r24, r28
    4494:	9d 2f       	mov	r25, r29
    4496:	01 c0       	rjmp	.+2      	; 0x449a <csp_init+0x46>
	if (ret != CSP_ERR_NONE)
		return ret;

	ret = csp_qfifo_init();
	if (ret != CSP_ERR_NONE)
		return ret;
    4498:	9d 2f       	mov	r25, r29
	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);

	return CSP_ERR_NONE;

}
    449a:	df 91       	pop	r29
    449c:	cf 91       	pop	r28
    449e:	08 95       	ret

000044a0 <csp_socket>:

csp_socket_t * csp_socket(uint32_t opts) {
    44a0:	cf 92       	push	r12
    44a2:	df 92       	push	r13
    44a4:	ef 92       	push	r14
    44a6:	ff 92       	push	r15
    44a8:	cf 93       	push	r28
    44aa:	df 93       	push	r29
    44ac:	6b 01       	movw	r12, r22
    44ae:	7c 01       	movw	r14, r24
	
	/* Validate socket options */
#ifndef CSP_USE_RDP
	if (opts & CSP_SO_RDPREQ) {
    44b0:	60 ff       	sbrs	r22, 0
    44b2:	0c c0       	rjmp	.+24     	; 0x44cc <csp_socket+0x2c>
		csp_log_error("Attempt to create socket that requires RDP, but CSP was compiled without RDP support");
    44b4:	88 ef       	ldi	r24, 0xF8	; 248
    44b6:	9d e0       	ldi	r25, 0x0D	; 13
    44b8:	9f 93       	push	r25
    44ba:	8f 93       	push	r24
    44bc:	1f 92       	push	r1
    44be:	60 d8       	rcall	.-3904   	; 0x3580 <do_csp_debug>
		return NULL;
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	0f 90       	pop	r0
    44c6:	80 e0       	ldi	r24, 0x00	; 0
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	50 c0       	rjmp	.+160    	; 0x456c <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_XTEA
	if (opts & CSP_SO_XTEAREQ) {
    44cc:	64 ff       	sbrs	r22, 4
    44ce:	0c c0       	rjmp	.+24     	; 0x44e8 <csp_socket+0x48>
		csp_log_error("Attempt to create socket that requires XTEA, but CSP was compiled without XTEA support");
    44d0:	81 ea       	ldi	r24, 0xA1	; 161
    44d2:	9d e0       	ldi	r25, 0x0D	; 13
    44d4:	9f 93       	push	r25
    44d6:	8f 93       	push	r24
    44d8:	1f 92       	push	r1
    44da:	52 d8       	rcall	.-3932   	; 0x3580 <do_csp_debug>
		return NULL;
    44dc:	0f 90       	pop	r0
    44de:	0f 90       	pop	r0
    44e0:	0f 90       	pop	r0
    44e2:	80 e0       	ldi	r24, 0x00	; 0
    44e4:	90 e0       	ldi	r25, 0x00	; 0
    44e6:	42 c0       	rjmp	.+132    	; 0x456c <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_HMAC
	if (opts & CSP_SO_HMACREQ) {
    44e8:	62 ff       	sbrs	r22, 2
    44ea:	0c c0       	rjmp	.+24     	; 0x4504 <csp_socket+0x64>
		csp_log_error("Attempt to create socket that requires HMAC, but CSP was compiled without HMAC support");
    44ec:	8a e4       	ldi	r24, 0x4A	; 74
    44ee:	9d e0       	ldi	r25, 0x0D	; 13
    44f0:	9f 93       	push	r25
    44f2:	8f 93       	push	r24
    44f4:	1f 92       	push	r1
    44f6:	44 d8       	rcall	.-3960   	; 0x3580 <do_csp_debug>
		return NULL;
    44f8:	0f 90       	pop	r0
    44fa:	0f 90       	pop	r0
    44fc:	0f 90       	pop	r0
    44fe:	80 e0       	ldi	r24, 0x00	; 0
    4500:	90 e0       	ldi	r25, 0x00	; 0
    4502:	34 c0       	rjmp	.+104    	; 0x456c <csp_socket+0xcc>
		return NULL;
	} 
#endif
	
	/* Drop packet if reserved flags are set */
	if (opts & ~(CSP_SO_RDPREQ | CSP_SO_XTEAREQ | CSP_SO_HMACREQ | CSP_SO_CRC32REQ | CSP_SO_CONN_LESS)) {
    4504:	dc 01       	movw	r26, r24
    4506:	cb 01       	movw	r24, r22
    4508:	8a 7a       	andi	r24, 0xAA	; 170
    450a:	9e 7f       	andi	r25, 0xFE	; 254
    450c:	89 2b       	or	r24, r25
    450e:	8a 2b       	or	r24, r26
    4510:	8b 2b       	or	r24, r27
    4512:	61 f0       	breq	.+24     	; 0x452c <csp_socket+0x8c>
		csp_log_error("Invalid socket option");
    4514:	84 e3       	ldi	r24, 0x34	; 52
    4516:	9d e0       	ldi	r25, 0x0D	; 13
    4518:	9f 93       	push	r25
    451a:	8f 93       	push	r24
    451c:	1f 92       	push	r1
    451e:	30 d8       	rcall	.-4000   	; 0x3580 <do_csp_debug>
		return NULL;
    4520:	0f 90       	pop	r0
    4522:	0f 90       	pop	r0
    4524:	0f 90       	pop	r0
    4526:	80 e0       	ldi	r24, 0x00	; 0
    4528:	90 e0       	ldi	r25, 0x00	; 0
    452a:	20 c0       	rjmp	.+64     	; 0x456c <csp_socket+0xcc>
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
    452c:	81 e0       	ldi	r24, 0x01	; 1
    452e:	0e 94 1e 18 	call	0x303c	; 0x303c <csp_conn_allocate>
    4532:	ec 01       	movw	r28, r24
	if (sock == NULL)
    4534:	89 2b       	or	r24, r25
    4536:	a9 f0       	breq	.+42     	; 0x4562 <csp_socket+0xc2>
		return NULL;

	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
    4538:	d0 fe       	sbrs	r13, 0
    453a:	0a c0       	rjmp	.+20     	; 0x4550 <csp_socket+0xb0>
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
    453c:	62 e0       	ldi	r22, 0x02	; 2
    453e:	70 e0       	ldi	r23, 0x00	; 0
    4540:	84 e6       	ldi	r24, 0x64	; 100
    4542:	90 e0       	ldi	r25, 0x00	; 0
    4544:	51 d3       	rcall	.+1698   	; 0x4be8 <csp_queue_create>
    4546:	9f 87       	std	Y+15, r25	; 0x0f
    4548:	8e 87       	std	Y+14, r24	; 0x0e
		if (sock->socket == NULL)
    454a:	89 2b       	or	r24, r25
    454c:	19 f4       	brne	.+6      	; 0x4554 <csp_socket+0xb4>
    454e:	0c c0       	rjmp	.+24     	; 0x4568 <csp_socket+0xc8>
			return NULL;
	} else {
		sock->socket = NULL;
    4550:	1f 86       	std	Y+15, r1	; 0x0f
    4552:	1e 86       	std	Y+14, r1	; 0x0e
	}
	sock->opts = opts;
    4554:	cc 8a       	std	Y+20, r12	; 0x14
    4556:	dd 8a       	std	Y+21, r13	; 0x15
    4558:	ee 8a       	std	Y+22, r14	; 0x16
    455a:	ff 8a       	std	Y+23, r15	; 0x17

	return sock;
    455c:	8c 2f       	mov	r24, r28
    455e:	9d 2f       	mov	r25, r29
    4560:	05 c0       	rjmp	.+10     	; 0x456c <csp_socket+0xcc>
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
	if (sock == NULL)
		return NULL;
    4562:	80 e0       	ldi	r24, 0x00	; 0
    4564:	90 e0       	ldi	r25, 0x00	; 0
    4566:	02 c0       	rjmp	.+4      	; 0x456c <csp_socket+0xcc>
	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
		if (sock->socket == NULL)
			return NULL;
    4568:	80 e0       	ldi	r24, 0x00	; 0
    456a:	90 e0       	ldi	r25, 0x00	; 0
	}
	sock->opts = opts;

	return sock;

}
    456c:	df 91       	pop	r29
    456e:	cf 91       	pop	r28
    4570:	ff 90       	pop	r15
    4572:	ef 90       	pop	r14
    4574:	df 90       	pop	r13
    4576:	cf 90       	pop	r12
    4578:	08 95       	ret

0000457a <csp_accept>:

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {
    457a:	cf 93       	push	r28
    457c:	df 93       	push	r29
    457e:	1f 92       	push	r1
    4580:	1f 92       	push	r1
    4582:	cd b7       	in	r28, 0x3d	; 61
    4584:	de b7       	in	r29, 0x3e	; 62

	if (sock == NULL)
    4586:	00 97       	sbiw	r24, 0x00	; 0
    4588:	81 f0       	breq	.+32     	; 0x45aa <csp_accept+0x30>
		return NULL;

	if (sock->socket == NULL)
    458a:	fc 01       	movw	r30, r24
    458c:	86 85       	ldd	r24, Z+14	; 0x0e
    458e:	97 85       	ldd	r25, Z+15	; 0x0f
    4590:	00 97       	sbiw	r24, 0x00	; 0
    4592:	71 f0       	breq	.+28     	; 0x45b0 <csp_accept+0x36>
    4594:	9a 01       	movw	r18, r20
    4596:	ab 01       	movw	r20, r22
		return NULL;

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
    4598:	be 01       	movw	r22, r28
    459a:	6f 5f       	subi	r22, 0xFF	; 255
    459c:	7f 4f       	sbci	r23, 0xFF	; 255
    459e:	53 d3       	rcall	.+1702   	; 0x4c46 <csp_queue_dequeue>
    45a0:	01 97       	sbiw	r24, 0x01	; 1
    45a2:	49 f4       	brne	.+18     	; 0x45b6 <csp_accept+0x3c>
		return conn;
    45a4:	89 81       	ldd	r24, Y+1	; 0x01
    45a6:	9a 81       	ldd	r25, Y+2	; 0x02
    45a8:	08 c0       	rjmp	.+16     	; 0x45ba <csp_accept+0x40>
}

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {

	if (sock == NULL)
		return NULL;
    45aa:	80 e0       	ldi	r24, 0x00	; 0
    45ac:	90 e0       	ldi	r25, 0x00	; 0
    45ae:	05 c0       	rjmp	.+10     	; 0x45ba <csp_accept+0x40>

	if (sock->socket == NULL)
		return NULL;
    45b0:	80 e0       	ldi	r24, 0x00	; 0
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	02 c0       	rjmp	.+4      	; 0x45ba <csp_accept+0x40>

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
		return conn;

	return NULL;
    45b6:	80 e0       	ldi	r24, 0x00	; 0
    45b8:	90 e0       	ldi	r25, 0x00	; 0

}
    45ba:	0f 90       	pop	r0
    45bc:	0f 90       	pop	r0
    45be:	df 91       	pop	r29
    45c0:	cf 91       	pop	r28
    45c2:	08 95       	ret

000045c4 <csp_read>:

csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {
    45c4:	cf 93       	push	r28
    45c6:	df 93       	push	r29
    45c8:	1f 92       	push	r1
    45ca:	1f 92       	push	r1
    45cc:	cd b7       	in	r28, 0x3d	; 61
    45ce:	de b7       	in	r29, 0x3e	; 62

	csp_packet_t * packet = NULL;
    45d0:	1a 82       	std	Y+2, r1	; 0x02
    45d2:	19 82       	std	Y+1, r1	; 0x01

	if (conn == NULL || conn->state != CONN_OPEN)
    45d4:	00 97       	sbiw	r24, 0x00	; 0
    45d6:	89 f0       	breq	.+34     	; 0x45fa <csp_read+0x36>
    45d8:	fc 01       	movw	r30, r24
    45da:	21 81       	ldd	r18, Z+1	; 0x01
    45dc:	21 30       	cpi	r18, 0x01	; 1
    45de:	81 f4       	brne	.+32     	; 0x4600 <csp_read+0x3c>
    45e0:	9a 01       	movw	r18, r20
    45e2:	ab 01       	movw	r20, r22

	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
    45e4:	be 01       	movw	r22, r28
    45e6:	6f 5f       	subi	r22, 0xFF	; 255
    45e8:	7f 4f       	sbci	r23, 0xFF	; 255
    45ea:	84 85       	ldd	r24, Z+12	; 0x0c
    45ec:	95 85       	ldd	r25, Z+13	; 0x0d
    45ee:	2b d3       	rcall	.+1622   	; 0x4c46 <csp_queue_dequeue>
    45f0:	01 97       	sbiw	r24, 0x01	; 1
    45f2:	49 f4       	brne	.+18     	; 0x4606 <csp_read+0x42>
	/* Packet read could trigger ACK transmission */
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_check_ack(conn);
#endif

	return packet;
    45f4:	89 81       	ldd	r24, Y+1	; 0x01
    45f6:	9a 81       	ldd	r25, Y+2	; 0x02
    45f8:	08 c0       	rjmp	.+16     	; 0x460a <csp_read+0x46>
csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {

	csp_packet_t * packet = NULL;

	if (conn == NULL || conn->state != CONN_OPEN)
		return NULL;
    45fa:	80 e0       	ldi	r24, 0x00	; 0
    45fc:	90 e0       	ldi	r25, 0x00	; 0
    45fe:	05 c0       	rjmp	.+10     	; 0x460a <csp_read+0x46>
    4600:	80 e0       	ldi	r24, 0x00	; 0
    4602:	90 e0       	ldi	r25, 0x00	; 0
    4604:	02 c0       	rjmp	.+4      	; 0x460a <csp_read+0x46>
	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
		return NULL;
    4606:	80 e0       	ldi	r24, 0x00	; 0
    4608:	90 e0       	ldi	r25, 0x00	; 0
		csp_rdp_check_ack(conn);
#endif

	return packet;

}
    460a:	0f 90       	pop	r0
    460c:	0f 90       	pop	r0
    460e:	df 91       	pop	r29
    4610:	cf 91       	pop	r28
    4612:	08 95       	ret

00004614 <csp_send_direct>:

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {
    4614:	4f 92       	push	r4
    4616:	5f 92       	push	r5
    4618:	6f 92       	push	r6
    461a:	7f 92       	push	r7
    461c:	8f 92       	push	r8
    461e:	9f 92       	push	r9
    4620:	af 92       	push	r10
    4622:	bf 92       	push	r11
    4624:	cf 92       	push	r12
    4626:	df 92       	push	r13
    4628:	ef 92       	push	r14
    462a:	ff 92       	push	r15
    462c:	0f 93       	push	r16
    462e:	1f 93       	push	r17
    4630:	cf 93       	push	r28
    4632:	df 93       	push	r29
    4634:	86 2e       	mov	r8, r22
    4636:	97 2e       	mov	r9, r23
    4638:	a8 2e       	mov	r10, r24
    463a:	b9 2e       	mov	r11, r25
    463c:	6a 01       	movw	r12, r20
    463e:	e9 01       	movw	r28, r18
    4640:	27 01       	movw	r4, r14
    4642:	38 01       	movw	r6, r16

	if (packet == NULL) {
    4644:	41 15       	cp	r20, r1
    4646:	51 05       	cpc	r21, r1
    4648:	69 f4       	brne	.+26     	; 0x4664 <csp_send_direct+0x50>
		csp_log_error("csp_send_direct called with NULL packet");
    464a:	8c e0       	ldi	r24, 0x0C	; 12
    464c:	9d e0       	ldi	r25, 0x0D	; 13
    464e:	9f 93       	push	r25
    4650:	8f 93       	push	r24
    4652:	1f 92       	push	r1
    4654:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		goto err;
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
    465c:	0f 90       	pop	r0
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    465e:	86 ef       	ldi	r24, 0xF6	; 246
    4660:	9f ef       	ldi	r25, 0xFF	; 255

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {

	if (packet == NULL) {
		csp_log_error("csp_send_direct called with NULL packet");
		goto err;
    4662:	d5 c0       	rjmp	.+426    	; 0x480e <csp_send_direct+0x1fa>
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
    4664:	20 97       	sbiw	r28, 0x00	; 0
    4666:	21 f0       	breq	.+8      	; 0x4670 <csp_send_direct+0x5c>
    4668:	8c 81       	ldd	r24, Y+4	; 0x04
    466a:	9d 81       	ldd	r25, Y+5	; 0x05
    466c:	89 2b       	or	r24, r25
    466e:	b9 f4       	brne	.+46     	; 0x469e <csp_send_direct+0x8a>
		csp_log_error("No route to host: %#08x", idout.ext);
    4670:	bf 92       	push	r11
    4672:	af 92       	push	r10
    4674:	9f 92       	push	r9
    4676:	8f 92       	push	r8
    4678:	84 ef       	ldi	r24, 0xF4	; 244
    467a:	9c e0       	ldi	r25, 0x0C	; 12
    467c:	9f 93       	push	r25
    467e:	8f 93       	push	r24
    4680:	1f 92       	push	r1
    4682:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		goto err;
    4686:	2d b7       	in	r18, 0x3d	; 61
    4688:	3e b7       	in	r19, 0x3e	; 62
    468a:	29 5f       	subi	r18, 0xF9	; 249
    468c:	3f 4f       	sbci	r19, 0xFF	; 255
    468e:	0f b6       	in	r0, 0x3f	; 63
    4690:	f8 94       	cli
    4692:	3e bf       	out	0x3e, r19	; 62
    4694:	0f be       	out	0x3f, r0	; 63
    4696:	2d bf       	out	0x3d, r18	; 61
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    4698:	86 ef       	ldi	r24, 0xF6	; 246
    469a:	9f ef       	ldi	r25, 0xFF	; 255
		goto err;
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
		csp_log_error("No route to host: %#08x", idout.ext);
		goto err;
    469c:	b8 c0       	rjmp	.+368    	; 0x480e <csp_send_direct+0x1fa>
	}

	csp_log_packet("OUT: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %u VIA: %s",
    469e:	8b 2d       	mov	r24, r11
    46a0:	86 95       	lsr	r24
    46a2:	8f 71       	andi	r24, 0x1F	; 31
    46a4:	08 2f       	mov	r16, r24
    46a6:	10 e0       	ldi	r17, 0x00	; 0
    46a8:	99 81       	ldd	r25, Y+1	; 0x01
    46aa:	9f 93       	push	r25
    46ac:	98 81       	ld	r25, Y
    46ae:	9f 93       	push	r25
    46b0:	fa 01       	movw	r30, r20
    46b2:	91 85       	ldd	r25, Z+9	; 0x09
    46b4:	9f 93       	push	r25
    46b6:	90 85       	ldd	r25, Z+8	; 0x08
    46b8:	9f 93       	push	r25
    46ba:	1f 92       	push	r1
    46bc:	6f 93       	push	r22
    46be:	9b 2d       	mov	r25, r11
    46c0:	92 95       	swap	r25
    46c2:	96 95       	lsr	r25
    46c4:	96 95       	lsr	r25
    46c6:	93 70       	andi	r25, 0x03	; 3
    46c8:	1f 92       	push	r1
    46ca:	9f 93       	push	r25
    46cc:	97 2f       	mov	r25, r23
    46ce:	9f 73       	andi	r25, 0x3F	; 63
    46d0:	1f 92       	push	r1
    46d2:	9f 93       	push	r25
    46d4:	27 2f       	mov	r18, r23
    46d6:	22 95       	swap	r18
    46d8:	26 95       	lsr	r18
    46da:	26 95       	lsr	r18
    46dc:	23 70       	andi	r18, 0x03	; 3
    46de:	9a 2d       	mov	r25, r10
    46e0:	9f 70       	andi	r25, 0x0F	; 15
    46e2:	99 0f       	add	r25, r25
    46e4:	99 0f       	add	r25, r25
    46e6:	92 2b       	or	r25, r18
    46e8:	1f 92       	push	r1
    46ea:	9f 93       	push	r25
    46ec:	2a 2d       	mov	r18, r10
    46ee:	22 95       	swap	r18
    46f0:	2f 70       	andi	r18, 0x0F	; 15
    46f2:	9b 2d       	mov	r25, r11
    46f4:	91 70       	andi	r25, 0x01	; 1
    46f6:	92 95       	swap	r25
    46f8:	90 7f       	andi	r25, 0xF0	; 240
    46fa:	92 2b       	or	r25, r18
    46fc:	1f 92       	push	r1
    46fe:	9f 93       	push	r25
    4700:	1f 92       	push	r1
    4702:	8f 93       	push	r24
    4704:	85 eb       	ldi	r24, 0xB5	; 181
    4706:	9c e0       	ldi	r25, 0x0C	; 12
    4708:	9f 93       	push	r25
    470a:	8f 93       	push	r24
    470c:	84 e0       	ldi	r24, 0x04	; 4
    470e:	8f 93       	push	r24
    4710:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		idout.src, idout.dst, idout.dport, idout.sport, idout.pri, idout.flags, packet->length, ifout->name);

	/* Copy identifier to packet (before crc, xtea and hmac) */
	packet->id.ext = idout.ext;
    4714:	f6 01       	movw	r30, r12
    4716:	82 86       	std	Z+10, r8	; 0x0a
    4718:	93 86       	std	Z+11, r9	; 0x0b
    471a:	a4 86       	std	Z+12, r10	; 0x0c
    471c:	b5 86       	std	Z+13, r11	; 0x0d
		csp_promisc_add(packet);
	}
#endif

	/* Only encrypt packets from the current node */
	if (idout.src == csp_get_address()) {
    471e:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    4722:	90 e0       	ldi	r25, 0x00	; 0
    4724:	2d b7       	in	r18, 0x3d	; 61
    4726:	3e b7       	in	r19, 0x3e	; 62
    4728:	2d 5e       	subi	r18, 0xED	; 237
    472a:	3f 4f       	sbci	r19, 0xFF	; 255
    472c:	0f b6       	in	r0, 0x3f	; 63
    472e:	f8 94       	cli
    4730:	3e bf       	out	0x3e, r19	; 62
    4732:	0f be       	out	0x3f, r0	; 63
    4734:	2d bf       	out	0x3d, r18	; 61
    4736:	08 17       	cp	r16, r24
    4738:	19 07       	cpc	r17, r25
    473a:	81 f5       	brne	.+96     	; 0x479c <csp_send_direct+0x188>
		/* Append HMAC */
		if (idout.flags & CSP_FHMAC) {
    473c:	83 fe       	sbrs	r8, 3
    473e:	0c c0       	rjmp	.+24     	; 0x4758 <csp_send_direct+0x144>
				/* HMAC append failed */
				csp_log_warn("HMAC append failed!");
				goto tx_err;
			}
#else
			csp_log_warn("Attempt to send packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    4740:	86 e5       	ldi	r24, 0x56	; 86
    4742:	9c e0       	ldi	r25, 0x0C	; 12
    4744:	9f 93       	push	r25
    4746:	8f 93       	push	r24
    4748:	81 e0       	ldi	r24, 0x01	; 1
    474a:	8f 93       	push	r24
    474c:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			goto tx_err;
    4750:	0f 90       	pop	r0
    4752:	0f 90       	pop	r0
    4754:	0f 90       	pop	r0
    4756:	4e c0       	rjmp	.+156    	; 0x47f4 <csp_send_direct+0x1e0>
#endif
		}

		/* Append CRC32 */
		if (idout.flags & CSP_FCRC32) {
    4758:	80 fe       	sbrs	r8, 0
    475a:	12 c0       	rjmp	.+36     	; 0x4780 <csp_send_direct+0x16c>
#ifdef CSP_USE_CRC32
			/* Calculate and add CRC32 (does not include header for backwards compatability with csp1.x) */
			if (csp_crc32_append(packet, false) != 0) {
    475c:	60 e0       	ldi	r22, 0x00	; 0
    475e:	c6 01       	movw	r24, r12
    4760:	0e 94 38 1a 	call	0x3470	; 0x3470 <csp_crc32_append>
    4764:	89 2b       	or	r24, r25
    4766:	61 f0       	breq	.+24     	; 0x4780 <csp_send_direct+0x16c>
				/* CRC32 append failed */
				csp_log_warn("CRC32 append failed!");
    4768:	81 e4       	ldi	r24, 0x41	; 65
    476a:	9c e0       	ldi	r25, 0x0C	; 12
    476c:	9f 93       	push	r25
    476e:	8f 93       	push	r24
    4770:	81 e0       	ldi	r24, 0x01	; 1
    4772:	8f 93       	push	r24
    4774:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
				goto tx_err;
    4778:	0f 90       	pop	r0
    477a:	0f 90       	pop	r0
    477c:	0f 90       	pop	r0
    477e:	3a c0       	rjmp	.+116    	; 0x47f4 <csp_send_direct+0x1e0>
			csp_log_warn("Attempt to send packet with CRC32, but CSP was compiled without CRC32 support. Sending without CRC32r");
			idout.flags &= ~(CSP_FCRC32);
#endif
		}

		if (idout.flags & CSP_FXTEA) {
    4780:	82 fe       	sbrs	r8, 2
    4782:	0c c0       	rjmp	.+24     	; 0x479c <csp_send_direct+0x188>
				goto tx_err;
			}

			packet->length += sizeof(nonce_n);
#else
			csp_log_warn("Attempt to send XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4784:	8d ed       	ldi	r24, 0xDD	; 221
    4786:	9b e0       	ldi	r25, 0x0B	; 11
    4788:	9f 93       	push	r25
    478a:	8f 93       	push	r24
    478c:	81 e0       	ldi	r24, 0x01	; 1
    478e:	8f 93       	push	r24
    4790:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			goto tx_err;
    4794:	0f 90       	pop	r0
    4796:	0f 90       	pop	r0
    4798:	0f 90       	pop	r0
    479a:	2c c0       	rjmp	.+88     	; 0x47f4 <csp_send_direct+0x1e0>
#endif
		}
	}

	/* Store length before passing to interface */
	uint16_t bytes = packet->length;
    479c:	f6 01       	movw	r30, r12
    479e:	00 85       	ldd	r16, Z+8	; 0x08
    47a0:	11 85       	ldd	r17, Z+9	; 0x09
	uint16_t mtu = ifout->mtu;
    47a2:	8e 81       	ldd	r24, Y+6	; 0x06
    47a4:	9f 81       	ldd	r25, Y+7	; 0x07

	if (mtu > 0 && bytes > mtu)
    47a6:	00 97       	sbiw	r24, 0x00	; 0
    47a8:	19 f0       	breq	.+6      	; 0x47b0 <csp_send_direct+0x19c>
    47aa:	80 17       	cp	r24, r16
    47ac:	91 07       	cpc	r25, r17
    47ae:	10 f1       	brcs	.+68     	; 0x47f4 <csp_send_direct+0x1e0>
		goto tx_err;

	if ((*ifout->nexthop)(ifout, packet, timeout) != CSP_ERR_NONE)
    47b0:	ec 81       	ldd	r30, Y+4	; 0x04
    47b2:	fd 81       	ldd	r31, Y+5	; 0x05
    47b4:	a3 01       	movw	r20, r6
    47b6:	92 01       	movw	r18, r4
    47b8:	b6 01       	movw	r22, r12
    47ba:	ce 01       	movw	r24, r28
    47bc:	19 95       	eicall
    47be:	00 97       	sbiw	r24, 0x00	; 0
    47c0:	c9 f4       	brne	.+50     	; 0x47f4 <csp_send_direct+0x1e0>
		goto tx_err;

	ifout->tx++;
    47c2:	49 85       	ldd	r20, Y+9	; 0x09
    47c4:	5a 85       	ldd	r21, Y+10	; 0x0a
    47c6:	6b 85       	ldd	r22, Y+11	; 0x0b
    47c8:	7c 85       	ldd	r23, Y+12	; 0x0c
    47ca:	4f 5f       	subi	r20, 0xFF	; 255
    47cc:	5f 4f       	sbci	r21, 0xFF	; 255
    47ce:	6f 4f       	sbci	r22, 0xFF	; 255
    47d0:	7f 4f       	sbci	r23, 0xFF	; 255
    47d2:	49 87       	std	Y+9, r20	; 0x09
    47d4:	5a 87       	std	Y+10, r21	; 0x0a
    47d6:	6b 87       	std	Y+11, r22	; 0x0b
    47d8:	7c 87       	std	Y+12, r23	; 0x0c
	ifout->txbytes += bytes;
    47da:	4d a1       	ldd	r20, Y+37	; 0x25
    47dc:	5e a1       	ldd	r21, Y+38	; 0x26
    47de:	6f a1       	ldd	r22, Y+39	; 0x27
    47e0:	78 a5       	ldd	r23, Y+40	; 0x28
    47e2:	40 0f       	add	r20, r16
    47e4:	51 1f       	adc	r21, r17
    47e6:	61 1d       	adc	r22, r1
    47e8:	71 1d       	adc	r23, r1
    47ea:	4d a3       	std	Y+37, r20	; 0x25
    47ec:	5e a3       	std	Y+38, r21	; 0x26
    47ee:	6f a3       	std	Y+39, r22	; 0x27
    47f0:	78 a7       	std	Y+40, r23	; 0x28
	return CSP_ERR_NONE;
    47f2:	0d c0       	rjmp	.+26     	; 0x480e <csp_send_direct+0x1fa>

tx_err:
	ifout->tx_error++;
    47f4:	89 89       	ldd	r24, Y+17	; 0x11
    47f6:	9a 89       	ldd	r25, Y+18	; 0x12
    47f8:	ab 89       	ldd	r26, Y+19	; 0x13
    47fa:	bc 89       	ldd	r27, Y+20	; 0x14
    47fc:	01 96       	adiw	r24, 0x01	; 1
    47fe:	a1 1d       	adc	r26, r1
    4800:	b1 1d       	adc	r27, r1
    4802:	89 8b       	std	Y+17, r24	; 0x11
    4804:	9a 8b       	std	Y+18, r25	; 0x12
    4806:	ab 8b       	std	Y+19, r26	; 0x13
    4808:	bc 8b       	std	Y+20, r27	; 0x14
err:
	return CSP_ERR_TX;
    480a:	86 ef       	ldi	r24, 0xF6	; 246
    480c:	9f ef       	ldi	r25, 0xFF	; 255

}
    480e:	df 91       	pop	r29
    4810:	cf 91       	pop	r28
    4812:	1f 91       	pop	r17
    4814:	0f 91       	pop	r16
    4816:	ff 90       	pop	r15
    4818:	ef 90       	pop	r14
    481a:	df 90       	pop	r13
    481c:	cf 90       	pop	r12
    481e:	bf 90       	pop	r11
    4820:	af 90       	pop	r10
    4822:	9f 90       	pop	r9
    4824:	8f 90       	pop	r8
    4826:	7f 90       	pop	r7
    4828:	6f 90       	pop	r6
    482a:	5f 90       	pop	r5
    482c:	4f 90       	pop	r4
    482e:	08 95       	ret

00004830 <csp_send>:

int csp_send(csp_conn_t * conn, csp_packet_t * packet, uint32_t timeout) {
    4830:	8f 92       	push	r8
    4832:	9f 92       	push	r9
    4834:	af 92       	push	r10
    4836:	bf 92       	push	r11
    4838:	cf 92       	push	r12
    483a:	df 92       	push	r13
    483c:	ef 92       	push	r14
    483e:	ff 92       	push	r15
    4840:	0f 93       	push	r16
    4842:	1f 93       	push	r17
    4844:	cf 93       	push	r28
    4846:	df 93       	push	r29
    4848:	ec 01       	movw	r28, r24
    484a:	6b 01       	movw	r12, r22
    484c:	49 01       	movw	r8, r18
    484e:	5a 01       	movw	r10, r20

	int ret;

	if ((conn == NULL) || (packet == NULL) || (conn->state != CONN_OPEN)) {
    4850:	89 2b       	or	r24, r25
    4852:	29 f0       	breq	.+10     	; 0x485e <csp_send+0x2e>
    4854:	67 2b       	or	r22, r23
    4856:	19 f0       	breq	.+6      	; 0x485e <csp_send+0x2e>
    4858:	89 81       	ldd	r24, Y+1	; 0x01
    485a:	81 30       	cpi	r24, 0x01	; 1
    485c:	69 f0       	breq	.+26     	; 0x4878 <csp_send+0x48>
		csp_log_error("Invalid call to csp_send");
    485e:	84 ec       	ldi	r24, 0xC4	; 196
    4860:	9b e0       	ldi	r25, 0x0B	; 11
    4862:	9f 93       	push	r25
    4864:	8f 93       	push	r24
    4866:	1f 92       	push	r1
    4868:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return 0;
    486c:	0f 90       	pop	r0
    486e:	0f 90       	pop	r0
    4870:	0f 90       	pop	r0
    4872:	80 e0       	ldi	r24, 0x00	; 0
    4874:	90 e0       	ldi	r25, 0x00	; 0
    4876:	19 c0       	rjmp	.+50     	; 0x48aa <csp_send+0x7a>
			return 0;
		}
	}
#endif

	csp_iface_t * ifout = csp_rtable_find_iface(conn->idout.dst);
    4878:	9a 85       	ldd	r25, Y+10	; 0x0a
    487a:	92 95       	swap	r25
    487c:	9f 70       	andi	r25, 0x0F	; 15
    487e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4880:	81 70       	andi	r24, 0x01	; 1
    4882:	82 95       	swap	r24
    4884:	80 7f       	andi	r24, 0xF0	; 240
    4886:	89 2b       	or	r24, r25
    4888:	a6 d4       	rcall	.+2380   	; 0x51d6 <csp_rtable_find_iface>
    488a:	9c 01       	movw	r18, r24
	ret = csp_send_direct(conn->idout, packet, ifout, timeout);
    488c:	68 85       	ldd	r22, Y+8	; 0x08
    488e:	79 85       	ldd	r23, Y+9	; 0x09
    4890:	8a 85       	ldd	r24, Y+10	; 0x0a
    4892:	9b 85       	ldd	r25, Y+11	; 0x0b
    4894:	85 01       	movw	r16, r10
    4896:	74 01       	movw	r14, r8
    4898:	a6 01       	movw	r20, r12
    489a:	bc de       	rcall	.-648    	; 0x4614 <csp_send_direct>

	return (ret == CSP_ERR_NONE) ? 1 : 0;
    489c:	31 e0       	ldi	r19, 0x01	; 1
    489e:	20 e0       	ldi	r18, 0x00	; 0
    48a0:	89 2b       	or	r24, r25
    48a2:	09 f0       	breq	.+2      	; 0x48a6 <csp_send+0x76>
    48a4:	30 e0       	ldi	r19, 0x00	; 0
    48a6:	83 2f       	mov	r24, r19
    48a8:	92 2f       	mov	r25, r18

}
    48aa:	df 91       	pop	r29
    48ac:	cf 91       	pop	r28
    48ae:	1f 91       	pop	r17
    48b0:	0f 91       	pop	r16
    48b2:	ff 90       	pop	r15
    48b4:	ef 90       	pop	r14
    48b6:	df 90       	pop	r13
    48b8:	cf 90       	pop	r12
    48ba:	bf 90       	pop	r11
    48bc:	af 90       	pop	r10
    48be:	9f 90       	pop	r9
    48c0:	8f 90       	pop	r8
    48c2:	08 95       	ret

000048c4 <csp_malloc>:

/* FreeRTOS includes */
#include "FreeRTOS.h"

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    48c4:	0c 94 0a 2f 	jmp	0x5e14	; 0x5e14 <pvPortMalloc>
}
    48c8:	08 95       	ret

000048ca <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    48ca:	0c 94 ca 2e 	jmp	0x5d94	; 0x5d94 <vPortFree>
    48ce:	08 95       	ret

000048d0 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
    48d0:	80 32       	cpi	r24, 0x20	; 32
    48d2:	91 05       	cpc	r25, r1
    48d4:	f0 f4       	brcc	.+60     	; 0x4912 <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    48d6:	fc 01       	movw	r30, r24
    48d8:	ee 0f       	add	r30, r30
    48da:	ff 1f       	adc	r31, r31
    48dc:	e8 0f       	add	r30, r24
    48de:	f9 1f       	adc	r31, r25
    48e0:	e6 55       	subi	r30, 0x56	; 86
    48e2:	fa 4f       	sbci	r31, 0xFA	; 250
    48e4:	20 81       	ld	r18, Z
    48e6:	21 30       	cpi	r18, 0x01	; 1
    48e8:	59 f4       	brne	.+22     	; 0x4900 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    48ea:	fc 01       	movw	r30, r24
    48ec:	ee 0f       	add	r30, r30
    48ee:	ff 1f       	adc	r31, r31
    48f0:	8e 0f       	add	r24, r30
    48f2:	9f 1f       	adc	r25, r31
    48f4:	fc 01       	movw	r30, r24
    48f6:	e6 55       	subi	r30, 0x56	; 86
    48f8:	fa 4f       	sbci	r31, 0xFA	; 250
    48fa:	81 81       	ldd	r24, Z+1	; 0x01
    48fc:	92 81       	ldd	r25, Z+2	; 0x02
    48fe:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    4900:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <ports+0x60>
    4904:	81 30       	cpi	r24, 0x01	; 1
    4906:	41 f4       	brne	.+16     	; 0x4918 <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    4908:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ports+0x61>
    490c:	90 91 0c 06 	lds	r25, 0x060C	; 0x80060c <ports+0x62>
    4910:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
		return NULL;
    4912:	80 e0       	ldi	r24, 0x00	; 0
    4914:	90 e0       	ldi	r25, 0x00	; 0
    4916:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    4918:	80 e0       	ldi	r24, 0x00	; 0
    491a:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    491c:	08 95       	ret

0000491e <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    491e:	83 e6       	ldi	r24, 0x63	; 99
    4920:	ea ea       	ldi	r30, 0xAA	; 170
    4922:	f5 e0       	ldi	r31, 0x05	; 5
    4924:	df 01       	movw	r26, r30
    4926:	1d 92       	st	X+, r1
    4928:	8a 95       	dec	r24
    492a:	e9 f7       	brne	.-6      	; 0x4926 <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    492c:	80 e0       	ldi	r24, 0x00	; 0
    492e:	90 e0       	ldi	r25, 0x00	; 0
    4930:	08 95       	ret

00004932 <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    4932:	cf 93       	push	r28
    4934:	df 93       	push	r29
    4936:	9c 01       	movw	r18, r24
	
	if (socket == NULL)
    4938:	89 2b       	or	r24, r25
    493a:	91 f0       	breq	.+36     	; 0x4960 <csp_listen+0x2e>
    493c:	cb 01       	movw	r24, r22
    493e:	e9 01       	movw	r28, r18
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    4940:	62 e0       	ldi	r22, 0x02	; 2
    4942:	70 e0       	ldi	r23, 0x00	; 0
    4944:	51 d1       	rcall	.+674    	; 0x4be8 <csp_queue_create>
    4946:	9f 87       	std	Y+15, r25	; 0x0f
    4948:	8e 87       	std	Y+14, r24	; 0x0e
	if (socket->socket == NULL)
    494a:	21 e0       	ldi	r18, 0x01	; 1
    494c:	30 e0       	ldi	r19, 0x00	; 0
    494e:	89 2b       	or	r24, r25
    4950:	11 f0       	breq	.+4      	; 0x4956 <csp_listen+0x24>
    4952:	20 e0       	ldi	r18, 0x00	; 0
    4954:	30 e0       	ldi	r19, 0x00	; 0
    4956:	88 27       	eor	r24, r24
    4958:	99 27       	eor	r25, r25
    495a:	82 1b       	sub	r24, r18
    495c:	93 0b       	sbc	r25, r19
    495e:	02 c0       	rjmp	.+4      	; 0x4964 <csp_listen+0x32>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    4960:	8e ef       	ldi	r24, 0xFE	; 254
    4962:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    4964:	df 91       	pop	r29
    4966:	cf 91       	pop	r28
    4968:	08 95       	ret

0000496a <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
    496a:	0f 93       	push	r16
    496c:	1f 93       	push	r17
    496e:	cf 93       	push	r28
    4970:	df 93       	push	r29
	
	if (socket == NULL)
    4972:	00 97       	sbiw	r24, 0x00	; 0
    4974:	09 f4       	brne	.+2      	; 0x4978 <csp_bind+0xe>
    4976:	54 c0       	rjmp	.+168    	; 0x4a20 <csp_bind+0xb6>
    4978:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    497a:	61 32       	cpi	r22, 0x21	; 33
    497c:	90 f0       	brcs	.+36     	; 0x49a2 <csp_bind+0x38>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports", CSP_ANY);
    497e:	1f 92       	push	r1
    4980:	80 e2       	ldi	r24, 0x20	; 32
    4982:	8f 93       	push	r24
    4984:	84 e8       	ldi	r24, 0x84	; 132
    4986:	9e e0       	ldi	r25, 0x0E	; 14
    4988:	9f 93       	push	r25
    498a:	8f 93       	push	r24
    498c:	1f 92       	push	r1
    498e:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return CSP_ERR_INVAL;
    4992:	0f 90       	pop	r0
    4994:	0f 90       	pop	r0
    4996:	0f 90       	pop	r0
    4998:	0f 90       	pop	r0
    499a:	0f 90       	pop	r0
    499c:	8e ef       	ldi	r24, 0xFE	; 254
    499e:	9f ef       	ldi	r25, 0xFF	; 255
    49a0:	41 c0       	rjmp	.+130    	; 0x4a24 <csp_bind+0xba>
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    49a2:	c6 2f       	mov	r28, r22
    49a4:	d0 e0       	ldi	r29, 0x00	; 0
    49a6:	fe 01       	movw	r30, r28
    49a8:	ee 0f       	add	r30, r30
    49aa:	ff 1f       	adc	r31, r31
    49ac:	ec 0f       	add	r30, r28
    49ae:	fd 1f       	adc	r31, r29
    49b0:	e6 55       	subi	r30, 0x56	; 86
    49b2:	fa 4f       	sbci	r31, 0xFA	; 250
    49b4:	80 81       	ld	r24, Z
    49b6:	88 23       	and	r24, r24
    49b8:	89 f0       	breq	.+34     	; 0x49dc <csp_bind+0x72>
		csp_log_error("Port %d is already in use", port);
    49ba:	1f 92       	push	r1
    49bc:	6f 93       	push	r22
    49be:	8a e6       	ldi	r24, 0x6A	; 106
    49c0:	9e e0       	ldi	r25, 0x0E	; 14
    49c2:	9f 93       	push	r25
    49c4:	8f 93       	push	r24
    49c6:	1f 92       	push	r1
    49c8:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return CSP_ERR_USED;
    49cc:	0f 90       	pop	r0
    49ce:	0f 90       	pop	r0
    49d0:	0f 90       	pop	r0
    49d2:	0f 90       	pop	r0
    49d4:	0f 90       	pop	r0
    49d6:	8c ef       	ldi	r24, 0xFC	; 252
    49d8:	9f ef       	ldi	r25, 0xFF	; 255
    49da:	24 c0       	rjmp	.+72     	; 0x4a24 <csp_bind+0xba>
	}

	csp_log_info("Binding socket %p to port %u", socket, port);
    49dc:	1f 92       	push	r1
    49de:	6f 93       	push	r22
    49e0:	1f 93       	push	r17
    49e2:	0f 93       	push	r16
    49e4:	8d e4       	ldi	r24, 0x4D	; 77
    49e6:	9e e0       	ldi	r25, 0x0E	; 14
    49e8:	9f 93       	push	r25
    49ea:	8f 93       	push	r24
    49ec:	82 e0       	ldi	r24, 0x02	; 2
    49ee:	8f 93       	push	r24
    49f0:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>

	/* Save listener */
	ports[port].socket = socket;
    49f4:	ce 01       	movw	r24, r28
    49f6:	88 0f       	add	r24, r24
    49f8:	99 1f       	adc	r25, r25
    49fa:	c8 0f       	add	r28, r24
    49fc:	d9 1f       	adc	r29, r25
    49fe:	c6 55       	subi	r28, 0x56	; 86
    4a00:	da 4f       	sbci	r29, 0xFA	; 250
    4a02:	1a 83       	std	Y+2, r17	; 0x02
    4a04:	09 83       	std	Y+1, r16	; 0x01
	ports[port].state = PORT_OPEN;
    4a06:	81 e0       	ldi	r24, 0x01	; 1
    4a08:	88 83       	st	Y, r24

	return CSP_ERR_NONE;
    4a0a:	8d b7       	in	r24, 0x3d	; 61
    4a0c:	9e b7       	in	r25, 0x3e	; 62
    4a0e:	07 96       	adiw	r24, 0x07	; 7
    4a10:	0f b6       	in	r0, 0x3f	; 63
    4a12:	f8 94       	cli
    4a14:	9e bf       	out	0x3e, r25	; 62
    4a16:	0f be       	out	0x3f, r0	; 63
    4a18:	8d bf       	out	0x3d, r24	; 61
    4a1a:	80 e0       	ldi	r24, 0x00	; 0
    4a1c:	90 e0       	ldi	r25, 0x00	; 0
    4a1e:	02 c0       	rjmp	.+4      	; 0x4a24 <csp_bind+0xba>
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    4a20:	8e ef       	ldi	r24, 0xFE	; 254
    4a22:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    4a24:	df 91       	pop	r29
    4a26:	cf 91       	pop	r28
    4a28:	1f 91       	pop	r17
    4a2a:	0f 91       	pop	r16
    4a2c:	08 95       	ret

00004a2e <csp_qfifo_init>:
int csp_qfifo_init(void) {
	int prio;

	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
    4a2e:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4a32:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4a36:	89 2b       	or	r24, r25
    4a38:	59 f4       	brne	.+22     	; 0x4a50 <csp_qfifo_init+0x22>
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
    4a3a:	64 e0       	ldi	r22, 0x04	; 4
    4a3c:	70 e0       	ldi	r23, 0x00	; 0
    4a3e:	8a e0       	ldi	r24, 0x0A	; 10
    4a40:	90 e0       	ldi	r25, 0x00	; 0
    4a42:	d2 d0       	rcall	.+420    	; 0x4be8 <csp_queue_create>
    4a44:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <qfifo+0x1>
    4a48:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <qfifo>
			if (!qfifo[prio])
    4a4c:	89 2b       	or	r24, r25
    4a4e:	19 f0       	breq	.+6      	; 0x4a56 <csp_qfifo_init+0x28>
	qfifo_events = csp_queue_create(CSP_FIFO_INPUT, sizeof(int));
	if (!qfifo_events)
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;
    4a50:	80 e0       	ldi	r24, 0x00	; 0
    4a52:	90 e0       	ldi	r25, 0x00	; 0
    4a54:	08 95       	ret
	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
			if (!qfifo[prio])
				return CSP_ERR_NOMEM;
    4a56:	8f ef       	ldi	r24, 0xFF	; 255
    4a58:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;

}
    4a5a:	08 95       	ret

00004a5c <csp_qfifo_read>:
	if (!found) {
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
    4a5c:	2f ef       	ldi	r18, 0xFF	; 255
    4a5e:	3f ef       	ldi	r19, 0xFF	; 255
    4a60:	40 e0       	ldi	r20, 0x00	; 0
    4a62:	50 e0       	ldi	r21, 0x00	; 0
    4a64:	bc 01       	movw	r22, r24
    4a66:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4a6a:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4a6e:	eb d0       	rcall	.+470    	; 0x4c46 <csp_queue_dequeue>
    4a70:	01 97       	sbiw	r24, 0x01	; 1
    4a72:	19 f4       	brne	.+6      	; 0x4a7a <csp_qfifo_read+0x1e>
		return CSP_ERR_TIMEDOUT;
#endif

	return CSP_ERR_NONE;
    4a74:	80 e0       	ldi	r24, 0x00	; 0
    4a76:	90 e0       	ldi	r25, 0x00	; 0
    4a78:	08 95       	ret
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
		return CSP_ERR_TIMEDOUT;
    4a7a:	8d ef       	ldi	r24, 0xFD	; 253
    4a7c:	9f ef       	ldi	r25, 0xFF	; 255
#endif

	return CSP_ERR_NONE;

}
    4a7e:	08 95       	ret

00004a80 <csp_qfifo_write>:

void csp_qfifo_write(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    4a80:	cf 92       	push	r12
    4a82:	df 92       	push	r13
    4a84:	ef 92       	push	r14
    4a86:	ff 92       	push	r15
    4a88:	0f 93       	push	r16
    4a8a:	1f 93       	push	r17
    4a8c:	cf 93       	push	r28
    4a8e:	df 93       	push	r29
    4a90:	00 d0       	rcall	.+0      	; 0x4a92 <csp_qfifo_write+0x12>
    4a92:	1f 92       	push	r1
    4a94:	cd b7       	in	r28, 0x3d	; 61
    4a96:	de b7       	in	r29, 0x3e	; 62
    4a98:	7c 01       	movw	r14, r24
    4a9a:	8b 01       	movw	r16, r22
    4a9c:	6a 01       	movw	r12, r20

	int result;

	if (packet == NULL) {
    4a9e:	00 97       	sbiw	r24, 0x00	; 0
    4aa0:	61 f4       	brne	.+24     	; 0x4aba <csp_qfifo_write+0x3a>
		csp_log_warn("csp_new packet called with NULL packet");
    4aa2:	82 e3       	ldi	r24, 0x32	; 50
    4aa4:	9f e0       	ldi	r25, 0x0F	; 15
    4aa6:	9f 93       	push	r25
    4aa8:	8f 93       	push	r24
    4aaa:	81 e0       	ldi	r24, 0x01	; 1
    4aac:	8f 93       	push	r24
    4aae:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return;
    4ab2:	0f 90       	pop	r0
    4ab4:	0f 90       	pop	r0
    4ab6:	0f 90       	pop	r0
    4ab8:	8a c0       	rjmp	.+276    	; 0x4bce <csp_qfifo_write+0x14e>
	} else if (interface == NULL) {
    4aba:	61 15       	cp	r22, r1
    4abc:	71 05       	cpc	r23, r1
    4abe:	a9 f4       	brne	.+42     	; 0x4aea <csp_qfifo_write+0x6a>
		csp_log_warn("csp_new packet called with NULL interface");
    4ac0:	88 e0       	ldi	r24, 0x08	; 8
    4ac2:	9f e0       	ldi	r25, 0x0F	; 15
    4ac4:	9f 93       	push	r25
    4ac6:	8f 93       	push	r24
    4ac8:	81 e0       	ldi	r24, 0x01	; 1
    4aca:	8f 93       	push	r24
    4acc:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		if (pxTaskWoken == NULL)
    4ad0:	0f 90       	pop	r0
    4ad2:	0f 90       	pop	r0
    4ad4:	0f 90       	pop	r0
    4ad6:	cd 28       	or	r12, r13
    4ad8:	21 f4       	brne	.+8      	; 0x4ae2 <csp_qfifo_write+0x62>
			csp_buffer_free(packet);
    4ada:	c7 01       	movw	r24, r14
    4adc:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    4ae0:	76 c0       	rjmp	.+236    	; 0x4bce <csp_qfifo_write+0x14e>
		else
			csp_buffer_free_isr(packet);
    4ae2:	c7 01       	movw	r24, r14
    4ae4:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <csp_buffer_free_isr>
    4ae8:	72 c0       	rjmp	.+228    	; 0x4bce <csp_qfifo_write+0x14e>
		return;
	}

	csp_qfifo_t queue_element;
	queue_element.interface = interface;
    4aea:	7a 83       	std	Y+2, r23	; 0x02
    4aec:	69 83       	std	Y+1, r22	; 0x01
	queue_element.packet = packet;
    4aee:	9c 83       	std	Y+4, r25	; 0x04
    4af0:	8b 83       	std	Y+3, r24	; 0x03
	int fifo = packet->id.pri;
#else
	int fifo = 0;
#endif

	if (pxTaskWoken == NULL)
    4af2:	41 15       	cp	r20, r1
    4af4:	51 05       	cpc	r21, r1
    4af6:	79 f4       	brne	.+30     	; 0x4b16 <csp_qfifo_write+0x96>
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
    4af8:	20 e0       	ldi	r18, 0x00	; 0
    4afa:	30 e0       	ldi	r19, 0x00	; 0
    4afc:	a9 01       	movw	r20, r18
    4afe:	be 01       	movw	r22, r28
    4b00:	6f 5f       	subi	r22, 0xFF	; 255
    4b02:	7f 4f       	sbci	r23, 0xFF	; 255
    4b04:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4b08:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4b0c:	71 d0       	rcall	.+226    	; 0x4bf0 <csp_queue_enqueue>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    4b0e:	01 97       	sbiw	r24, 0x01	; 1
    4b10:	09 f0       	breq	.+2      	; 0x4b14 <csp_qfifo_write+0x94>
    4b12:	43 c0       	rjmp	.+134    	; 0x4b9a <csp_qfifo_write+0x11a>
    4b14:	0a c0       	rjmp	.+20     	; 0x4b2a <csp_qfifo_write+0xaa>
#endif

	if (pxTaskWoken == NULL)
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
	else
		result = csp_queue_enqueue_isr(qfifo[fifo], &queue_element, pxTaskWoken);
    4b16:	be 01       	movw	r22, r28
    4b18:	6f 5f       	subi	r22, 0xFF	; 255
    4b1a:	7f 4f       	sbci	r23, 0xFF	; 255
    4b1c:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4b20:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4b24:	89 d0       	rcall	.+274    	; 0x4c38 <csp_queue_enqueue_isr>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    4b26:	01 97       	sbiw	r24, 0x01	; 1
    4b28:	e9 f4       	brne	.+58     	; 0x4b64 <csp_qfifo_write+0xe4>
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
	} else {
		interface->rx++;
    4b2a:	f8 01       	movw	r30, r16
    4b2c:	85 85       	ldd	r24, Z+13	; 0x0d
    4b2e:	96 85       	ldd	r25, Z+14	; 0x0e
    4b30:	a7 85       	ldd	r26, Z+15	; 0x0f
    4b32:	b0 89       	ldd	r27, Z+16	; 0x10
    4b34:	01 96       	adiw	r24, 0x01	; 1
    4b36:	a1 1d       	adc	r26, r1
    4b38:	b1 1d       	adc	r27, r1
    4b3a:	85 87       	std	Z+13, r24	; 0x0d
    4b3c:	96 87       	std	Z+14, r25	; 0x0e
    4b3e:	a7 87       	std	Z+15, r26	; 0x0f
    4b40:	b0 8b       	std	Z+16, r27	; 0x10
		interface->rxbytes += packet->length;
    4b42:	f7 01       	movw	r30, r14
    4b44:	20 85       	ldd	r18, Z+8	; 0x08
    4b46:	31 85       	ldd	r19, Z+9	; 0x09
    4b48:	f8 01       	movw	r30, r16
    4b4a:	81 a5       	ldd	r24, Z+41	; 0x29
    4b4c:	92 a5       	ldd	r25, Z+42	; 0x2a
    4b4e:	a3 a5       	ldd	r26, Z+43	; 0x2b
    4b50:	b4 a5       	ldd	r27, Z+44	; 0x2c
    4b52:	82 0f       	add	r24, r18
    4b54:	93 1f       	adc	r25, r19
    4b56:	a1 1d       	adc	r26, r1
    4b58:	b1 1d       	adc	r27, r1
    4b5a:	81 a7       	std	Z+41, r24	; 0x29
    4b5c:	92 a7       	std	Z+42, r25	; 0x2a
    4b5e:	a3 a7       	std	Z+43, r26	; 0x2b
    4b60:	b4 a7       	std	Z+44, r27	; 0x2c
    4b62:	35 c0       	rjmp	.+106    	; 0x4bce <csp_qfifo_write+0x14e>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    4b64:	84 ed       	ldi	r24, 0xD4	; 212
    4b66:	9e e0       	ldi	r25, 0x0E	; 14
    4b68:	9f 93       	push	r25
    4b6a:	8f 93       	push	r24
    4b6c:	81 e0       	ldi	r24, 0x01	; 1
    4b6e:	8f 93       	push	r24
    4b70:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		interface->drop++;
    4b74:	f8 01       	movw	r30, r16
    4b76:	81 8d       	ldd	r24, Z+25	; 0x19
    4b78:	92 8d       	ldd	r25, Z+26	; 0x1a
    4b7a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4b7c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    4b7e:	01 96       	adiw	r24, 0x01	; 1
    4b80:	a1 1d       	adc	r26, r1
    4b82:	b1 1d       	adc	r27, r1
    4b84:	81 8f       	std	Z+25, r24	; 0x19
    4b86:	92 8f       	std	Z+26, r25	; 0x1a
    4b88:	a3 8f       	std	Z+27, r26	; 0x1b
    4b8a:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
    4b8c:	c7 01       	movw	r24, r14
    4b8e:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <csp_buffer_free_isr>
    4b92:	0f 90       	pop	r0
    4b94:	0f 90       	pop	r0
    4b96:	0f 90       	pop	r0
    4b98:	1a c0       	rjmp	.+52     	; 0x4bce <csp_qfifo_write+0x14e>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    4b9a:	84 ed       	ldi	r24, 0xD4	; 212
    4b9c:	9e e0       	ldi	r25, 0x0E	; 14
    4b9e:	9f 93       	push	r25
    4ba0:	8f 93       	push	r24
    4ba2:	81 e0       	ldi	r24, 0x01	; 1
    4ba4:	8f 93       	push	r24
    4ba6:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		interface->drop++;
    4baa:	f8 01       	movw	r30, r16
    4bac:	81 8d       	ldd	r24, Z+25	; 0x19
    4bae:	92 8d       	ldd	r25, Z+26	; 0x1a
    4bb0:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4bb2:	b4 8d       	ldd	r27, Z+28	; 0x1c
    4bb4:	01 96       	adiw	r24, 0x01	; 1
    4bb6:	a1 1d       	adc	r26, r1
    4bb8:	b1 1d       	adc	r27, r1
    4bba:	81 8f       	std	Z+25, r24	; 0x19
    4bbc:	92 8f       	std	Z+26, r25	; 0x1a
    4bbe:	a3 8f       	std	Z+27, r26	; 0x1b
    4bc0:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
    4bc2:	c7 01       	movw	r24, r14
    4bc4:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    4bc8:	0f 90       	pop	r0
    4bca:	0f 90       	pop	r0
    4bcc:	0f 90       	pop	r0
	} else {
		interface->rx++;
		interface->rxbytes += packet->length;
	}

}
    4bce:	0f 90       	pop	r0
    4bd0:	0f 90       	pop	r0
    4bd2:	0f 90       	pop	r0
    4bd4:	0f 90       	pop	r0
    4bd6:	df 91       	pop	r29
    4bd8:	cf 91       	pop	r28
    4bda:	1f 91       	pop	r17
    4bdc:	0f 91       	pop	r16
    4bde:	ff 90       	pop	r15
    4be0:	ef 90       	pop	r14
    4be2:	df 90       	pop	r13
    4be4:	cf 90       	pop	r12
    4be6:	08 95       	ret

00004be8 <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    4be8:	40 e0       	ldi	r20, 0x00	; 0
    4bea:	0c 94 d2 32 	jmp	0x65a4	; 0x65a4 <xQueueGenericCreate>
    4bee:	08 95       	ret

00004bf0 <csp_queue_enqueue>:
    4bf0:	0f 93       	push	r16
    4bf2:	1f 93       	push	r17
    4bf4:	cf 93       	push	r28
    4bf6:	df 93       	push	r29
    4bf8:	ec 01       	movw	r28, r24
    4bfa:	8b 01       	movw	r16, r22
    4bfc:	ca 01       	movw	r24, r20
    4bfe:	b9 01       	movw	r22, r18
    4c00:	6f 3f       	cpi	r22, 0xFF	; 255
    4c02:	2f ef       	ldi	r18, 0xFF	; 255
    4c04:	72 07       	cpc	r23, r18
    4c06:	81 05       	cpc	r24, r1
    4c08:	91 05       	cpc	r25, r1
    4c0a:	41 f0       	breq	.+16     	; 0x4c1c <csp_queue_enqueue+0x2c>
    4c0c:	2a e0       	ldi	r18, 0x0A	; 10
    4c0e:	30 e0       	ldi	r19, 0x00	; 0
    4c10:	40 e0       	ldi	r20, 0x00	; 0
    4c12:	50 e0       	ldi	r21, 0x00	; 0
    4c14:	0e 94 d8 41 	call	0x83b0	; 0x83b0 <__udivmodsi4>
    4c18:	ca 01       	movw	r24, r20
    4c1a:	b9 01       	movw	r22, r18
    4c1c:	20 e0       	ldi	r18, 0x00	; 0
    4c1e:	ab 01       	movw	r20, r22
    4c20:	b8 01       	movw	r22, r16
    4c22:	ce 01       	movw	r24, r28
    4c24:	0e 94 00 33 	call	0x6600	; 0x6600 <xQueueGenericSend>
    4c28:	08 2e       	mov	r0, r24
    4c2a:	00 0c       	add	r0, r0
    4c2c:	99 0b       	sbc	r25, r25
    4c2e:	df 91       	pop	r29
    4c30:	cf 91       	pop	r28
    4c32:	1f 91       	pop	r17
    4c34:	0f 91       	pop	r16
    4c36:	08 95       	ret

00004c38 <csp_queue_enqueue_isr>:
    4c38:	20 e0       	ldi	r18, 0x00	; 0
    4c3a:	0e 94 aa 33 	call	0x6754	; 0x6754 <xQueueGenericSendFromISR>
    4c3e:	08 2e       	mov	r0, r24
    4c40:	00 0c       	add	r0, r0
    4c42:	99 0b       	sbc	r25, r25
    4c44:	08 95       	ret

00004c46 <csp_queue_dequeue>:
    4c46:	0f 93       	push	r16
    4c48:	1f 93       	push	r17
    4c4a:	cf 93       	push	r28
    4c4c:	df 93       	push	r29
    4c4e:	ec 01       	movw	r28, r24
    4c50:	8b 01       	movw	r16, r22
    4c52:	2f 3f       	cpi	r18, 0xFF	; 255
    4c54:	8f ef       	ldi	r24, 0xFF	; 255
    4c56:	38 07       	cpc	r19, r24
    4c58:	41 05       	cpc	r20, r1
    4c5a:	51 05       	cpc	r21, r1
    4c5c:	41 f0       	breq	.+16     	; 0x4c6e <csp_queue_dequeue+0x28>
    4c5e:	ca 01       	movw	r24, r20
    4c60:	b9 01       	movw	r22, r18
    4c62:	2a e0       	ldi	r18, 0x0A	; 10
    4c64:	30 e0       	ldi	r19, 0x00	; 0
    4c66:	40 e0       	ldi	r20, 0x00	; 0
    4c68:	50 e0       	ldi	r21, 0x00	; 0
    4c6a:	0e 94 d8 41 	call	0x83b0	; 0x83b0 <__udivmodsi4>
    4c6e:	a9 01       	movw	r20, r18
    4c70:	b8 01       	movw	r22, r16
    4c72:	ce 01       	movw	r24, r28
    4c74:	0e 94 e2 33 	call	0x67c4	; 0x67c4 <xQueueReceive>
    4c78:	08 2e       	mov	r0, r24
    4c7a:	00 0c       	add	r0, r0
    4c7c:	99 0b       	sbc	r25, r25
    4c7e:	df 91       	pop	r29
    4c80:	cf 91       	pop	r28
    4c82:	1f 91       	pop	r17
    4c84:	0f 91       	pop	r16
    4c86:	08 95       	ret

00004c88 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    4c88:	0e 94 5c 35 	call	0x6ab8	; 0x6ab8 <uxQueueMessagesWaiting>
}
    4c8c:	90 e0       	ldi	r25, 0x00	; 0
    4c8e:	08 95       	ret

00004c90 <csp_route_security_check>:
 * @param security_opts either socket_opts or conn_opts
 * @param interface pointer to incoming interface
 * @param packet pointer to packet
 * @return -1 Missing feature, -2 XTEA error, -3 CRC error, -4 HMAC error, 0 = OK.
 */
static int csp_route_security_check(uint32_t security_opts, csp_iface_t * interface, csp_packet_t * packet) {
    4c90:	0f 93       	push	r16
    4c92:	1f 93       	push	r17
    4c94:	cf 93       	push	r28
    4c96:	df 93       	push	r29
    4c98:	8a 01       	movw	r16, r20
    4c9a:	e9 01       	movw	r28, r18
		return CSP_ERR_XTEA;
	}
#endif

	/* CRC32 verified packet */
	if (packet->id.flags & CSP_FCRC32) {
    4c9c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c9e:	80 ff       	sbrs	r24, 0
    4ca0:	32 c0       	rjmp	.+100    	; 0x4d06 <csp_route_security_check+0x76>
#ifdef CSP_USE_CRC32
		if (packet->length < 4)
    4ca2:	88 85       	ldd	r24, Y+8	; 0x08
    4ca4:	99 85       	ldd	r25, Y+9	; 0x09
    4ca6:	84 30       	cpi	r24, 0x04	; 4
    4ca8:	91 05       	cpc	r25, r1
    4caa:	70 f4       	brcc	.+28     	; 0x4cc8 <csp_route_security_check+0x38>
			csp_log_error("Too short packet for CRC32, %u", packet->length);
    4cac:	9f 93       	push	r25
    4cae:	8f 93       	push	r24
    4cb0:	88 ed       	ldi	r24, 0xD8	; 216
    4cb2:	9f e0       	ldi	r25, 0x0F	; 15
    4cb4:	9f 93       	push	r25
    4cb6:	8f 93       	push	r24
    4cb8:	1f 92       	push	r1
    4cba:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    4cbe:	0f 90       	pop	r0
    4cc0:	0f 90       	pop	r0
    4cc2:	0f 90       	pop	r0
    4cc4:	0f 90       	pop	r0
    4cc6:	0f 90       	pop	r0
		/* Verify CRC32 (does not include header for backwards compatability with csp1.x) */
		if (csp_crc32_verify(packet, false) != 0) {
    4cc8:	60 e0       	ldi	r22, 0x00	; 0
    4cca:	ce 01       	movw	r24, r28
    4ccc:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <csp_crc32_verify>
    4cd0:	00 97       	sbiw	r24, 0x00	; 0
    4cd2:	59 f1       	breq	.+86     	; 0x4d2a <csp_route_security_check+0x9a>
			/* Checksum failed */
			csp_log_error("CRC32 verification error! Discarding packet");
    4cd4:	8c ea       	ldi	r24, 0xAC	; 172
    4cd6:	9f e0       	ldi	r25, 0x0F	; 15
    4cd8:	9f 93       	push	r25
    4cda:	8f 93       	push	r24
    4cdc:	1f 92       	push	r1
    4cde:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			interface->rx_error++;
    4ce2:	f8 01       	movw	r30, r16
    4ce4:	85 89       	ldd	r24, Z+21	; 0x15
    4ce6:	96 89       	ldd	r25, Z+22	; 0x16
    4ce8:	a7 89       	ldd	r26, Z+23	; 0x17
    4cea:	b0 8d       	ldd	r27, Z+24	; 0x18
    4cec:	01 96       	adiw	r24, 0x01	; 1
    4cee:	a1 1d       	adc	r26, r1
    4cf0:	b1 1d       	adc	r27, r1
    4cf2:	85 8b       	std	Z+21, r24	; 0x15
    4cf4:	96 8b       	std	Z+22, r25	; 0x16
    4cf6:	a7 8b       	std	Z+23, r26	; 0x17
    4cf8:	b0 8f       	std	Z+24, r27	; 0x18
			return CSP_ERR_CRC32;
    4cfa:	0f 90       	pop	r0
    4cfc:	0f 90       	pop	r0
    4cfe:	0f 90       	pop	r0
    4d00:	8a e9       	ldi	r24, 0x9A	; 154
    4d02:	9f ef       	ldi	r25, 0xFF	; 255
    4d04:	12 c0       	rjmp	.+36     	; 0x4d2a <csp_route_security_check+0x9a>
		}
	} else if (security_opts & CSP_SO_CRC32REQ) {
    4d06:	66 ff       	sbrs	r22, 6
    4d08:	0e c0       	rjmp	.+28     	; 0x4d26 <csp_route_security_check+0x96>
		csp_log_warn("Received packet without CRC32. Accepting packet");
    4d0a:	8c e7       	ldi	r24, 0x7C	; 124
    4d0c:	9f e0       	ldi	r25, 0x0F	; 15
    4d0e:	9f 93       	push	r25
    4d10:	8f 93       	push	r24
    4d12:	81 e0       	ldi	r24, 0x01	; 1
    4d14:	8f 93       	push	r24
    4d16:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    4d1a:	0f 90       	pop	r0
    4d1c:	0f 90       	pop	r0
    4d1e:	0f 90       	pop	r0
			return CSP_ERR_INVAL;
		}
	}
#endif

	return CSP_ERR_NONE;
    4d20:	80 e0       	ldi	r24, 0x00	; 0
    4d22:	90 e0       	ldi	r25, 0x00	; 0
    4d24:	02 c0       	rjmp	.+4      	; 0x4d2a <csp_route_security_check+0x9a>
    4d26:	80 e0       	ldi	r24, 0x00	; 0
    4d28:	90 e0       	ldi	r25, 0x00	; 0

}
    4d2a:	df 91       	pop	r29
    4d2c:	cf 91       	pop	r28
    4d2e:	1f 91       	pop	r17
    4d30:	0f 91       	pop	r16
    4d32:	08 95       	ret

00004d34 <csp_route_work>:

int csp_route_work(uint32_t timeout) {
    4d34:	cf 92       	push	r12
    4d36:	df 92       	push	r13
    4d38:	ef 92       	push	r14
    4d3a:	ff 92       	push	r15
    4d3c:	0f 93       	push	r16
    4d3e:	1f 93       	push	r17
    4d40:	cf 93       	push	r28
    4d42:	df 93       	push	r29
    4d44:	00 d0       	rcall	.+0      	; 0x4d46 <csp_route_work+0x12>
    4d46:	00 d0       	rcall	.+0      	; 0x4d48 <csp_route_work+0x14>
    4d48:	cd b7       	in	r28, 0x3d	; 61
    4d4a:	de b7       	in	r29, 0x3e	; 62
	/* Check connection timeouts (currently only for RDP) */
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
    4d4c:	ce 01       	movw	r24, r28
    4d4e:	01 96       	adiw	r24, 0x01	; 1
    4d50:	85 de       	rcall	.-758    	; 0x4a5c <csp_qfifo_read>
    4d52:	6c 01       	movw	r12, r24
    4d54:	89 2b       	or	r24, r25
    4d56:	09 f0       	breq	.+2      	; 0x4d5a <csp_route_work+0x26>
    4d58:	a0 c1       	rjmp	.+832    	; 0x509a <csp_route_work+0x366>
		return -1;

	packet = input.packet;
    4d5a:	eb 81       	ldd	r30, Y+3	; 0x03
    4d5c:	fc 81       	ldd	r31, Y+4	; 0x04
    4d5e:	fe 83       	std	Y+6, r31	; 0x06
    4d60:	ed 83       	std	Y+5, r30	; 0x05

	csp_log_packet("INP: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %"PRIu16" VIA: %s",
    4d62:	a9 81       	ldd	r26, Y+1	; 0x01
    4d64:	ba 81       	ldd	r27, Y+2	; 0x02
    4d66:	11 96       	adiw	r26, 0x01	; 1
    4d68:	8c 91       	ld	r24, X
    4d6a:	11 97       	sbiw	r26, 0x01	; 1
    4d6c:	8f 93       	push	r24
    4d6e:	8c 91       	ld	r24, X
    4d70:	8f 93       	push	r24
    4d72:	81 85       	ldd	r24, Z+9	; 0x09
    4d74:	8f 93       	push	r24
    4d76:	80 85       	ldd	r24, Z+8	; 0x08
    4d78:	8f 93       	push	r24
    4d7a:	82 85       	ldd	r24, Z+10	; 0x0a
    4d7c:	1f 92       	push	r1
    4d7e:	8f 93       	push	r24
    4d80:	85 85       	ldd	r24, Z+13	; 0x0d
    4d82:	82 95       	swap	r24
    4d84:	86 95       	lsr	r24
    4d86:	86 95       	lsr	r24
    4d88:	83 70       	andi	r24, 0x03	; 3
    4d8a:	1f 92       	push	r1
    4d8c:	8f 93       	push	r24
    4d8e:	83 85       	ldd	r24, Z+11	; 0x0b
    4d90:	8f 73       	andi	r24, 0x3F	; 63
    4d92:	1f 92       	push	r1
    4d94:	8f 93       	push	r24
    4d96:	83 85       	ldd	r24, Z+11	; 0x0b
    4d98:	98 2f       	mov	r25, r24
    4d9a:	92 95       	swap	r25
    4d9c:	96 95       	lsr	r25
    4d9e:	96 95       	lsr	r25
    4da0:	93 70       	andi	r25, 0x03	; 3
    4da2:	84 85       	ldd	r24, Z+12	; 0x0c
    4da4:	8f 70       	andi	r24, 0x0F	; 15
    4da6:	88 0f       	add	r24, r24
    4da8:	88 0f       	add	r24, r24
    4daa:	89 2b       	or	r24, r25
    4dac:	1f 92       	push	r1
    4dae:	8f 93       	push	r24
    4db0:	84 85       	ldd	r24, Z+12	; 0x0c
    4db2:	98 2f       	mov	r25, r24
    4db4:	92 95       	swap	r25
    4db6:	9f 70       	andi	r25, 0x0F	; 15
    4db8:	85 85       	ldd	r24, Z+13	; 0x0d
    4dba:	81 70       	andi	r24, 0x01	; 1
    4dbc:	82 95       	swap	r24
    4dbe:	80 7f       	andi	r24, 0xF0	; 240
    4dc0:	89 2b       	or	r24, r25
    4dc2:	1f 92       	push	r1
    4dc4:	8f 93       	push	r24
    4dc6:	85 85       	ldd	r24, Z+13	; 0x0d
    4dc8:	86 95       	lsr	r24
    4dca:	8f 71       	andi	r24, 0x1F	; 31
    4dcc:	1f 92       	push	r1
    4dce:	8f 93       	push	r24
    4dd0:	8d e4       	ldi	r24, 0x4D	; 77
    4dd2:	91 e1       	ldi	r25, 0x11	; 17
    4dd4:	9f 93       	push	r25
    4dd6:	8f 93       	push	r24
    4dd8:	84 e0       	ldi	r24, 0x04	; 4
    4dda:	8f 93       	push	r24
    4ddc:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return 0;
	}
#endif

	/* If the message is not to me, route the message to the correct interface */
	if ((packet->id.dst != csp_get_address()) && (packet->id.dst != CSP_BROADCAST_ADDR)) {
    4de0:	ed 81       	ldd	r30, Y+5	; 0x05
    4de2:	fe 81       	ldd	r31, Y+6	; 0x06
    4de4:	04 85       	ldd	r16, Z+12	; 0x0c
    4de6:	80 2f       	mov	r24, r16
    4de8:	82 95       	swap	r24
    4dea:	8f 70       	andi	r24, 0x0F	; 15
    4dec:	05 85       	ldd	r16, Z+13	; 0x0d
    4dee:	01 70       	andi	r16, 0x01	; 1
    4df0:	02 95       	swap	r16
    4df2:	00 7f       	andi	r16, 0xF0	; 240
    4df4:	08 2b       	or	r16, r24
    4df6:	10 e0       	ldi	r17, 0x00	; 0
    4df8:	1b db       	rcall	.-2506   	; 0x4430 <csp_get_address>
    4dfa:	90 e0       	ldi	r25, 0x00	; 0
    4dfc:	0f b6       	in	r0, 0x3f	; 63
    4dfe:	f8 94       	cli
    4e00:	de bf       	out	0x3e, r29	; 62
    4e02:	0f be       	out	0x3f, r0	; 63
    4e04:	cd bf       	out	0x3d, r28	; 61
    4e06:	08 17       	cp	r16, r24
    4e08:	19 07       	cpc	r17, r25
    4e0a:	09 f4       	brne	.+2      	; 0x4e0e <csp_route_work+0xda>
    4e0c:	3f c0       	rjmp	.+126    	; 0x4e8c <csp_route_work+0x158>
    4e0e:	ed 81       	ldd	r30, Y+5	; 0x05
    4e10:	fe 81       	ldd	r31, Y+6	; 0x06
    4e12:	84 85       	ldd	r24, Z+12	; 0x0c
    4e14:	98 2f       	mov	r25, r24
    4e16:	92 95       	swap	r25
    4e18:	9f 70       	andi	r25, 0x0F	; 15
    4e1a:	85 85       	ldd	r24, Z+13	; 0x0d
    4e1c:	81 70       	andi	r24, 0x01	; 1
    4e1e:	82 95       	swap	r24
    4e20:	80 7f       	andi	r24, 0xF0	; 240
    4e22:	89 2b       	or	r24, r25
    4e24:	8f 31       	cpi	r24, 0x1F	; 31

		/* Find the destination interface */
		csp_iface_t * dstif = csp_rtable_find_iface(packet->id.dst);
    4e26:	91 f1       	breq	.+100    	; 0x4e8c <csp_route_work+0x158>
    4e28:	d6 d1       	rcall	.+940    	; 0x51d6 <csp_rtable_find_iface>
    4e2a:	fc 01       	movw	r30, r24

		/* If the message resolves to the input interface, don't loop it back out */
		if ((dstif == NULL) || ((dstif == input.interface) && (input.interface->split_horizon_off == 0))) {
    4e2c:	00 97       	sbiw	r24, 0x00	; 0
    4e2e:	41 f0       	breq	.+16     	; 0x4e40 <csp_route_work+0x10c>
    4e30:	29 81       	ldd	r18, Y+1	; 0x01
    4e32:	3a 81       	ldd	r19, Y+2	; 0x02
    4e34:	82 17       	cp	r24, r18
    4e36:	93 07       	cpc	r25, r19
    4e38:	41 f4       	brne	.+16     	; 0x4e4a <csp_route_work+0x116>
    4e3a:	20 85       	ldd	r18, Z+8	; 0x08
    4e3c:	21 11       	cpse	r18, r1
    4e3e:	05 c0       	rjmp	.+10     	; 0x4e4a <csp_route_work+0x116>
			csp_buffer_free(packet);
    4e40:	8d 81       	ldd	r24, Y+5	; 0x05
    4e42:	9e 81       	ldd	r25, Y+6	; 0x06
    4e44:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    4e48:	67 c1       	rjmp	.+718    	; 0x5118 <csp_route_work+0x3e4>
		}

		/* Otherwise, actually send the message */
		if (csp_send_direct(packet->id, packet, dstif, 0) != CSP_ERR_NONE) {
    4e4a:	4d 81       	ldd	r20, Y+5	; 0x05
    4e4c:	5e 81       	ldd	r21, Y+6	; 0x06
    4e4e:	da 01       	movw	r26, r20
    4e50:	1a 96       	adiw	r26, 0x0a	; 10
    4e52:	6d 91       	ld	r22, X+
    4e54:	7d 91       	ld	r23, X+
    4e56:	8d 91       	ld	r24, X+
    4e58:	9c 91       	ld	r25, X
    4e5a:	1d 97       	sbiw	r26, 0x0d	; 13
    4e5c:	e1 2c       	mov	r14, r1
    4e5e:	f1 2c       	mov	r15, r1
    4e60:	87 01       	movw	r16, r14
    4e62:	9f 01       	movw	r18, r30
    4e64:	d7 db       	rcall	.-2130   	; 0x4614 <csp_send_direct>
    4e66:	00 97       	sbiw	r24, 0x00	; 0
    4e68:	09 f4       	brne	.+2      	; 0x4e6c <csp_route_work+0x138>
    4e6a:	1b c1       	rjmp	.+566    	; 0x50a2 <csp_route_work+0x36e>
			csp_log_warn("Router failed to send");
    4e6c:	87 e3       	ldi	r24, 0x37	; 55
    4e6e:	91 e1       	ldi	r25, 0x11	; 17
    4e70:	9f 93       	push	r25
    4e72:	8f 93       	push	r24
    4e74:	81 e0       	ldi	r24, 0x01	; 1
    4e76:	8f 93       	push	r24
    4e78:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			csp_buffer_free(packet);
    4e7c:	8d 81       	ldd	r24, Y+5	; 0x05
    4e7e:	9e 81       	ldd	r25, Y+6	; 0x06
    4e80:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    4e84:	0f 90       	pop	r0
    4e86:	0f 90       	pop	r0
    4e88:	0f 90       	pop	r0
    4e8a:	46 c1       	rjmp	.+652    	; 0x5118 <csp_route_work+0x3e4>
		/* Next message, please */
		return 0;
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
    4e8c:	ed 81       	ldd	r30, Y+5	; 0x05
    4e8e:	fe 81       	ldd	r31, Y+6	; 0x06
    4e90:	09 81       	ldd	r16, Y+1	; 0x01
    4e92:	1a 81       	ldd	r17, Y+2	; 0x02
 */
static int csp_route_check_options(csp_iface_t *interface, csp_packet_t *packet)
{
#ifndef CSP_USE_XTEA
	/* Drop XTEA packets */
	if (packet->id.flags & CSP_FXTEA) {
    4e94:	82 85       	ldd	r24, Z+10	; 0x0a
    4e96:	82 ff       	sbrs	r24, 2
    4e98:	17 c0       	rjmp	.+46     	; 0x4ec8 <csp_route_work+0x194>
		csp_log_error("Received XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4e9a:	80 ea       	ldi	r24, 0xA0	; 160
    4e9c:	90 e1       	ldi	r25, 0x10	; 16
    4e9e:	9f 93       	push	r25
    4ea0:	8f 93       	push	r24
    4ea2:	1f 92       	push	r1
    4ea4:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		interface->autherr++;
    4ea8:	f8 01       	movw	r30, r16
    4eaa:	85 8d       	ldd	r24, Z+29	; 0x1d
    4eac:	96 8d       	ldd	r25, Z+30	; 0x1e
    4eae:	a7 8d       	ldd	r26, Z+31	; 0x1f
    4eb0:	b0 a1       	ldd	r27, Z+32	; 0x20
    4eb2:	01 96       	adiw	r24, 0x01	; 1
    4eb4:	a1 1d       	adc	r26, r1
    4eb6:	b1 1d       	adc	r27, r1
    4eb8:	85 8f       	std	Z+29, r24	; 0x1d
    4eba:	96 8f       	std	Z+30, r25	; 0x1e
    4ebc:	a7 8f       	std	Z+31, r26	; 0x1f
    4ebe:	b0 a3       	std	Z+32, r27	; 0x20
    4ec0:	0f 90       	pop	r0
    4ec2:	0f 90       	pop	r0
    4ec4:	0f 90       	pop	r0
    4ec6:	ef c0       	rjmp	.+478    	; 0x50a6 <csp_route_work+0x372>
	}
#endif

#ifndef CSP_USE_HMAC
	/* Drop HMAC packets */
	if (packet->id.flags & CSP_FHMAC) {
    4ec8:	83 ff       	sbrs	r24, 3
    4eca:	17 c0       	rjmp	.+46     	; 0x4efa <csp_route_work+0x1c6>
		csp_log_error("Received packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    4ecc:	88 e4       	ldi	r24, 0x48	; 72
    4ece:	90 e1       	ldi	r25, 0x10	; 16
    4ed0:	9f 93       	push	r25
    4ed2:	8f 93       	push	r24
    4ed4:	1f 92       	push	r1
    4ed6:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		interface->autherr++;
    4eda:	f8 01       	movw	r30, r16
    4edc:	85 8d       	ldd	r24, Z+29	; 0x1d
    4ede:	96 8d       	ldd	r25, Z+30	; 0x1e
    4ee0:	a7 8d       	ldd	r26, Z+31	; 0x1f
    4ee2:	b0 a1       	ldd	r27, Z+32	; 0x20
    4ee4:	01 96       	adiw	r24, 0x01	; 1
    4ee6:	a1 1d       	adc	r26, r1
    4ee8:	b1 1d       	adc	r27, r1
    4eea:	85 8f       	std	Z+29, r24	; 0x1d
    4eec:	96 8f       	std	Z+30, r25	; 0x1e
    4eee:	a7 8f       	std	Z+31, r26	; 0x1f
    4ef0:	b0 a3       	std	Z+32, r27	; 0x20
    4ef2:	0f 90       	pop	r0
    4ef4:	0f 90       	pop	r0
    4ef6:	0f 90       	pop	r0
    4ef8:	d6 c0       	rjmp	.+428    	; 0x50a6 <csp_route_work+0x372>
	}
#endif

#ifndef CSP_USE_RDP
	/* Drop RDP packets */
	if (packet->id.flags & CSP_FRDP) {
    4efa:	81 ff       	sbrs	r24, 1
    4efc:	d9 c0       	rjmp	.+434    	; 0x50b0 <csp_route_work+0x37c>
		csp_log_error("Received RDP packet, but CSP was compiled without RDP support. Discarding packet");
    4efe:	87 ef       	ldi	r24, 0xF7	; 247
    4f00:	9f e0       	ldi	r25, 0x0F	; 15
    4f02:	9f 93       	push	r25
    4f04:	8f 93       	push	r24
    4f06:	1f 92       	push	r1
    4f08:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		interface->rx_error++;
    4f0c:	f8 01       	movw	r30, r16
    4f0e:	85 89       	ldd	r24, Z+21	; 0x15
    4f10:	96 89       	ldd	r25, Z+22	; 0x16
    4f12:	a7 89       	ldd	r26, Z+23	; 0x17
    4f14:	b0 8d       	ldd	r27, Z+24	; 0x18
    4f16:	01 96       	adiw	r24, 0x01	; 1
    4f18:	a1 1d       	adc	r26, r1
    4f1a:	b1 1d       	adc	r27, r1
    4f1c:	85 8b       	std	Z+21, r24	; 0x15
    4f1e:	96 8b       	std	Z+22, r25	; 0x16
    4f20:	a7 8b       	std	Z+23, r26	; 0x17
    4f22:	b0 8f       	std	Z+24, r27	; 0x18
    4f24:	0f 90       	pop	r0
    4f26:	0f 90       	pop	r0
    4f28:	0f 90       	pop	r0
    4f2a:	bd c0       	rjmp	.+378    	; 0x50a6 <csp_route_work+0x372>

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    4f2c:	d8 01       	movw	r26, r16
    4f2e:	54 96       	adiw	r26, 0x14	; 20
    4f30:	6d 91       	ld	r22, X+
    4f32:	7d 91       	ld	r23, X+
    4f34:	8d 91       	ld	r24, X+
    4f36:	9c 91       	ld	r25, X
    4f38:	57 97       	sbiw	r26, 0x17	; 23
    4f3a:	70 ff       	sbrs	r23, 0
    4f3c:	cb c0       	rjmp	.+406    	; 0x50d4 <csp_route_work+0x3a0>
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    4f3e:	2d 81       	ldd	r18, Y+5	; 0x05
    4f40:	3e 81       	ldd	r19, Y+6	; 0x06
    4f42:	49 81       	ldd	r20, Y+1	; 0x01
    4f44:	5a 81       	ldd	r21, Y+2	; 0x02
    4f46:	a4 de       	rcall	.-696    	; 0x4c90 <csp_route_security_check>
    4f48:	99 23       	and	r25, r25
    4f4a:	2c f4       	brge	.+10     	; 0x4f56 <csp_route_work+0x222>
			csp_buffer_free(packet);
    4f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    4f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    4f50:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    4f54:	e1 c0       	rjmp	.+450    	; 0x5118 <csp_route_work+0x3e4>
		}
		if (csp_queue_enqueue(socket->socket, &packet, 0) != CSP_QUEUE_OK) {
    4f56:	20 e0       	ldi	r18, 0x00	; 0
    4f58:	30 e0       	ldi	r19, 0x00	; 0
    4f5a:	a9 01       	movw	r20, r18
    4f5c:	be 01       	movw	r22, r28
    4f5e:	6b 5f       	subi	r22, 0xFB	; 251
    4f60:	7f 4f       	sbci	r23, 0xFF	; 255
    4f62:	f8 01       	movw	r30, r16
    4f64:	86 85       	ldd	r24, Z+14	; 0x0e
    4f66:	97 85       	ldd	r25, Z+15	; 0x0f
    4f68:	43 de       	rcall	.-890    	; 0x4bf0 <csp_queue_enqueue>
    4f6a:	01 97       	sbiw	r24, 0x01	; 1
    4f6c:	09 f4       	brne	.+2      	; 0x4f70 <csp_route_work+0x23c>
    4f6e:	d4 c0       	rjmp	.+424    	; 0x5118 <csp_route_work+0x3e4>
			csp_log_error("Conn-less socket queue full");
    4f70:	8b e1       	ldi	r24, 0x1B	; 27
    4f72:	91 e1       	ldi	r25, 0x11	; 17
    4f74:	9f 93       	push	r25
    4f76:	8f 93       	push	r24
    4f78:	1f 92       	push	r1
    4f7a:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			csp_buffer_free(packet);
    4f7e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f80:	9e 81       	ldd	r25, Y+6	; 0x06
    4f82:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    4f86:	0f 90       	pop	r0
    4f88:	0f 90       	pop	r0
    4f8a:	0f 90       	pop	r0
    4f8c:	c5 c0       	rjmp	.+394    	; 0x5118 <csp_route_work+0x3e4>
	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {

		/* Reject packet if no matching socket is found */
		if (!socket) {
			csp_buffer_free(packet);
    4f8e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f90:	9e 81       	ldd	r25, Y+6	; 0x06
    4f92:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    4f96:	c0 c0       	rjmp	.+384    	; 0x5118 <csp_route_work+0x3e4>
		}

		/* Run security check on incoming packet */
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    4f98:	2d 81       	ldd	r18, Y+5	; 0x05
    4f9a:	3e 81       	ldd	r19, Y+6	; 0x06
    4f9c:	49 81       	ldd	r20, Y+1	; 0x01
    4f9e:	5a 81       	ldd	r21, Y+2	; 0x02
    4fa0:	d8 01       	movw	r26, r16
    4fa2:	54 96       	adiw	r26, 0x14	; 20
    4fa4:	6d 91       	ld	r22, X+
    4fa6:	7d 91       	ld	r23, X+
    4fa8:	8d 91       	ld	r24, X+
    4faa:	9c 91       	ld	r25, X
    4fac:	57 97       	sbiw	r26, 0x17	; 23
    4fae:	70 de       	rcall	.-800    	; 0x4c90 <csp_route_security_check>
    4fb0:	99 23       	and	r25, r25
    4fb2:	2c f4       	brge	.+10     	; 0x4fbe <csp_route_work+0x28a>
			csp_buffer_free(packet);
    4fb4:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb6:	9e 81       	ldd	r25, Y+6	; 0x06
    4fb8:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
		}

		/* New incoming connection accepted */
		csp_id_t idout;
		idout.pri   = packet->id.pri;
    4fbc:	ad c0       	rjmp	.+346    	; 0x5118 <csp_route_work+0x3e4>
    4fbe:	ed 81       	ldd	r30, Y+5	; 0x05
    4fc0:	fe 81       	ldd	r31, Y+6	; 0x06
    4fc2:	85 85       	ldd	r24, Z+13	; 0x0d
    4fc4:	80 7c       	andi	r24, 0xC0	; 192
		idout.src   = csp_get_address();
    4fc6:	f8 2e       	mov	r15, r24
    4fc8:	33 da       	rcall	.-2970   	; 0x4430 <csp_get_address>
    4fca:	8f 71       	andi	r24, 0x1F	; 31
    4fcc:	88 0f       	add	r24, r24
    4fce:	f8 2a       	or	r15, r24

		idout.dst   = packet->id.src;
    4fd0:	ed 81       	ldd	r30, Y+5	; 0x05
    4fd2:	fe 81       	ldd	r31, Y+6	; 0x06
    4fd4:	85 85       	ldd	r24, Z+13	; 0x0d
    4fd6:	86 95       	lsr	r24
    4fd8:	84 fb       	bst	r24, 4
    4fda:	99 27       	eor	r25, r25
    4fdc:	90 f9       	bld	r25, 0
    4fde:	f9 2a       	or	r15, r25
		idout.dport = packet->id.sport;
    4fe0:	53 85       	ldd	r21, Z+11	; 0x0b
    4fe2:	45 2f       	mov	r20, r21
    4fe4:	4f 73       	andi	r20, 0x3F	; 63
    4fe6:	46 95       	lsr	r20
    4fe8:	46 95       	lsr	r20
    4fea:	82 95       	swap	r24
    4fec:	80 7f       	andi	r24, 0xF0	; 240
    4fee:	48 2b       	or	r20, r24
		idout.sport = packet->id.dport;
    4ff0:	25 2f       	mov	r18, r21
    4ff2:	22 95       	swap	r18
    4ff4:	26 95       	lsr	r18
    4ff6:	26 95       	lsr	r18
    4ff8:	23 70       	andi	r18, 0x03	; 3
    4ffa:	34 85       	ldd	r19, Z+12	; 0x0c
    4ffc:	3f 70       	andi	r19, 0x0F	; 15
    4ffe:	33 0f       	add	r19, r19
    5000:	33 0f       	add	r19, r19
    5002:	93 2f       	mov	r25, r19
    5004:	92 2b       	or	r25, r18
    5006:	35 2f       	mov	r19, r21
    5008:	32 95       	swap	r19
    500a:	33 0f       	add	r19, r19
    500c:	33 0f       	add	r19, r19
    500e:	30 7c       	andi	r19, 0xC0	; 192
    5010:	39 2b       	or	r19, r25
		idout.flags = packet->id.flags;
    5012:	22 85       	ldd	r18, Z+10	; 0x0a

		/* Create connection */
		conn = csp_conn_new(packet->id, idout);
    5014:	62 85       	ldd	r22, Z+10	; 0x0a
    5016:	73 85       	ldd	r23, Z+11	; 0x0b
    5018:	84 85       	ldd	r24, Z+12	; 0x0c
    501a:	95 85       	ldd	r25, Z+13	; 0x0d
    501c:	5f 2d       	mov	r21, r15
    501e:	0e 94 98 18 	call	0x3130	; 0x3130 <csp_conn_new>
    5022:	7c 01       	movw	r14, r24

		if (!conn) {
    5024:	89 2b       	or	r24, r25
    5026:	79 f4       	brne	.+30     	; 0x5046 <csp_route_work+0x312>
			csp_log_error("No more connections available");
    5028:	8d ef       	ldi	r24, 0xFD	; 253
    502a:	90 e1       	ldi	r25, 0x10	; 16
    502c:	9f 93       	push	r25
    502e:	8f 93       	push	r24
    5030:	1f 92       	push	r1
    5032:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			csp_buffer_free(packet);
    5036:	8d 81       	ldd	r24, Y+5	; 0x05
    5038:	9e 81       	ldd	r25, Y+6	; 0x06
    503a:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    503e:	0f 90       	pop	r0
    5040:	0f 90       	pop	r0
    5042:	0f 90       	pop	r0
    5044:	69 c0       	rjmp	.+210    	; 0x5118 <csp_route_work+0x3e4>
		}

		/* Store the socket queue and options */
		conn->socket = socket->socket;
    5046:	f8 01       	movw	r30, r16
    5048:	86 85       	ldd	r24, Z+14	; 0x0e
    504a:	97 85       	ldd	r25, Z+15	; 0x0f
    504c:	d7 01       	movw	r26, r14
    504e:	1f 96       	adiw	r26, 0x0f	; 15
    5050:	9c 93       	st	X, r25
    5052:	8e 93       	st	-X, r24
    5054:	1e 97       	sbiw	r26, 0x0e	; 14
		conn->opts = socket->opts;
    5056:	84 89       	ldd	r24, Z+20	; 0x14
    5058:	95 89       	ldd	r25, Z+21	; 0x15
    505a:	a6 89       	ldd	r26, Z+22	; 0x16
    505c:	b7 89       	ldd	r27, Z+23	; 0x17
    505e:	f7 01       	movw	r30, r14
    5060:	84 8b       	std	Z+20, r24	; 0x14
    5062:	95 8b       	std	Z+21, r25	; 0x15
    5064:	a6 8b       	std	Z+22, r26	; 0x16
    5066:	b7 8b       	std	Z+23, r27	; 0x17
    5068:	13 c0       	rjmp	.+38     	; 0x5090 <csp_route_work+0x35c>

	/* Packet to existing connection */
	} else {

		/* Run security check on incoming packet */
		if (csp_route_security_check(conn->opts, input.interface, packet) < 0) {
    506a:	2d 81       	ldd	r18, Y+5	; 0x05
    506c:	3e 81       	ldd	r19, Y+6	; 0x06
    506e:	49 81       	ldd	r20, Y+1	; 0x01
    5070:	5a 81       	ldd	r21, Y+2	; 0x02
    5072:	d7 01       	movw	r26, r14
    5074:	54 96       	adiw	r26, 0x14	; 20
    5076:	6d 91       	ld	r22, X+
    5078:	7d 91       	ld	r23, X+
    507a:	8d 91       	ld	r24, X+
    507c:	9c 91       	ld	r25, X
    507e:	57 97       	sbiw	r26, 0x17	; 23
    5080:	07 de       	rcall	.-1010   	; 0x4c90 <csp_route_security_check>
    5082:	99 23       	and	r25, r25
    5084:	2c f4       	brge	.+10     	; 0x5090 <csp_route_work+0x35c>
			csp_buffer_free(packet);
    5086:	8d 81       	ldd	r24, Y+5	; 0x05
    5088:	9e 81       	ldd	r25, Y+6	; 0x06
    508a:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return 0;
    508e:	44 c0       	rjmp	.+136    	; 0x5118 <csp_route_work+0x3e4>
		return 0;
	}
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
    5090:	6d 81       	ldd	r22, Y+5	; 0x05
    5092:	7e 81       	ldd	r23, Y+6	; 0x06
    5094:	c7 01       	movw	r24, r14
    5096:	e9 d5       	rcall	.+3026   	; 0x5c6a <csp_udp_new_packet>
    5098:	3f c0       	rjmp	.+126    	; 0x5118 <csp_route_work+0x3e4>
	return 0;
    509a:	cc 24       	eor	r12, r12
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
		return -1;
    509c:	ca 94       	dec	r12
    509e:	dc 2c       	mov	r13, r12
    50a0:	3b c0       	rjmp	.+118    	; 0x5118 <csp_route_work+0x3e4>
    50a2:	6c 01       	movw	r12, r24
			csp_log_warn("Router failed to send");
			csp_buffer_free(packet);
		}

		/* Next message, please */
		return 0;
    50a4:	39 c0       	rjmp	.+114    	; 0x5118 <csp_route_work+0x3e4>
    50a6:	8d 81       	ldd	r24, Y+5	; 0x05
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
		csp_buffer_free(packet);
    50a8:	9e 81       	ldd	r25, Y+6	; 0x06
    50aa:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    50ae:	34 c0       	rjmp	.+104    	; 0x5118 <csp_route_work+0x3e4>
		return 0;
    50b0:	83 85       	ldd	r24, Z+11	; 0x0b
	}

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);
    50b2:	98 2f       	mov	r25, r24
    50b4:	92 95       	swap	r25
    50b6:	96 95       	lsr	r25
    50b8:	96 95       	lsr	r25
    50ba:	93 70       	andi	r25, 0x03	; 3
    50bc:	84 85       	ldd	r24, Z+12	; 0x0c
    50be:	8f 70       	andi	r24, 0x0F	; 15
    50c0:	88 0f       	add	r24, r24
    50c2:	88 0f       	add	r24, r24
    50c4:	89 2b       	or	r24, r25
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	03 dc       	rcall	.-2042   	; 0x48d0 <csp_port_get_socket>
    50ca:	8c 01       	movw	r16, r24
    50cc:	89 2b       	or	r24, r25

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    50ce:	09 f0       	breq	.+2      	; 0x50d2 <csp_route_work+0x39e>
    50d0:	2d cf       	rjmp	.-422    	; 0x4f2c <csp_route_work+0x1f8>
    50d2:	11 c0       	rjmp	.+34     	; 0x50f6 <csp_route_work+0x3c2>
    50d4:	ed 81       	ldd	r30, Y+5	; 0x05
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    50d6:	fe 81       	ldd	r31, Y+6	; 0x06
    50d8:	62 85       	ldd	r22, Z+10	; 0x0a
    50da:	73 85       	ldd	r23, Z+11	; 0x0b
    50dc:	84 85       	ldd	r24, Z+12	; 0x0c
    50de:	95 85       	ldd	r25, Z+13	; 0x0d
    50e0:	20 e0       	ldi	r18, 0x00	; 0
    50e2:	3f ef       	ldi	r19, 0xFF	; 255
    50e4:	4f ef       	ldi	r20, 0xFF	; 255
    50e6:	5f e3       	ldi	r21, 0x3F	; 63
    50e8:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <csp_conn_find>
    50ec:	7c 01       	movw	r14, r24
    50ee:	89 2b       	or	r24, r25

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    50f0:	09 f0       	breq	.+2      	; 0x50f4 <csp_route_work+0x3c0>
    50f2:	bb cf       	rjmp	.-138    	; 0x506a <csp_route_work+0x336>
    50f4:	51 cf       	rjmp	.-350    	; 0x4f98 <csp_route_work+0x264>
    50f6:	ed 81       	ldd	r30, Y+5	; 0x05
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    50f8:	fe 81       	ldd	r31, Y+6	; 0x06
    50fa:	62 85       	ldd	r22, Z+10	; 0x0a
    50fc:	73 85       	ldd	r23, Z+11	; 0x0b
    50fe:	84 85       	ldd	r24, Z+12	; 0x0c
    5100:	95 85       	ldd	r25, Z+13	; 0x0d
    5102:	20 e0       	ldi	r18, 0x00	; 0
    5104:	3f ef       	ldi	r19, 0xFF	; 255
    5106:	4f ef       	ldi	r20, 0xFF	; 255
    5108:	5f e3       	ldi	r21, 0x3F	; 63
    510a:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <csp_conn_find>
    510e:	7c 01       	movw	r14, r24
    5110:	89 2b       	or	r24, r25

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    5112:	09 f0       	breq	.+2      	; 0x5116 <csp_route_work+0x3e2>
    5114:	aa cf       	rjmp	.-172    	; 0x506a <csp_route_work+0x336>
    5116:	3b cf       	rjmp	.-394    	; 0x4f8e <csp_route_work+0x25a>
    5118:	c6 01       	movw	r24, r12
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
	return 0;
}
    511a:	26 96       	adiw	r28, 0x06	; 6
    511c:	0f b6       	in	r0, 0x3f	; 63
    511e:	f8 94       	cli
    5120:	de bf       	out	0x3e, r29	; 62
    5122:	0f be       	out	0x3f, r0	; 63
    5124:	cd bf       	out	0x3d, r28	; 61
    5126:	df 91       	pop	r29
    5128:	cf 91       	pop	r28
    512a:	1f 91       	pop	r17
    512c:	0f 91       	pop	r16
    512e:	ff 90       	pop	r15
    5130:	ef 90       	pop	r14
    5132:	df 90       	pop	r13
    5134:	cf 90       	pop	r12
    5136:	08 95       	ret

00005138 <csp_task_router>:
    5138:	c9 e5       	ldi	r28, 0x59	; 89

static CSP_DEFINE_TASK(csp_task_router) {

	/* Here there be routing */
	while (1) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    513a:	df e0       	ldi	r29, 0x0F	; 15
    513c:	68 94       	set
    513e:	ff 24       	eor	r15, r15
    5140:	f1 f8       	bld	r15, 1
    5142:	80 e0       	ldi	r24, 0x00	; 0
    5144:	90 e0       	ldi	r25, 0x00	; 0
    5146:	0e 94 b6 3b 	call	0x776c	; 0x776c <uxTaskGetStackHighWaterMark2>
    514a:	18 2f       	mov	r17, r24
    514c:	09 2f       	mov	r16, r25
    514e:	80 e0       	ldi	r24, 0x00	; 0
    5150:	90 e0       	ldi	r25, 0x00	; 0
    5152:	0e 94 9c 38 	call	0x7138	; 0x7138 <pcTaskGetName>
    5156:	0f 93       	push	r16
    5158:	1f 93       	push	r17
    515a:	9f 93       	push	r25
    515c:	8f 93       	push	r24
    515e:	df 93       	push	r29
    5160:	cf 93       	push	r28
    5162:	ff 92       	push	r15
    5164:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		csp_route_work(FIFO_TIMEOUT);
    5168:	6f ef       	ldi	r22, 0xFF	; 255
    516a:	7f ef       	ldi	r23, 0xFF	; 255
    516c:	80 e0       	ldi	r24, 0x00	; 0
    516e:	90 e0       	ldi	r25, 0x00	; 0
    5170:	e1 dd       	rcall	.-1086   	; 0x4d34 <csp_route_work>
    5172:	8d b7       	in	r24, 0x3d	; 61
    5174:	9e b7       	in	r25, 0x3e	; 62
    5176:	07 96       	adiw	r24, 0x07	; 7
    5178:	0f b6       	in	r0, 0x3f	; 63
    517a:	f8 94       	cli
    517c:	9e bf       	out	0x3e, r25	; 62
    517e:	0f be       	out	0x3f, r0	; 63
    5180:	8d bf       	out	0x3d, r24	; 61
    5182:	df cf       	rjmp	.-66     	; 0x5142 <csp_task_router+0xa>

00005184 <csp_route_start_task>:
	}

}

int csp_route_start_task(unsigned int task_stack_size, unsigned int priority) {
    5184:	ef 92       	push	r14
    5186:	ff 92       	push	r15
    5188:	0f 93       	push	r16
    518a:	1f 93       	push	r17

	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);
    518c:	0f 2e       	mov	r0, r31
    518e:	ff e0       	ldi	r31, 0x0F	; 15
    5190:	ef 2e       	mov	r14, r31
    5192:	f6 e0       	ldi	r31, 0x06	; 6
    5194:	ff 2e       	mov	r15, r31
    5196:	f0 2d       	mov	r31, r0
    5198:	8b 01       	movw	r16, r22
    519a:	20 e0       	ldi	r18, 0x00	; 0
    519c:	30 e0       	ldi	r19, 0x00	; 0
    519e:	ac 01       	movw	r20, r24
    51a0:	6f e8       	ldi	r22, 0x8F	; 143
    51a2:	72 e0       	ldi	r23, 0x02	; 2
    51a4:	8c e9       	ldi	r24, 0x9C	; 156
    51a6:	98 e2       	ldi	r25, 0x28	; 40
    51a8:	2c d5       	rcall	.+2648   	; 0x5c02 <csp_thread_create>

	if (ret != 0) {
    51aa:	89 2b       	or	r24, r25
    51ac:	69 f0       	breq	.+26     	; 0x51c8 <csp_route_start_task+0x44>
		csp_log_error("Failed to start router task");
    51ae:	80 e6       	ldi	r24, 0x60	; 96
    51b0:	9f e0       	ldi	r25, 0x0F	; 15
    51b2:	9f 93       	push	r25
    51b4:	8f 93       	push	r24
    51b6:	1f 92       	push	r1
    51b8:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return CSP_ERR_NOMEM;
    51bc:	0f 90       	pop	r0
    51be:	0f 90       	pop	r0
    51c0:	0f 90       	pop	r0
    51c2:	8f ef       	ldi	r24, 0xFF	; 255
    51c4:	9f ef       	ldi	r25, 0xFF	; 255
    51c6:	02 c0       	rjmp	.+4      	; 0x51cc <csp_route_start_task+0x48>
	}

	return CSP_ERR_NONE;
    51c8:	80 e0       	ldi	r24, 0x00	; 0
    51ca:	90 e0       	ldi	r25, 0x00	; 0

}
    51cc:	1f 91       	pop	r17
    51ce:	0f 91       	pop	r16
    51d0:	ff 90       	pop	r15
    51d2:	ef 90       	pop	r14
    51d4:	08 95       	ret

000051d6 <csp_rtable_find_iface>:
void csp_route_table_load(uint8_t route_table_in[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(routes, route_table_in, sizeof(routes[0]) * CSP_ROUTE_COUNT);
}

void csp_route_table_save(uint8_t route_table_out[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(route_table_out, routes, sizeof(routes[0]) * CSP_ROUTE_COUNT);
    51d6:	90 e0       	ldi	r25, 0x00	; 0
    51d8:	fc 01       	movw	r30, r24
    51da:	ee 0f       	add	r30, r30
    51dc:	ff 1f       	adc	r31, r31
    51de:	e8 0f       	add	r30, r24
    51e0:	f9 1f       	adc	r31, r25
    51e2:	ef 5e       	subi	r30, 0xEF	; 239
    51e4:	f9 4f       	sbci	r31, 0xF9	; 249
    51e6:	20 81       	ld	r18, Z
    51e8:	31 81       	ldd	r19, Z+1	; 0x01
    51ea:	23 2b       	or	r18, r19
    51ec:	49 f0       	breq	.+18     	; 0x5200 <csp_rtable_find_iface+0x2a>
    51ee:	fc 01       	movw	r30, r24
    51f0:	ee 0f       	add	r30, r30
    51f2:	ff 1f       	adc	r31, r31
    51f4:	8e 0f       	add	r24, r30
    51f6:	9f 1f       	adc	r25, r31
    51f8:	fc 01       	movw	r30, r24
    51fa:	ef 5e       	subi	r30, 0xEF	; 239
    51fc:	f9 4f       	sbci	r31, 0xF9	; 249
    51fe:	08 c0       	rjmp	.+16     	; 0x5210 <csp_rtable_find_iface+0x3a>
    5200:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <routes+0x60>
    5204:	90 91 72 06 	lds	r25, 0x0672	; 0x800672 <routes+0x61>
    5208:	00 97       	sbiw	r24, 0x00	; 0
    520a:	21 f0       	breq	.+8      	; 0x5214 <csp_rtable_find_iface+0x3e>
    520c:	e1 e7       	ldi	r30, 0x71	; 113
    520e:	f6 e0       	ldi	r31, 0x06	; 6
    5210:	80 81       	ld	r24, Z
    5212:	91 81       	ldd	r25, Z+1	; 0x01
    5214:	08 95       	ret

00005216 <csp_rtable_find_mac>:
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	fc 01       	movw	r30, r24
    521a:	ee 0f       	add	r30, r30
    521c:	ff 1f       	adc	r31, r31
    521e:	e8 0f       	add	r30, r24
    5220:	f9 1f       	adc	r31, r25
    5222:	ef 5e       	subi	r30, 0xEF	; 239
    5224:	f9 4f       	sbci	r31, 0xF9	; 249
    5226:	20 81       	ld	r18, Z
    5228:	31 81       	ldd	r19, Z+1	; 0x01
    522a:	23 2b       	or	r18, r19
    522c:	49 f0       	breq	.+18     	; 0x5240 <csp_rtable_find_mac+0x2a>
    522e:	fc 01       	movw	r30, r24
    5230:	ee 0f       	add	r30, r30
    5232:	ff 1f       	adc	r31, r31
    5234:	8e 0f       	add	r24, r30
    5236:	9f 1f       	adc	r25, r31
    5238:	fc 01       	movw	r30, r24
    523a:	ef 5e       	subi	r30, 0xEF	; 239
    523c:	f9 4f       	sbci	r31, 0xF9	; 249
    523e:	08 c0       	rjmp	.+16     	; 0x5250 <csp_rtable_find_mac+0x3a>
    5240:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <routes+0x60>
    5244:	90 91 72 06 	lds	r25, 0x0672	; 0x800672 <routes+0x61>
    5248:	89 2b       	or	r24, r25
    524a:	21 f0       	breq	.+8      	; 0x5254 <csp_rtable_find_mac+0x3e>
    524c:	e1 e7       	ldi	r30, 0x71	; 113
    524e:	f6 e0       	ldi	r31, 0x06	; 6
    5250:	82 81       	ldd	r24, Z+2	; 0x02
    5252:	08 95       	ret
    5254:	8f ef       	ldi	r24, 0xFF	; 255
    5256:	08 95       	ret

00005258 <csp_rtable_set>:
}

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {
    5258:	0f 93       	push	r16
    525a:	1f 93       	push	r17
    525c:	cf 93       	push	r28
    525e:	df 93       	push	r29

	/* Don't add nothing */
	if (ifc == NULL)
    5260:	41 15       	cp	r20, r1
    5262:	51 05       	cpc	r21, r1
    5264:	41 f1       	breq	.+80     	; 0x52b6 <csp_rtable_set+0x5e>
    5266:	d2 2f       	mov	r29, r18
    5268:	8a 01       	movw	r16, r20
    526a:	c8 2f       	mov	r28, r24
	 * NOTE: For future implementations, interfaces should call
	 * csp_route_add_if in its csp_if_<name>_init function, instead
	 * of registering at first route_set, in order to make the interface
	 * available to network based (CMP) route configuration.
	 */
	csp_iflist_add(ifc);
    526c:	ca 01       	movw	r24, r20
    526e:	0e 94 17 1c 	call	0x382e	; 0x382e <csp_iflist_add>

	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
    5272:	c1 32       	cpi	r28, 0x21	; 33
    5274:	78 f4       	brcc	.+30     	; 0x5294 <csp_rtable_set+0x3c>
		routes[node].interface = ifc;
    5276:	8c 2f       	mov	r24, r28
    5278:	90 e0       	ldi	r25, 0x00	; 0
    527a:	fc 01       	movw	r30, r24
    527c:	ee 0f       	add	r30, r30
    527e:	ff 1f       	adc	r31, r31
    5280:	e8 0f       	add	r30, r24
    5282:	f9 1f       	adc	r31, r25
    5284:	ef 5e       	subi	r30, 0xEF	; 239
    5286:	f9 4f       	sbci	r31, 0xF9	; 249
    5288:	11 83       	std	Z+1, r17	; 0x01
    528a:	00 83       	st	Z, r16
		routes[node].mac = mac;
    528c:	d2 83       	std	Z+2, r29	; 0x02
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;
    528e:	80 e0       	ldi	r24, 0x00	; 0
    5290:	90 e0       	ldi	r25, 0x00	; 0
    5292:	13 c0       	rjmp	.+38     	; 0x52ba <csp_rtable_set+0x62>
	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
    5294:	1f 92       	push	r1
    5296:	cf 93       	push	r28
    5298:	8c e8       	ldi	r24, 0x8C	; 140
    529a:	91 e1       	ldi	r25, 0x11	; 17
    529c:	9f 93       	push	r25
    529e:	8f 93       	push	r24
    52a0:	1f 92       	push	r1
    52a2:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		return CSP_ERR_INVAL;
    52a6:	0f 90       	pop	r0
    52a8:	0f 90       	pop	r0
    52aa:	0f 90       	pop	r0
    52ac:	0f 90       	pop	r0
    52ae:	0f 90       	pop	r0
    52b0:	8e ef       	ldi	r24, 0xFE	; 254
    52b2:	9f ef       	ldi	r25, 0xFF	; 255
    52b4:	02 c0       	rjmp	.+4      	; 0x52ba <csp_rtable_set+0x62>

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {

	/* Don't add nothing */
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    52b6:	8e ef       	ldi	r24, 0xFE	; 254
    52b8:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;

}
    52ba:	df 91       	pop	r29
    52bc:	cf 91       	pop	r28
    52be:	1f 91       	pop	r17
    52c0:	0f 91       	pop	r16
    52c2:	08 95       	ret

000052c4 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    52c4:	cf 93       	push	r28
    52c6:	df 93       	push	r29
    52c8:	ec 01       	movw	r28, r24
    52ca:	81 e0       	ldi	r24, 0x01	; 1
    52cc:	0e 94 92 33 	call	0x6724	; 0x6724 <xQueueCreateMutex>
    52d0:	99 83       	std	Y+1, r25	; 0x01
    52d2:	88 83       	st	Y, r24
    52d4:	21 e0       	ldi	r18, 0x01	; 1
    52d6:	30 e0       	ldi	r19, 0x00	; 0
    52d8:	89 2b       	or	r24, r25
    52da:	11 f4       	brne	.+4      	; 0x52e0 <csp_mutex_create+0x1c>
    52dc:	20 e0       	ldi	r18, 0x00	; 0
    52de:	30 e0       	ldi	r19, 0x00	; 0
    52e0:	c9 01       	movw	r24, r18
    52e2:	df 91       	pop	r29
    52e4:	cf 91       	pop	r28
    52e6:	08 95       	ret

000052e8 <csp_bin_sem_create>:
    52e8:	cf 93       	push	r28
    52ea:	df 93       	push	r29
    52ec:	ec 01       	movw	r28, r24
    52ee:	43 e0       	ldi	r20, 0x03	; 3
    52f0:	60 e0       	ldi	r22, 0x00	; 0
    52f2:	81 e0       	ldi	r24, 0x01	; 1
    52f4:	0e 94 d2 32 	call	0x65a4	; 0x65a4 <xQueueGenericCreate>
    52f8:	99 83       	std	Y+1, r25	; 0x01
    52fa:	88 83       	st	Y, r24
    52fc:	00 97       	sbiw	r24, 0x00	; 0
    52fe:	39 f0       	breq	.+14     	; 0x530e <csp_bin_sem_create+0x26>
    5300:	20 e0       	ldi	r18, 0x00	; 0
    5302:	40 e0       	ldi	r20, 0x00	; 0
    5304:	50 e0       	ldi	r21, 0x00	; 0
    5306:	60 e0       	ldi	r22, 0x00	; 0
    5308:	70 e0       	ldi	r23, 0x00	; 0
    530a:	0e 94 00 33 	call	0x6600	; 0x6600 <xQueueGenericSend>
    530e:	81 e0       	ldi	r24, 0x01	; 1
    5310:	90 e0       	ldi	r25, 0x00	; 0
    5312:	df 91       	pop	r29
    5314:	cf 91       	pop	r28
    5316:	08 95       	ret

00005318 <csp_bin_sem_wait>:
    5318:	cf 92       	push	r12
    531a:	df 92       	push	r13
    531c:	ef 92       	push	r14
    531e:	ff 92       	push	r15
    5320:	cf 93       	push	r28
    5322:	df 93       	push	r29
    5324:	ec 01       	movw	r28, r24
    5326:	6a 01       	movw	r12, r20
    5328:	7b 01       	movw	r14, r22
    532a:	df 93       	push	r29
    532c:	cf 93       	push	r28
    532e:	8d eb       	ldi	r24, 0xBD	; 189
    5330:	91 e1       	ldi	r25, 0x11	; 17
    5332:	9f 93       	push	r25
    5334:	8f 93       	push	r24
    5336:	87 e0       	ldi	r24, 0x07	; 7
    5338:	8f 93       	push	r24
    533a:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
    533e:	0f 90       	pop	r0
    5340:	0f 90       	pop	r0
    5342:	0f 90       	pop	r0
    5344:	0f 90       	pop	r0
    5346:	0f 90       	pop	r0
    5348:	8f ef       	ldi	r24, 0xFF	; 255
    534a:	c8 16       	cp	r12, r24
    534c:	d8 06       	cpc	r13, r24
    534e:	e1 04       	cpc	r14, r1
    5350:	f1 04       	cpc	r15, r1
    5352:	51 f0       	breq	.+20     	; 0x5368 <csp_bin_sem_wait+0x50>
    5354:	c7 01       	movw	r24, r14
    5356:	b6 01       	movw	r22, r12
    5358:	2a e0       	ldi	r18, 0x0A	; 10
    535a:	30 e0       	ldi	r19, 0x00	; 0
    535c:	40 e0       	ldi	r20, 0x00	; 0
    535e:	50 e0       	ldi	r21, 0x00	; 0
    5360:	0e 94 d8 41 	call	0x83b0	; 0x83b0 <__udivmodsi4>
    5364:	69 01       	movw	r12, r18
    5366:	7a 01       	movw	r14, r20
    5368:	b6 01       	movw	r22, r12
    536a:	88 81       	ld	r24, Y
    536c:	99 81       	ldd	r25, Y+1	; 0x01
    536e:	0e 94 6b 34 	call	0x68d6	; 0x68d6 <xQueueSemaphoreTake>
    5372:	21 e0       	ldi	r18, 0x01	; 1
    5374:	30 e0       	ldi	r19, 0x00	; 0
    5376:	81 30       	cpi	r24, 0x01	; 1
    5378:	11 f0       	breq	.+4      	; 0x537e <csp_bin_sem_wait+0x66>
    537a:	20 e0       	ldi	r18, 0x00	; 0
    537c:	30 e0       	ldi	r19, 0x00	; 0
    537e:	c9 01       	movw	r24, r18
    5380:	df 91       	pop	r29
    5382:	cf 91       	pop	r28
    5384:	ff 90       	pop	r15
    5386:	ef 90       	pop	r14
    5388:	df 90       	pop	r13
    538a:	cf 90       	pop	r12
    538c:	08 95       	ret

0000538e <csp_bin_sem_post>:
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
    538e:	cf 93       	push	r28
    5390:	df 93       	push	r29
    5392:	ec 01       	movw	r28, r24
	csp_log_lock("Post: %p", sem);
    5394:	df 93       	push	r29
    5396:	cf 93       	push	r28
    5398:	84 eb       	ldi	r24, 0xB4	; 180
    539a:	91 e1       	ldi	r25, 0x11	; 17
    539c:	9f 93       	push	r25
    539e:	8f 93       	push	r24
    53a0:	87 e0       	ldi	r24, 0x07	; 7
    53a2:	8f 93       	push	r24
    53a4:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
	if (xSemaphoreGive(*sem) == pdPASS) {
    53a8:	20 e0       	ldi	r18, 0x00	; 0
    53aa:	40 e0       	ldi	r20, 0x00	; 0
    53ac:	50 e0       	ldi	r21, 0x00	; 0
    53ae:	60 e0       	ldi	r22, 0x00	; 0
    53b0:	70 e0       	ldi	r23, 0x00	; 0
    53b2:	88 81       	ld	r24, Y
    53b4:	99 81       	ldd	r25, Y+1	; 0x01
    53b6:	0e 94 00 33 	call	0x6600	; 0x6600 <xQueueGenericSend>
    53ba:	21 e0       	ldi	r18, 0x01	; 1
    53bc:	30 e0       	ldi	r19, 0x00	; 0
    53be:	0f 90       	pop	r0
    53c0:	0f 90       	pop	r0
    53c2:	0f 90       	pop	r0
    53c4:	0f 90       	pop	r0
    53c6:	0f 90       	pop	r0
    53c8:	81 30       	cpi	r24, 0x01	; 1
    53ca:	11 f0       	breq	.+4      	; 0x53d0 <csp_bin_sem_post+0x42>
    53cc:	20 e0       	ldi	r18, 0x00	; 0
    53ce:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    53d0:	c9 01       	movw	r24, r18
    53d2:	df 91       	pop	r29
    53d4:	cf 91       	pop	r28
    53d6:	08 95       	ret

000053d8 <csp_ping>:
#include "csp_endian.h"

#include "csp_time.h"


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {
    53d8:	3f 92       	push	r3
    53da:	4f 92       	push	r4
    53dc:	5f 92       	push	r5
    53de:	6f 92       	push	r6
    53e0:	7f 92       	push	r7
    53e2:	8f 92       	push	r8
    53e4:	9f 92       	push	r9
    53e6:	af 92       	push	r10
    53e8:	bf 92       	push	r11
    53ea:	cf 92       	push	r12
    53ec:	df 92       	push	r13
    53ee:	ef 92       	push	r14
    53f0:	ff 92       	push	r15
    53f2:	0f 93       	push	r16
    53f4:	1f 93       	push	r17
    53f6:	cf 93       	push	r28
    53f8:	df 93       	push	r29
    53fa:	38 2e       	mov	r3, r24
    53fc:	4a 01       	movw	r8, r20
    53fe:	5b 01       	movw	r10, r22
    5400:	e9 01       	movw	r28, r18

	unsigned int i;
	uint32_t start, time, status = 0;

	/* Counter */
	start = csp_get_ms();
    5402:	12 d4       	rcall	.+2084   	; 0x5c28 <csp_get_ms>
    5404:	2b 01       	movw	r4, r22
    5406:	3c 01       	movw	r6, r24

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
    5408:	c0 2e       	mov	r12, r16
    540a:	d1 2c       	mov	r13, r1
    540c:	e1 2c       	mov	r14, r1
    540e:	f1 2c       	mov	r15, r1
    5410:	95 01       	movw	r18, r10
    5412:	84 01       	movw	r16, r8
    5414:	41 e0       	ldi	r20, 0x01	; 1
    5416:	63 2d       	mov	r22, r3
    5418:	82 e0       	ldi	r24, 0x02	; 2
    541a:	0e 94 0a 19 	call	0x3214	; 0x3214 <csp_connect>
    541e:	8c 01       	movw	r16, r24
	if (conn == NULL)
    5420:	89 2b       	or	r24, r25
    5422:	e1 f1       	breq	.+120    	; 0x549c <csp_ping+0xc4>
		return -1;

	/* Prepare data */
	csp_packet_t * packet;
	packet = csp_buffer_get(size);
    5424:	ce 01       	movw	r24, r28
    5426:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <csp_buffer_get>
    542a:	7c 01       	movw	r14, r24
	if (packet == NULL)
    542c:	00 97       	sbiw	r24, 0x00	; 0
    542e:	c9 f1       	breq	.+114    	; 0x54a2 <csp_ping+0xca>
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
    5430:	fc 01       	movw	r30, r24
    5432:	d1 87       	std	Z+9, r29	; 0x09
    5434:	c0 87       	std	Z+8, r28	; 0x08
	for (i = 0; i < size; i++)
    5436:	20 97       	sbiw	r28, 0x00	; 0
    5438:	41 f0       	breq	.+16     	; 0x544a <csp_ping+0x72>
    543a:	3e 96       	adiw	r30, 0x0e	; 14
    543c:	80 e0       	ldi	r24, 0x00	; 0
    543e:	90 e0       	ldi	r25, 0x00	; 0
		packet->data[i] = i;
    5440:	81 93       	st	Z+, r24
	if (packet == NULL)
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
	for (i = 0; i < size; i++)
    5442:	01 96       	adiw	r24, 0x01	; 1
    5444:	c8 17       	cp	r28, r24
    5446:	d9 07       	cpc	r29, r25
    5448:	d9 f7       	brne	.-10     	; 0x5440 <csp_ping+0x68>
		packet->data[i] = i;

	/* Try to send frame */
	if (!csp_send(conn, packet, 0))
    544a:	20 e0       	ldi	r18, 0x00	; 0
    544c:	30 e0       	ldi	r19, 0x00	; 0
    544e:	a9 01       	movw	r20, r18
    5450:	b7 01       	movw	r22, r14
    5452:	c8 01       	movw	r24, r16
    5454:	ed d9       	rcall	.-3110   	; 0x4830 <csp_send>
    5456:	89 2b       	or	r24, r25
    5458:	59 f1       	breq	.+86     	; 0x54b0 <csp_ping+0xd8>
		goto out;

	/* Read incoming frame */
	packet = csp_read(conn, timeout);
    545a:	b5 01       	movw	r22, r10
    545c:	a4 01       	movw	r20, r8
    545e:	c8 01       	movw	r24, r16
    5460:	b1 d8       	rcall	.-3742   	; 0x45c4 <csp_read>
    5462:	7c 01       	movw	r14, r24
	if (packet == NULL)
    5464:	00 97       	sbiw	r24, 0x00	; 0
    5466:	e9 f0       	breq	.+58     	; 0x54a2 <csp_ping+0xca>
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    5468:	20 97       	sbiw	r28, 0x00	; 0
    546a:	31 f1       	breq	.+76     	; 0x54b8 <csp_ping+0xe0>
		if (packet->data[i] != i % (0xff + 1))
    546c:	fc 01       	movw	r30, r24
    546e:	86 85       	ldd	r24, Z+14	; 0x0e
    5470:	81 11       	cpse	r24, r1
    5472:	27 c0       	rjmp	.+78     	; 0x54c2 <csp_ping+0xea>
    5474:	3f 96       	adiw	r30, 0x0f	; 15
    5476:	80 e0       	ldi	r24, 0x00	; 0
    5478:	90 e0       	ldi	r25, 0x00	; 0
    547a:	07 c0       	rjmp	.+14     	; 0x548a <csp_ping+0xb2>
    547c:	21 91       	ld	r18, Z+
    547e:	30 e0       	ldi	r19, 0x00	; 0
    5480:	ac 01       	movw	r20, r24
    5482:	55 27       	eor	r21, r21
    5484:	24 17       	cp	r18, r20
    5486:	35 07       	cpc	r19, r21
    5488:	01 f5       	brne	.+64     	; 0x54ca <csp_ping+0xf2>
	packet = csp_read(conn, timeout);
	if (packet == NULL)
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    548a:	01 96       	adiw	r24, 0x01	; 1
    548c:	c8 17       	cp	r28, r24
    548e:	d9 07       	cpc	r29, r25
    5490:	a9 f7       	brne	.-22     	; 0x547c <csp_ping+0xa4>
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    5492:	81 2c       	mov	r8, r1
    5494:	91 2c       	mov	r9, r1
    5496:	54 01       	movw	r10, r8
    5498:	83 94       	inc	r8
    549a:	1a c0       	rjmp	.+52     	; 0x54d0 <csp_ping+0xf8>
	start = csp_get_ms();

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
	if (conn == NULL)
		return -1;
    549c:	8f ef       	ldi	r24, 0xFF	; 255
    549e:	9f ef       	ldi	r25, 0xFF	; 255
    54a0:	2a c0       	rjmp	.+84     	; 0x54f6 <csp_ping+0x11e>

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
	csp_close(conn);
    54a2:	c8 01       	movw	r24, r16
    54a4:	0e 94 c7 18 	call	0x318e	; 0x318e <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    54a8:	bf d3       	rcall	.+1918   	; 0x5c28 <csp_get_ms>

	if (status) {
		return time;
	} else {
		return -1;
    54aa:	8f ef       	ldi	r24, 0xFF	; 255
    54ac:	9f ef       	ldi	r25, 0xFF	; 255
    54ae:	23 c0       	rjmp	.+70     	; 0x54f6 <csp_ping+0x11e>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    54b0:	81 2c       	mov	r8, r1
    54b2:	91 2c       	mov	r9, r1
    54b4:	54 01       	movw	r10, r8
    54b6:	0c c0       	rjmp	.+24     	; 0x54d0 <csp_ping+0xf8>
	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    54b8:	81 2c       	mov	r8, r1
    54ba:	91 2c       	mov	r9, r1
    54bc:	54 01       	movw	r10, r8
    54be:	83 94       	inc	r8
    54c0:	07 c0       	rjmp	.+14     	; 0x54d0 <csp_ping+0xf8>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    54c2:	81 2c       	mov	r8, r1
    54c4:	91 2c       	mov	r9, r1
    54c6:	54 01       	movw	r10, r8
    54c8:	03 c0       	rjmp	.+6      	; 0x54d0 <csp_ping+0xf8>
    54ca:	81 2c       	mov	r8, r1
    54cc:	91 2c       	mov	r9, r1
    54ce:	54 01       	movw	r10, r8
	status = 1;

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
    54d0:	c7 01       	movw	r24, r14
    54d2:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
	csp_close(conn);
    54d6:	c8 01       	movw	r24, r16
    54d8:	0e 94 c7 18 	call	0x318e	; 0x318e <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    54dc:	a5 d3       	rcall	.+1866   	; 0x5c28 <csp_get_ms>
    54de:	dc 01       	movw	r26, r24
    54e0:	cb 01       	movw	r24, r22
    54e2:	84 19       	sub	r24, r4
    54e4:	95 09       	sbc	r25, r5
    54e6:	a6 09       	sbc	r26, r6
    54e8:	b7 09       	sbc	r27, r7

	if (status) {
    54ea:	89 28       	or	r8, r9
    54ec:	8a 28       	or	r8, r10
    54ee:	8b 28       	or	r8, r11
    54f0:	11 f4       	brne	.+4      	; 0x54f6 <csp_ping+0x11e>
		return time;
	} else {
		return -1;
    54f2:	8f ef       	ldi	r24, 0xFF	; 255
    54f4:	9f ef       	ldi	r25, 0xFF	; 255
	}

}
    54f6:	df 91       	pop	r29
    54f8:	cf 91       	pop	r28
    54fa:	1f 91       	pop	r17
    54fc:	0f 91       	pop	r16
    54fe:	ff 90       	pop	r15
    5500:	ef 90       	pop	r14
    5502:	df 90       	pop	r13
    5504:	cf 90       	pop	r12
    5506:	bf 90       	pop	r11
    5508:	af 90       	pop	r10
    550a:	9f 90       	pop	r9
    550c:	8f 90       	pop	r8
    550e:	7f 90       	pop	r7
    5510:	6f 90       	pop	r6
    5512:	5f 90       	pop	r5
    5514:	4f 90       	pop	r4
    5516:	3f 90       	pop	r3
    5518:	08 95       	ret

0000551a <wrap_32bit_memcpy>:
static csp_memcpy_fnc_t csp_cmp_memcpy_fnc = (csp_memcpy_fnc_t) memcpy;
#endif


void csp_cmp_set_memcpy(csp_memcpy_fnc_t fnc) {
	csp_cmp_memcpy_fnc = fnc;
    551a:	cf 92       	push	r12
    551c:	df 92       	push	r13
    551e:	ef 92       	push	r14
    5520:	ff 92       	push	r15
    5522:	0f 93       	push	r16
    5524:	1f 93       	push	r17
    5526:	dc 01       	movw	r26, r24
    5528:	cb 01       	movw	r24, r22
    552a:	69 01       	movw	r12, r18
    552c:	7a 01       	movw	r14, r20
    552e:	a8 01       	movw	r20, r16
    5530:	b6 01       	movw	r22, r12
    5532:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>
    5536:	bc 01       	movw	r22, r24
    5538:	80 e0       	ldi	r24, 0x00	; 0
    553a:	90 e0       	ldi	r25, 0x00	; 0
    553c:	1f 91       	pop	r17
    553e:	0f 91       	pop	r16
    5540:	ff 90       	pop	r15
    5542:	ef 90       	pop	r14
    5544:	df 90       	pop	r13
    5546:	cf 90       	pop	r12
    5548:	08 95       	ret

0000554a <csp_service_handler>:
	cmp->type = CSP_CMP_REPLY;

	return ret;
}

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    554a:	6f 92       	push	r6
    554c:	7f 92       	push	r7
    554e:	8f 92       	push	r8
    5550:	9f 92       	push	r9
    5552:	af 92       	push	r10
    5554:	bf 92       	push	r11
    5556:	cf 92       	push	r12
    5558:	df 92       	push	r13
    555a:	ef 92       	push	r14
    555c:	ff 92       	push	r15
    555e:	0f 93       	push	r16
    5560:	1f 93       	push	r17
    5562:	cf 93       	push	r28
    5564:	df 93       	push	r29
    5566:	7c 01       	movw	r14, r24
    5568:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    556a:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <csp_conn_dport>
    556e:	87 30       	cpi	r24, 0x07	; 7
    5570:	91 05       	cpc	r25, r1
    5572:	08 f0       	brcs	.+2      	; 0x5576 <csp_service_handler+0x2c>
    5574:	37 c2       	rjmp	.+1134   	; 0x59e4 <csp_service_handler+0x49a>
    5576:	fc 01       	movw	r30, r24
    5578:	88 27       	eor	r24, r24
    557a:	e6 58       	subi	r30, 0x86	; 134
    557c:	ff 4f       	sbci	r31, 0xFF	; 255
    557e:	8f 4f       	sbci	r24, 0xFF	; 255
    5580:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    5584:	8e 85       	ldd	r24, Y+14	; 0x0e
    5586:	81 11       	cpse	r24, r1
    5588:	74 c1       	rjmp	.+744    	; 0x5872 <csp_service_handler+0x328>
		return ret;

	switch (cmp->code) {
    558a:	8f 85       	ldd	r24, Y+15	; 0x0f
    558c:	83 30       	cpi	r24, 0x03	; 3
    558e:	09 f4       	brne	.+2      	; 0x5592 <csp_service_handler+0x48>
    5590:	70 c0       	rjmp	.+224    	; 0x5672 <csp_service_handler+0x128>
    5592:	30 f4       	brcc	.+12     	; 0x55a0 <csp_service_handler+0x56>
    5594:	81 30       	cpi	r24, 0x01	; 1
    5596:	69 f0       	breq	.+26     	; 0x55b2 <csp_service_handler+0x68>
    5598:	82 30       	cpi	r24, 0x02	; 2
    559a:	09 f4       	brne	.+2      	; 0x559e <csp_service_handler+0x54>
    559c:	50 c0       	rjmp	.+160    	; 0x563e <csp_service_handler+0xf4>
    559e:	62 c1       	rjmp	.+708    	; 0x5864 <csp_service_handler+0x31a>
    55a0:	85 30       	cpi	r24, 0x05	; 5
    55a2:	09 f4       	brne	.+2      	; 0x55a6 <csp_service_handler+0x5c>
    55a4:	04 c1       	rjmp	.+520    	; 0x57ae <csp_service_handler+0x264>
    55a6:	08 f4       	brcc	.+2      	; 0x55aa <csp_service_handler+0x60>
    55a8:	e6 c0       	rjmp	.+460    	; 0x5776 <csp_service_handler+0x22c>
    55aa:	86 30       	cpi	r24, 0x06	; 6
    55ac:	09 f4       	brne	.+2      	; 0x55b0 <csp_service_handler+0x66>
    55ae:	19 c1       	rjmp	.+562    	; 0x57e2 <csp_service_handler+0x298>
    55b0:	59 c1       	rjmp	.+690    	; 0x5864 <csp_service_handler+0x31a>
}

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, csp_get_revision(), CSP_CMP_IDENT_REV_LEN);
    55b2:	0e 94 25 22 	call	0x444a	; 0x444a <csp_get_revision>
    55b6:	44 e1       	ldi	r20, 0x14	; 20
    55b8:	50 e0       	ldi	r21, 0x00	; 0
    55ba:	bc 01       	movw	r22, r24
    55bc:	ce 01       	movw	r24, r28
    55be:	8e 5b       	subi	r24, 0xBE	; 190
    55c0:	9f 4f       	sbci	r25, 0xFF	; 255
    55c2:	0e 94 c8 42 	call	0x8590	; 0x8590 <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    55c6:	fe 01       	movw	r30, r28
    55c8:	eb 5a       	subi	r30, 0xAB	; 171
    55ca:	ff 4f       	sbci	r31, 0xFF	; 255
    55cc:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    55ce:	8c e0       	ldi	r24, 0x0C	; 12
    55d0:	e3 e9       	ldi	r30, 0x93	; 147
    55d2:	f2 e0       	ldi	r31, 0x02	; 2
    55d4:	de 01       	movw	r26, r28
    55d6:	aa 5a       	subi	r26, 0xAA	; 170
    55d8:	bf 4f       	sbci	r27, 0xFF	; 255
    55da:	01 90       	ld	r0, Z+
    55dc:	0d 92       	st	X+, r0
    55de:	8a 95       	dec	r24
    55e0:	e1 f7       	brne	.-8      	; 0x55da <csp_service_handler+0x90>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    55e2:	fe 01       	movw	r30, r28
    55e4:	ef 59       	subi	r30, 0x9F	; 159
    55e6:	ff 4f       	sbci	r31, 0xFF	; 255
    55e8:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    55ea:	89 e0       	ldi	r24, 0x09	; 9
    55ec:	ef e9       	ldi	r30, 0x9F	; 159
    55ee:	f2 e0       	ldi	r31, 0x02	; 2
    55f0:	de 01       	movw	r26, r28
    55f2:	ae 59       	subi	r26, 0x9E	; 158
    55f4:	bf 4f       	sbci	r27, 0xFF	; 255
    55f6:	01 90       	ld	r0, Z+
    55f8:	0d 92       	st	X+, r0
    55fa:	8a 95       	dec	r24
    55fc:	e1 f7       	brne	.-8      	; 0x55f6 <csp_service_handler+0xac>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    55fe:	fe 01       	movw	r30, r28
    5600:	e6 59       	subi	r30, 0x96	; 150
    5602:	ff 4f       	sbci	r31, 0xFF	; 255
    5604:	10 82       	st	Z, r1

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    5606:	0e 94 1b 22 	call	0x4436	; 0x4436 <csp_get_hostname>
    560a:	44 e1       	ldi	r20, 0x14	; 20
    560c:	50 e0       	ldi	r21, 0x00	; 0
    560e:	bc 01       	movw	r22, r24
    5610:	ce 01       	movw	r24, r28
    5612:	40 96       	adiw	r24, 0x10	; 16
    5614:	0e 94 c8 42 	call	0x8590	; 0x8590 <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';
    5618:	1b a2       	std	Y+35, r1	; 0x23

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    561a:	0e 94 20 22 	call	0x4440	; 0x4440 <csp_get_model>
    561e:	4e e1       	ldi	r20, 0x1E	; 30
    5620:	50 e0       	ldi	r21, 0x00	; 0
    5622:	bc 01       	movw	r22, r24
    5624:	ce 01       	movw	r24, r28
    5626:	84 96       	adiw	r24, 0x24	; 36
    5628:	0e 94 c8 42 	call	0x8590	; 0x8590 <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    562c:	fe 01       	movw	r30, r28
    562e:	ef 5b       	subi	r30, 0xBF	; 191
    5630:	ff 4f       	sbci	r31, 0xFF	; 255
    5632:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    5634:	8d e5       	ldi	r24, 0x5D	; 93
    5636:	90 e0       	ldi	r25, 0x00	; 0
    5638:	99 87       	std	Y+9, r25	; 0x09
    563a:	88 87       	std	Y+8, r24	; 0x08
    563c:	e9 c1       	rjmp	.+978    	; 0x5a10 <csp_service_handler+0x4c6>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
    563e:	ce 01       	movw	r24, r28
    5640:	42 96       	adiw	r24, 0x12	; 18
    5642:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <csp_iflist_get_by_name>
	if (ifc == NULL)
    5646:	00 97       	sbiw	r24, 0x00	; 0
    5648:	51 f0       	breq	.+20     	; 0x565e <csp_service_handler+0x114>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    564a:	29 89       	ldd	r18, Y+17	; 0x11
    564c:	ac 01       	movw	r20, r24
    564e:	65 e0       	ldi	r22, 0x05	; 5
    5650:	88 89       	ldd	r24, Y+16	; 0x10
    5652:	02 de       	rcall	.-1020   	; 0x5258 <csp_rtable_set>
    5654:	89 2b       	or	r24, r25
    5656:	31 f4       	brne	.+12     	; 0x5664 <csp_service_handler+0x11a>
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    5658:	80 e0       	ldi	r24, 0x00	; 0
    565a:	90 e0       	ldi	r25, 0x00	; 0
    565c:	05 c0       	rjmp	.+10     	; 0x5668 <csp_service_handler+0x11e>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    565e:	8e ef       	ldi	r24, 0xFE	; 254
    5660:	9f ef       	ldi	r25, 0xFF	; 255
    5662:	02 c0       	rjmp	.+4      	; 0x5668 <csp_service_handler+0x11e>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;
    5664:	8e ef       	ldi	r24, 0xFE	; 254
    5666:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    5668:	2f e0       	ldi	r18, 0x0F	; 15
    566a:	30 e0       	ldi	r19, 0x00	; 0
    566c:	39 87       	std	Y+9, r19	; 0x09
    566e:	28 87       	std	Y+8, r18	; 0x08
    5670:	fb c0       	rjmp	.+502    	; 0x5868 <csp_service_handler+0x31e>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
    5672:	ce 01       	movw	r24, r28
    5674:	40 96       	adiw	r24, 0x10	; 16
    5676:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <csp_iflist_get_by_name>
    567a:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    567c:	00 97       	sbiw	r24, 0x00	; 0
    567e:	09 f4       	brne	.+2      	; 0x5682 <csp_service_handler+0x138>
    5680:	73 c0       	rjmp	.+230    	; 0x5768 <csp_service_handler+0x21e>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    5682:	fc 01       	movw	r30, r24
    5684:	61 85       	ldd	r22, Z+9	; 0x09
    5686:	72 85       	ldd	r23, Z+10	; 0x0a
    5688:	83 85       	ldd	r24, Z+11	; 0x0b
    568a:	94 85       	ldd	r25, Z+12	; 0x0c
    568c:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5690:	6b 8f       	std	Y+27, r22	; 0x1b
    5692:	7c 8f       	std	Y+28, r23	; 0x1c
    5694:	8d 8f       	std	Y+29, r24	; 0x1d
    5696:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    5698:	f8 01       	movw	r30, r16
    569a:	65 85       	ldd	r22, Z+13	; 0x0d
    569c:	76 85       	ldd	r23, Z+14	; 0x0e
    569e:	87 85       	ldd	r24, Z+15	; 0x0f
    56a0:	90 89       	ldd	r25, Z+16	; 0x10
    56a2:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    56a6:	6f 8f       	std	Y+31, r22	; 0x1f
    56a8:	78 a3       	std	Y+32, r23	; 0x20
    56aa:	89 a3       	std	Y+33, r24	; 0x21
    56ac:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    56ae:	f8 01       	movw	r30, r16
    56b0:	61 89       	ldd	r22, Z+17	; 0x11
    56b2:	72 89       	ldd	r23, Z+18	; 0x12
    56b4:	83 89       	ldd	r24, Z+19	; 0x13
    56b6:	94 89       	ldd	r25, Z+20	; 0x14
    56b8:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    56bc:	6b a3       	std	Y+35, r22	; 0x23
    56be:	7c a3       	std	Y+36, r23	; 0x24
    56c0:	8d a3       	std	Y+37, r24	; 0x25
    56c2:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    56c4:	f8 01       	movw	r30, r16
    56c6:	65 89       	ldd	r22, Z+21	; 0x15
    56c8:	76 89       	ldd	r23, Z+22	; 0x16
    56ca:	87 89       	ldd	r24, Z+23	; 0x17
    56cc:	90 8d       	ldd	r25, Z+24	; 0x18
    56ce:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    56d2:	6f a3       	std	Y+39, r22	; 0x27
    56d4:	78 a7       	std	Y+40, r23	; 0x28
    56d6:	89 a7       	std	Y+41, r24	; 0x29
    56d8:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    56da:	f8 01       	movw	r30, r16
    56dc:	61 8d       	ldd	r22, Z+25	; 0x19
    56de:	72 8d       	ldd	r23, Z+26	; 0x1a
    56e0:	83 8d       	ldd	r24, Z+27	; 0x1b
    56e2:	94 8d       	ldd	r25, Z+28	; 0x1c
    56e4:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    56e8:	6b a7       	std	Y+43, r22	; 0x2b
    56ea:	7c a7       	std	Y+44, r23	; 0x2c
    56ec:	8d a7       	std	Y+45, r24	; 0x2d
    56ee:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    56f0:	f8 01       	movw	r30, r16
    56f2:	65 8d       	ldd	r22, Z+29	; 0x1d
    56f4:	76 8d       	ldd	r23, Z+30	; 0x1e
    56f6:	87 8d       	ldd	r24, Z+31	; 0x1f
    56f8:	90 a1       	ldd	r25, Z+32	; 0x20
    56fa:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    56fe:	6f a7       	std	Y+47, r22	; 0x2f
    5700:	78 ab       	std	Y+48, r23	; 0x30
    5702:	89 ab       	std	Y+49, r24	; 0x31
    5704:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    5706:	f8 01       	movw	r30, r16
    5708:	61 a1       	ldd	r22, Z+33	; 0x21
    570a:	72 a1       	ldd	r23, Z+34	; 0x22
    570c:	83 a1       	ldd	r24, Z+35	; 0x23
    570e:	94 a1       	ldd	r25, Z+36	; 0x24
    5710:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5714:	6b ab       	std	Y+51, r22	; 0x33
    5716:	7c ab       	std	Y+52, r23	; 0x34
    5718:	8d ab       	std	Y+53, r24	; 0x35
    571a:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    571c:	f8 01       	movw	r30, r16
    571e:	65 a1       	ldd	r22, Z+37	; 0x25
    5720:	76 a1       	ldd	r23, Z+38	; 0x26
    5722:	87 a1       	ldd	r24, Z+39	; 0x27
    5724:	90 a5       	ldd	r25, Z+40	; 0x28
    5726:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    572a:	6f ab       	std	Y+55, r22	; 0x37
    572c:	78 af       	std	Y+56, r23	; 0x38
    572e:	89 af       	std	Y+57, r24	; 0x39
    5730:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    5732:	f8 01       	movw	r30, r16
    5734:	61 a5       	ldd	r22, Z+41	; 0x29
    5736:	72 a5       	ldd	r23, Z+42	; 0x2a
    5738:	83 a5       	ldd	r24, Z+43	; 0x2b
    573a:	94 a5       	ldd	r25, Z+44	; 0x2c
    573c:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5740:	6b af       	std	Y+59, r22	; 0x3b
    5742:	7c af       	std	Y+60, r23	; 0x3c
    5744:	8d af       	std	Y+61, r24	; 0x3d
    5746:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    5748:	f8 01       	movw	r30, r16
    574a:	65 a5       	ldd	r22, Z+45	; 0x2d
    574c:	76 a5       	ldd	r23, Z+46	; 0x2e
    574e:	87 a5       	ldd	r24, Z+47	; 0x2f
    5750:	90 a9       	ldd	r25, Z+48	; 0x30
    5752:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5756:	fe 01       	movw	r30, r28
    5758:	ff 96       	adiw	r30, 0x3f	; 63
    575a:	60 83       	st	Z, r22
    575c:	71 83       	std	Z+1, r23	; 0x01
    575e:	82 83       	std	Z+2, r24	; 0x02
    5760:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    5762:	80 e0       	ldi	r24, 0x00	; 0
    5764:	90 e0       	ldi	r25, 0x00	; 0
    5766:	02 c0       	rjmp	.+4      	; 0x576c <csp_service_handler+0x222>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    5768:	8e ef       	ldi	r24, 0xFE	; 254
    576a:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    576c:	25 e3       	ldi	r18, 0x35	; 53
    576e:	30 e0       	ldi	r19, 0x00	; 0
    5770:	39 87       	std	Y+9, r19	; 0x09
    5772:	28 87       	std	Y+8, r18	; 0x08
    5774:	79 c0       	rjmp	.+242    	; 0x5868 <csp_service_handler+0x31e>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    5776:	68 89       	ldd	r22, Y+16	; 0x10
    5778:	79 89       	ldd	r23, Y+17	; 0x11
    577a:	8a 89       	ldd	r24, Y+18	; 0x12
    577c:	9b 89       	ldd	r25, Y+19	; 0x13
    577e:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5782:	9b 01       	movw	r18, r22
    5784:	ac 01       	movw	r20, r24
    5786:	68 8b       	std	Y+16, r22	; 0x10
    5788:	79 8b       	std	Y+17, r23	; 0x11
    578a:	8a 8b       	std	Y+18, r24	; 0x12
    578c:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    578e:	0c 89       	ldd	r16, Y+20	; 0x14
    5790:	09 3c       	cpi	r16, 0xC9	; 201
    5792:	08 f0       	brcs	.+2      	; 0x5796 <csp_service_handler+0x24c>
    5794:	3a c1       	rjmp	.+628    	; 0x5a0a <csp_service_handler+0x4c0>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (uintptr_t) cmp->peek.data, (csp_memptr_t) (unsigned long) cmp->peek.addr, cmp->peek.len);
    5796:	10 e0       	ldi	r17, 0x00	; 0
    5798:	ce 01       	movw	r24, r28
    579a:	45 96       	adiw	r24, 0x15	; 21
    579c:	bc 01       	movw	r22, r24
    579e:	80 e0       	ldi	r24, 0x00	; 0
    57a0:	90 e0       	ldi	r25, 0x00	; 0
    57a2:	e0 91 7a 02 	lds	r30, 0x027A	; 0x80027a <csp_cmp_memcpy_fnc>
    57a6:	f0 91 7b 02 	lds	r31, 0x027B	; 0x80027b <csp_cmp_memcpy_fnc+0x1>
    57aa:	19 95       	eicall
    57ac:	31 c1       	rjmp	.+610    	; 0x5a10 <csp_service_handler+0x4c6>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    57ae:	68 89       	ldd	r22, Y+16	; 0x10
    57b0:	79 89       	ldd	r23, Y+17	; 0x11
    57b2:	8a 89       	ldd	r24, Y+18	; 0x12
    57b4:	9b 89       	ldd	r25, Y+19	; 0x13
    57b6:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    57ba:	68 8b       	std	Y+16, r22	; 0x10
    57bc:	79 8b       	std	Y+17, r23	; 0x11
    57be:	8a 8b       	std	Y+18, r24	; 0x12
    57c0:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    57c2:	0c 89       	ldd	r16, Y+20	; 0x14
    57c4:	09 3c       	cpi	r16, 0xC9	; 201
    57c6:	08 f0       	brcs	.+2      	; 0x57ca <csp_service_handler+0x280>
    57c8:	20 c1       	rjmp	.+576    	; 0x5a0a <csp_service_handler+0x4c0>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (unsigned long) cmp->poke.addr, (csp_memptr_t) (uintptr_t) cmp->poke.data, cmp->poke.len);
    57ca:	10 e0       	ldi	r17, 0x00	; 0
    57cc:	9e 01       	movw	r18, r28
    57ce:	2b 5e       	subi	r18, 0xEB	; 235
    57d0:	3f 4f       	sbci	r19, 0xFF	; 255
    57d2:	40 e0       	ldi	r20, 0x00	; 0
    57d4:	50 e0       	ldi	r21, 0x00	; 0
    57d6:	e0 91 7a 02 	lds	r30, 0x027A	; 0x80027a <csp_cmp_memcpy_fnc>
    57da:	f0 91 7b 02 	lds	r31, 0x027B	; 0x80027b <csp_cmp_memcpy_fnc+0x1>
    57de:	19 95       	eicall
    57e0:	17 c1       	rjmp	.+558    	; 0x5a10 <csp_service_handler+0x4c6>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    57e2:	68 89       	ldd	r22, Y+16	; 0x10
    57e4:	79 89       	ldd	r23, Y+17	; 0x11
    57e6:	8a 89       	ldd	r24, Y+18	; 0x12
    57e8:	9b 89       	ldd	r25, Y+19	; 0x13
    57ea:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <csp_ntoh32>
    57ee:	68 8b       	std	Y+16, r22	; 0x10
    57f0:	79 8b       	std	Y+17, r23	; 0x11
    57f2:	8a 8b       	std	Y+18, r24	; 0x12
    57f4:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    57f6:	6c 89       	ldd	r22, Y+20	; 0x14
    57f8:	7d 89       	ldd	r23, Y+21	; 0x15
    57fa:	8e 89       	ldd	r24, Y+22	; 0x16
    57fc:	9f 89       	ldd	r25, Y+23	; 0x17
    57fe:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <csp_ntoh32>
    5802:	6c 8b       	std	Y+20, r22	; 0x14
    5804:	7d 8b       	std	Y+21, r23	; 0x15
    5806:	8e 8b       	std	Y+22, r24	; 0x16
    5808:	9f 8b       	std	Y+23, r25	; 0x17

	if ((cmp->clock.tv_sec != 0) && (clock_set_time != NULL)) {
    580a:	88 89       	ldd	r24, Y+16	; 0x10
    580c:	99 89       	ldd	r25, Y+17	; 0x11
    580e:	aa 89       	ldd	r26, Y+18	; 0x12
    5810:	bb 89       	ldd	r27, Y+19	; 0x13
    5812:	89 2b       	or	r24, r25
    5814:	8a 2b       	or	r24, r26
    5816:	8b 2b       	or	r24, r27
    5818:	41 f0       	breq	.+16     	; 0x582a <csp_service_handler+0x2e0>
    581a:	80 e0       	ldi	r24, 0x00	; 0
    581c:	90 e0       	ldi	r25, 0x00	; 0
    581e:	89 2b       	or	r24, r25
    5820:	21 f0       	breq	.+8      	; 0x582a <csp_service_handler+0x2e0>
		clock_set_time(&cmp->clock);
    5822:	ce 01       	movw	r24, r28
    5824:	40 96       	adiw	r24, 0x10	; 16
    5826:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	if (clock_get_time != NULL) {
    582a:	80 e0       	ldi	r24, 0x00	; 0
    582c:	90 e0       	ldi	r25, 0x00	; 0
    582e:	89 2b       	or	r24, r25
    5830:	21 f0       	breq	.+8      	; 0x583a <csp_service_handler+0x2f0>
		clock_get_time(&cmp->clock);
    5832:	ce 01       	movw	r24, r28
    5834:	40 96       	adiw	r24, 0x10	; 16
    5836:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    583a:	68 89       	ldd	r22, Y+16	; 0x10
    583c:	79 89       	ldd	r23, Y+17	; 0x11
    583e:	8a 89       	ldd	r24, Y+18	; 0x12
    5840:	9b 89       	ldd	r25, Y+19	; 0x13
    5842:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    5846:	68 8b       	std	Y+16, r22	; 0x10
    5848:	79 8b       	std	Y+17, r23	; 0x11
    584a:	8a 8b       	std	Y+18, r24	; 0x12
    584c:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    584e:	6c 89       	ldd	r22, Y+20	; 0x14
    5850:	7d 89       	ldd	r23, Y+21	; 0x15
    5852:	8e 89       	ldd	r24, Y+22	; 0x16
    5854:	9f 89       	ldd	r25, Y+23	; 0x17
    5856:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
    585a:	6c 8b       	std	Y+20, r22	; 0x14
    585c:	7d 8b       	std	Y+21, r23	; 0x15
    585e:	8e 8b       	std	Y+22, r24	; 0x16
    5860:	9f 8b       	std	Y+23, r25	; 0x17
    5862:	d6 c0       	rjmp	.+428    	; 0x5a10 <csp_service_handler+0x4c6>
		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
			break;

		default:
			ret = CSP_ERR_INVAL;
    5864:	8e ef       	ldi	r24, 0xFE	; 254
    5866:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5868:	2f ef       	ldi	r18, 0xFF	; 255
    586a:	2e 87       	std	Y+14, r18	; 0x0e

	switch (csp_conn_dport(conn)) {

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    586c:	89 2b       	or	r24, r25
    586e:	09 f4       	brne	.+2      	; 0x5872 <csp_service_handler+0x328>
    5870:	bd c0       	rjmp	.+378    	; 0x59ec <csp_service_handler+0x4a2>
			csp_buffer_free(packet);
    5872:	ce 01       	movw	r24, r28
    5874:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			return;
    5878:	ce c0       	rjmp	.+412    	; 0x5a16 <csp_service_handler+0x4cc>
		}
		break;

	case CSP_PING:
		/* A ping means, just echo the packet, so no changes */
		csp_log_info("SERVICE: Ping received");
    587a:	86 ec       	ldi	r24, 0xC6	; 198
    587c:	91 e1       	ldi	r25, 0x11	; 17
    587e:	9f 93       	push	r25
    5880:	8f 93       	push	r24
    5882:	82 e0       	ldi	r24, 0x02	; 2
    5884:	8f 93       	push	r24
    5886:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		break;
    588a:	0f 90       	pop	r0
    588c:	0f 90       	pop	r0
    588e:	0f 90       	pop	r0
    5890:	ad c0       	rjmp	.+346    	; 0x59ec <csp_service_handler+0x4a2>

	case CSP_PS: {
		/* Sanity check on request */
		if ((packet->length != 1) || (packet->data[0] != 0x55)) {
    5892:	88 85       	ldd	r24, Y+8	; 0x08
    5894:	99 85       	ldd	r25, Y+9	; 0x09
    5896:	01 97       	sbiw	r24, 0x01	; 1
    5898:	19 f4       	brne	.+6      	; 0x58a0 <csp_service_handler+0x356>
    589a:	8e 85       	ldd	r24, Y+14	; 0x0e
    589c:	85 35       	cpi	r24, 0x55	; 85
    589e:	21 f0       	breq	.+8      	; 0x58a8 <csp_service_handler+0x35e>
			/* Sanity check failed */
			csp_buffer_free(packet);
    58a0:	ce 01       	movw	r24, r28
    58a2:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
			/* Clear the packet, it has been freed */
			packet = NULL;
			break;
		}
		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    58a6:	b7 c0       	rjmp	.+366    	; 0x5a16 <csp_service_handler+0x4cc>
    58a8:	ca d0       	rcall	.+404    	; 0x5a3e <csp_sys_tasklist_size>
		char * pslist = csp_malloc(task_list_size);
    58aa:	8c 01       	movw	r16, r24
    58ac:	0b d8       	rcall	.-4074   	; 0x48c4 <csp_malloc>
    58ae:	4c 01       	movw	r8, r24
		/* Check for malloc fail */
		if (pslist == NULL) {
    58b0:	00 97       	sbiw	r24, 0x00	; 0
    58b2:	a1 f4       	brne	.+40     	; 0x58dc <csp_service_handler+0x392>
			/* Send out the data */
			strcpy((char *)packet->data, "Not enough memory");
    58b4:	22 e1       	ldi	r18, 0x12	; 18
    58b6:	e8 ea       	ldi	r30, 0xA8	; 168
    58b8:	f2 e0       	ldi	r31, 0x02	; 2
    58ba:	ce 01       	movw	r24, r28
    58bc:	0e 96       	adiw	r24, 0x0e	; 14
    58be:	dc 01       	movw	r26, r24
    58c0:	01 90       	ld	r0, Z+
    58c2:	0d 92       	st	X+, r0
    58c4:	2a 95       	dec	r18
    58c6:	e1 f7       	brne	.-8      	; 0x58c0 <csp_service_handler+0x376>
			packet->length = strlen((char *)packet->data);
    58c8:	fc 01       	movw	r30, r24
    58ca:	01 90       	ld	r0, Z+
    58cc:	00 20       	and	r0, r0
    58ce:	e9 f7       	brne	.-6      	; 0x58ca <csp_service_handler+0x380>
    58d0:	31 97       	sbiw	r30, 0x01	; 1
    58d2:	e8 1b       	sub	r30, r24
    58d4:	f9 0b       	sbc	r31, r25
    58d6:	f9 87       	std	Y+9, r31	; 0x09
			/* Break and let the default handling send packet */
			break;
    58d8:	e8 87       	std	Y+8, r30	; 0x08
		}

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    58da:	88 c0       	rjmp	.+272    	; 0x59ec <csp_service_handler+0x4a2>
    58dc:	ab d0       	rcall	.+342    	; 0x5a34 <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    58de:	b8 01       	movw	r22, r16
    58e0:	c4 01       	movw	r24, r8
    58e2:	0e 94 d7 42 	call	0x85ae	; 0x85ae <strnlen>
    58e6:	5c 01       	movw	r10, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    58e8:	18 16       	cp	r1, r24
    58ea:	19 06       	cpc	r1, r25
    58ec:	a4 f5       	brge	.+104    	; 0x5956 <csp_service_handler+0x40c>
    58ee:	c1 2c       	mov	r12, r1
    58f0:	d1 2c       	mov	r13, r1
    58f2:	61 2c       	mov	r6, r1
    58f4:	71 2c       	mov	r7, r1

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    58f6:	20 97       	sbiw	r28, 0x00	; 0
    58f8:	39 f4       	brne	.+14     	; 0x5908 <csp_service_handler+0x3be>
				packet = csp_buffer_get(CSP_RPS_MTU);
    58fa:	84 ec       	ldi	r24, 0xC4	; 196
    58fc:	90 e0       	ldi	r25, 0x00	; 0
    58fe:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <csp_buffer_get>
    5902:	ec 01       	movw	r28, r24
			if (packet == NULL)
    5904:	89 2b       	or	r24, r25
    5906:	39 f1       	breq	.+78     	; 0x5956 <csp_service_handler+0x40c>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    5908:	85 01       	movw	r16, r10
    590a:	0c 19       	sub	r16, r12
    590c:	1d 09       	sbc	r17, r13
    590e:	05 3c       	cpi	r16, 0xC5	; 197
    5910:	11 05       	cpc	r17, r1
    5912:	14 f0       	brlt	.+4      	; 0x5918 <csp_service_handler+0x3ce>
    5914:	04 ec       	ldi	r16, 0xC4	; 196
    5916:	10 e0       	ldi	r17, 0x00	; 0
    5918:	19 87       	std	Y+9, r17	; 0x09
    591a:	08 87       	std	Y+8, r16	; 0x08

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    591c:	b4 01       	movw	r22, r8
    591e:	6c 0d       	add	r22, r12
    5920:	7d 1d       	adc	r23, r13
    5922:	a8 01       	movw	r20, r16
    5924:	ce 01       	movw	r24, r28
    5926:	0e 96       	adiw	r24, 0x0e	; 14
    5928:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>
			i += packet->length;
    592c:	c0 0e       	add	r12, r16
    592e:	d1 1e       	adc	r13, r17
			if (!csp_send(conn, packet, 0))
    5930:	20 e0       	ldi	r18, 0x00	; 0
    5932:	30 e0       	ldi	r19, 0x00	; 0
    5934:	a9 01       	movw	r20, r18
    5936:	be 01       	movw	r22, r28
    5938:	c7 01       	movw	r24, r14
    593a:	0e 94 18 24 	call	0x4830	; 0x4830 <csp_send>
    593e:	89 2b       	or	r24, r25
    5940:	19 f4       	brne	.+6      	; 0x5948 <csp_service_handler+0x3fe>
				csp_buffer_free(packet);
    5942:	ce 01       	movw	r24, r28
    5944:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    5948:	c6 2d       	mov	r28, r6
    594a:	d7 2d       	mov	r29, r7
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    594c:	ca 14       	cp	r12, r10
    594e:	db 04       	cpc	r13, r11
    5950:	94 f2       	brlt	.-92     	; 0x58f6 <csp_service_handler+0x3ac>
    5952:	c0 e0       	ldi	r28, 0x00	; 0
    5954:	d0 e0       	ldi	r29, 0x00	; 0

			/* Clear the packet reference when sent */
			packet = NULL;

		}
		csp_free(pslist);
    5956:	c4 01       	movw	r24, r8
    5958:	0e 94 65 24 	call	0x48ca	; 0x48ca <csp_free>
		break;
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    595c:	47 c0       	rjmp	.+142    	; 0x59ec <csp_service_handler+0x4a2>
    595e:	76 d0       	rcall	.+236    	; 0x5a4c <csp_sys_memfree>

		total = csp_hton32(total);
    5960:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    5964:	6e 87       	std	Y+14, r22	; 0x0e
    5966:	7f 87       	std	Y+15, r23	; 0x0f
    5968:	88 8b       	std	Y+16, r24	; 0x10
    596a:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    596c:	84 e0       	ldi	r24, 0x04	; 4
    596e:	90 e0       	ldi	r25, 0x00	; 0
    5970:	99 87       	std	Y+9, r25	; 0x09
    5972:	88 87       	std	Y+8, r24	; 0x08
    5974:	3b c0       	rjmp	.+118    	; 0x59ec <csp_service_handler+0x4a2>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    5976:	6e 85       	ldd	r22, Y+14	; 0x0e
    5978:	7f 85       	ldd	r23, Y+15	; 0x0f
    597a:	88 89       	ldd	r24, Y+16	; 0x10
    597c:	99 89       	ldd	r25, Y+17	; 0x11
    597e:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <csp_ntoh32>

		/* If the magic word is valid, reboot */
		if (magic_word == CSP_REBOOT_MAGIC) {
    5982:	67 30       	cpi	r22, 0x07	; 7
    5984:	e0 e8       	ldi	r30, 0x80	; 128
    5986:	7e 07       	cpc	r23, r30
    5988:	e7 e0       	ldi	r30, 0x07	; 7
    598a:	8e 07       	cpc	r24, r30
    598c:	e0 e8       	ldi	r30, 0x80	; 128
    598e:	9e 07       	cpc	r25, r30
			csp_sys_reboot();
    5990:	11 f4       	brne	.+4      	; 0x5996 <csp_service_handler+0x44c>
    5992:	b1 d0       	rcall	.+354    	; 0x5af6 <csp_sys_reboot>
    5994:	06 c0       	rjmp	.+12     	; 0x59a2 <csp_service_handler+0x458>
		} else if (magic_word == CSP_REBOOT_SHUTDOWN_MAGIC) {
    5996:	6a 39       	cpi	r22, 0x9A	; 154
    5998:	72 45       	sbci	r23, 0x52	; 82
    599a:	85 4e       	sbci	r24, 0xE5	; 229
    599c:	91 4d       	sbci	r25, 0xD1	; 209
			csp_sys_shutdown();
    599e:	09 f4       	brne	.+2      	; 0x59a2 <csp_service_handler+0x458>
    59a0:	c6 d0       	rcall	.+396    	; 0x5b2e <csp_sys_shutdown>
		}


		
		csp_buffer_free(packet);
    59a2:	ce 01       	movw	r24, r28
    59a4:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    59a8:	36 c0       	rjmp	.+108    	; 0x5a16 <csp_service_handler+0x4cc>
		return;
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    59aa:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <csp_buffer_remaining>
		size = csp_hton32(size);
    59ae:	bc 01       	movw	r22, r24
    59b0:	99 0f       	add	r25, r25
    59b2:	88 0b       	sbc	r24, r24
    59b4:	99 0b       	sbc	r25, r25
    59b6:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    59ba:	6e 87       	std	Y+14, r22	; 0x0e
    59bc:	7f 87       	std	Y+15, r23	; 0x0f
    59be:	88 8b       	std	Y+16, r24	; 0x10
		packet->length = sizeof(size);
    59c0:	99 8b       	std	Y+17, r25	; 0x11
    59c2:	84 e0       	ldi	r24, 0x04	; 4
    59c4:	90 e0       	ldi	r25, 0x00	; 0
    59c6:	99 87       	std	Y+9, r25	; 0x09
    59c8:	88 87       	std	Y+8, r24	; 0x08
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    59ca:	10 c0       	rjmp	.+32     	; 0x59ec <csp_service_handler+0x4a2>
    59cc:	3d d1       	rcall	.+634    	; 0x5c48 <csp_get_s>
		time = csp_hton32(time);
    59ce:	0e 94 3f 1b 	call	0x367e	; 0x367e <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    59d2:	6e 87       	std	Y+14, r22	; 0x0e
    59d4:	7f 87       	std	Y+15, r23	; 0x0f
    59d6:	88 8b       	std	Y+16, r24	; 0x10
    59d8:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    59da:	84 e0       	ldi	r24, 0x04	; 4
    59dc:	90 e0       	ldi	r25, 0x00	; 0
    59de:	99 87       	std	Y+9, r25	; 0x09
    59e0:	88 87       	std	Y+8, r24	; 0x08
    59e2:	04 c0       	rjmp	.+8      	; 0x59ec <csp_service_handler+0x4a2>
		break;
	}

	default:
		csp_buffer_free(packet);
    59e4:	ce 01       	movw	r24, r28
    59e6:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
		return;
    59ea:	15 c0       	rjmp	.+42     	; 0x5a16 <csp_service_handler+0x4cc>
	}

	if (packet != NULL) {
    59ec:	20 97       	sbiw	r28, 0x00	; 0
    59ee:	99 f0       	breq	.+38     	; 0x5a16 <csp_service_handler+0x4cc>
		if (!csp_send(conn, packet, 0))
    59f0:	20 e0       	ldi	r18, 0x00	; 0
    59f2:	30 e0       	ldi	r19, 0x00	; 0
    59f4:	a9 01       	movw	r20, r18
    59f6:	be 01       	movw	r22, r28
    59f8:	c7 01       	movw	r24, r14
    59fa:	0e 94 18 24 	call	0x4830	; 0x4830 <csp_send>
    59fe:	89 2b       	or	r24, r25
    5a00:	51 f4       	brne	.+20     	; 0x5a16 <csp_service_handler+0x4cc>
			csp_buffer_free(packet);
    5a02:	ce 01       	movw	r24, r28
    5a04:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
    5a08:	06 c0       	rjmp	.+12     	; 0x5a16 <csp_service_handler+0x4cc>
		default:
			ret = CSP_ERR_INVAL;
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5a0a:	8f ef       	ldi	r24, 0xFF	; 255
    5a0c:	8e 87       	std	Y+14, r24	; 0x0e
    5a0e:	31 cf       	rjmp	.-414    	; 0x5872 <csp_service_handler+0x328>
    5a10:	8f ef       	ldi	r24, 0xFF	; 255
    5a12:	8e 87       	std	Y+14, r24	; 0x0e
    5a14:	eb cf       	rjmp	.-42     	; 0x59ec <csp_service_handler+0x4a2>
	if (packet != NULL) {
		if (!csp_send(conn, packet, 0))
			csp_buffer_free(packet);
	}

}
    5a16:	df 91       	pop	r29
    5a18:	cf 91       	pop	r28
    5a1a:	1f 91       	pop	r17
    5a1c:	0f 91       	pop	r16
    5a1e:	ff 90       	pop	r15
    5a20:	ef 90       	pop	r14
    5a22:	df 90       	pop	r13
    5a24:	cf 90       	pop	r12
    5a26:	bf 90       	pop	r11
    5a28:	af 90       	pop	r10
    5a2a:	9f 90       	pop	r9
    5a2c:	8f 90       	pop	r8
    5a2e:	7f 90       	pop	r7
    5a30:	6f 90       	pop	r6
    5a32:	08 95       	ret

00005a34 <csp_sys_tasklist>:

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed portCHAR *) out);
#else
	vTaskList(out);
    5a34:	0e 94 e3 3c 	call	0x79c6	; 0x79c6 <vTaskList>
#endif
	return CSP_ERR_NONE;
}
    5a38:	80 e0       	ldi	r24, 0x00	; 0
    5a3a:	90 e0       	ldi	r25, 0x00	; 0
    5a3c:	08 95       	ret

00005a3e <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    5a3e:	0e 94 99 38 	call	0x7132	; 0x7132 <uxTaskGetNumberOfTasks>
}
    5a42:	28 e2       	ldi	r18, 0x28	; 40
    5a44:	82 9f       	mul	r24, r18
    5a46:	c0 01       	movw	r24, r0
    5a48:	11 24       	eor	r1, r1
    5a4a:	08 95       	ret

00005a4c <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    5a4c:	4f 92       	push	r4
    5a4e:	5f 92       	push	r5
    5a50:	6f 92       	push	r6
    5a52:	7f 92       	push	r7
    5a54:	8f 92       	push	r8
    5a56:	9f 92       	push	r9
    5a58:	af 92       	push	r10
    5a5a:	bf 92       	push	r11
    5a5c:	cf 92       	push	r12
    5a5e:	df 92       	push	r13
    5a60:	ef 92       	push	r14
    5a62:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    5a64:	0f 2e       	mov	r0, r31
    5a66:	f0 e1       	ldi	r31, 0x10	; 16
    5a68:	cf 2e       	mov	r12, r31
    5a6a:	f7 e2       	ldi	r31, 0x27	; 39
    5a6c:	df 2e       	mov	r13, r31
    5a6e:	e1 2c       	mov	r14, r1
    5a70:	f1 2c       	mov	r15, r1
    5a72:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    5a74:	44 24       	eor	r4, r4
    5a76:	4a 94       	dec	r4
    5a78:	54 2c       	mov	r5, r4
    5a7a:	32 01       	movw	r6, r4
    5a7c:	81 2c       	mov	r8, r1
    5a7e:	91 2c       	mov	r9, r1
    5a80:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    5a82:	c6 01       	movw	r24, r12
    5a84:	88 0d       	add	r24, r8
    5a86:	99 1d       	adc	r25, r9
    5a88:	c5 d1       	rcall	.+906    	; 0x5e14 <pvPortMalloc>
		if (pmem == NULL) {
    5a8a:	00 97       	sbiw	r24, 0x00	; 0
    5a8c:	59 f4       	brne	.+22     	; 0x5aa4 <csp_sys_memfree+0x58>
			max = size + total;
    5a8e:	24 01       	movw	r4, r8
    5a90:	35 01       	movw	r6, r10
    5a92:	4c 0c       	add	r4, r12
    5a94:	5d 1c       	adc	r5, r13
    5a96:	6e 1c       	adc	r6, r14
    5a98:	7f 1c       	adc	r7, r15
			size = size / 2;
    5a9a:	f6 94       	lsr	r15
    5a9c:	e7 94       	ror	r14
    5a9e:	d7 94       	ror	r13
    5aa0:	c7 94       	ror	r12
    5aa2:	14 c0       	rjmp	.+40     	; 0x5acc <csp_sys_memfree+0x80>
		} else {
			total += size;
    5aa4:	8c 0c       	add	r8, r12
    5aa6:	9d 1c       	adc	r9, r13
    5aa8:	ae 1c       	adc	r10, r14
    5aaa:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    5aac:	b7 01       	movw	r22, r14
    5aae:	a6 01       	movw	r20, r12
    5ab0:	48 0d       	add	r20, r8
    5ab2:	59 1d       	adc	r21, r9
    5ab4:	6a 1d       	adc	r22, r10
    5ab6:	7b 1d       	adc	r23, r11
    5ab8:	44 15       	cp	r20, r4
    5aba:	55 05       	cpc	r21, r5
    5abc:	66 05       	cpc	r22, r6
    5abe:	77 05       	cpc	r23, r7
    5ac0:	20 f0       	brcs	.+8      	; 0x5aca <csp_sys_memfree+0x7e>
				size = size / 2;
    5ac2:	f6 94       	lsr	r15
    5ac4:	e7 94       	ror	r14
    5ac6:	d7 94       	ror	r13
			vPortFree(pmem);
    5ac8:	c7 94       	ror	r12
    5aca:	64 d1       	rcall	.+712    	; 0x5d94 <vPortFree>
		}
		if (size < 32) break;
    5acc:	80 e2       	ldi	r24, 0x20	; 32
    5ace:	c8 16       	cp	r12, r24
    5ad0:	d1 04       	cpc	r13, r1
    5ad2:	e1 04       	cpc	r14, r1
    5ad4:	f1 04       	cpc	r15, r1
    5ad6:	a8 f6       	brcc	.-86     	; 0x5a82 <csp_sys_memfree+0x36>
	}

	return total;
}
    5ad8:	c5 01       	movw	r24, r10
    5ada:	b4 01       	movw	r22, r8
    5adc:	ff 90       	pop	r15
    5ade:	ef 90       	pop	r14
    5ae0:	df 90       	pop	r13
    5ae2:	cf 90       	pop	r12
    5ae4:	bf 90       	pop	r11
    5ae6:	af 90       	pop	r10
    5ae8:	9f 90       	pop	r9
    5aea:	8f 90       	pop	r8
    5aec:	7f 90       	pop	r7
    5aee:	6f 90       	pop	r6
    5af0:	5f 90       	pop	r5
    5af2:	4f 90       	pop	r4
    5af4:	08 95       	ret

00005af6 <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    5af6:	80 e0       	ldi	r24, 0x00	; 0
    5af8:	90 e0       	ldi	r25, 0x00	; 0
    5afa:	89 2b       	or	r24, r25
    5afc:	21 f0       	breq	.+8      	; 0x5b06 <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    5afe:	81 e0       	ldi	r24, 0x01	; 1
    5b00:	90 e0       	ldi	r25, 0x00	; 0
    5b02:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    5b06:	80 e0       	ldi	r24, 0x00	; 0
    5b08:	90 e0       	ldi	r25, 0x00	; 0
    5b0a:	89 2b       	or	r24, r25
    5b0c:	19 f0       	breq	.+6      	; 0x5b14 <csp_sys_reboot+0x1e>
		cpu_reset();
    5b0e:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    5b12:	ff cf       	rjmp	.-2      	; 0x5b12 <csp_sys_reboot+0x1c>
		while (1);
	}
	
	csp_log_error("Failed to reboot");
    5b14:	89 ef       	ldi	r24, 0xF9	; 249
    5b16:	91 e1       	ldi	r25, 0x11	; 17
    5b18:	9f 93       	push	r25
    5b1a:	8f 93       	push	r24
    5b1c:	1f 92       	push	r1
    5b1e:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>

	return CSP_ERR_INVAL;
    5b22:	0f 90       	pop	r0
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
}
    5b28:	8e ef       	ldi	r24, 0xFE	; 254
    5b2a:	9f ef       	ldi	r25, 0xFF	; 255
    5b2c:	08 95       	ret

00005b2e <csp_sys_shutdown>:

int csp_sys_shutdown(void) {

	extern void __attribute__((weak)) cpu_shutdown(void);
	if (cpu_shutdown) {
    5b2e:	80 e0       	ldi	r24, 0x00	; 0
    5b30:	90 e0       	ldi	r25, 0x00	; 0
    5b32:	89 2b       	or	r24, r25
    5b34:	19 f0       	breq	.+6      	; 0x5b3c <csp_sys_shutdown+0xe>
		cpu_shutdown();
    5b36:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    5b3a:	ff cf       	rjmp	.-2      	; 0x5b3a <csp_sys_shutdown+0xc>
		while (1);
	}

	csp_log_error("Failed to shutdown");
    5b3c:	86 ee       	ldi	r24, 0xE6	; 230
    5b3e:	91 e1       	ldi	r25, 0x11	; 17
    5b40:	9f 93       	push	r25
    5b42:	8f 93       	push	r24
    5b44:	1f 92       	push	r1
    5b46:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>

	return CSP_ERR_INVAL;
    5b4a:	0f 90       	pop	r0
    5b4c:	0f 90       	pop	r0
    5b4e:	0f 90       	pop	r0
}
    5b50:	8e ef       	ldi	r24, 0xFE	; 254
    5b52:	9f ef       	ldi	r25, 0xFF	; 255
    5b54:	08 95       	ret

00005b56 <csp_sys_set_color>:

void csp_sys_set_color(csp_color_t color) {
    5b56:	98 2f       	mov	r25, r24

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
    5b58:	e8 2f       	mov	r30, r24
    5b5a:	ef 70       	andi	r30, 0x0F	; 15
    5b5c:	4e 2f       	mov	r20, r30
    5b5e:	50 e0       	ldi	r21, 0x00	; 0
    5b60:	fa 01       	movw	r30, r20
    5b62:	31 97       	sbiw	r30, 0x01	; 1
    5b64:	e8 30       	cpi	r30, 0x08	; 8
    5b66:	f1 05       	cpc	r31, r1
    5b68:	d8 f4       	brcc	.+54     	; 0x5ba0 <csp_sys_set_color+0x4a>
    5b6a:	88 27       	eor	r24, r24
    5b6c:	ef 57       	subi	r30, 0x7F	; 127
    5b6e:	ff 4f       	sbci	r31, 0xFF	; 255
    5b70:	8f 4f       	sbci	r24, 0xFF	; 255
    5b72:	0c 94 16 42 	jmp	0x842c	; 0x842c <__tablejump2__>
		case COLOR_BLACK:
			color_code = 30; break;
		case COLOR_RED:
			color_code = 31; break;
    5b76:	2f e1       	ldi	r18, 0x1F	; 31
    5b78:	30 e0       	ldi	r19, 0x00	; 0
    5b7a:	17 c0       	rjmp	.+46     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_GREEN:
			color_code = 32; break;
    5b7c:	20 e2       	ldi	r18, 0x20	; 32
    5b7e:	30 e0       	ldi	r19, 0x00	; 0
    5b80:	14 c0       	rjmp	.+40     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_YELLOW:
			color_code = 33; break;
    5b82:	21 e2       	ldi	r18, 0x21	; 33
    5b84:	30 e0       	ldi	r19, 0x00	; 0
    5b86:	11 c0       	rjmp	.+34     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_BLUE:
			color_code = 34; break;
    5b88:	22 e2       	ldi	r18, 0x22	; 34
    5b8a:	30 e0       	ldi	r19, 0x00	; 0
    5b8c:	0e c0       	rjmp	.+28     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_MAGENTA:
			color_code = 35; break;
    5b8e:	23 e2       	ldi	r18, 0x23	; 35
    5b90:	30 e0       	ldi	r19, 0x00	; 0
    5b92:	0b c0       	rjmp	.+22     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_CYAN:
			color_code = 36; break;
    5b94:	24 e2       	ldi	r18, 0x24	; 36
    5b96:	30 e0       	ldi	r19, 0x00	; 0
    5b98:	08 c0       	rjmp	.+16     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_WHITE:
			color_code = 37; break;
    5b9a:	25 e2       	ldi	r18, 0x25	; 37
    5b9c:	30 e0       	ldi	r19, 0x00	; 0
    5b9e:	05 c0       	rjmp	.+10     	; 0x5baa <csp_sys_set_color+0x54>
		case COLOR_RESET:
		default:
			color_code = 0; break;
    5ba0:	20 e0       	ldi	r18, 0x00	; 0
    5ba2:	30 e0       	ldi	r19, 0x00	; 0
    5ba4:	02 c0       	rjmp	.+4      	; 0x5baa <csp_sys_set_color+0x54>
void csp_sys_set_color(csp_color_t color) {

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
		case COLOR_BLACK:
			color_code = 30; break;
    5ba6:	2e e1       	ldi	r18, 0x1E	; 30
    5ba8:	30 e0       	ldi	r19, 0x00	; 0
		case COLOR_RESET:
		default:
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
    5baa:	89 2f       	mov	r24, r25
    5bac:	80 7f       	andi	r24, 0xF0	; 240
    5bae:	80 32       	cpi	r24, 0x20	; 32
    5bb0:	49 f0       	breq	.+18     	; 0x5bc4 <csp_sys_set_color+0x6e>
    5bb2:	18 f4       	brcc	.+6      	; 0x5bba <csp_sys_set_color+0x64>
    5bb4:	80 31       	cpi	r24, 0x10	; 16
    5bb6:	91 f0       	breq	.+36     	; 0x5bdc <csp_sys_set_color+0x86>
    5bb8:	0e c0       	rjmp	.+28     	; 0x5bd6 <csp_sys_set_color+0x80>
    5bba:	80 33       	cpi	r24, 0x30	; 48
    5bbc:	31 f0       	breq	.+12     	; 0x5bca <csp_sys_set_color+0x74>
    5bbe:	80 34       	cpi	r24, 0x40	; 64
    5bc0:	39 f0       	breq	.+14     	; 0x5bd0 <csp_sys_set_color+0x7a>
    5bc2:	09 c0       	rjmp	.+18     	; 0x5bd6 <csp_sys_set_color+0x80>
		case COLOR_BOLD:
			modifier_code = 1; break;
		case COLOR_UNDERLINE:
			modifier_code = 2; break;
    5bc4:	82 e0       	ldi	r24, 0x02	; 2
    5bc6:	90 e0       	ldi	r25, 0x00	; 0
    5bc8:	0b c0       	rjmp	.+22     	; 0x5be0 <csp_sys_set_color+0x8a>
		case COLOR_BLINK:
			modifier_code = 3; break;
    5bca:	83 e0       	ldi	r24, 0x03	; 3
    5bcc:	90 e0       	ldi	r25, 0x00	; 0
    5bce:	08 c0       	rjmp	.+16     	; 0x5be0 <csp_sys_set_color+0x8a>
		case COLOR_HIDE:
			modifier_code = 4; break;
    5bd0:	84 e0       	ldi	r24, 0x04	; 4
    5bd2:	90 e0       	ldi	r25, 0x00	; 0
    5bd4:	05 c0       	rjmp	.+10     	; 0x5be0 <csp_sys_set_color+0x8a>
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
    5bd6:	80 e0       	ldi	r24, 0x00	; 0
    5bd8:	90 e0       	ldi	r25, 0x00	; 0
    5bda:	02 c0       	rjmp	.+4      	; 0x5be0 <csp_sys_set_color+0x8a>
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
		case COLOR_BOLD:
			modifier_code = 1; break;
    5bdc:	81 e0       	ldi	r24, 0x01	; 1
    5bde:	90 e0       	ldi	r25, 0x00	; 0
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
	}

	printf("\033[%u;%um", modifier_code, color_code);
    5be0:	3f 93       	push	r19
    5be2:	2f 93       	push	r18
    5be4:	9f 93       	push	r25
    5be6:	8f 93       	push	r24
    5be8:	8d ed       	ldi	r24, 0xDD	; 221
    5bea:	91 e1       	ldi	r25, 0x11	; 17
    5bec:	9f 93       	push	r25
    5bee:	8f 93       	push	r24
    5bf0:	0e 94 3f 43 	call	0x867e	; 0x867e <printf_P>
}
    5bf4:	0f 90       	pop	r0
    5bf6:	0f 90       	pop	r0
    5bf8:	0f 90       	pop	r0
    5bfa:	0f 90       	pop	r0
    5bfc:	0f 90       	pop	r0
    5bfe:	0f 90       	pop	r0
    5c00:	08 95       	ret

00005c02 <csp_thread_create>:
/* CSP includes */
#include "csp.h"

#include "csp_thread.h"

int csp_thread_create(csp_thread_return_t (* routine)(void *), const char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    5c02:	ef 92       	push	r14
    5c04:	ff 92       	push	r15
    5c06:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
    5c08:	0e 94 af 36 	call	0x6d5e	; 0x6d5e <xTaskCreate>
    5c0c:	21 e0       	ldi	r18, 0x01	; 1
    5c0e:	30 e0       	ldi	r19, 0x00	; 0
    5c10:	81 30       	cpi	r24, 0x01	; 1
    5c12:	11 f4       	brne	.+4      	; 0x5c18 <csp_thread_create+0x16>
    5c14:	20 e0       	ldi	r18, 0x00	; 0
    5c16:	30 e0       	ldi	r19, 0x00	; 0
	portBASE_TYPE ret = xTaskCreate(routine, (signed char *) thread_name, stack_depth, parameters, priority, handle);
#endif
	if (ret != pdTRUE)
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    5c18:	88 27       	eor	r24, r24
    5c1a:	99 27       	eor	r25, r25
    5c1c:	82 1b       	sub	r24, r18
    5c1e:	93 0b       	sbc	r25, r19
    5c20:	0f 91       	pop	r16
    5c22:	ff 90       	pop	r15
    5c24:	ef 90       	pop	r14
    5c26:	08 95       	ret

00005c28 <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    5c28:	0e 94 8f 38 	call	0x711e	; 0x711e <xTaskGetTickCount>
    5c2c:	bc 01       	movw	r22, r24
    5c2e:	66 0f       	add	r22, r22
    5c30:	77 1f       	adc	r23, r23
    5c32:	88 0f       	add	r24, r24
    5c34:	99 1f       	adc	r25, r25
    5c36:	88 0f       	add	r24, r24
    5c38:	99 1f       	adc	r25, r25
    5c3a:	88 0f       	add	r24, r24
    5c3c:	99 1f       	adc	r25, r25
    5c3e:	68 0f       	add	r22, r24
    5c40:	79 1f       	adc	r23, r25
    5c42:	80 e0       	ldi	r24, 0x00	; 0
    5c44:	90 e0       	ldi	r25, 0x00	; 0
    5c46:	08 95       	ret

00005c48 <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    5c48:	0e 94 8f 38 	call	0x711e	; 0x711e <xTaskGetTickCount>
    5c4c:	9c 01       	movw	r18, r24
    5c4e:	36 95       	lsr	r19
    5c50:	27 95       	ror	r18
    5c52:	36 95       	lsr	r19
    5c54:	27 95       	ror	r18
    5c56:	ab e7       	ldi	r26, 0x7B	; 123
    5c58:	b4 e1       	ldi	r27, 0x14	; 20
    5c5a:	0e 94 1e 42 	call	0x843c	; 0x843c <__umulhisi3>
    5c5e:	96 95       	lsr	r25
    5c60:	87 95       	ror	r24
    5c62:	bc 01       	movw	r22, r24
    5c64:	80 e0       	ldi	r24, 0x00	; 0
    5c66:	90 e0       	ldi	r25, 0x00	; 0
}
    5c68:	08 95       	ret

00005c6a <csp_udp_new_packet>:
#include "csp_queue.h"
#include "csp_port.h"
#include "csp_conn.h"
#include "csp_transport.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    5c6a:	0f 93       	push	r16
    5c6c:	1f 93       	push	r17
    5c6e:	cf 93       	push	r28
    5c70:	df 93       	push	r29
    5c72:	1f 92       	push	r1
    5c74:	1f 92       	push	r1
    5c76:	cd b7       	in	r28, 0x3d	; 61
    5c78:	de b7       	in	r29, 0x3e	; 62
    5c7a:	9a 83       	std	Y+2, r25	; 0x02
    5c7c:	89 83       	std	Y+1, r24	; 0x01
    5c7e:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    5c80:	0e 94 33 17 	call	0x2e66	; 0x2e66 <csp_conn_enqueue_packet>
    5c84:	99 23       	and	r25, r25
    5c86:	74 f4       	brge	.+28     	; 0x5ca4 <csp_udp_new_packet+0x3a>
		csp_log_error("Connection buffer queue full!");
    5c88:	8f e2       	ldi	r24, 0x2F	; 47
    5c8a:	92 e1       	ldi	r25, 0x12	; 18
    5c8c:	9f 93       	push	r25
    5c8e:	8f 93       	push	r24
    5c90:	1f 92       	push	r1
    5c92:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
		csp_buffer_free(packet);
    5c96:	c8 01       	movw	r24, r16
    5c98:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <csp_buffer_free>
		return;
    5c9c:	0f 90       	pop	r0
    5c9e:	0f 90       	pop	r0
    5ca0:	0f 90       	pop	r0
    5ca2:	24 c0       	rjmp	.+72     	; 0x5cec <csp_udp_new_packet+0x82>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    5ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    5ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    5ca8:	86 85       	ldd	r24, Z+14	; 0x0e
    5caa:	97 85       	ldd	r25, Z+15	; 0x0f
    5cac:	00 97       	sbiw	r24, 0x00	; 0
    5cae:	f1 f0       	breq	.+60     	; 0x5cec <csp_udp_new_packet+0x82>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    5cb0:	20 e0       	ldi	r18, 0x00	; 0
    5cb2:	30 e0       	ldi	r19, 0x00	; 0
    5cb4:	a9 01       	movw	r20, r18
    5cb6:	be 01       	movw	r22, r28
    5cb8:	6f 5f       	subi	r22, 0xFF	; 255
    5cba:	7f 4f       	sbci	r23, 0xFF	; 255
    5cbc:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <csp_queue_enqueue>
    5cc0:	01 97       	sbiw	r24, 0x01	; 1
    5cc2:	81 f0       	breq	.+32     	; 0x5ce4 <csp_udp_new_packet+0x7a>
			csp_log_warn("Warning socket connection queue full");
    5cc4:	8a e0       	ldi	r24, 0x0A	; 10
    5cc6:	92 e1       	ldi	r25, 0x12	; 18
    5cc8:	9f 93       	push	r25
    5cca:	8f 93       	push	r24
    5ccc:	81 e0       	ldi	r24, 0x01	; 1
    5cce:	8f 93       	push	r24
    5cd0:	0e 94 c0 1a 	call	0x3580	; 0x3580 <do_csp_debug>
			csp_close(conn);
    5cd4:	89 81       	ldd	r24, Y+1	; 0x01
    5cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cd8:	0e 94 c7 18 	call	0x318e	; 0x318e <csp_close>
			return;
    5cdc:	0f 90       	pop	r0
    5cde:	0f 90       	pop	r0
    5ce0:	0f 90       	pop	r0
    5ce2:	04 c0       	rjmp	.+8      	; 0x5cec <csp_udp_new_packet+0x82>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    5ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    5ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    5ce8:	17 86       	std	Z+15, r1	; 0x0f
    5cea:	16 86       	std	Z+14, r1	; 0x0e
	}

}
    5cec:	0f 90       	pop	r0
    5cee:	0f 90       	pop	r0
    5cf0:	df 91       	pop	r29
    5cf2:	cf 91       	pop	r28
    5cf4:	1f 91       	pop	r17
    5cf6:	0f 91       	pop	r16
    5cf8:	08 95       	ret

00005cfa <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    5cfa:	cf 93       	push	r28
    5cfc:	df 93       	push	r29
    5cfe:	dc 01       	movw	r26, r24
    5d00:	ee e7       	ldi	r30, 0x7E	; 126
    5d02:	f6 e0       	ldi	r31, 0x06	; 6
    5d04:	01 c0       	rjmp	.+2      	; 0x5d08 <prvInsertBlockIntoFreeList+0xe>
    5d06:	f9 01       	movw	r30, r18
    5d08:	20 81       	ld	r18, Z
    5d0a:	31 81       	ldd	r19, Z+1	; 0x01
    5d0c:	2a 17       	cp	r18, r26
    5d0e:	3b 07       	cpc	r19, r27
    5d10:	d0 f3       	brcs	.-12     	; 0x5d06 <prvInsertBlockIntoFreeList+0xc>
    5d12:	82 81       	ldd	r24, Z+2	; 0x02
    5d14:	93 81       	ldd	r25, Z+3	; 0x03
    5d16:	af 01       	movw	r20, r30
    5d18:	48 0f       	add	r20, r24
    5d1a:	59 1f       	adc	r21, r25
    5d1c:	a4 17       	cp	r26, r20
    5d1e:	b5 07       	cpc	r27, r21
    5d20:	49 f4       	brne	.+18     	; 0x5d34 <prvInsertBlockIntoFreeList+0x3a>
    5d22:	12 96       	adiw	r26, 0x02	; 2
    5d24:	4d 91       	ld	r20, X+
    5d26:	5c 91       	ld	r21, X
    5d28:	13 97       	sbiw	r26, 0x03	; 3
    5d2a:	84 0f       	add	r24, r20
    5d2c:	95 1f       	adc	r25, r21
    5d2e:	93 83       	std	Z+3, r25	; 0x03
    5d30:	82 83       	std	Z+2, r24	; 0x02
    5d32:	df 01       	movw	r26, r30
    5d34:	12 96       	adiw	r26, 0x02	; 2
    5d36:	8d 91       	ld	r24, X+
    5d38:	9c 91       	ld	r25, X
    5d3a:	13 97       	sbiw	r26, 0x03	; 3
    5d3c:	ed 01       	movw	r28, r26
    5d3e:	c8 0f       	add	r28, r24
    5d40:	d9 1f       	adc	r29, r25
    5d42:	2c 17       	cp	r18, r28
    5d44:	3d 07       	cpc	r19, r29
    5d46:	d9 f4       	brne	.+54     	; 0x5d7e <prvInsertBlockIntoFreeList+0x84>
    5d48:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <pxEnd>
    5d4c:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <pxEnd+0x1>
    5d50:	c2 17       	cp	r28, r18
    5d52:	d3 07       	cpc	r29, r19
    5d54:	81 f0       	breq	.+32     	; 0x5d76 <prvInsertBlockIntoFreeList+0x7c>
    5d56:	2a 81       	ldd	r18, Y+2	; 0x02
    5d58:	3b 81       	ldd	r19, Y+3	; 0x03
    5d5a:	82 0f       	add	r24, r18
    5d5c:	93 1f       	adc	r25, r19
    5d5e:	13 96       	adiw	r26, 0x03	; 3
    5d60:	9c 93       	st	X, r25
    5d62:	8e 93       	st	-X, r24
    5d64:	12 97       	sbiw	r26, 0x02	; 2
    5d66:	c0 81       	ld	r28, Z
    5d68:	d1 81       	ldd	r29, Z+1	; 0x01
    5d6a:	88 81       	ld	r24, Y
    5d6c:	99 81       	ldd	r25, Y+1	; 0x01
    5d6e:	11 96       	adiw	r26, 0x01	; 1
    5d70:	9c 93       	st	X, r25
    5d72:	8e 93       	st	-X, r24
    5d74:	07 c0       	rjmp	.+14     	; 0x5d84 <prvInsertBlockIntoFreeList+0x8a>
    5d76:	11 96       	adiw	r26, 0x01	; 1
    5d78:	dc 93       	st	X, r29
    5d7a:	ce 93       	st	-X, r28
    5d7c:	03 c0       	rjmp	.+6      	; 0x5d84 <prvInsertBlockIntoFreeList+0x8a>
    5d7e:	11 96       	adiw	r26, 0x01	; 1
    5d80:	3c 93       	st	X, r19
    5d82:	2e 93       	st	-X, r18
    5d84:	ae 17       	cp	r26, r30
    5d86:	bf 07       	cpc	r27, r31
    5d88:	11 f0       	breq	.+4      	; 0x5d8e <prvInsertBlockIntoFreeList+0x94>
    5d8a:	b1 83       	std	Z+1, r27	; 0x01
    5d8c:	a0 83       	st	Z, r26
    5d8e:	df 91       	pop	r29
    5d90:	cf 91       	pop	r28
    5d92:	08 95       	ret

00005d94 <vPortFree>:
    5d94:	cf 93       	push	r28
    5d96:	df 93       	push	r29
    5d98:	00 97       	sbiw	r24, 0x00	; 0
    5d9a:	51 f1       	breq	.+84     	; 0x5df0 <vPortFree+0x5c>
    5d9c:	fc 01       	movw	r30, r24
    5d9e:	34 97       	sbiw	r30, 0x04	; 4
    5da0:	22 81       	ldd	r18, Z+2	; 0x02
    5da2:	33 81       	ldd	r19, Z+3	; 0x03
    5da4:	40 91 76 06 	lds	r20, 0x0676	; 0x800676 <xBlockAllocatedBit>
    5da8:	50 91 77 06 	lds	r21, 0x0677	; 0x800677 <xBlockAllocatedBit+0x1>
    5dac:	b9 01       	movw	r22, r18
    5dae:	64 23       	and	r22, r20
    5db0:	75 23       	and	r23, r21
    5db2:	67 2b       	or	r22, r23
    5db4:	e9 f0       	breq	.+58     	; 0x5df0 <vPortFree+0x5c>
    5db6:	60 81       	ld	r22, Z
    5db8:	71 81       	ldd	r23, Z+1	; 0x01
    5dba:	67 2b       	or	r22, r23
    5dbc:	c9 f4       	brne	.+50     	; 0x5df0 <vPortFree+0x5c>
    5dbe:	ef 01       	movw	r28, r30
    5dc0:	40 95       	com	r20
    5dc2:	50 95       	com	r21
    5dc4:	24 23       	and	r18, r20
    5dc6:	35 23       	and	r19, r21
    5dc8:	33 83       	std	Z+3, r19	; 0x03
    5dca:	22 83       	std	Z+2, r18	; 0x02
    5dcc:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
    5dd0:	20 91 7a 06 	lds	r18, 0x067A	; 0x80067a <xFreeBytesRemaining>
    5dd4:	30 91 7b 06 	lds	r19, 0x067B	; 0x80067b <xFreeBytesRemaining+0x1>
    5dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dda:	9b 81       	ldd	r25, Y+3	; 0x03
    5ddc:	82 0f       	add	r24, r18
    5dde:	93 1f       	adc	r25, r19
    5de0:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xFreeBytesRemaining+0x1>
    5de4:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xFreeBytesRemaining>
    5de8:	ce 01       	movw	r24, r28
    5dea:	87 df       	rcall	.-242    	; 0x5cfa <prvInsertBlockIntoFreeList>
    5dec:	0e 94 46 39 	call	0x728c	; 0x728c <xTaskResumeAll>
    5df0:	df 91       	pop	r29
    5df2:	cf 91       	pop	r28
    5df4:	08 95       	ret

00005df6 <vApplicationMallocFailedHook>:
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
void vApplicationMallocFailedHook(void) {
	printf("outmem");
    5df6:	8a eb       	ldi	r24, 0xBA	; 186
    5df8:	92 e0       	ldi	r25, 0x02	; 2
    5dfa:	9f 93       	push	r25
    5dfc:	8f 93       	push	r24
    5dfe:	0e 94 2c 43 	call	0x8658	; 0x8658 <printf>
	FORCERESET
    5e02:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
    5e06:	81 ec       	ldi	r24, 0xC1	; 193
    5e08:	92 e0       	ldi	r25, 0x02	; 2
    5e0a:	0e 94 66 43 	call	0x86cc	; 0x86cc <puts>
    5e0e:	0f 90       	pop	r0
    5e10:	0f 90       	pop	r0
    5e12:	ff cf       	rjmp	.-2      	; 0x5e12 <vApplicationMallocFailedHook+0x1c>

00005e14 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5e14:	cf 92       	push	r12
    5e16:	df 92       	push	r13
    5e18:	ef 92       	push	r14
    5e1a:	ff 92       	push	r15
    5e1c:	0f 93       	push	r16
    5e1e:	1f 93       	push	r17
    5e20:	cf 93       	push	r28
    5e22:	df 93       	push	r29
    5e24:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    5e26:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    5e2a:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <pxEnd>
    5e2e:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <pxEnd+0x1>
    5e32:	89 2b       	or	r24, r25
    5e34:	41 f5       	brne	.+80     	; 0x5e86 <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    5e36:	ee e7       	ldi	r30, 0x7E	; 126
    5e38:	f6 e0       	ldi	r31, 0x06	; 6
    5e3a:	a2 e8       	ldi	r26, 0x82	; 130
    5e3c:	b6 e0       	ldi	r27, 0x06	; 6
    5e3e:	b1 83       	std	Z+1, r27	; 0x01
    5e40:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    5e42:	13 82       	std	Z+3, r1	; 0x03
    5e44:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    5e46:	e2 ee       	ldi	r30, 0xE2	; 226
    5e48:	ff e1       	ldi	r31, 0x1F	; 31
    5e4a:	f0 93 7d 06 	sts	0x067D, r31	; 0x80067d <pxEnd+0x1>
    5e4e:	e0 93 7c 06 	sts	0x067C, r30	; 0x80067c <pxEnd>
	pxEnd->xBlockSize = 0;
    5e52:	13 82       	std	Z+3, r1	; 0x03
    5e54:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    5e56:	11 82       	std	Z+1, r1	; 0x01
    5e58:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    5e5a:	80 e6       	ldi	r24, 0x60	; 96
    5e5c:	99 e1       	ldi	r25, 0x19	; 25
    5e5e:	13 96       	adiw	r26, 0x03	; 3
    5e60:	9c 93       	st	X, r25
    5e62:	8e 93       	st	-X, r24
    5e64:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    5e66:	ed 93       	st	X+, r30
    5e68:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    5e6a:	90 93 79 06 	sts	0x0679, r25	; 0x800679 <xMinimumEverFreeBytesRemaining+0x1>
    5e6e:	80 93 78 06 	sts	0x0678, r24	; 0x800678 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    5e72:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xFreeBytesRemaining+0x1>
    5e76:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    5e7a:	80 e0       	ldi	r24, 0x00	; 0
    5e7c:	90 e8       	ldi	r25, 0x80	; 128
    5e7e:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <xBlockAllocatedBit+0x1>
    5e82:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    5e86:	e0 90 76 06 	lds	r14, 0x0676	; 0x800676 <xBlockAllocatedBit>
    5e8a:	f0 90 77 06 	lds	r15, 0x0677	; 0x800677 <xBlockAllocatedBit+0x1>
    5e8e:	c7 01       	movw	r24, r14
    5e90:	8c 23       	and	r24, r28
    5e92:	9d 23       	and	r25, r29
    5e94:	89 2b       	or	r24, r25
    5e96:	09 f0       	breq	.+2      	; 0x5e9a <pvPortMalloc+0x86>
    5e98:	62 c0       	rjmp	.+196    	; 0x5f5e <pvPortMalloc+0x14a>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    5e9a:	20 97       	sbiw	r28, 0x00	; 0
    5e9c:	09 f4       	brne	.+2      	; 0x5ea0 <pvPortMalloc+0x8c>
    5e9e:	62 c0       	rjmp	.+196    	; 0x5f64 <pvPortMalloc+0x150>
			{
				xWantedSize += xHeapStructSize;
    5ea0:	ae 01       	movw	r20, r28
    5ea2:	4c 5f       	subi	r20, 0xFC	; 252
    5ea4:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    5ea6:	09 f4       	brne	.+2      	; 0x5eaa <pvPortMalloc+0x96>
    5ea8:	5a c0       	rjmp	.+180    	; 0x5f5e <pvPortMalloc+0x14a>
    5eaa:	00 91 7a 06 	lds	r16, 0x067A	; 0x80067a <xFreeBytesRemaining>
    5eae:	10 91 7b 06 	lds	r17, 0x067B	; 0x80067b <xFreeBytesRemaining+0x1>
    5eb2:	04 17       	cp	r16, r20
    5eb4:	15 07       	cpc	r17, r21
    5eb6:	08 f4       	brcc	.+2      	; 0x5eba <pvPortMalloc+0xa6>
    5eb8:	52 c0       	rjmp	.+164    	; 0x5f5e <pvPortMalloc+0x14a>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    5eba:	c0 91 7e 06 	lds	r28, 0x067E	; 0x80067e <xStart>
    5ebe:	d0 91 7f 06 	lds	r29, 0x067F	; 0x80067f <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    5ec2:	ee e7       	ldi	r30, 0x7E	; 126
    5ec4:	f6 e0       	ldi	r31, 0x06	; 6
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    5ec6:	02 c0       	rjmp	.+4      	; 0x5ecc <pvPortMalloc+0xb8>
    5ec8:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    5eca:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    5ecc:	2a 81       	ldd	r18, Y+2	; 0x02
    5ece:	3b 81       	ldd	r19, Y+3	; 0x03
    5ed0:	24 17       	cp	r18, r20
    5ed2:	35 07       	cpc	r19, r21
    5ed4:	28 f4       	brcc	.+10     	; 0x5ee0 <pvPortMalloc+0xcc>
    5ed6:	28 81       	ld	r18, Y
    5ed8:	39 81       	ldd	r19, Y+1	; 0x01
    5eda:	21 15       	cp	r18, r1
    5edc:	31 05       	cpc	r19, r1
    5ede:	a1 f7       	brne	.-24     	; 0x5ec8 <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    5ee0:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <pxEnd>
    5ee4:	90 91 7d 06 	lds	r25, 0x067D	; 0x80067d <pxEnd+0x1>
    5ee8:	c8 17       	cp	r28, r24
    5eea:	d9 07       	cpc	r29, r25
    5eec:	c1 f1       	breq	.+112    	; 0x5f5e <pvPortMalloc+0x14a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    5eee:	c0 80       	ld	r12, Z
    5ef0:	d1 80       	ldd	r13, Z+1	; 0x01
    5ef2:	84 e0       	ldi	r24, 0x04	; 4
    5ef4:	c8 0e       	add	r12, r24
    5ef6:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    5ef8:	88 81       	ld	r24, Y
    5efa:	99 81       	ldd	r25, Y+1	; 0x01
    5efc:	91 83       	std	Z+1, r25	; 0x01
    5efe:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    5f00:	2a 81       	ldd	r18, Y+2	; 0x02
    5f02:	3b 81       	ldd	r19, Y+3	; 0x03
    5f04:	24 1b       	sub	r18, r20
    5f06:	35 0b       	sbc	r19, r21
    5f08:	29 30       	cpi	r18, 0x09	; 9
    5f0a:	31 05       	cpc	r19, r1
    5f0c:	48 f0       	brcs	.+18     	; 0x5f20 <pvPortMalloc+0x10c>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    5f0e:	ce 01       	movw	r24, r28
    5f10:	84 0f       	add	r24, r20
    5f12:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    5f14:	fc 01       	movw	r30, r24
    5f16:	33 83       	std	Z+3, r19	; 0x03
    5f18:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    5f1a:	5b 83       	std	Y+3, r21	; 0x03
    5f1c:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    5f1e:	ed de       	rcall	.-550    	; 0x5cfa <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    5f20:	8a 81       	ldd	r24, Y+2	; 0x02
    5f22:	9b 81       	ldd	r25, Y+3	; 0x03
    5f24:	08 1b       	sub	r16, r24
    5f26:	19 0b       	sbc	r17, r25
    5f28:	10 93 7b 06 	sts	0x067B, r17	; 0x80067b <xFreeBytesRemaining+0x1>
    5f2c:	00 93 7a 06 	sts	0x067A, r16	; 0x80067a <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    5f30:	20 91 78 06 	lds	r18, 0x0678	; 0x800678 <xMinimumEverFreeBytesRemaining>
    5f34:	30 91 79 06 	lds	r19, 0x0679	; 0x800679 <xMinimumEverFreeBytesRemaining+0x1>
    5f38:	02 17       	cp	r16, r18
    5f3a:	13 07       	cpc	r17, r19
    5f3c:	20 f4       	brcc	.+8      	; 0x5f46 <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    5f3e:	10 93 79 06 	sts	0x0679, r17	; 0x800679 <xMinimumEverFreeBytesRemaining+0x1>
    5f42:	00 93 78 06 	sts	0x0678, r16	; 0x800678 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    5f46:	e8 2a       	or	r14, r24
    5f48:	f9 2a       	or	r15, r25
    5f4a:	fb 82       	std	Y+3, r15	; 0x03
    5f4c:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    5f4e:	19 82       	std	Y+1, r1	; 0x01
    5f50:	18 82       	st	Y, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    5f52:	0e 94 46 39 	call	0x728c	; 0x728c <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    5f56:	c1 14       	cp	r12, r1
    5f58:	d1 04       	cpc	r13, r1
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    5f5a:	39 f4       	brne	.+14     	; 0x5f6a <pvPortMalloc+0x156>
    5f5c:	4c df       	rcall	.-360    	; 0x5df6 <vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    5f5e:	0e 94 46 39 	call	0x728c	; 0x728c <xTaskResumeAll>
    5f62:	fc cf       	rjmp	.-8      	; 0x5f5c <pvPortMalloc+0x148>
    5f64:	0e 94 46 39 	call	0x728c	; 0x728c <xTaskResumeAll>
    5f68:	f9 cf       	rjmp	.-14     	; 0x5f5c <pvPortMalloc+0x148>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    5f6a:	c6 01       	movw	r24, r12
    5f6c:	df 91       	pop	r29
    5f6e:	cf 91       	pop	r28
    5f70:	1f 91       	pop	r17
    5f72:	0f 91       	pop	r16
    5f74:	ff 90       	pop	r15
    5f76:	ef 90       	pop	r14
    5f78:	df 90       	pop	r13
    5f7a:	cf 90       	pop	r12
    5f7c:	08 95       	ret

00005f7e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    5f7e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5f80:	03 96       	adiw	r24, 0x03	; 3
    5f82:	92 83       	std	Z+2, r25	; 0x02
    5f84:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    5f86:	2f ef       	ldi	r18, 0xFF	; 255
    5f88:	3f ef       	ldi	r19, 0xFF	; 255
    5f8a:	34 83       	std	Z+4, r19	; 0x04
    5f8c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5f8e:	96 83       	std	Z+6, r25	; 0x06
    5f90:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5f92:	90 87       	std	Z+8, r25	; 0x08
    5f94:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    5f96:	10 82       	st	Z, r1
    5f98:	08 95       	ret

00005f9a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    5f9a:	fc 01       	movw	r30, r24
    5f9c:	11 86       	std	Z+9, r1	; 0x09
    5f9e:	10 86       	std	Z+8, r1	; 0x08
    5fa0:	08 95       	ret

00005fa2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5fa2:	cf 93       	push	r28
    5fa4:	df 93       	push	r29
    5fa6:	9c 01       	movw	r18, r24
    5fa8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    5faa:	dc 01       	movw	r26, r24
    5fac:	11 96       	adiw	r26, 0x01	; 1
    5fae:	cd 91       	ld	r28, X+
    5fb0:	dc 91       	ld	r29, X
    5fb2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    5fb4:	d3 83       	std	Z+3, r29	; 0x03
    5fb6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    5fb8:	8c 81       	ldd	r24, Y+4	; 0x04
    5fba:	9d 81       	ldd	r25, Y+5	; 0x05
    5fbc:	95 83       	std	Z+5, r25	; 0x05
    5fbe:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    5fc0:	8c 81       	ldd	r24, Y+4	; 0x04
    5fc2:	9d 81       	ldd	r25, Y+5	; 0x05
    5fc4:	dc 01       	movw	r26, r24
    5fc6:	13 96       	adiw	r26, 0x03	; 3
    5fc8:	7c 93       	st	X, r23
    5fca:	6e 93       	st	-X, r22
    5fcc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    5fce:	7d 83       	std	Y+5, r23	; 0x05
    5fd0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    5fd2:	31 87       	std	Z+9, r19	; 0x09
    5fd4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    5fd6:	f9 01       	movw	r30, r18
    5fd8:	80 81       	ld	r24, Z
    5fda:	8f 5f       	subi	r24, 0xFF	; 255
    5fdc:	80 83       	st	Z, r24
}
    5fde:	df 91       	pop	r29
    5fe0:	cf 91       	pop	r28
    5fe2:	08 95       	ret

00005fe4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5fe4:	cf 93       	push	r28
    5fe6:	df 93       	push	r29
    5fe8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    5fea:	48 81       	ld	r20, Y
    5fec:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    5fee:	4f 3f       	cpi	r20, 0xFF	; 255
    5ff0:	2f ef       	ldi	r18, 0xFF	; 255
    5ff2:	52 07       	cpc	r21, r18
    5ff4:	21 f4       	brne	.+8      	; 0x5ffe <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    5ff6:	fc 01       	movw	r30, r24
    5ff8:	a7 81       	ldd	r26, Z+7	; 0x07
    5ffa:	b0 85       	ldd	r27, Z+8	; 0x08
    5ffc:	0d c0       	rjmp	.+26     	; 0x6018 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    5ffe:	dc 01       	movw	r26, r24
    6000:	13 96       	adiw	r26, 0x03	; 3
    6002:	01 c0       	rjmp	.+2      	; 0x6006 <vListInsert+0x22>
    6004:	df 01       	movw	r26, r30
    6006:	12 96       	adiw	r26, 0x02	; 2
    6008:	ed 91       	ld	r30, X+
    600a:	fc 91       	ld	r31, X
    600c:	13 97       	sbiw	r26, 0x03	; 3
    600e:	20 81       	ld	r18, Z
    6010:	31 81       	ldd	r19, Z+1	; 0x01
    6012:	42 17       	cp	r20, r18
    6014:	53 07       	cpc	r21, r19
    6016:	b0 f7       	brcc	.-20     	; 0x6004 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    6018:	12 96       	adiw	r26, 0x02	; 2
    601a:	ed 91       	ld	r30, X+
    601c:	fc 91       	ld	r31, X
    601e:	13 97       	sbiw	r26, 0x03	; 3
    6020:	fb 83       	std	Y+3, r31	; 0x03
    6022:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    6024:	d5 83       	std	Z+5, r29	; 0x05
    6026:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    6028:	bd 83       	std	Y+5, r27	; 0x05
    602a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    602c:	13 96       	adiw	r26, 0x03	; 3
    602e:	dc 93       	st	X, r29
    6030:	ce 93       	st	-X, r28
    6032:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    6034:	99 87       	std	Y+9, r25	; 0x09
    6036:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    6038:	fc 01       	movw	r30, r24
    603a:	20 81       	ld	r18, Z
    603c:	2f 5f       	subi	r18, 0xFF	; 255
    603e:	20 83       	st	Z, r18
}
    6040:	df 91       	pop	r29
    6042:	cf 91       	pop	r28
    6044:	08 95       	ret

00006046 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    6046:	cf 93       	push	r28
    6048:	df 93       	push	r29
    604a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    604c:	a0 85       	ldd	r26, Z+8	; 0x08
    604e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    6050:	c2 81       	ldd	r28, Z+2	; 0x02
    6052:	d3 81       	ldd	r29, Z+3	; 0x03
    6054:	84 81       	ldd	r24, Z+4	; 0x04
    6056:	95 81       	ldd	r25, Z+5	; 0x05
    6058:	9d 83       	std	Y+5, r25	; 0x05
    605a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    605c:	c4 81       	ldd	r28, Z+4	; 0x04
    605e:	d5 81       	ldd	r29, Z+5	; 0x05
    6060:	82 81       	ldd	r24, Z+2	; 0x02
    6062:	93 81       	ldd	r25, Z+3	; 0x03
    6064:	9b 83       	std	Y+3, r25	; 0x03
    6066:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    6068:	11 96       	adiw	r26, 0x01	; 1
    606a:	8d 91       	ld	r24, X+
    606c:	9c 91       	ld	r25, X
    606e:	12 97       	sbiw	r26, 0x02	; 2
    6070:	e8 17       	cp	r30, r24
    6072:	f9 07       	cpc	r31, r25
    6074:	31 f4       	brne	.+12     	; 0x6082 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    6076:	84 81       	ldd	r24, Z+4	; 0x04
    6078:	95 81       	ldd	r25, Z+5	; 0x05
    607a:	12 96       	adiw	r26, 0x02	; 2
    607c:	9c 93       	st	X, r25
    607e:	8e 93       	st	-X, r24
    6080:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    6082:	11 86       	std	Z+9, r1	; 0x09
    6084:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    6086:	8c 91       	ld	r24, X
    6088:	81 50       	subi	r24, 0x01	; 1
    608a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    608c:	8c 91       	ld	r24, X
}
    608e:	df 91       	pop	r29
    6090:	cf 91       	pop	r28
    6092:	08 95       	ret

00006094 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    6094:	31 e1       	ldi	r19, 0x11	; 17
    6096:	fc 01       	movw	r30, r24
    6098:	30 83       	st	Z, r19
    609a:	31 97       	sbiw	r30, 0x01	; 1
    609c:	22 e2       	ldi	r18, 0x22	; 34
    609e:	20 83       	st	Z, r18
    60a0:	31 97       	sbiw	r30, 0x01	; 1
    60a2:	a3 e3       	ldi	r26, 0x33	; 51
    60a4:	a0 83       	st	Z, r26
    60a6:	31 97       	sbiw	r30, 0x01	; 1
    60a8:	60 83       	st	Z, r22
    60aa:	31 97       	sbiw	r30, 0x01	; 1
    60ac:	70 83       	st	Z, r23
    60ae:	31 97       	sbiw	r30, 0x01	; 1
    60b0:	10 82       	st	Z, r1
    60b2:	31 97       	sbiw	r30, 0x01	; 1
    60b4:	10 82       	st	Z, r1
    60b6:	31 97       	sbiw	r30, 0x01	; 1
    60b8:	60 e8       	ldi	r22, 0x80	; 128
    60ba:	60 83       	st	Z, r22
    60bc:	31 97       	sbiw	r30, 0x01	; 1
    60be:	10 82       	st	Z, r1
    60c0:	31 97       	sbiw	r30, 0x01	; 1
    60c2:	10 82       	st	Z, r1
    60c4:	31 97       	sbiw	r30, 0x01	; 1
    60c6:	10 82       	st	Z, r1
    60c8:	31 97       	sbiw	r30, 0x01	; 1
    60ca:	62 e0       	ldi	r22, 0x02	; 2
    60cc:	60 83       	st	Z, r22
    60ce:	31 97       	sbiw	r30, 0x01	; 1
    60d0:	63 e0       	ldi	r22, 0x03	; 3
    60d2:	60 83       	st	Z, r22
    60d4:	31 97       	sbiw	r30, 0x01	; 1
    60d6:	64 e0       	ldi	r22, 0x04	; 4
    60d8:	60 83       	st	Z, r22
    60da:	31 97       	sbiw	r30, 0x01	; 1
    60dc:	65 e0       	ldi	r22, 0x05	; 5
    60de:	60 83       	st	Z, r22
    60e0:	31 97       	sbiw	r30, 0x01	; 1
    60e2:	66 e0       	ldi	r22, 0x06	; 6
    60e4:	60 83       	st	Z, r22
    60e6:	31 97       	sbiw	r30, 0x01	; 1
    60e8:	67 e0       	ldi	r22, 0x07	; 7
    60ea:	60 83       	st	Z, r22
    60ec:	31 97       	sbiw	r30, 0x01	; 1
    60ee:	68 e0       	ldi	r22, 0x08	; 8
    60f0:	60 83       	st	Z, r22
    60f2:	31 97       	sbiw	r30, 0x01	; 1
    60f4:	69 e0       	ldi	r22, 0x09	; 9
    60f6:	60 83       	st	Z, r22
    60f8:	31 97       	sbiw	r30, 0x01	; 1
    60fa:	60 e1       	ldi	r22, 0x10	; 16
    60fc:	60 83       	st	Z, r22
    60fe:	31 97       	sbiw	r30, 0x01	; 1
    6100:	30 83       	st	Z, r19
    6102:	31 97       	sbiw	r30, 0x01	; 1
    6104:	32 e1       	ldi	r19, 0x12	; 18
    6106:	30 83       	st	Z, r19
    6108:	31 97       	sbiw	r30, 0x01	; 1
    610a:	33 e1       	ldi	r19, 0x13	; 19
    610c:	30 83       	st	Z, r19
    610e:	31 97       	sbiw	r30, 0x01	; 1
    6110:	34 e1       	ldi	r19, 0x14	; 20
    6112:	30 83       	st	Z, r19
    6114:	31 97       	sbiw	r30, 0x01	; 1
    6116:	35 e1       	ldi	r19, 0x15	; 21
    6118:	30 83       	st	Z, r19
    611a:	31 97       	sbiw	r30, 0x01	; 1
    611c:	36 e1       	ldi	r19, 0x16	; 22
    611e:	30 83       	st	Z, r19
    6120:	31 97       	sbiw	r30, 0x01	; 1
    6122:	37 e1       	ldi	r19, 0x17	; 23
    6124:	30 83       	st	Z, r19
    6126:	31 97       	sbiw	r30, 0x01	; 1
    6128:	38 e1       	ldi	r19, 0x18	; 24
    612a:	30 83       	st	Z, r19
    612c:	31 97       	sbiw	r30, 0x01	; 1
    612e:	39 e1       	ldi	r19, 0x19	; 25
    6130:	30 83       	st	Z, r19
    6132:	31 97       	sbiw	r30, 0x01	; 1
    6134:	30 e2       	ldi	r19, 0x20	; 32
    6136:	30 83       	st	Z, r19
    6138:	31 97       	sbiw	r30, 0x01	; 1
    613a:	31 e2       	ldi	r19, 0x21	; 33
    613c:	30 83       	st	Z, r19
    613e:	31 97       	sbiw	r30, 0x01	; 1
    6140:	20 83       	st	Z, r18
    6142:	31 97       	sbiw	r30, 0x01	; 1
    6144:	23 e2       	ldi	r18, 0x23	; 35
    6146:	20 83       	st	Z, r18
    6148:	31 97       	sbiw	r30, 0x01	; 1
    614a:	40 83       	st	Z, r20
    614c:	31 97       	sbiw	r30, 0x01	; 1
    614e:	50 83       	st	Z, r21
    6150:	31 97       	sbiw	r30, 0x01	; 1
    6152:	26 e2       	ldi	r18, 0x26	; 38
    6154:	20 83       	st	Z, r18
    6156:	31 97       	sbiw	r30, 0x01	; 1
    6158:	27 e2       	ldi	r18, 0x27	; 39
    615a:	20 83       	st	Z, r18
    615c:	31 97       	sbiw	r30, 0x01	; 1
    615e:	28 e2       	ldi	r18, 0x28	; 40
    6160:	20 83       	st	Z, r18
    6162:	31 97       	sbiw	r30, 0x01	; 1
    6164:	29 e2       	ldi	r18, 0x29	; 41
    6166:	20 83       	st	Z, r18
    6168:	31 97       	sbiw	r30, 0x01	; 1
    616a:	20 e3       	ldi	r18, 0x30	; 48
    616c:	20 83       	st	Z, r18
    616e:	31 97       	sbiw	r30, 0x01	; 1
    6170:	21 e3       	ldi	r18, 0x31	; 49
    6172:	20 83       	st	Z, r18
    6174:	89 97       	sbiw	r24, 0x29	; 41
    6176:	08 95       	ret

00006178 <xPortStartScheduler>:
    6178:	89 e0       	ldi	r24, 0x09	; 9
    617a:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
    617e:	83 ec       	ldi	r24, 0xC3	; 195
    6180:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
    6184:	8b e0       	ldi	r24, 0x0B	; 11
    6186:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
    618a:	ef e6       	ldi	r30, 0x6F	; 111
    618c:	f0 e0       	ldi	r31, 0x00	; 0
    618e:	80 81       	ld	r24, Z
    6190:	82 60       	ori	r24, 0x02	; 2
    6192:	80 83       	st	Z, r24
    6194:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    6198:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    619c:	cd 91       	ld	r28, X+
    619e:	cd bf       	out	0x3d, r28	; 61
    61a0:	dd 91       	ld	r29, X+
    61a2:	de bf       	out	0x3e, r29	; 62
    61a4:	ff 91       	pop	r31
    61a6:	ef 91       	pop	r30
    61a8:	df 91       	pop	r29
    61aa:	cf 91       	pop	r28
    61ac:	bf 91       	pop	r27
    61ae:	af 91       	pop	r26
    61b0:	9f 91       	pop	r25
    61b2:	8f 91       	pop	r24
    61b4:	7f 91       	pop	r23
    61b6:	6f 91       	pop	r22
    61b8:	5f 91       	pop	r21
    61ba:	4f 91       	pop	r20
    61bc:	3f 91       	pop	r19
    61be:	2f 91       	pop	r18
    61c0:	1f 91       	pop	r17
    61c2:	0f 91       	pop	r16
    61c4:	ff 90       	pop	r15
    61c6:	ef 90       	pop	r14
    61c8:	df 90       	pop	r13
    61ca:	cf 90       	pop	r12
    61cc:	bf 90       	pop	r11
    61ce:	af 90       	pop	r10
    61d0:	9f 90       	pop	r9
    61d2:	8f 90       	pop	r8
    61d4:	7f 90       	pop	r7
    61d6:	6f 90       	pop	r6
    61d8:	5f 90       	pop	r5
    61da:	4f 90       	pop	r4
    61dc:	3f 90       	pop	r3
    61de:	2f 90       	pop	r2
    61e0:	1f 90       	pop	r1
    61e2:	0f 90       	pop	r0
    61e4:	0c be       	out	0x3c, r0	; 60
    61e6:	0f 90       	pop	r0
    61e8:	0b be       	out	0x3b, r0	; 59
    61ea:	0f 90       	pop	r0
    61ec:	0f be       	out	0x3f, r0	; 63
    61ee:	0f 90       	pop	r0
    61f0:	08 95       	ret
    61f2:	81 e0       	ldi	r24, 0x01	; 1
    61f4:	08 95       	ret

000061f6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    61f6:	0f 92       	push	r0
    61f8:	0f b6       	in	r0, 0x3f	; 63
    61fa:	f8 94       	cli
    61fc:	0f 92       	push	r0
    61fe:	0b b6       	in	r0, 0x3b	; 59
    6200:	0f 92       	push	r0
    6202:	0c b6       	in	r0, 0x3c	; 60
    6204:	0f 92       	push	r0
    6206:	1f 92       	push	r1
    6208:	11 24       	eor	r1, r1
    620a:	2f 92       	push	r2
    620c:	3f 92       	push	r3
    620e:	4f 92       	push	r4
    6210:	5f 92       	push	r5
    6212:	6f 92       	push	r6
    6214:	7f 92       	push	r7
    6216:	8f 92       	push	r8
    6218:	9f 92       	push	r9
    621a:	af 92       	push	r10
    621c:	bf 92       	push	r11
    621e:	cf 92       	push	r12
    6220:	df 92       	push	r13
    6222:	ef 92       	push	r14
    6224:	ff 92       	push	r15
    6226:	0f 93       	push	r16
    6228:	1f 93       	push	r17
    622a:	2f 93       	push	r18
    622c:	3f 93       	push	r19
    622e:	4f 93       	push	r20
    6230:	5f 93       	push	r21
    6232:	6f 93       	push	r22
    6234:	7f 93       	push	r23
    6236:	8f 93       	push	r24
    6238:	9f 93       	push	r25
    623a:	af 93       	push	r26
    623c:	bf 93       	push	r27
    623e:	cf 93       	push	r28
    6240:	df 93       	push	r29
    6242:	ef 93       	push	r30
    6244:	ff 93       	push	r31
    6246:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    624a:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    624e:	0d b6       	in	r0, 0x3d	; 61
    6250:	0d 92       	st	X+, r0
    6252:	0e b6       	in	r0, 0x3e	; 62
    6254:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    6256:	0e 94 bd 3d 	call	0x7b7a	; 0x7b7a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    625a:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    625e:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6262:	cd 91       	ld	r28, X+
    6264:	cd bf       	out	0x3d, r28	; 61
    6266:	dd 91       	ld	r29, X+
    6268:	de bf       	out	0x3e, r29	; 62
    626a:	ff 91       	pop	r31
    626c:	ef 91       	pop	r30
    626e:	df 91       	pop	r29
    6270:	cf 91       	pop	r28
    6272:	bf 91       	pop	r27
    6274:	af 91       	pop	r26
    6276:	9f 91       	pop	r25
    6278:	8f 91       	pop	r24
    627a:	7f 91       	pop	r23
    627c:	6f 91       	pop	r22
    627e:	5f 91       	pop	r21
    6280:	4f 91       	pop	r20
    6282:	3f 91       	pop	r19
    6284:	2f 91       	pop	r18
    6286:	1f 91       	pop	r17
    6288:	0f 91       	pop	r16
    628a:	ff 90       	pop	r15
    628c:	ef 90       	pop	r14
    628e:	df 90       	pop	r13
    6290:	cf 90       	pop	r12
    6292:	bf 90       	pop	r11
    6294:	af 90       	pop	r10
    6296:	9f 90       	pop	r9
    6298:	8f 90       	pop	r8
    629a:	7f 90       	pop	r7
    629c:	6f 90       	pop	r6
    629e:	5f 90       	pop	r5
    62a0:	4f 90       	pop	r4
    62a2:	3f 90       	pop	r3
    62a4:	2f 90       	pop	r2
    62a6:	1f 90       	pop	r1
    62a8:	0f 90       	pop	r0
    62aa:	0c be       	out	0x3c, r0	; 60
    62ac:	0f 90       	pop	r0
    62ae:	0b be       	out	0x3b, r0	; 59
    62b0:	0f 90       	pop	r0
    62b2:	0f be       	out	0x3f, r0	; 63
    62b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    62b6:	08 95       	ret

000062b8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    62b8:	0f 92       	push	r0
    62ba:	0f b6       	in	r0, 0x3f	; 63
    62bc:	f8 94       	cli
    62be:	0f 92       	push	r0
    62c0:	0b b6       	in	r0, 0x3b	; 59
    62c2:	0f 92       	push	r0
    62c4:	0c b6       	in	r0, 0x3c	; 60
    62c6:	0f 92       	push	r0
    62c8:	1f 92       	push	r1
    62ca:	11 24       	eor	r1, r1
    62cc:	2f 92       	push	r2
    62ce:	3f 92       	push	r3
    62d0:	4f 92       	push	r4
    62d2:	5f 92       	push	r5
    62d4:	6f 92       	push	r6
    62d6:	7f 92       	push	r7
    62d8:	8f 92       	push	r8
    62da:	9f 92       	push	r9
    62dc:	af 92       	push	r10
    62de:	bf 92       	push	r11
    62e0:	cf 92       	push	r12
    62e2:	df 92       	push	r13
    62e4:	ef 92       	push	r14
    62e6:	ff 92       	push	r15
    62e8:	0f 93       	push	r16
    62ea:	1f 93       	push	r17
    62ec:	2f 93       	push	r18
    62ee:	3f 93       	push	r19
    62f0:	4f 93       	push	r20
    62f2:	5f 93       	push	r21
    62f4:	6f 93       	push	r22
    62f6:	7f 93       	push	r23
    62f8:	8f 93       	push	r24
    62fa:	9f 93       	push	r25
    62fc:	af 93       	push	r26
    62fe:	bf 93       	push	r27
    6300:	cf 93       	push	r28
    6302:	df 93       	push	r29
    6304:	ef 93       	push	r30
    6306:	ff 93       	push	r31
    6308:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    630c:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6310:	0d b6       	in	r0, 0x3d	; 61
    6312:	0d 92       	st	X+, r0
    6314:	0e b6       	in	r0, 0x3e	; 62
    6316:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    6318:	17 d7       	rcall	.+3630   	; 0x7148 <xTaskIncrementTick>
    631a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    631c:	0e 94 bd 3d 	call	0x7b7a	; 0x7b7a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    6320:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    6324:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6328:	cd 91       	ld	r28, X+
    632a:	cd bf       	out	0x3d, r28	; 61
    632c:	dd 91       	ld	r29, X+
    632e:	de bf       	out	0x3e, r29	; 62
    6330:	ff 91       	pop	r31
    6332:	ef 91       	pop	r30
    6334:	df 91       	pop	r29
    6336:	cf 91       	pop	r28
    6338:	bf 91       	pop	r27
    633a:	af 91       	pop	r26
    633c:	9f 91       	pop	r25
    633e:	8f 91       	pop	r24
    6340:	7f 91       	pop	r23
    6342:	6f 91       	pop	r22
    6344:	5f 91       	pop	r21
    6346:	4f 91       	pop	r20
    6348:	3f 91       	pop	r19
    634a:	2f 91       	pop	r18
    634c:	1f 91       	pop	r17
    634e:	0f 91       	pop	r16
    6350:	ff 90       	pop	r15
    6352:	ef 90       	pop	r14
    6354:	df 90       	pop	r13
    6356:	cf 90       	pop	r12
    6358:	bf 90       	pop	r11
    635a:	af 90       	pop	r10
    635c:	9f 90       	pop	r9
    635e:	8f 90       	pop	r8
    6360:	7f 90       	pop	r7
    6362:	6f 90       	pop	r6
    6364:	5f 90       	pop	r5
    6366:	4f 90       	pop	r4
    6368:	3f 90       	pop	r3
    636a:	2f 90       	pop	r2
    636c:	1f 90       	pop	r1
    636e:	0f 90       	pop	r0
    6370:	0c be       	out	0x3c, r0	; 60
    6372:	0f 90       	pop	r0
    6374:	0b be       	out	0x3b, r0	; 59
    6376:	0f 90       	pop	r0
    6378:	0f be       	out	0x3f, r0	; 63
    637a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    637c:	08 95       	ret

0000637e <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    637e:	9c df       	rcall	.-200    	; 0x62b8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    6380:	18 95       	reti

00006382 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6382:	0f b6       	in	r0, 0x3f	; 63
    6384:	f8 94       	cli
    6386:	0f 92       	push	r0
    6388:	fc 01       	movw	r30, r24
    638a:	92 8d       	ldd	r25, Z+26	; 0x1a
    638c:	0f 90       	pop	r0
    638e:	0f be       	out	0x3f, r0	; 63
    6390:	81 e0       	ldi	r24, 0x01	; 1
    6392:	91 11       	cpse	r25, r1
    6394:	80 e0       	ldi	r24, 0x00	; 0
    6396:	08 95       	ret

00006398 <prvCopyDataToQueue>:
    6398:	0f 93       	push	r16
    639a:	1f 93       	push	r17
    639c:	cf 93       	push	r28
    639e:	df 93       	push	r29
    63a0:	ec 01       	movw	r28, r24
    63a2:	04 2f       	mov	r16, r20
    63a4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    63a6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    63a8:	41 11       	cpse	r20, r1
    63aa:	0c c0       	rjmp	.+24     	; 0x63c4 <prvCopyDataToQueue+0x2c>
    63ac:	88 81       	ld	r24, Y
    63ae:	99 81       	ldd	r25, Y+1	; 0x01
    63b0:	89 2b       	or	r24, r25
    63b2:	09 f0       	breq	.+2      	; 0x63b6 <prvCopyDataToQueue+0x1e>
    63b4:	42 c0       	rjmp	.+132    	; 0x643a <prvCopyDataToQueue+0xa2>
    63b6:	8c 81       	ldd	r24, Y+4	; 0x04
    63b8:	9d 81       	ldd	r25, Y+5	; 0x05
    63ba:	0e 94 53 3c 	call	0x78a6	; 0x78a6 <xTaskPriorityDisinherit>
    63be:	1d 82       	std	Y+5, r1	; 0x05
    63c0:	1c 82       	std	Y+4, r1	; 0x04
    63c2:	42 c0       	rjmp	.+132    	; 0x6448 <prvCopyDataToQueue+0xb0>
    63c4:	01 11       	cpse	r16, r1
    63c6:	17 c0       	rjmp	.+46     	; 0x63f6 <prvCopyDataToQueue+0x5e>
    63c8:	50 e0       	ldi	r21, 0x00	; 0
    63ca:	8a 81       	ldd	r24, Y+2	; 0x02
    63cc:	9b 81       	ldd	r25, Y+3	; 0x03
    63ce:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>
    63d2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    63d4:	8a 81       	ldd	r24, Y+2	; 0x02
    63d6:	9b 81       	ldd	r25, Y+3	; 0x03
    63d8:	82 0f       	add	r24, r18
    63da:	91 1d       	adc	r25, r1
    63dc:	9b 83       	std	Y+3, r25	; 0x03
    63de:	8a 83       	std	Y+2, r24	; 0x02
    63e0:	2c 81       	ldd	r18, Y+4	; 0x04
    63e2:	3d 81       	ldd	r19, Y+5	; 0x05
    63e4:	82 17       	cp	r24, r18
    63e6:	93 07       	cpc	r25, r19
    63e8:	50 f1       	brcs	.+84     	; 0x643e <prvCopyDataToQueue+0xa6>
    63ea:	88 81       	ld	r24, Y
    63ec:	99 81       	ldd	r25, Y+1	; 0x01
    63ee:	9b 83       	std	Y+3, r25	; 0x03
    63f0:	8a 83       	std	Y+2, r24	; 0x02
    63f2:	80 e0       	ldi	r24, 0x00	; 0
    63f4:	29 c0       	rjmp	.+82     	; 0x6448 <prvCopyDataToQueue+0xb0>
    63f6:	50 e0       	ldi	r21, 0x00	; 0
    63f8:	8e 81       	ldd	r24, Y+6	; 0x06
    63fa:	9f 81       	ldd	r25, Y+7	; 0x07
    63fc:	0e 94 a3 42 	call	0x8546	; 0x8546 <memcpy>
    6400:	8c 8d       	ldd	r24, Y+28	; 0x1c
    6402:	90 e0       	ldi	r25, 0x00	; 0
    6404:	91 95       	neg	r25
    6406:	81 95       	neg	r24
    6408:	91 09       	sbc	r25, r1
    640a:	2e 81       	ldd	r18, Y+6	; 0x06
    640c:	3f 81       	ldd	r19, Y+7	; 0x07
    640e:	28 0f       	add	r18, r24
    6410:	39 1f       	adc	r19, r25
    6412:	3f 83       	std	Y+7, r19	; 0x07
    6414:	2e 83       	std	Y+6, r18	; 0x06
    6416:	48 81       	ld	r20, Y
    6418:	59 81       	ldd	r21, Y+1	; 0x01
    641a:	24 17       	cp	r18, r20
    641c:	35 07       	cpc	r19, r21
    641e:	30 f4       	brcc	.+12     	; 0x642c <prvCopyDataToQueue+0x94>
    6420:	2c 81       	ldd	r18, Y+4	; 0x04
    6422:	3d 81       	ldd	r19, Y+5	; 0x05
    6424:	82 0f       	add	r24, r18
    6426:	93 1f       	adc	r25, r19
    6428:	9f 83       	std	Y+7, r25	; 0x07
    642a:	8e 83       	std	Y+6, r24	; 0x06
    642c:	02 30       	cpi	r16, 0x02	; 2
    642e:	49 f4       	brne	.+18     	; 0x6442 <prvCopyDataToQueue+0xaa>
    6430:	11 23       	and	r17, r17
    6432:	49 f0       	breq	.+18     	; 0x6446 <prvCopyDataToQueue+0xae>
    6434:	11 50       	subi	r17, 0x01	; 1
    6436:	80 e0       	ldi	r24, 0x00	; 0
    6438:	07 c0       	rjmp	.+14     	; 0x6448 <prvCopyDataToQueue+0xb0>
    643a:	80 e0       	ldi	r24, 0x00	; 0
    643c:	05 c0       	rjmp	.+10     	; 0x6448 <prvCopyDataToQueue+0xb0>
    643e:	80 e0       	ldi	r24, 0x00	; 0
    6440:	03 c0       	rjmp	.+6      	; 0x6448 <prvCopyDataToQueue+0xb0>
    6442:	80 e0       	ldi	r24, 0x00	; 0
    6444:	01 c0       	rjmp	.+2      	; 0x6448 <prvCopyDataToQueue+0xb0>
    6446:	80 e0       	ldi	r24, 0x00	; 0
    6448:	1f 5f       	subi	r17, 0xFF	; 255
    644a:	1a 8f       	std	Y+26, r17	; 0x1a
    644c:	df 91       	pop	r29
    644e:	cf 91       	pop	r28
    6450:	1f 91       	pop	r17
    6452:	0f 91       	pop	r16
    6454:	08 95       	ret

00006456 <prvCopyDataFromQueue>:
    6456:	fc 01       	movw	r30, r24
    6458:	44 8d       	ldd	r20, Z+28	; 0x1c
    645a:	44 23       	and	r20, r20
    645c:	a9 f0       	breq	.+42     	; 0x6488 <prvCopyDataFromQueue+0x32>
    645e:	50 e0       	ldi	r21, 0x00	; 0
    6460:	26 81       	ldd	r18, Z+6	; 0x06
    6462:	37 81       	ldd	r19, Z+7	; 0x07
    6464:	24 0f       	add	r18, r20
    6466:	35 1f       	adc	r19, r21
    6468:	37 83       	std	Z+7, r19	; 0x07
    646a:	26 83       	std	Z+6, r18	; 0x06
    646c:	84 81       	ldd	r24, Z+4	; 0x04
    646e:	95 81       	ldd	r25, Z+5	; 0x05
    6470:	28 17       	cp	r18, r24
    6472:	39 07       	cpc	r19, r25
    6474:	20 f0       	brcs	.+8      	; 0x647e <prvCopyDataFromQueue+0x28>
    6476:	80 81       	ld	r24, Z
    6478:	91 81       	ldd	r25, Z+1	; 0x01
    647a:	97 83       	std	Z+7, r25	; 0x07
    647c:	86 83       	std	Z+6, r24	; 0x06
    647e:	cb 01       	movw	r24, r22
    6480:	66 81       	ldd	r22, Z+6	; 0x06
    6482:	77 81       	ldd	r23, Z+7	; 0x07
    6484:	0c 94 a3 42 	jmp	0x8546	; 0x8546 <memcpy>
    6488:	08 95       	ret

0000648a <prvUnlockQueue>:
    648a:	ef 92       	push	r14
    648c:	ff 92       	push	r15
    648e:	0f 93       	push	r16
    6490:	1f 93       	push	r17
    6492:	cf 93       	push	r28
    6494:	8c 01       	movw	r16, r24
    6496:	0f b6       	in	r0, 0x3f	; 63
    6498:	f8 94       	cli
    649a:	0f 92       	push	r0
    649c:	fc 01       	movw	r30, r24
    649e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    64a0:	1c 16       	cp	r1, r28
    64a2:	a4 f4       	brge	.+40     	; 0x64cc <prvUnlockQueue+0x42>
    64a4:	81 89       	ldd	r24, Z+17	; 0x11
    64a6:	81 11       	cpse	r24, r1
    64a8:	06 c0       	rjmp	.+12     	; 0x64b6 <prvUnlockQueue+0x2c>
    64aa:	10 c0       	rjmp	.+32     	; 0x64cc <prvUnlockQueue+0x42>
    64ac:	f8 01       	movw	r30, r16
    64ae:	81 89       	ldd	r24, Z+17	; 0x11
    64b0:	81 11       	cpse	r24, r1
    64b2:	05 c0       	rjmp	.+10     	; 0x64be <prvUnlockQueue+0x34>
    64b4:	0b c0       	rjmp	.+22     	; 0x64cc <prvUnlockQueue+0x42>
    64b6:	78 01       	movw	r14, r16
    64b8:	f1 e1       	ldi	r31, 0x11	; 17
    64ba:	ef 0e       	add	r14, r31
    64bc:	f1 1c       	adc	r15, r1
    64be:	c7 01       	movw	r24, r14
    64c0:	9c d7       	rcall	.+3896   	; 0x73fa <xTaskRemoveFromEventList>
    64c2:	81 11       	cpse	r24, r1
    64c4:	0e 94 85 3a 	call	0x750a	; 0x750a <vTaskMissedYield>
    64c8:	c1 50       	subi	r28, 0x01	; 1
    64ca:	81 f7       	brne	.-32     	; 0x64ac <prvUnlockQueue+0x22>
    64cc:	8f ef       	ldi	r24, 0xFF	; 255
    64ce:	f8 01       	movw	r30, r16
    64d0:	86 8f       	std	Z+30, r24	; 0x1e
    64d2:	0f 90       	pop	r0
    64d4:	0f be       	out	0x3f, r0	; 63
    64d6:	0f b6       	in	r0, 0x3f	; 63
    64d8:	f8 94       	cli
    64da:	0f 92       	push	r0
    64dc:	c5 8d       	ldd	r28, Z+29	; 0x1d
    64de:	1c 16       	cp	r1, r28
    64e0:	a4 f4       	brge	.+40     	; 0x650a <prvUnlockQueue+0x80>
    64e2:	80 85       	ldd	r24, Z+8	; 0x08
    64e4:	81 11       	cpse	r24, r1
    64e6:	06 c0       	rjmp	.+12     	; 0x64f4 <prvUnlockQueue+0x6a>
    64e8:	10 c0       	rjmp	.+32     	; 0x650a <prvUnlockQueue+0x80>
    64ea:	f8 01       	movw	r30, r16
    64ec:	80 85       	ldd	r24, Z+8	; 0x08
    64ee:	81 11       	cpse	r24, r1
    64f0:	05 c0       	rjmp	.+10     	; 0x64fc <prvUnlockQueue+0x72>
    64f2:	0b c0       	rjmp	.+22     	; 0x650a <prvUnlockQueue+0x80>
    64f4:	78 01       	movw	r14, r16
    64f6:	f8 e0       	ldi	r31, 0x08	; 8
    64f8:	ef 0e       	add	r14, r31
    64fa:	f1 1c       	adc	r15, r1
    64fc:	c7 01       	movw	r24, r14
    64fe:	7d d7       	rcall	.+3834   	; 0x73fa <xTaskRemoveFromEventList>
    6500:	81 11       	cpse	r24, r1
    6502:	0e 94 85 3a 	call	0x750a	; 0x750a <vTaskMissedYield>
    6506:	c1 50       	subi	r28, 0x01	; 1
    6508:	81 f7       	brne	.-32     	; 0x64ea <prvUnlockQueue+0x60>
    650a:	8f ef       	ldi	r24, 0xFF	; 255
    650c:	f8 01       	movw	r30, r16
    650e:	85 8f       	std	Z+29, r24	; 0x1d
    6510:	0f 90       	pop	r0
    6512:	0f be       	out	0x3f, r0	; 63
    6514:	cf 91       	pop	r28
    6516:	1f 91       	pop	r17
    6518:	0f 91       	pop	r16
    651a:	ff 90       	pop	r15
    651c:	ef 90       	pop	r14
    651e:	08 95       	ret

00006520 <xQueueGenericReset>:
    6520:	cf 93       	push	r28
    6522:	df 93       	push	r29
    6524:	ec 01       	movw	r28, r24
    6526:	0f b6       	in	r0, 0x3f	; 63
    6528:	f8 94       	cli
    652a:	0f 92       	push	r0
    652c:	e8 81       	ld	r30, Y
    652e:	f9 81       	ldd	r31, Y+1	; 0x01
    6530:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6532:	2c 8d       	ldd	r18, Y+28	; 0x1c
    6534:	90 e0       	ldi	r25, 0x00	; 0
    6536:	30 e0       	ldi	r19, 0x00	; 0
    6538:	82 9f       	mul	r24, r18
    653a:	a0 01       	movw	r20, r0
    653c:	83 9f       	mul	r24, r19
    653e:	50 0d       	add	r21, r0
    6540:	92 9f       	mul	r25, r18
    6542:	50 0d       	add	r21, r0
    6544:	11 24       	eor	r1, r1
    6546:	4e 0f       	add	r20, r30
    6548:	5f 1f       	adc	r21, r31
    654a:	5d 83       	std	Y+5, r21	; 0x05
    654c:	4c 83       	std	Y+4, r20	; 0x04
    654e:	1a 8e       	std	Y+26, r1	; 0x1a
    6550:	fb 83       	std	Y+3, r31	; 0x03
    6552:	ea 83       	std	Y+2, r30	; 0x02
    6554:	01 97       	sbiw	r24, 0x01	; 1
    6556:	82 9f       	mul	r24, r18
    6558:	a0 01       	movw	r20, r0
    655a:	83 9f       	mul	r24, r19
    655c:	50 0d       	add	r21, r0
    655e:	92 9f       	mul	r25, r18
    6560:	50 0d       	add	r21, r0
    6562:	11 24       	eor	r1, r1
    6564:	cf 01       	movw	r24, r30
    6566:	84 0f       	add	r24, r20
    6568:	95 1f       	adc	r25, r21
    656a:	9f 83       	std	Y+7, r25	; 0x07
    656c:	8e 83       	std	Y+6, r24	; 0x06
    656e:	8f ef       	ldi	r24, 0xFF	; 255
    6570:	8d 8f       	std	Y+29, r24	; 0x1d
    6572:	8e 8f       	std	Y+30, r24	; 0x1e
    6574:	61 11       	cpse	r22, r1
    6576:	0a c0       	rjmp	.+20     	; 0x658c <xQueueGenericReset+0x6c>
    6578:	88 85       	ldd	r24, Y+8	; 0x08
    657a:	88 23       	and	r24, r24
    657c:	69 f0       	breq	.+26     	; 0x6598 <xQueueGenericReset+0x78>
    657e:	ce 01       	movw	r24, r28
    6580:	08 96       	adiw	r24, 0x08	; 8
    6582:	3b d7       	rcall	.+3702   	; 0x73fa <xTaskRemoveFromEventList>
    6584:	88 23       	and	r24, r24
    6586:	41 f0       	breq	.+16     	; 0x6598 <xQueueGenericReset+0x78>
    6588:	36 de       	rcall	.-916    	; 0x61f6 <vPortYield>
    658a:	06 c0       	rjmp	.+12     	; 0x6598 <xQueueGenericReset+0x78>
    658c:	ce 01       	movw	r24, r28
    658e:	08 96       	adiw	r24, 0x08	; 8
    6590:	f6 dc       	rcall	.-1556   	; 0x5f7e <vListInitialise>
    6592:	ce 01       	movw	r24, r28
    6594:	41 96       	adiw	r24, 0x11	; 17
    6596:	f3 dc       	rcall	.-1562   	; 0x5f7e <vListInitialise>
    6598:	0f 90       	pop	r0
    659a:	0f be       	out	0x3f, r0	; 63
    659c:	81 e0       	ldi	r24, 0x01	; 1
    659e:	df 91       	pop	r29
    65a0:	cf 91       	pop	r28
    65a2:	08 95       	ret

000065a4 <xQueueGenericCreate>:
    65a4:	ff 92       	push	r15
    65a6:	0f 93       	push	r16
    65a8:	1f 93       	push	r17
    65aa:	cf 93       	push	r28
    65ac:	df 93       	push	r29
    65ae:	08 2f       	mov	r16, r24
    65b0:	16 2f       	mov	r17, r22
    65b2:	f4 2e       	mov	r15, r20
    65b4:	66 23       	and	r22, r22
    65b6:	b9 f0       	breq	.+46     	; 0x65e6 <xQueueGenericCreate+0x42>
    65b8:	86 9f       	mul	r24, r22
    65ba:	c0 01       	movw	r24, r0
    65bc:	11 24       	eor	r1, r1
    65be:	81 96       	adiw	r24, 0x21	; 33
    65c0:	29 dc       	rcall	.-1966   	; 0x5e14 <pvPortMalloc>
    65c2:	ec 01       	movw	r28, r24
    65c4:	00 97       	sbiw	r24, 0x00	; 0
    65c6:	41 f4       	brne	.+16     	; 0x65d8 <xQueueGenericCreate+0x34>
    65c8:	14 c0       	rjmp	.+40     	; 0x65f2 <xQueueGenericCreate+0x4e>
    65ca:	0b 8f       	std	Y+27, r16	; 0x1b
    65cc:	1c 8f       	std	Y+28, r17	; 0x1c
    65ce:	61 e0       	ldi	r22, 0x01	; 1
    65d0:	ce 01       	movw	r24, r28
    65d2:	a6 df       	rcall	.-180    	; 0x6520 <xQueueGenericReset>
    65d4:	f8 a2       	std	Y+32, r15	; 0x20
    65d6:	0d c0       	rjmp	.+26     	; 0x65f2 <xQueueGenericCreate+0x4e>
    65d8:	81 96       	adiw	r24, 0x21	; 33
    65da:	99 83       	std	Y+1, r25	; 0x01
    65dc:	88 83       	st	Y, r24
    65de:	f5 cf       	rjmp	.-22     	; 0x65ca <xQueueGenericCreate+0x26>
    65e0:	d9 83       	std	Y+1, r29	; 0x01
    65e2:	c8 83       	st	Y, r28
    65e4:	f2 cf       	rjmp	.-28     	; 0x65ca <xQueueGenericCreate+0x26>
    65e6:	81 e2       	ldi	r24, 0x21	; 33
    65e8:	90 e0       	ldi	r25, 0x00	; 0
    65ea:	14 dc       	rcall	.-2008   	; 0x5e14 <pvPortMalloc>
    65ec:	ec 01       	movw	r28, r24
    65ee:	89 2b       	or	r24, r25
    65f0:	b9 f7       	brne	.-18     	; 0x65e0 <xQueueGenericCreate+0x3c>
    65f2:	ce 01       	movw	r24, r28
    65f4:	df 91       	pop	r29
    65f6:	cf 91       	pop	r28
    65f8:	1f 91       	pop	r17
    65fa:	0f 91       	pop	r16
    65fc:	ff 90       	pop	r15
    65fe:	08 95       	ret

00006600 <xQueueGenericSend>:
    6600:	9f 92       	push	r9
    6602:	af 92       	push	r10
    6604:	bf 92       	push	r11
    6606:	cf 92       	push	r12
    6608:	df 92       	push	r13
    660a:	ef 92       	push	r14
    660c:	ff 92       	push	r15
    660e:	0f 93       	push	r16
    6610:	1f 93       	push	r17
    6612:	cf 93       	push	r28
    6614:	df 93       	push	r29
    6616:	00 d0       	rcall	.+0      	; 0x6618 <xQueueGenericSend+0x18>
    6618:	1f 92       	push	r1
    661a:	1f 92       	push	r1
    661c:	cd b7       	in	r28, 0x3d	; 61
    661e:	de b7       	in	r29, 0x3e	; 62
    6620:	8c 01       	movw	r16, r24
    6622:	6b 01       	movw	r12, r22
    6624:	5d 83       	std	Y+5, r21	; 0x05
    6626:	4c 83       	std	Y+4, r20	; 0x04
    6628:	a2 2e       	mov	r10, r18
    662a:	b1 2c       	mov	r11, r1
    662c:	99 24       	eor	r9, r9
    662e:	93 94       	inc	r9
    6630:	7c 01       	movw	r14, r24
    6632:	88 e0       	ldi	r24, 0x08	; 8
    6634:	e8 0e       	add	r14, r24
    6636:	f1 1c       	adc	r15, r1
    6638:	0f b6       	in	r0, 0x3f	; 63
    663a:	f8 94       	cli
    663c:	0f 92       	push	r0
    663e:	f8 01       	movw	r30, r16
    6640:	92 8d       	ldd	r25, Z+26	; 0x1a
    6642:	83 8d       	ldd	r24, Z+27	; 0x1b
    6644:	98 17       	cp	r25, r24
    6646:	18 f0       	brcs	.+6      	; 0x664e <xQueueGenericSend+0x4e>
    6648:	f2 e0       	ldi	r31, 0x02	; 2
    664a:	af 12       	cpse	r10, r31
    664c:	15 c0       	rjmp	.+42     	; 0x6678 <xQueueGenericSend+0x78>
    664e:	4a 2d       	mov	r20, r10
    6650:	b6 01       	movw	r22, r12
    6652:	c8 01       	movw	r24, r16
    6654:	a1 de       	rcall	.-702    	; 0x6398 <prvCopyDataToQueue>
    6656:	f8 01       	movw	r30, r16
    6658:	91 89       	ldd	r25, Z+17	; 0x11
    665a:	99 23       	and	r25, r25
    665c:	39 f0       	breq	.+14     	; 0x666c <xQueueGenericSend+0x6c>
    665e:	c8 01       	movw	r24, r16
    6660:	41 96       	adiw	r24, 0x11	; 17
    6662:	cb d6       	rcall	.+3478   	; 0x73fa <xTaskRemoveFromEventList>
    6664:	88 23       	and	r24, r24
    6666:	21 f0       	breq	.+8      	; 0x6670 <xQueueGenericSend+0x70>
    6668:	c6 dd       	rcall	.-1140   	; 0x61f6 <vPortYield>
    666a:	02 c0       	rjmp	.+4      	; 0x6670 <xQueueGenericSend+0x70>
    666c:	81 11       	cpse	r24, r1
    666e:	c3 dd       	rcall	.-1146   	; 0x61f6 <vPortYield>
    6670:	0f 90       	pop	r0
    6672:	0f be       	out	0x3f, r0	; 63
    6674:	81 e0       	ldi	r24, 0x01	; 1
    6676:	45 c0       	rjmp	.+138    	; 0x6702 <xQueueGenericSend+0x102>
    6678:	8c 81       	ldd	r24, Y+4	; 0x04
    667a:	9d 81       	ldd	r25, Y+5	; 0x05
    667c:	89 2b       	or	r24, r25
    667e:	21 f4       	brne	.+8      	; 0x6688 <xQueueGenericSend+0x88>
    6680:	0f 90       	pop	r0
    6682:	0f be       	out	0x3f, r0	; 63
    6684:	80 e0       	ldi	r24, 0x00	; 0
    6686:	3d c0       	rjmp	.+122    	; 0x6702 <xQueueGenericSend+0x102>
    6688:	b1 10       	cpse	r11, r1
    668a:	04 c0       	rjmp	.+8      	; 0x6694 <xQueueGenericSend+0x94>
    668c:	ce 01       	movw	r24, r28
    668e:	01 96       	adiw	r24, 0x01	; 1
    6690:	fc d6       	rcall	.+3576   	; 0x748a <vTaskInternalSetTimeOutState>
    6692:	b9 2c       	mov	r11, r9
    6694:	0f 90       	pop	r0
    6696:	0f be       	out	0x3f, r0	; 63
    6698:	3c d5       	rcall	.+2680   	; 0x7112 <vTaskSuspendAll>
    669a:	0f b6       	in	r0, 0x3f	; 63
    669c:	f8 94       	cli
    669e:	0f 92       	push	r0
    66a0:	f8 01       	movw	r30, r16
    66a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    66a4:	8f 3f       	cpi	r24, 0xFF	; 255
    66a6:	09 f4       	brne	.+2      	; 0x66aa <xQueueGenericSend+0xaa>
    66a8:	15 8e       	std	Z+29, r1	; 0x1d
    66aa:	f8 01       	movw	r30, r16
    66ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    66ae:	8f 3f       	cpi	r24, 0xFF	; 255
    66b0:	09 f4       	brne	.+2      	; 0x66b4 <xQueueGenericSend+0xb4>
    66b2:	16 8e       	std	Z+30, r1	; 0x1e
    66b4:	0f 90       	pop	r0
    66b6:	0f be       	out	0x3f, r0	; 63
    66b8:	be 01       	movw	r22, r28
    66ba:	6c 5f       	subi	r22, 0xFC	; 252
    66bc:	7f 4f       	sbci	r23, 0xFF	; 255
    66be:	ce 01       	movw	r24, r28
    66c0:	01 96       	adiw	r24, 0x01	; 1
    66c2:	ee d6       	rcall	.+3548   	; 0x74a0 <xTaskCheckForTimeOut>
    66c4:	81 11       	cpse	r24, r1
    66c6:	19 c0       	rjmp	.+50     	; 0x66fa <xQueueGenericSend+0xfa>
    66c8:	0f b6       	in	r0, 0x3f	; 63
    66ca:	f8 94       	cli
    66cc:	0f 92       	push	r0
    66ce:	f8 01       	movw	r30, r16
    66d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    66d2:	0f 90       	pop	r0
    66d4:	0f be       	out	0x3f, r0	; 63
    66d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    66d8:	98 13       	cpse	r25, r24
    66da:	0b c0       	rjmp	.+22     	; 0x66f2 <xQueueGenericSend+0xf2>
    66dc:	6c 81       	ldd	r22, Y+4	; 0x04
    66de:	7d 81       	ldd	r23, Y+5	; 0x05
    66e0:	c7 01       	movw	r24, r14
    66e2:	62 d6       	rcall	.+3268   	; 0x73a8 <vTaskPlaceOnEventList>
    66e4:	c8 01       	movw	r24, r16
    66e6:	d1 de       	rcall	.-606    	; 0x648a <prvUnlockQueue>
    66e8:	d1 d5       	rcall	.+2978   	; 0x728c <xTaskResumeAll>
    66ea:	81 11       	cpse	r24, r1
    66ec:	a5 cf       	rjmp	.-182    	; 0x6638 <xQueueGenericSend+0x38>
    66ee:	83 dd       	rcall	.-1274   	; 0x61f6 <vPortYield>
    66f0:	a3 cf       	rjmp	.-186    	; 0x6638 <xQueueGenericSend+0x38>
    66f2:	c8 01       	movw	r24, r16
    66f4:	ca de       	rcall	.-620    	; 0x648a <prvUnlockQueue>
    66f6:	ca d5       	rcall	.+2964   	; 0x728c <xTaskResumeAll>
    66f8:	9f cf       	rjmp	.-194    	; 0x6638 <xQueueGenericSend+0x38>
    66fa:	c8 01       	movw	r24, r16
    66fc:	c6 de       	rcall	.-628    	; 0x648a <prvUnlockQueue>
    66fe:	c6 d5       	rcall	.+2956   	; 0x728c <xTaskResumeAll>
    6700:	80 e0       	ldi	r24, 0x00	; 0
    6702:	0f 90       	pop	r0
    6704:	0f 90       	pop	r0
    6706:	0f 90       	pop	r0
    6708:	0f 90       	pop	r0
    670a:	0f 90       	pop	r0
    670c:	df 91       	pop	r29
    670e:	cf 91       	pop	r28
    6710:	1f 91       	pop	r17
    6712:	0f 91       	pop	r16
    6714:	ff 90       	pop	r15
    6716:	ef 90       	pop	r14
    6718:	df 90       	pop	r13
    671a:	cf 90       	pop	r12
    671c:	bf 90       	pop	r11
    671e:	af 90       	pop	r10
    6720:	9f 90       	pop	r9
    6722:	08 95       	ret

00006724 <xQueueCreateMutex>:
    6724:	cf 93       	push	r28
    6726:	df 93       	push	r29
    6728:	48 2f       	mov	r20, r24
    672a:	60 e0       	ldi	r22, 0x00	; 0
    672c:	81 e0       	ldi	r24, 0x01	; 1
    672e:	3a df       	rcall	.-396    	; 0x65a4 <xQueueGenericCreate>
    6730:	ec 01       	movw	r28, r24
    6732:	00 97       	sbiw	r24, 0x00	; 0
    6734:	59 f0       	breq	.+22     	; 0x674c <xQueueCreateMutex+0x28>
    6736:	1d 82       	std	Y+5, r1	; 0x05
    6738:	1c 82       	std	Y+4, r1	; 0x04
    673a:	19 82       	std	Y+1, r1	; 0x01
    673c:	18 82       	st	Y, r1
    673e:	1e 82       	std	Y+6, r1	; 0x06
    6740:	20 e0       	ldi	r18, 0x00	; 0
    6742:	40 e0       	ldi	r20, 0x00	; 0
    6744:	50 e0       	ldi	r21, 0x00	; 0
    6746:	60 e0       	ldi	r22, 0x00	; 0
    6748:	70 e0       	ldi	r23, 0x00	; 0
    674a:	5a df       	rcall	.-332    	; 0x6600 <xQueueGenericSend>
    674c:	ce 01       	movw	r24, r28
    674e:	df 91       	pop	r29
    6750:	cf 91       	pop	r28
    6752:	08 95       	ret

00006754 <xQueueGenericSendFromISR>:
    6754:	ef 92       	push	r14
    6756:	ff 92       	push	r15
    6758:	0f 93       	push	r16
    675a:	1f 93       	push	r17
    675c:	cf 93       	push	r28
    675e:	df 93       	push	r29
    6760:	8a 01       	movw	r16, r20
    6762:	fc 01       	movw	r30, r24
    6764:	52 8d       	ldd	r21, Z+26	; 0x1a
    6766:	33 8d       	ldd	r19, Z+27	; 0x1b
    6768:	53 17       	cp	r21, r19
    676a:	10 f0       	brcs	.+4      	; 0x6770 <xQueueGenericSendFromISR+0x1c>
    676c:	22 30       	cpi	r18, 0x02	; 2
    676e:	e1 f4       	brne	.+56     	; 0x67a8 <xQueueGenericSendFromISR+0x54>
    6770:	42 2f       	mov	r20, r18
    6772:	78 01       	movw	r14, r16
    6774:	ec 01       	movw	r28, r24
    6776:	1e 8d       	ldd	r17, Y+30	; 0x1e
    6778:	0f de       	rcall	.-994    	; 0x6398 <prvCopyDataToQueue>
    677a:	1f 3f       	cpi	r17, 0xFF	; 255
    677c:	79 f4       	brne	.+30     	; 0x679c <xQueueGenericSendFromISR+0x48>
    677e:	89 89       	ldd	r24, Y+17	; 0x11
    6780:	88 23       	and	r24, r24
    6782:	a1 f0       	breq	.+40     	; 0x67ac <xQueueGenericSendFromISR+0x58>
    6784:	ce 01       	movw	r24, r28
    6786:	41 96       	adiw	r24, 0x11	; 17
    6788:	38 d6       	rcall	.+3184   	; 0x73fa <xTaskRemoveFromEventList>
    678a:	88 23       	and	r24, r24
    678c:	89 f0       	breq	.+34     	; 0x67b0 <xQueueGenericSendFromISR+0x5c>
    678e:	e1 14       	cp	r14, r1
    6790:	f1 04       	cpc	r15, r1
    6792:	81 f0       	breq	.+32     	; 0x67b4 <xQueueGenericSendFromISR+0x60>
    6794:	81 e0       	ldi	r24, 0x01	; 1
    6796:	f7 01       	movw	r30, r14
    6798:	80 83       	st	Z, r24
    679a:	0d c0       	rjmp	.+26     	; 0x67b6 <xQueueGenericSendFromISR+0x62>
    679c:	ff 24       	eor	r15, r15
    679e:	f3 94       	inc	r15
    67a0:	f1 0e       	add	r15, r17
    67a2:	fe 8e       	std	Y+30, r15	; 0x1e
    67a4:	81 e0       	ldi	r24, 0x01	; 1
    67a6:	07 c0       	rjmp	.+14     	; 0x67b6 <xQueueGenericSendFromISR+0x62>
    67a8:	80 e0       	ldi	r24, 0x00	; 0
    67aa:	05 c0       	rjmp	.+10     	; 0x67b6 <xQueueGenericSendFromISR+0x62>
    67ac:	81 e0       	ldi	r24, 0x01	; 1
    67ae:	03 c0       	rjmp	.+6      	; 0x67b6 <xQueueGenericSendFromISR+0x62>
    67b0:	81 e0       	ldi	r24, 0x01	; 1
    67b2:	01 c0       	rjmp	.+2      	; 0x67b6 <xQueueGenericSendFromISR+0x62>
    67b4:	81 e0       	ldi	r24, 0x01	; 1
    67b6:	df 91       	pop	r29
    67b8:	cf 91       	pop	r28
    67ba:	1f 91       	pop	r17
    67bc:	0f 91       	pop	r16
    67be:	ff 90       	pop	r15
    67c0:	ef 90       	pop	r14
    67c2:	08 95       	ret

000067c4 <xQueueReceive>:
    67c4:	9f 92       	push	r9
    67c6:	af 92       	push	r10
    67c8:	bf 92       	push	r11
    67ca:	cf 92       	push	r12
    67cc:	df 92       	push	r13
    67ce:	ef 92       	push	r14
    67d0:	ff 92       	push	r15
    67d2:	0f 93       	push	r16
    67d4:	1f 93       	push	r17
    67d6:	cf 93       	push	r28
    67d8:	df 93       	push	r29
    67da:	00 d0       	rcall	.+0      	; 0x67dc <xQueueReceive+0x18>
    67dc:	1f 92       	push	r1
    67de:	1f 92       	push	r1
    67e0:	cd b7       	in	r28, 0x3d	; 61
    67e2:	de b7       	in	r29, 0x3e	; 62
    67e4:	8c 01       	movw	r16, r24
    67e6:	5b 01       	movw	r10, r22
    67e8:	5d 83       	std	Y+5, r21	; 0x05
    67ea:	4c 83       	std	Y+4, r20	; 0x04
    67ec:	e1 2c       	mov	r14, r1
    67ee:	99 24       	eor	r9, r9
    67f0:	93 94       	inc	r9
    67f2:	6c 01       	movw	r12, r24
    67f4:	81 e1       	ldi	r24, 0x11	; 17
    67f6:	c8 0e       	add	r12, r24
    67f8:	d1 1c       	adc	r13, r1
    67fa:	0f b6       	in	r0, 0x3f	; 63
    67fc:	f8 94       	cli
    67fe:	0f 92       	push	r0
    6800:	f8 01       	movw	r30, r16
    6802:	f2 8c       	ldd	r15, Z+26	; 0x1a
    6804:	ff 20       	and	r15, r15
    6806:	91 f0       	breq	.+36     	; 0x682c <xQueueReceive+0x68>
    6808:	b5 01       	movw	r22, r10
    680a:	c8 01       	movw	r24, r16
    680c:	24 de       	rcall	.-952    	; 0x6456 <prvCopyDataFromQueue>
    680e:	fa 94       	dec	r15
    6810:	f8 01       	movw	r30, r16
    6812:	f2 8e       	std	Z+26, r15	; 0x1a
    6814:	80 85       	ldd	r24, Z+8	; 0x08
    6816:	88 23       	and	r24, r24
    6818:	29 f0       	breq	.+10     	; 0x6824 <xQueueReceive+0x60>
    681a:	c8 01       	movw	r24, r16
    681c:	08 96       	adiw	r24, 0x08	; 8
    681e:	ed d5       	rcall	.+3034   	; 0x73fa <xTaskRemoveFromEventList>
    6820:	81 11       	cpse	r24, r1
    6822:	e9 dc       	rcall	.-1582   	; 0x61f6 <vPortYield>
    6824:	0f 90       	pop	r0
    6826:	0f be       	out	0x3f, r0	; 63
    6828:	81 e0       	ldi	r24, 0x01	; 1
    682a:	44 c0       	rjmp	.+136    	; 0x68b4 <xQueueReceive+0xf0>
    682c:	8c 81       	ldd	r24, Y+4	; 0x04
    682e:	9d 81       	ldd	r25, Y+5	; 0x05
    6830:	89 2b       	or	r24, r25
    6832:	21 f4       	brne	.+8      	; 0x683c <xQueueReceive+0x78>
    6834:	0f 90       	pop	r0
    6836:	0f be       	out	0x3f, r0	; 63
    6838:	80 e0       	ldi	r24, 0x00	; 0
    683a:	3c c0       	rjmp	.+120    	; 0x68b4 <xQueueReceive+0xf0>
    683c:	e1 10       	cpse	r14, r1
    683e:	04 c0       	rjmp	.+8      	; 0x6848 <xQueueReceive+0x84>
    6840:	ce 01       	movw	r24, r28
    6842:	01 96       	adiw	r24, 0x01	; 1
    6844:	22 d6       	rcall	.+3140   	; 0x748a <vTaskInternalSetTimeOutState>
    6846:	e9 2c       	mov	r14, r9
    6848:	0f 90       	pop	r0
    684a:	0f be       	out	0x3f, r0	; 63
    684c:	62 d4       	rcall	.+2244   	; 0x7112 <vTaskSuspendAll>
    684e:	0f b6       	in	r0, 0x3f	; 63
    6850:	f8 94       	cli
    6852:	0f 92       	push	r0
    6854:	f8 01       	movw	r30, r16
    6856:	85 8d       	ldd	r24, Z+29	; 0x1d
    6858:	8f 3f       	cpi	r24, 0xFF	; 255
    685a:	09 f4       	brne	.+2      	; 0x685e <xQueueReceive+0x9a>
    685c:	15 8e       	std	Z+29, r1	; 0x1d
    685e:	f8 01       	movw	r30, r16
    6860:	86 8d       	ldd	r24, Z+30	; 0x1e
    6862:	8f 3f       	cpi	r24, 0xFF	; 255
    6864:	09 f4       	brne	.+2      	; 0x6868 <xQueueReceive+0xa4>
    6866:	16 8e       	std	Z+30, r1	; 0x1e
    6868:	0f 90       	pop	r0
    686a:	0f be       	out	0x3f, r0	; 63
    686c:	be 01       	movw	r22, r28
    686e:	6c 5f       	subi	r22, 0xFC	; 252
    6870:	7f 4f       	sbci	r23, 0xFF	; 255
    6872:	ce 01       	movw	r24, r28
    6874:	01 96       	adiw	r24, 0x01	; 1
    6876:	14 d6       	rcall	.+3112   	; 0x74a0 <xTaskCheckForTimeOut>
    6878:	81 11       	cpse	r24, r1
    687a:	13 c0       	rjmp	.+38     	; 0x68a2 <xQueueReceive+0xde>
    687c:	c8 01       	movw	r24, r16
    687e:	81 dd       	rcall	.-1278   	; 0x6382 <prvIsQueueEmpty>
    6880:	88 23       	and	r24, r24
    6882:	59 f0       	breq	.+22     	; 0x689a <xQueueReceive+0xd6>
    6884:	6c 81       	ldd	r22, Y+4	; 0x04
    6886:	7d 81       	ldd	r23, Y+5	; 0x05
    6888:	c6 01       	movw	r24, r12
    688a:	8e d5       	rcall	.+2844   	; 0x73a8 <vTaskPlaceOnEventList>
    688c:	c8 01       	movw	r24, r16
    688e:	fd dd       	rcall	.-1030   	; 0x648a <prvUnlockQueue>
    6890:	fd d4       	rcall	.+2554   	; 0x728c <xTaskResumeAll>
    6892:	81 11       	cpse	r24, r1
    6894:	b2 cf       	rjmp	.-156    	; 0x67fa <xQueueReceive+0x36>
    6896:	af dc       	rcall	.-1698   	; 0x61f6 <vPortYield>
    6898:	b0 cf       	rjmp	.-160    	; 0x67fa <xQueueReceive+0x36>
    689a:	c8 01       	movw	r24, r16
    689c:	f6 dd       	rcall	.-1044   	; 0x648a <prvUnlockQueue>
    689e:	f6 d4       	rcall	.+2540   	; 0x728c <xTaskResumeAll>
    68a0:	ac cf       	rjmp	.-168    	; 0x67fa <xQueueReceive+0x36>
    68a2:	c8 01       	movw	r24, r16
    68a4:	f2 dd       	rcall	.-1052   	; 0x648a <prvUnlockQueue>
    68a6:	f2 d4       	rcall	.+2532   	; 0x728c <xTaskResumeAll>
    68a8:	c8 01       	movw	r24, r16
    68aa:	6b dd       	rcall	.-1322   	; 0x6382 <prvIsQueueEmpty>
    68ac:	88 23       	and	r24, r24
    68ae:	09 f4       	brne	.+2      	; 0x68b2 <xQueueReceive+0xee>
    68b0:	a4 cf       	rjmp	.-184    	; 0x67fa <xQueueReceive+0x36>
    68b2:	80 e0       	ldi	r24, 0x00	; 0
    68b4:	0f 90       	pop	r0
    68b6:	0f 90       	pop	r0
    68b8:	0f 90       	pop	r0
    68ba:	0f 90       	pop	r0
    68bc:	0f 90       	pop	r0
    68be:	df 91       	pop	r29
    68c0:	cf 91       	pop	r28
    68c2:	1f 91       	pop	r17
    68c4:	0f 91       	pop	r16
    68c6:	ff 90       	pop	r15
    68c8:	ef 90       	pop	r14
    68ca:	df 90       	pop	r13
    68cc:	cf 90       	pop	r12
    68ce:	bf 90       	pop	r11
    68d0:	af 90       	pop	r10
    68d2:	9f 90       	pop	r9
    68d4:	08 95       	ret

000068d6 <xQueueSemaphoreTake>:
    68d6:	bf 92       	push	r11
    68d8:	cf 92       	push	r12
    68da:	df 92       	push	r13
    68dc:	ef 92       	push	r14
    68de:	ff 92       	push	r15
    68e0:	0f 93       	push	r16
    68e2:	1f 93       	push	r17
    68e4:	cf 93       	push	r28
    68e6:	df 93       	push	r29
    68e8:	00 d0       	rcall	.+0      	; 0x68ea <xQueueSemaphoreTake+0x14>
    68ea:	1f 92       	push	r1
    68ec:	1f 92       	push	r1
    68ee:	cd b7       	in	r28, 0x3d	; 61
    68f0:	de b7       	in	r29, 0x3e	; 62
    68f2:	8c 01       	movw	r16, r24
    68f4:	7d 83       	std	Y+5, r23	; 0x05
    68f6:	6c 83       	std	Y+4, r22	; 0x04
    68f8:	b1 2c       	mov	r11, r1
    68fa:	d1 2c       	mov	r13, r1
    68fc:	cc 24       	eor	r12, r12
    68fe:	c3 94       	inc	r12
    6900:	7c 01       	movw	r14, r24
    6902:	81 e1       	ldi	r24, 0x11	; 17
    6904:	e8 0e       	add	r14, r24
    6906:	f1 1c       	adc	r15, r1
    6908:	0f b6       	in	r0, 0x3f	; 63
    690a:	f8 94       	cli
    690c:	0f 92       	push	r0
    690e:	d8 01       	movw	r26, r16
    6910:	5a 96       	adiw	r26, 0x1a	; 26
    6912:	8c 91       	ld	r24, X
    6914:	5a 97       	sbiw	r26, 0x1a	; 26
    6916:	88 23       	and	r24, r24
    6918:	d9 f0       	breq	.+54     	; 0x6950 <xQueueSemaphoreTake+0x7a>
    691a:	81 50       	subi	r24, 0x01	; 1
    691c:	5a 96       	adiw	r26, 0x1a	; 26
    691e:	8c 93       	st	X, r24
    6920:	5a 97       	sbiw	r26, 0x1a	; 26
    6922:	8d 91       	ld	r24, X+
    6924:	9c 91       	ld	r25, X
    6926:	89 2b       	or	r24, r25
    6928:	29 f4       	brne	.+10     	; 0x6934 <xQueueSemaphoreTake+0x5e>
    692a:	0e 94 9b 3d 	call	0x7b36	; 0x7b36 <pvTaskIncrementMutexHeldCount>
    692e:	f8 01       	movw	r30, r16
    6930:	95 83       	std	Z+5, r25	; 0x05
    6932:	84 83       	std	Z+4, r24	; 0x04
    6934:	d8 01       	movw	r26, r16
    6936:	18 96       	adiw	r26, 0x08	; 8
    6938:	8c 91       	ld	r24, X
    693a:	88 23       	and	r24, r24
    693c:	29 f0       	breq	.+10     	; 0x6948 <xQueueSemaphoreTake+0x72>
    693e:	c8 01       	movw	r24, r16
    6940:	08 96       	adiw	r24, 0x08	; 8
    6942:	5b d5       	rcall	.+2742   	; 0x73fa <xTaskRemoveFromEventList>
    6944:	81 11       	cpse	r24, r1
    6946:	57 dc       	rcall	.-1874   	; 0x61f6 <vPortYield>
    6948:	0f 90       	pop	r0
    694a:	0f be       	out	0x3f, r0	; 63
    694c:	81 e0       	ldi	r24, 0x01	; 1
    694e:	70 c0       	rjmp	.+224    	; 0x6a30 <xQueueSemaphoreTake+0x15a>
    6950:	8c 81       	ldd	r24, Y+4	; 0x04
    6952:	9d 81       	ldd	r25, Y+5	; 0x05
    6954:	89 2b       	or	r24, r25
    6956:	21 f4       	brne	.+8      	; 0x6960 <xQueueSemaphoreTake+0x8a>
    6958:	0f 90       	pop	r0
    695a:	0f be       	out	0x3f, r0	; 63
    695c:	80 e0       	ldi	r24, 0x00	; 0
    695e:	68 c0       	rjmp	.+208    	; 0x6a30 <xQueueSemaphoreTake+0x15a>
    6960:	d1 10       	cpse	r13, r1
    6962:	04 c0       	rjmp	.+8      	; 0x696c <xQueueSemaphoreTake+0x96>
    6964:	ce 01       	movw	r24, r28
    6966:	01 96       	adiw	r24, 0x01	; 1
    6968:	90 d5       	rcall	.+2848   	; 0x748a <vTaskInternalSetTimeOutState>
    696a:	dc 2c       	mov	r13, r12
    696c:	0f 90       	pop	r0
    696e:	0f be       	out	0x3f, r0	; 63
    6970:	d0 d3       	rcall	.+1952   	; 0x7112 <vTaskSuspendAll>
    6972:	0f b6       	in	r0, 0x3f	; 63
    6974:	f8 94       	cli
    6976:	0f 92       	push	r0
    6978:	f8 01       	movw	r30, r16
    697a:	85 8d       	ldd	r24, Z+29	; 0x1d
    697c:	8f 3f       	cpi	r24, 0xFF	; 255
    697e:	09 f4       	brne	.+2      	; 0x6982 <xQueueSemaphoreTake+0xac>
    6980:	15 8e       	std	Z+29, r1	; 0x1d
    6982:	d8 01       	movw	r26, r16
    6984:	5e 96       	adiw	r26, 0x1e	; 30
    6986:	8c 91       	ld	r24, X
    6988:	5e 97       	sbiw	r26, 0x1e	; 30
    698a:	8f 3f       	cpi	r24, 0xFF	; 255
    698c:	11 f4       	brne	.+4      	; 0x6992 <xQueueSemaphoreTake+0xbc>
    698e:	5e 96       	adiw	r26, 0x1e	; 30
    6990:	1c 92       	st	X, r1
    6992:	0f 90       	pop	r0
    6994:	0f be       	out	0x3f, r0	; 63
    6996:	be 01       	movw	r22, r28
    6998:	6c 5f       	subi	r22, 0xFC	; 252
    699a:	7f 4f       	sbci	r23, 0xFF	; 255
    699c:	ce 01       	movw	r24, r28
    699e:	01 96       	adiw	r24, 0x01	; 1
    69a0:	7f d5       	rcall	.+2814   	; 0x74a0 <xTaskCheckForTimeOut>
    69a2:	81 11       	cpse	r24, r1
    69a4:	21 c0       	rjmp	.+66     	; 0x69e8 <xQueueSemaphoreTake+0x112>
    69a6:	c8 01       	movw	r24, r16
    69a8:	ec dc       	rcall	.-1576   	; 0x6382 <prvIsQueueEmpty>
    69aa:	88 23       	and	r24, r24
    69ac:	c9 f0       	breq	.+50     	; 0x69e0 <xQueueSemaphoreTake+0x10a>
    69ae:	f8 01       	movw	r30, r16
    69b0:	80 81       	ld	r24, Z
    69b2:	91 81       	ldd	r25, Z+1	; 0x01
    69b4:	89 2b       	or	r24, r25
    69b6:	49 f4       	brne	.+18     	; 0x69ca <xQueueSemaphoreTake+0xf4>
    69b8:	0f b6       	in	r0, 0x3f	; 63
    69ba:	f8 94       	cli
    69bc:	0f 92       	push	r0
    69be:	84 81       	ldd	r24, Z+4	; 0x04
    69c0:	95 81       	ldd	r25, Z+5	; 0x05
    69c2:	ff d6       	rcall	.+3582   	; 0x77c2 <xTaskPriorityInherit>
    69c4:	b8 2e       	mov	r11, r24
    69c6:	0f 90       	pop	r0
    69c8:	0f be       	out	0x3f, r0	; 63
    69ca:	6c 81       	ldd	r22, Y+4	; 0x04
    69cc:	7d 81       	ldd	r23, Y+5	; 0x05
    69ce:	c7 01       	movw	r24, r14
    69d0:	eb d4       	rcall	.+2518   	; 0x73a8 <vTaskPlaceOnEventList>
    69d2:	c8 01       	movw	r24, r16
    69d4:	5a dd       	rcall	.-1356   	; 0x648a <prvUnlockQueue>
    69d6:	5a d4       	rcall	.+2228   	; 0x728c <xTaskResumeAll>
    69d8:	81 11       	cpse	r24, r1
    69da:	96 cf       	rjmp	.-212    	; 0x6908 <xQueueSemaphoreTake+0x32>
    69dc:	0c dc       	rcall	.-2024   	; 0x61f6 <vPortYield>
    69de:	94 cf       	rjmp	.-216    	; 0x6908 <xQueueSemaphoreTake+0x32>
    69e0:	c8 01       	movw	r24, r16
    69e2:	53 dd       	rcall	.-1370   	; 0x648a <prvUnlockQueue>
    69e4:	53 d4       	rcall	.+2214   	; 0x728c <xTaskResumeAll>
    69e6:	90 cf       	rjmp	.-224    	; 0x6908 <xQueueSemaphoreTake+0x32>
    69e8:	c8 01       	movw	r24, r16
    69ea:	4f dd       	rcall	.-1378   	; 0x648a <prvUnlockQueue>
    69ec:	4f d4       	rcall	.+2206   	; 0x728c <xTaskResumeAll>
    69ee:	c8 01       	movw	r24, r16
    69f0:	c8 dc       	rcall	.-1648   	; 0x6382 <prvIsQueueEmpty>
    69f2:	88 23       	and	r24, r24
    69f4:	09 f4       	brne	.+2      	; 0x69f8 <xQueueSemaphoreTake+0x122>
    69f6:	88 cf       	rjmp	.-240    	; 0x6908 <xQueueSemaphoreTake+0x32>
    69f8:	bb 20       	and	r11, r11
    69fa:	c9 f0       	breq	.+50     	; 0x6a2e <xQueueSemaphoreTake+0x158>
    69fc:	0f b6       	in	r0, 0x3f	; 63
    69fe:	f8 94       	cli
    6a00:	0f 92       	push	r0
    6a02:	f8 01       	movw	r30, r16
    6a04:	81 89       	ldd	r24, Z+17	; 0x11
    6a06:	88 23       	and	r24, r24
    6a08:	39 f0       	breq	.+14     	; 0x6a18 <xQueueSemaphoreTake+0x142>
    6a0a:	06 88       	ldd	r0, Z+22	; 0x16
    6a0c:	f7 89       	ldd	r31, Z+23	; 0x17
    6a0e:	e0 2d       	mov	r30, r0
    6a10:	80 81       	ld	r24, Z
    6a12:	64 e0       	ldi	r22, 0x04	; 4
    6a14:	68 1b       	sub	r22, r24
    6a16:	01 c0       	rjmp	.+2      	; 0x6a1a <xQueueSemaphoreTake+0x144>
    6a18:	60 e0       	ldi	r22, 0x00	; 0
    6a1a:	d8 01       	movw	r26, r16
    6a1c:	14 96       	adiw	r26, 0x04	; 4
    6a1e:	8d 91       	ld	r24, X+
    6a20:	9c 91       	ld	r25, X
    6a22:	15 97       	sbiw	r26, 0x05	; 5
    6a24:	80 d7       	rcall	.+3840   	; 0x7926 <vTaskPriorityDisinheritAfterTimeout>
    6a26:	0f 90       	pop	r0
    6a28:	0f be       	out	0x3f, r0	; 63
    6a2a:	80 e0       	ldi	r24, 0x00	; 0
    6a2c:	01 c0       	rjmp	.+2      	; 0x6a30 <xQueueSemaphoreTake+0x15a>
    6a2e:	80 e0       	ldi	r24, 0x00	; 0
    6a30:	0f 90       	pop	r0
    6a32:	0f 90       	pop	r0
    6a34:	0f 90       	pop	r0
    6a36:	0f 90       	pop	r0
    6a38:	0f 90       	pop	r0
    6a3a:	df 91       	pop	r29
    6a3c:	cf 91       	pop	r28
    6a3e:	1f 91       	pop	r17
    6a40:	0f 91       	pop	r16
    6a42:	ff 90       	pop	r15
    6a44:	ef 90       	pop	r14
    6a46:	df 90       	pop	r13
    6a48:	cf 90       	pop	r12
    6a4a:	bf 90       	pop	r11
    6a4c:	08 95       	ret

00006a4e <xQueueReceiveFromISR>:
    6a4e:	ef 92       	push	r14
    6a50:	ff 92       	push	r15
    6a52:	0f 93       	push	r16
    6a54:	1f 93       	push	r17
    6a56:	cf 93       	push	r28
    6a58:	df 93       	push	r29
    6a5a:	fc 01       	movw	r30, r24
    6a5c:	c2 8d       	ldd	r28, Z+26	; 0x1a
    6a5e:	cc 23       	and	r28, r28
    6a60:	e9 f0       	breq	.+58     	; 0x6a9c <xQueueReceiveFromISR+0x4e>
    6a62:	7a 01       	movw	r14, r20
    6a64:	8c 01       	movw	r16, r24
    6a66:	d5 8d       	ldd	r29, Z+29	; 0x1d
    6a68:	f6 dc       	rcall	.-1556   	; 0x6456 <prvCopyDataFromQueue>
    6a6a:	c1 50       	subi	r28, 0x01	; 1
    6a6c:	f8 01       	movw	r30, r16
    6a6e:	c2 8f       	std	Z+26, r28	; 0x1a
    6a70:	df 3f       	cpi	r29, 0xFF	; 255
    6a72:	79 f4       	brne	.+30     	; 0x6a92 <xQueueReceiveFromISR+0x44>
    6a74:	80 85       	ldd	r24, Z+8	; 0x08
    6a76:	88 23       	and	r24, r24
    6a78:	99 f0       	breq	.+38     	; 0x6aa0 <xQueueReceiveFromISR+0x52>
    6a7a:	c8 01       	movw	r24, r16
    6a7c:	08 96       	adiw	r24, 0x08	; 8
    6a7e:	bd d4       	rcall	.+2426   	; 0x73fa <xTaskRemoveFromEventList>
    6a80:	88 23       	and	r24, r24
    6a82:	81 f0       	breq	.+32     	; 0x6aa4 <xQueueReceiveFromISR+0x56>
    6a84:	e1 14       	cp	r14, r1
    6a86:	f1 04       	cpc	r15, r1
    6a88:	79 f0       	breq	.+30     	; 0x6aa8 <xQueueReceiveFromISR+0x5a>
    6a8a:	81 e0       	ldi	r24, 0x01	; 1
    6a8c:	f7 01       	movw	r30, r14
    6a8e:	80 83       	st	Z, r24
    6a90:	0c c0       	rjmp	.+24     	; 0x6aaa <xQueueReceiveFromISR+0x5c>
    6a92:	df 5f       	subi	r29, 0xFF	; 255
    6a94:	f8 01       	movw	r30, r16
    6a96:	d5 8f       	std	Z+29, r29	; 0x1d
    6a98:	81 e0       	ldi	r24, 0x01	; 1
    6a9a:	07 c0       	rjmp	.+14     	; 0x6aaa <xQueueReceiveFromISR+0x5c>
    6a9c:	80 e0       	ldi	r24, 0x00	; 0
    6a9e:	05 c0       	rjmp	.+10     	; 0x6aaa <xQueueReceiveFromISR+0x5c>
    6aa0:	81 e0       	ldi	r24, 0x01	; 1
    6aa2:	03 c0       	rjmp	.+6      	; 0x6aaa <xQueueReceiveFromISR+0x5c>
    6aa4:	81 e0       	ldi	r24, 0x01	; 1
    6aa6:	01 c0       	rjmp	.+2      	; 0x6aaa <xQueueReceiveFromISR+0x5c>
    6aa8:	81 e0       	ldi	r24, 0x01	; 1
    6aaa:	df 91       	pop	r29
    6aac:	cf 91       	pop	r28
    6aae:	1f 91       	pop	r17
    6ab0:	0f 91       	pop	r16
    6ab2:	ff 90       	pop	r15
    6ab4:	ef 90       	pop	r14
    6ab6:	08 95       	ret

00006ab8 <uxQueueMessagesWaiting>:
    6ab8:	0f b6       	in	r0, 0x3f	; 63
    6aba:	f8 94       	cli
    6abc:	0f 92       	push	r0
    6abe:	fc 01       	movw	r30, r24
    6ac0:	82 8d       	ldd	r24, Z+26	; 0x1a
    6ac2:	0f 90       	pop	r0
    6ac4:	0f be       	out	0x3f, r0	; 63
    6ac6:	08 95       	ret

00006ac8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    6ac8:	cf 93       	push	r28
    6aca:	df 93       	push	r29
    6acc:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    6ace:	0f b6       	in	r0, 0x3f	; 63
    6ad0:	f8 94       	cli
    6ad2:	0f 92       	push	r0
    6ad4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6ad6:	8f 3f       	cpi	r24, 0xFF	; 255
    6ad8:	09 f4       	brne	.+2      	; 0x6adc <vQueueWaitForMessageRestricted+0x14>
    6ada:	1d 8e       	std	Y+29, r1	; 0x1d
    6adc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6ade:	8f 3f       	cpi	r24, 0xFF	; 255
    6ae0:	09 f4       	brne	.+2      	; 0x6ae4 <vQueueWaitForMessageRestricted+0x1c>
    6ae2:	1e 8e       	std	Y+30, r1	; 0x1e
    6ae4:	0f 90       	pop	r0
    6ae6:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    6ae8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6aea:	81 11       	cpse	r24, r1
    6aec:	03 c0       	rjmp	.+6      	; 0x6af4 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    6aee:	ce 01       	movw	r24, r28
    6af0:	41 96       	adiw	r24, 0x11	; 17
    6af2:	6b d4       	rcall	.+2262   	; 0x73ca <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    6af4:	ce 01       	movw	r24, r28
    6af6:	c9 dc       	rcall	.-1646   	; 0x648a <prvUnlockQueue>
	}
    6af8:	df 91       	pop	r29
    6afa:	cf 91       	pop	r28
    6afc:	08 95       	ret

00006afe <__vector_25>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART0_RX_vect )
{
    6afe:	1f 92       	push	r1
    6b00:	0f 92       	push	r0
    6b02:	0f b6       	in	r0, 0x3f	; 63
    6b04:	0f 92       	push	r0
    6b06:	11 24       	eor	r1, r1
    6b08:	0b b6       	in	r0, 0x3b	; 59
    6b0a:	0f 92       	push	r0
    6b0c:	2f 93       	push	r18
    6b0e:	3f 93       	push	r19
    6b10:	4f 93       	push	r20
    6b12:	5f 93       	push	r21
    6b14:	6f 93       	push	r22
    6b16:	7f 93       	push	r23
    6b18:	8f 93       	push	r24
    6b1a:	9f 93       	push	r25
    6b1c:	af 93       	push	r26
    6b1e:	bf 93       	push	r27
    6b20:	ef 93       	push	r30
    6b22:	ff 93       	push	r31
    6b24:	cf 93       	push	r28
    6b26:	df 93       	push	r29
    6b28:	1f 92       	push	r1
    6b2a:	1f 92       	push	r1
    6b2c:	cd b7       	in	r28, 0x3d	; 61
    6b2e:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    6b30:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    6b32:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    6b36:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    6b38:	20 e0       	ldi	r18, 0x00	; 0
    6b3a:	ae 01       	movw	r20, r28
    6b3c:	4e 5f       	subi	r20, 0xFE	; 254
    6b3e:	5f 4f       	sbci	r21, 0xFF	; 255
    6b40:	be 01       	movw	r22, r28
    6b42:	6f 5f       	subi	r22, 0xFF	; 255
    6b44:	7f 4f       	sbci	r23, 0xFF	; 255
    6b46:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xRxedChars>
    6b4a:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <xRxedChars+0x1>
    6b4e:	02 de       	rcall	.-1020   	; 0x6754 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    6b50:	8a 81       	ldd	r24, Y+2	; 0x02
	{
		taskYIELD();
    6b52:	81 11       	cpse	r24, r1
    6b54:	50 db       	rcall	.-2400   	; 0x61f6 <vPortYield>
	}
}
    6b56:	0f 90       	pop	r0
    6b58:	0f 90       	pop	r0
    6b5a:	df 91       	pop	r29
    6b5c:	cf 91       	pop	r28
    6b5e:	ff 91       	pop	r31
    6b60:	ef 91       	pop	r30
    6b62:	bf 91       	pop	r27
    6b64:	af 91       	pop	r26
    6b66:	9f 91       	pop	r25
    6b68:	8f 91       	pop	r24
    6b6a:	7f 91       	pop	r23
    6b6c:	6f 91       	pop	r22
    6b6e:	5f 91       	pop	r21
    6b70:	4f 91       	pop	r20
    6b72:	3f 91       	pop	r19
    6b74:	2f 91       	pop	r18
    6b76:	0f 90       	pop	r0
    6b78:	0b be       	out	0x3b, r0	; 59
    6b7a:	0f 90       	pop	r0
    6b7c:	0f be       	out	0x3f, r0	; 63
    6b7e:	0f 90       	pop	r0
    6b80:	1f 90       	pop	r1
    6b82:	18 95       	reti

00006b84 <__vector_26>:
/*-----------------------------------------------------------*/

SIGNAL( USART0_UDRE_vect )
{
    6b84:	1f 92       	push	r1
    6b86:	0f 92       	push	r0
    6b88:	0f b6       	in	r0, 0x3f	; 63
    6b8a:	0f 92       	push	r0
    6b8c:	11 24       	eor	r1, r1
    6b8e:	0b b6       	in	r0, 0x3b	; 59
    6b90:	0f 92       	push	r0
    6b92:	2f 93       	push	r18
    6b94:	3f 93       	push	r19
    6b96:	4f 93       	push	r20
    6b98:	5f 93       	push	r21
    6b9a:	6f 93       	push	r22
    6b9c:	7f 93       	push	r23
    6b9e:	8f 93       	push	r24
    6ba0:	9f 93       	push	r25
    6ba2:	af 93       	push	r26
    6ba4:	bf 93       	push	r27
    6ba6:	ef 93       	push	r30
    6ba8:	ff 93       	push	r31
    6baa:	cf 93       	push	r28
    6bac:	df 93       	push	r29
    6bae:	1f 92       	push	r1
    6bb0:	1f 92       	push	r1
    6bb2:	cd b7       	in	r28, 0x3d	; 61
    6bb4:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    6bb6:	ae 01       	movw	r20, r28
    6bb8:	4e 5f       	subi	r20, 0xFE	; 254
    6bba:	5f 4f       	sbci	r21, 0xFF	; 255
    6bbc:	be 01       	movw	r22, r28
    6bbe:	6f 5f       	subi	r22, 0xFF	; 255
    6bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    6bc2:	80 91 e9 1f 	lds	r24, 0x1FE9	; 0x801fe9 <xCharsForTx>
    6bc6:	90 91 ea 1f 	lds	r25, 0x1FEA	; 0x801fea <xCharsForTx+0x1>
    6bca:	41 df       	rcall	.-382    	; 0x6a4e <xQueueReceiveFromISR>
    6bcc:	81 30       	cpi	r24, 0x01	; 1
    6bce:	21 f4       	brne	.+8      	; 0x6bd8 <__vector_26+0x54>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    6bd0:	89 81       	ldd	r24, Y+1	; 0x01
    6bd2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    6bd6:	05 c0       	rjmp	.+10     	; 0x6be2 <__vector_26+0x5e>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    6bd8:	e1 ec       	ldi	r30, 0xC1	; 193
    6bda:	f0 e0       	ldi	r31, 0x00	; 0
    6bdc:	80 81       	ld	r24, Z
    6bde:	8f 7d       	andi	r24, 0xDF	; 223
    6be0:	80 83       	st	Z, r24
	}
}
    6be2:	0f 90       	pop	r0
    6be4:	0f 90       	pop	r0
    6be6:	df 91       	pop	r29
    6be8:	cf 91       	pop	r28
    6bea:	ff 91       	pop	r31
    6bec:	ef 91       	pop	r30
    6bee:	bf 91       	pop	r27
    6bf0:	af 91       	pop	r26
    6bf2:	9f 91       	pop	r25
    6bf4:	8f 91       	pop	r24
    6bf6:	7f 91       	pop	r23
    6bf8:	6f 91       	pop	r22
    6bfa:	5f 91       	pop	r21
    6bfc:	4f 91       	pop	r20
    6bfe:	3f 91       	pop	r19
    6c00:	2f 91       	pop	r18
    6c02:	0f 90       	pop	r0
    6c04:	0b be       	out	0x3b, r0	; 59
    6c06:	0f 90       	pop	r0
    6c08:	0f be       	out	0x3f, r0	; 63
    6c0a:	0f 90       	pop	r0
    6c0c:	1f 90       	pop	r1
    6c0e:	18 95       	reti

00006c10 <prvResetNextTaskUnblockTime>:
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
    6c10:	e0 91 1d 20 	lds	r30, 0x201D	; 0x80201d <pxDelayedTaskList>
    6c14:	f0 91 1e 20 	lds	r31, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    6c18:	80 81       	ld	r24, Z
    6c1a:	81 11       	cpse	r24, r1
    6c1c:	07 c0       	rjmp	.+14     	; 0x6c2c <prvResetNextTaskUnblockTime+0x1c>
    6c1e:	8f ef       	ldi	r24, 0xFF	; 255
    6c20:	9f ef       	ldi	r25, 0xFF	; 255
    6c22:	90 93 f5 1f 	sts	0x1FF5, r25	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    6c26:	80 93 f4 1f 	sts	0x1FF4, r24	; 0x801ff4 <xNextTaskUnblockTime>
    6c2a:	08 95       	ret
    6c2c:	e0 91 1d 20 	lds	r30, 0x201D	; 0x80201d <pxDelayedTaskList>
    6c30:	f0 91 1e 20 	lds	r31, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    6c34:	05 80       	ldd	r0, Z+5	; 0x05
    6c36:	f6 81       	ldd	r31, Z+6	; 0x06
    6c38:	e0 2d       	mov	r30, r0
    6c3a:	06 80       	ldd	r0, Z+6	; 0x06
    6c3c:	f7 81       	ldd	r31, Z+7	; 0x07
    6c3e:	e0 2d       	mov	r30, r0
    6c40:	82 81       	ldd	r24, Z+2	; 0x02
    6c42:	93 81       	ldd	r25, Z+3	; 0x03
    6c44:	90 93 f5 1f 	sts	0x1FF5, r25	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    6c48:	80 93 f4 1f 	sts	0x1FF4, r24	; 0x801ff4 <xNextTaskUnblockTime>
    6c4c:	08 95       	ret

00006c4e <prvIdleTask>:
    6c4e:	09 e0       	ldi	r16, 0x09	; 9
    6c50:	10 e2       	ldi	r17, 0x20	; 32
    6c52:	0f 2e       	mov	r0, r31
    6c54:	f1 e3       	ldi	r31, 0x31	; 49
    6c56:	ef 2e       	mov	r14, r31
    6c58:	f0 e2       	ldi	r31, 0x20	; 32
    6c5a:	ff 2e       	mov	r15, r31
    6c5c:	f0 2d       	mov	r31, r0
    6c5e:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <uxDeletedTasksWaitingCleanUp>
    6c62:	88 23       	and	r24, r24
    6c64:	11 f1       	breq	.+68     	; 0x6caa <prvIdleTask+0x5c>
    6c66:	0f b6       	in	r0, 0x3f	; 63
    6c68:	f8 94       	cli
    6c6a:	0f 92       	push	r0
    6c6c:	d8 01       	movw	r26, r16
    6c6e:	15 96       	adiw	r26, 0x05	; 5
    6c70:	ed 91       	ld	r30, X+
    6c72:	fc 91       	ld	r31, X
    6c74:	16 97       	sbiw	r26, 0x06	; 6
    6c76:	c6 81       	ldd	r28, Z+6	; 0x06
    6c78:	d7 81       	ldd	r29, Z+7	; 0x07
    6c7a:	ce 01       	movw	r24, r28
    6c7c:	02 96       	adiw	r24, 0x02	; 2
    6c7e:	e3 d9       	rcall	.-3130   	; 0x6046 <uxListRemove>
    6c80:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    6c84:	81 50       	subi	r24, 0x01	; 1
    6c86:	80 93 fe 1f 	sts	0x1FFE, r24	; 0x801ffe <uxCurrentNumberOfTasks>
    6c8a:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <uxDeletedTasksWaitingCleanUp>
    6c8e:	81 50       	subi	r24, 0x01	; 1
    6c90:	80 93 08 20 	sts	0x2008, r24	; 0x802008 <uxDeletedTasksWaitingCleanUp>
    6c94:	0f 90       	pop	r0
    6c96:	0f be       	out	0x3f, r0	; 63
    6c98:	8f 89       	ldd	r24, Y+23	; 0x17
    6c9a:	98 8d       	ldd	r25, Y+24	; 0x18
    6c9c:	7b d8       	rcall	.-3850   	; 0x5d94 <vPortFree>
    6c9e:	ce 01       	movw	r24, r28
    6ca0:	79 d8       	rcall	.-3854   	; 0x5d94 <vPortFree>
    6ca2:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <uxDeletedTasksWaitingCleanUp>
    6ca6:	81 11       	cpse	r24, r1
    6ca8:	de cf       	rjmp	.-68     	; 0x6c66 <prvIdleTask+0x18>
    6caa:	f7 01       	movw	r30, r14
    6cac:	80 81       	ld	r24, Z
    6cae:	82 30       	cpi	r24, 0x02	; 2
    6cb0:	b0 f2       	brcs	.-84     	; 0x6c5e <prvIdleTask+0x10>
    6cb2:	a1 da       	rcall	.-2750   	; 0x61f6 <vPortYield>
    6cb4:	d4 cf       	rjmp	.-88     	; 0x6c5e <prvIdleTask+0x10>

00006cb6 <prvAddCurrentTaskToDelayedList>:
    6cb6:	ff 92       	push	r15
    6cb8:	0f 93       	push	r16
    6cba:	1f 93       	push	r17
    6cbc:	cf 93       	push	r28
    6cbe:	df 93       	push	r29
    6cc0:	ec 01       	movw	r28, r24
    6cc2:	f6 2e       	mov	r15, r22
    6cc4:	00 91 fc 1f 	lds	r16, 0x1FFC	; 0x801ffc <xTickCount>
    6cc8:	10 91 fd 1f 	lds	r17, 0x1FFD	; 0x801ffd <xTickCount+0x1>
    6ccc:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    6cd0:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6cd4:	02 96       	adiw	r24, 0x02	; 2
    6cd6:	b7 d9       	rcall	.-3218   	; 0x6046 <uxListRemove>
    6cd8:	cf 3f       	cpi	r28, 0xFF	; 255
    6cda:	8f ef       	ldi	r24, 0xFF	; 255
    6cdc:	d8 07       	cpc	r29, r24
    6cde:	61 f4       	brne	.+24     	; 0x6cf8 <prvAddCurrentTaskToDelayedList+0x42>
    6ce0:	ff 20       	and	r15, r15
    6ce2:	51 f0       	breq	.+20     	; 0x6cf8 <prvAddCurrentTaskToDelayedList+0x42>
    6ce4:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    6ce8:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6cec:	6e 5f       	subi	r22, 0xFE	; 254
    6cee:	7f 4f       	sbci	r23, 0xFF	; 255
    6cf0:	8f ef       	ldi	r24, 0xFF	; 255
    6cf2:	9f e1       	ldi	r25, 0x1F	; 31
    6cf4:	56 d9       	rcall	.-3412   	; 0x5fa2 <vListInsertEnd>
    6cf6:	2d c0       	rjmp	.+90     	; 0x6d52 <prvAddCurrentTaskToDelayedList+0x9c>
    6cf8:	c0 0f       	add	r28, r16
    6cfa:	d1 1f       	adc	r29, r17
    6cfc:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    6d00:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6d04:	d3 83       	std	Z+3, r29	; 0x03
    6d06:	c2 83       	std	Z+2, r28	; 0x02
    6d08:	c0 17       	cp	r28, r16
    6d0a:	d1 07       	cpc	r29, r17
    6d0c:	60 f4       	brcc	.+24     	; 0x6d26 <prvAddCurrentTaskToDelayedList+0x70>
    6d0e:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    6d12:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6d16:	80 91 1b 20 	lds	r24, 0x201B	; 0x80201b <pxOverflowDelayedTaskList>
    6d1a:	90 91 1c 20 	lds	r25, 0x201C	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    6d1e:	6e 5f       	subi	r22, 0xFE	; 254
    6d20:	7f 4f       	sbci	r23, 0xFF	; 255
    6d22:	60 d9       	rcall	.-3392   	; 0x5fe4 <vListInsert>
    6d24:	16 c0       	rjmp	.+44     	; 0x6d52 <prvAddCurrentTaskToDelayedList+0x9c>
    6d26:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    6d2a:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6d2e:	80 91 1d 20 	lds	r24, 0x201D	; 0x80201d <pxDelayedTaskList>
    6d32:	90 91 1e 20 	lds	r25, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    6d36:	6e 5f       	subi	r22, 0xFE	; 254
    6d38:	7f 4f       	sbci	r23, 0xFF	; 255
    6d3a:	54 d9       	rcall	.-3416   	; 0x5fe4 <vListInsert>
    6d3c:	80 91 f4 1f 	lds	r24, 0x1FF4	; 0x801ff4 <xNextTaskUnblockTime>
    6d40:	90 91 f5 1f 	lds	r25, 0x1FF5	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    6d44:	c8 17       	cp	r28, r24
    6d46:	d9 07       	cpc	r29, r25
    6d48:	20 f4       	brcc	.+8      	; 0x6d52 <prvAddCurrentTaskToDelayedList+0x9c>
    6d4a:	d0 93 f5 1f 	sts	0x1FF5, r29	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    6d4e:	c0 93 f4 1f 	sts	0x1FF4, r28	; 0x801ff4 <xNextTaskUnblockTime>
    6d52:	df 91       	pop	r29
    6d54:	cf 91       	pop	r28
    6d56:	1f 91       	pop	r17
    6d58:	0f 91       	pop	r16
    6d5a:	ff 90       	pop	r15
    6d5c:	08 95       	ret

00006d5e <xTaskCreate>:
    6d5e:	4f 92       	push	r4
    6d60:	5f 92       	push	r5
    6d62:	6f 92       	push	r6
    6d64:	7f 92       	push	r7
    6d66:	8f 92       	push	r8
    6d68:	9f 92       	push	r9
    6d6a:	af 92       	push	r10
    6d6c:	bf 92       	push	r11
    6d6e:	cf 92       	push	r12
    6d70:	df 92       	push	r13
    6d72:	ef 92       	push	r14
    6d74:	ff 92       	push	r15
    6d76:	0f 93       	push	r16
    6d78:	cf 93       	push	r28
    6d7a:	df 93       	push	r29
    6d7c:	4c 01       	movw	r8, r24
    6d7e:	6b 01       	movw	r12, r22
    6d80:	5a 01       	movw	r10, r20
    6d82:	29 01       	movw	r4, r18
    6d84:	ca 01       	movw	r24, r20
    6d86:	46 d8       	rcall	.-3956   	; 0x5e14 <pvPortMalloc>
    6d88:	3c 01       	movw	r6, r24
    6d8a:	89 2b       	or	r24, r25
    6d8c:	09 f4       	brne	.+2      	; 0x6d90 <xTaskCreate+0x32>
    6d8e:	ed c0       	rjmp	.+474    	; 0x6f6a <xTaskCreate+0x20c>
    6d90:	8c e3       	ldi	r24, 0x3C	; 60
    6d92:	90 e0       	ldi	r25, 0x00	; 0
    6d94:	3f d8       	rcall	.-3970   	; 0x5e14 <pvPortMalloc>
    6d96:	ec 01       	movw	r28, r24
    6d98:	89 2b       	or	r24, r25
    6d9a:	99 f0       	breq	.+38     	; 0x6dc2 <xTaskCreate+0x64>
    6d9c:	78 8e       	std	Y+24, r7	; 0x18
    6d9e:	6f 8a       	std	Y+23, r6	; 0x17
    6da0:	a5 01       	movw	r20, r10
    6da2:	65 ea       	ldi	r22, 0xA5	; 165
    6da4:	70 e0       	ldi	r23, 0x00	; 0
    6da6:	c3 01       	movw	r24, r6
    6da8:	0e 94 ac 42 	call	0x8558	; 0x8558 <memset>
    6dac:	81 e0       	ldi	r24, 0x01	; 1
    6dae:	a8 1a       	sub	r10, r24
    6db0:	b1 08       	sbc	r11, r1
    6db2:	8f 89       	ldd	r24, Y+23	; 0x17
    6db4:	98 8d       	ldd	r25, Y+24	; 0x18
    6db6:	a8 0e       	add	r10, r24
    6db8:	b9 1e       	adc	r11, r25
    6dba:	c1 14       	cp	r12, r1
    6dbc:	d1 04       	cpc	r13, r1
    6dbe:	29 f4       	brne	.+10     	; 0x6dca <xTaskCreate+0x6c>
    6dc0:	20 c0       	rjmp	.+64     	; 0x6e02 <xTaskCreate+0xa4>
    6dc2:	c3 01       	movw	r24, r6
    6dc4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <vPortFree>
    6dc8:	d0 c0       	rjmp	.+416    	; 0x6f6a <xTaskCreate+0x20c>
    6dca:	d6 01       	movw	r26, r12
    6dcc:	8c 91       	ld	r24, X
    6dce:	89 8f       	std	Y+25, r24	; 0x19
    6dd0:	8c 91       	ld	r24, X
    6dd2:	88 23       	and	r24, r24
    6dd4:	a1 f0       	breq	.+40     	; 0x6dfe <xTaskCreate+0xa0>
    6dd6:	ae 01       	movw	r20, r28
    6dd8:	46 5e       	subi	r20, 0xE6	; 230
    6dda:	5f 4f       	sbci	r21, 0xFF	; 255
    6ddc:	f6 01       	movw	r30, r12
    6dde:	31 96       	adiw	r30, 0x01	; 1
    6de0:	b0 e1       	ldi	r27, 0x10	; 16
    6de2:	cb 0e       	add	r12, r27
    6de4:	d1 1c       	adc	r13, r1
    6de6:	cf 01       	movw	r24, r30
    6de8:	21 91       	ld	r18, Z+
    6dea:	da 01       	movw	r26, r20
    6dec:	2d 93       	st	X+, r18
    6dee:	ad 01       	movw	r20, r26
    6df0:	dc 01       	movw	r26, r24
    6df2:	8c 91       	ld	r24, X
    6df4:	88 23       	and	r24, r24
    6df6:	19 f0       	breq	.+6      	; 0x6dfe <xTaskCreate+0xa0>
    6df8:	ec 15       	cp	r30, r12
    6dfa:	fd 05       	cpc	r31, r13
    6dfc:	a1 f7       	brne	.-24     	; 0x6de6 <xTaskCreate+0x88>
    6dfe:	18 a6       	std	Y+40, r1	; 0x28
    6e00:	01 c0       	rjmp	.+2      	; 0x6e04 <xTaskCreate+0xa6>
    6e02:	19 8e       	std	Y+25, r1	; 0x19
    6e04:	04 30       	cpi	r16, 0x04	; 4
    6e06:	08 f0       	brcs	.+2      	; 0x6e0a <xTaskCreate+0xac>
    6e08:	03 e0       	ldi	r16, 0x03	; 3
    6e0a:	0e 8b       	std	Y+22, r16	; 0x16
    6e0c:	0b a7       	std	Y+43, r16	; 0x2b
    6e0e:	1c a6       	std	Y+44, r1	; 0x2c
    6e10:	6e 01       	movw	r12, r28
    6e12:	b2 e0       	ldi	r27, 0x02	; 2
    6e14:	cb 0e       	add	r12, r27
    6e16:	d1 1c       	adc	r13, r1
    6e18:	c6 01       	movw	r24, r12
    6e1a:	bf d8       	rcall	.-3714   	; 0x5f9a <vListInitialiseItem>
    6e1c:	ce 01       	movw	r24, r28
    6e1e:	0c 96       	adiw	r24, 0x0c	; 12
    6e20:	bc d8       	rcall	.-3720   	; 0x5f9a <vListInitialiseItem>
    6e22:	d9 87       	std	Y+9, r29	; 0x09
    6e24:	c8 87       	std	Y+8, r28	; 0x08
    6e26:	84 e0       	ldi	r24, 0x04	; 4
    6e28:	90 e0       	ldi	r25, 0x00	; 0
    6e2a:	80 1b       	sub	r24, r16
    6e2c:	91 09       	sbc	r25, r1
    6e2e:	9d 87       	std	Y+13, r25	; 0x0d
    6e30:	8c 87       	std	Y+12, r24	; 0x0c
    6e32:	db 8b       	std	Y+19, r29	; 0x13
    6e34:	ca 8b       	std	Y+18, r28	; 0x12
    6e36:	1e a6       	std	Y+46, r1	; 0x2e
    6e38:	1d a6       	std	Y+45, r1	; 0x2d
    6e3a:	18 aa       	std	Y+48, r1	; 0x30
    6e3c:	1f a6       	std	Y+47, r1	; 0x2f
    6e3e:	1a aa       	std	Y+50, r1	; 0x32
    6e40:	19 aa       	std	Y+49, r1	; 0x31
    6e42:	1c aa       	std	Y+52, r1	; 0x34
    6e44:	1b aa       	std	Y+51, r1	; 0x33
    6e46:	1e aa       	std	Y+54, r1	; 0x36
    6e48:	1d aa       	std	Y+53, r1	; 0x35
    6e4a:	1f aa       	std	Y+55, r1	; 0x37
    6e4c:	18 ae       	std	Y+56, r1	; 0x38
    6e4e:	19 ae       	std	Y+57, r1	; 0x39
    6e50:	1a ae       	std	Y+58, r1	; 0x3a
    6e52:	1b ae       	std	Y+59, r1	; 0x3b
    6e54:	a2 01       	movw	r20, r4
    6e56:	b4 01       	movw	r22, r8
    6e58:	c5 01       	movw	r24, r10
    6e5a:	1c d9       	rcall	.-3528   	; 0x6094 <pxPortInitialiseStack>
    6e5c:	99 83       	std	Y+1, r25	; 0x01
    6e5e:	88 83       	st	Y, r24
    6e60:	e1 14       	cp	r14, r1
    6e62:	f1 04       	cpc	r15, r1
    6e64:	19 f0       	breq	.+6      	; 0x6e6c <xTaskCreate+0x10e>
    6e66:	f7 01       	movw	r30, r14
    6e68:	d1 83       	std	Z+1, r29	; 0x01
    6e6a:	c0 83       	st	Z, r28
    6e6c:	0f b6       	in	r0, 0x3f	; 63
    6e6e:	f8 94       	cli
    6e70:	0f 92       	push	r0
    6e72:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    6e76:	8f 5f       	subi	r24, 0xFF	; 255
    6e78:	80 93 fe 1f 	sts	0x1FFE, r24	; 0x801ffe <uxCurrentNumberOfTasks>
    6e7c:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    6e80:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6e84:	89 2b       	or	r24, r25
    6e86:	89 f5       	brne	.+98     	; 0x6eea <xTaskCreate+0x18c>
    6e88:	d0 93 56 20 	sts	0x2056, r29	; 0x802056 <pxCurrentTCB+0x1>
    6e8c:	c0 93 55 20 	sts	0x2055, r28	; 0x802055 <pxCurrentTCB>
    6e90:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    6e94:	81 30       	cpi	r24, 0x01	; 1
    6e96:	09 f0       	breq	.+2      	; 0x6e9a <xTaskCreate+0x13c>
    6e98:	38 c0       	rjmp	.+112    	; 0x6f0a <xTaskCreate+0x1ac>
    6e9a:	81 e3       	ldi	r24, 0x31	; 49
    6e9c:	90 e2       	ldi	r25, 0x20	; 32
    6e9e:	6f d8       	rcall	.-3874   	; 0x5f7e <vListInitialise>
    6ea0:	8a e3       	ldi	r24, 0x3A	; 58
    6ea2:	90 e2       	ldi	r25, 0x20	; 32
    6ea4:	6c d8       	rcall	.-3880   	; 0x5f7e <vListInitialise>
    6ea6:	83 e4       	ldi	r24, 0x43	; 67
    6ea8:	90 e2       	ldi	r25, 0x20	; 32
    6eaa:	69 d8       	rcall	.-3886   	; 0x5f7e <vListInitialise>
    6eac:	8c e4       	ldi	r24, 0x4C	; 76
    6eae:	90 e2       	ldi	r25, 0x20	; 32
    6eb0:	66 d8       	rcall	.-3892   	; 0x5f7e <vListInitialise>
    6eb2:	88 e2       	ldi	r24, 0x28	; 40
    6eb4:	90 e2       	ldi	r25, 0x20	; 32
    6eb6:	63 d8       	rcall	.-3898   	; 0x5f7e <vListInitialise>
    6eb8:	8f e1       	ldi	r24, 0x1F	; 31
    6eba:	90 e2       	ldi	r25, 0x20	; 32
    6ebc:	60 d8       	rcall	.-3904   	; 0x5f7e <vListInitialise>
    6ebe:	82 e1       	ldi	r24, 0x12	; 18
    6ec0:	90 e2       	ldi	r25, 0x20	; 32
    6ec2:	5d d8       	rcall	.-3910   	; 0x5f7e <vListInitialise>
    6ec4:	89 e0       	ldi	r24, 0x09	; 9
    6ec6:	90 e2       	ldi	r25, 0x20	; 32
    6ec8:	5a d8       	rcall	.-3916   	; 0x5f7e <vListInitialise>
    6eca:	8f ef       	ldi	r24, 0xFF	; 255
    6ecc:	9f e1       	ldi	r25, 0x1F	; 31
    6ece:	57 d8       	rcall	.-3922   	; 0x5f7e <vListInitialise>
    6ed0:	88 e2       	ldi	r24, 0x28	; 40
    6ed2:	90 e2       	ldi	r25, 0x20	; 32
    6ed4:	90 93 1e 20 	sts	0x201E, r25	; 0x80201e <pxDelayedTaskList+0x1>
    6ed8:	80 93 1d 20 	sts	0x201D, r24	; 0x80201d <pxDelayedTaskList>
    6edc:	8f e1       	ldi	r24, 0x1F	; 31
    6ede:	90 e2       	ldi	r25, 0x20	; 32
    6ee0:	90 93 1c 20 	sts	0x201C, r25	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    6ee4:	80 93 1b 20 	sts	0x201B, r24	; 0x80201b <pxOverflowDelayedTaskList>
    6ee8:	10 c0       	rjmp	.+32     	; 0x6f0a <xTaskCreate+0x1ac>
    6eea:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xSchedulerRunning>
    6eee:	81 11       	cpse	r24, r1
    6ef0:	0c c0       	rjmp	.+24     	; 0x6f0a <xTaskCreate+0x1ac>
    6ef2:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    6ef6:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6efa:	96 89       	ldd	r25, Z+22	; 0x16
    6efc:	8e 89       	ldd	r24, Y+22	; 0x16
    6efe:	89 17       	cp	r24, r25
    6f00:	20 f0       	brcs	.+8      	; 0x6f0a <xTaskCreate+0x1ac>
    6f02:	d0 93 56 20 	sts	0x2056, r29	; 0x802056 <pxCurrentTCB+0x1>
    6f06:	c0 93 55 20 	sts	0x2055, r28	; 0x802055 <pxCurrentTCB>
    6f0a:	80 91 f6 1f 	lds	r24, 0x1FF6	; 0x801ff6 <uxTaskNumber>
    6f0e:	8f 5f       	subi	r24, 0xFF	; 255
    6f10:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <uxTaskNumber>
    6f14:	89 a7       	std	Y+41, r24	; 0x29
    6f16:	8e 89       	ldd	r24, Y+22	; 0x16
    6f18:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    6f1c:	98 17       	cp	r25, r24
    6f1e:	10 f4       	brcc	.+4      	; 0x6f24 <xTaskCreate+0x1c6>
    6f20:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    6f24:	90 e0       	ldi	r25, 0x00	; 0
    6f26:	9c 01       	movw	r18, r24
    6f28:	22 0f       	add	r18, r18
    6f2a:	33 1f       	adc	r19, r19
    6f2c:	22 0f       	add	r18, r18
    6f2e:	33 1f       	adc	r19, r19
    6f30:	22 0f       	add	r18, r18
    6f32:	33 1f       	adc	r19, r19
    6f34:	82 0f       	add	r24, r18
    6f36:	93 1f       	adc	r25, r19
    6f38:	b6 01       	movw	r22, r12
    6f3a:	8f 5c       	subi	r24, 0xCF	; 207
    6f3c:	9f 4d       	sbci	r25, 0xDF	; 223
    6f3e:	31 d8       	rcall	.-3998   	; 0x5fa2 <vListInsertEnd>
    6f40:	0f 90       	pop	r0
    6f42:	0f be       	out	0x3f, r0	; 63
    6f44:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xSchedulerRunning>
    6f48:	88 23       	and	r24, r24
    6f4a:	59 f0       	breq	.+22     	; 0x6f62 <xTaskCreate+0x204>
    6f4c:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    6f50:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6f54:	96 89       	ldd	r25, Z+22	; 0x16
    6f56:	8e 89       	ldd	r24, Y+22	; 0x16
    6f58:	98 17       	cp	r25, r24
    6f5a:	28 f4       	brcc	.+10     	; 0x6f66 <xTaskCreate+0x208>
    6f5c:	4c d9       	rcall	.-3432   	; 0x61f6 <vPortYield>
    6f5e:	81 e0       	ldi	r24, 0x01	; 1
    6f60:	05 c0       	rjmp	.+10     	; 0x6f6c <xTaskCreate+0x20e>
    6f62:	81 e0       	ldi	r24, 0x01	; 1
    6f64:	03 c0       	rjmp	.+6      	; 0x6f6c <xTaskCreate+0x20e>
    6f66:	81 e0       	ldi	r24, 0x01	; 1
    6f68:	01 c0       	rjmp	.+2      	; 0x6f6c <xTaskCreate+0x20e>
    6f6a:	8f ef       	ldi	r24, 0xFF	; 255
    6f6c:	df 91       	pop	r29
    6f6e:	cf 91       	pop	r28
    6f70:	0f 91       	pop	r16
    6f72:	ff 90       	pop	r15
    6f74:	ef 90       	pop	r14
    6f76:	df 90       	pop	r13
    6f78:	cf 90       	pop	r12
    6f7a:	bf 90       	pop	r11
    6f7c:	af 90       	pop	r10
    6f7e:	9f 90       	pop	r9
    6f80:	8f 90       	pop	r8
    6f82:	7f 90       	pop	r7
    6f84:	6f 90       	pop	r6
    6f86:	5f 90       	pop	r5
    6f88:	4f 90       	pop	r4
    6f8a:	08 95       	ret

00006f8c <eTaskGetState>:
    6f8c:	20 91 55 20 	lds	r18, 0x2055	; 0x802055 <pxCurrentTCB>
    6f90:	30 91 56 20 	lds	r19, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    6f94:	82 17       	cp	r24, r18
    6f96:	93 07       	cpc	r25, r19
    6f98:	61 f1       	breq	.+88     	; 0x6ff2 <eTaskGetState+0x66>
    6f9a:	0f b6       	in	r0, 0x3f	; 63
    6f9c:	f8 94       	cli
    6f9e:	0f 92       	push	r0
    6fa0:	fc 01       	movw	r30, r24
    6fa2:	22 85       	ldd	r18, Z+10	; 0x0a
    6fa4:	33 85       	ldd	r19, Z+11	; 0x0b
    6fa6:	40 91 1d 20 	lds	r20, 0x201D	; 0x80201d <pxDelayedTaskList>
    6faa:	50 91 1e 20 	lds	r21, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    6fae:	60 91 1b 20 	lds	r22, 0x201B	; 0x80201b <pxOverflowDelayedTaskList>
    6fb2:	70 91 1c 20 	lds	r23, 0x201C	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    6fb6:	0f 90       	pop	r0
    6fb8:	0f be       	out	0x3f, r0	; 63
    6fba:	24 17       	cp	r18, r20
    6fbc:	35 07       	cpc	r19, r21
    6fbe:	d9 f0       	breq	.+54     	; 0x6ff6 <eTaskGetState+0x6a>
    6fc0:	26 17       	cp	r18, r22
    6fc2:	37 07       	cpc	r19, r23
    6fc4:	d1 f0       	breq	.+52     	; 0x6ffa <eTaskGetState+0x6e>
    6fc6:	ff e1       	ldi	r31, 0x1F	; 31
    6fc8:	2f 3f       	cpi	r18, 0xFF	; 255
    6fca:	3f 07       	cpc	r19, r31
    6fcc:	51 f4       	brne	.+20     	; 0x6fe2 <eTaskGetState+0x56>
    6fce:	fc 01       	movw	r30, r24
    6fd0:	24 89       	ldd	r18, Z+20	; 0x14
    6fd2:	35 89       	ldd	r19, Z+21	; 0x15
    6fd4:	23 2b       	or	r18, r19
    6fd6:	99 f4       	brne	.+38     	; 0x6ffe <eTaskGetState+0x72>
    6fd8:	83 ad       	ldd	r24, Z+59	; 0x3b
    6fda:	81 30       	cpi	r24, 0x01	; 1
    6fdc:	91 f0       	breq	.+36     	; 0x7002 <eTaskGetState+0x76>
    6fde:	83 e0       	ldi	r24, 0x03	; 3
    6fe0:	08 95       	ret
    6fe2:	f0 e2       	ldi	r31, 0x20	; 32
    6fe4:	29 30       	cpi	r18, 0x09	; 9
    6fe6:	3f 07       	cpc	r19, r31
    6fe8:	71 f0       	breq	.+28     	; 0x7006 <eTaskGetState+0x7a>
    6fea:	23 2b       	or	r18, r19
    6fec:	71 f0       	breq	.+28     	; 0x700a <eTaskGetState+0x7e>
    6fee:	81 e0       	ldi	r24, 0x01	; 1
    6ff0:	08 95       	ret
    6ff2:	80 e0       	ldi	r24, 0x00	; 0
    6ff4:	08 95       	ret
    6ff6:	82 e0       	ldi	r24, 0x02	; 2
    6ff8:	08 95       	ret
    6ffa:	82 e0       	ldi	r24, 0x02	; 2
    6ffc:	08 95       	ret
    6ffe:	82 e0       	ldi	r24, 0x02	; 2
    7000:	08 95       	ret
    7002:	82 e0       	ldi	r24, 0x02	; 2
    7004:	08 95       	ret
    7006:	84 e0       	ldi	r24, 0x04	; 4
    7008:	08 95       	ret
    700a:	84 e0       	ldi	r24, 0x04	; 4
    700c:	08 95       	ret

0000700e <xTaskResumeFromISR>:
    700e:	ef 92       	push	r14
    7010:	ff 92       	push	r15
    7012:	1f 93       	push	r17
    7014:	cf 93       	push	r28
    7016:	df 93       	push	r29
    7018:	fc 01       	movw	r30, r24
    701a:	22 85       	ldd	r18, Z+10	; 0x0a
    701c:	33 85       	ldd	r19, Z+11	; 0x0b
    701e:	2f 5f       	subi	r18, 0xFF	; 255
    7020:	3f 41       	sbci	r19, 0x1F	; 31
    7022:	09 f0       	breq	.+2      	; 0x7026 <xTaskResumeFromISR+0x18>
    7024:	3f c0       	rjmp	.+126    	; 0x70a4 <xTaskResumeFromISR+0x96>
    7026:	fc 01       	movw	r30, r24
    7028:	24 89       	ldd	r18, Z+20	; 0x14
    702a:	35 89       	ldd	r19, Z+21	; 0x15
    702c:	f0 e2       	ldi	r31, 0x20	; 32
    702e:	22 31       	cpi	r18, 0x12	; 18
    7030:	3f 07       	cpc	r19, r31
    7032:	d1 f1       	breq	.+116    	; 0x70a8 <xTaskResumeFromISR+0x9a>
    7034:	23 2b       	or	r18, r19
    7036:	d1 f5       	brne	.+116    	; 0x70ac <xTaskResumeFromISR+0x9e>
    7038:	ec 01       	movw	r28, r24
    703a:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    703e:	81 11       	cpse	r24, r1
    7040:	28 c0       	rjmp	.+80     	; 0x7092 <xTaskResumeFromISR+0x84>
    7042:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    7046:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    704a:	11 e0       	ldi	r17, 0x01	; 1
    704c:	9e 89       	ldd	r25, Y+22	; 0x16
    704e:	86 89       	ldd	r24, Z+22	; 0x16
    7050:	98 17       	cp	r25, r24
    7052:	08 f4       	brcc	.+2      	; 0x7056 <xTaskResumeFromISR+0x48>
    7054:	10 e0       	ldi	r17, 0x00	; 0
    7056:	7e 01       	movw	r14, r28
    7058:	42 e0       	ldi	r20, 0x02	; 2
    705a:	e4 0e       	add	r14, r20
    705c:	f1 1c       	adc	r15, r1
    705e:	c7 01       	movw	r24, r14
    7060:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    7064:	8e 89       	ldd	r24, Y+22	; 0x16
    7066:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    706a:	98 17       	cp	r25, r24
    706c:	10 f4       	brcc	.+4      	; 0x7072 <xTaskResumeFromISR+0x64>
    706e:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    7072:	90 e0       	ldi	r25, 0x00	; 0
    7074:	9c 01       	movw	r18, r24
    7076:	22 0f       	add	r18, r18
    7078:	33 1f       	adc	r19, r19
    707a:	22 0f       	add	r18, r18
    707c:	33 1f       	adc	r19, r19
    707e:	22 0f       	add	r18, r18
    7080:	33 1f       	adc	r19, r19
    7082:	82 0f       	add	r24, r18
    7084:	93 1f       	adc	r25, r19
    7086:	b7 01       	movw	r22, r14
    7088:	8f 5c       	subi	r24, 0xCF	; 207
    708a:	9f 4d       	sbci	r25, 0xDF	; 223
    708c:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    7090:	0e c0       	rjmp	.+28     	; 0x70ae <xTaskResumeFromISR+0xa0>
    7092:	be 01       	movw	r22, r28
    7094:	64 5f       	subi	r22, 0xF4	; 244
    7096:	7f 4f       	sbci	r23, 0xFF	; 255
    7098:	82 e1       	ldi	r24, 0x12	; 18
    709a:	90 e2       	ldi	r25, 0x20	; 32
    709c:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    70a0:	10 e0       	ldi	r17, 0x00	; 0
    70a2:	05 c0       	rjmp	.+10     	; 0x70ae <xTaskResumeFromISR+0xa0>
    70a4:	10 e0       	ldi	r17, 0x00	; 0
    70a6:	03 c0       	rjmp	.+6      	; 0x70ae <xTaskResumeFromISR+0xa0>
    70a8:	10 e0       	ldi	r17, 0x00	; 0
    70aa:	01 c0       	rjmp	.+2      	; 0x70ae <xTaskResumeFromISR+0xa0>
    70ac:	10 e0       	ldi	r17, 0x00	; 0
    70ae:	81 2f       	mov	r24, r17
    70b0:	df 91       	pop	r29
    70b2:	cf 91       	pop	r28
    70b4:	1f 91       	pop	r17
    70b6:	ff 90       	pop	r15
    70b8:	ef 90       	pop	r14
    70ba:	08 95       	ret

000070bc <vTaskStartScheduler>:
    70bc:	ef 92       	push	r14
    70be:	ff 92       	push	r15
    70c0:	0f 93       	push	r16
    70c2:	0f 2e       	mov	r0, r31
    70c4:	f2 ef       	ldi	r31, 0xF2	; 242
    70c6:	ef 2e       	mov	r14, r31
    70c8:	ff e1       	ldi	r31, 0x1F	; 31
    70ca:	ff 2e       	mov	r15, r31
    70cc:	f0 2d       	mov	r31, r0
    70ce:	00 e0       	ldi	r16, 0x00	; 0
    70d0:	20 e0       	ldi	r18, 0x00	; 0
    70d2:	30 e0       	ldi	r19, 0x00	; 0
    70d4:	44 e6       	ldi	r20, 0x64	; 100
    70d6:	50 e0       	ldi	r21, 0x00	; 0
    70d8:	6b ef       	ldi	r22, 0xFB	; 251
    70da:	72 e0       	ldi	r23, 0x02	; 2
    70dc:	87 e2       	ldi	r24, 0x27	; 39
    70de:	96 e3       	ldi	r25, 0x36	; 54
    70e0:	3e de       	rcall	.-900    	; 0x6d5e <xTaskCreate>
    70e2:	81 30       	cpi	r24, 0x01	; 1
    70e4:	91 f4       	brne	.+36     	; 0x710a <vTaskStartScheduler+0x4e>
    70e6:	8e d6       	rcall	.+3356   	; 0x7e04 <xTimerCreateTimerTask>
    70e8:	81 30       	cpi	r24, 0x01	; 1
    70ea:	79 f4       	brne	.+30     	; 0x710a <vTaskStartScheduler+0x4e>
    70ec:	f8 94       	cli
    70ee:	8f ef       	ldi	r24, 0xFF	; 255
    70f0:	9f ef       	ldi	r25, 0xFF	; 255
    70f2:	90 93 f5 1f 	sts	0x1FF5, r25	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    70f6:	80 93 f4 1f 	sts	0x1FF4, r24	; 0x801ff4 <xNextTaskUnblockTime>
    70fa:	81 e0       	ldi	r24, 0x01	; 1
    70fc:	80 93 fa 1f 	sts	0x1FFA, r24	; 0x801ffa <xSchedulerRunning>
    7100:	10 92 fd 1f 	sts	0x1FFD, r1	; 0x801ffd <xTickCount+0x1>
    7104:	10 92 fc 1f 	sts	0x1FFC, r1	; 0x801ffc <xTickCount>
    7108:	37 d8       	rcall	.-3986   	; 0x6178 <xPortStartScheduler>
    710a:	0f 91       	pop	r16
    710c:	ff 90       	pop	r15
    710e:	ef 90       	pop	r14
    7110:	08 95       	ret

00007112 <vTaskSuspendAll>:
    7112:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    7116:	8f 5f       	subi	r24, 0xFF	; 255
    7118:	80 93 f1 1f 	sts	0x1FF1, r24	; 0x801ff1 <uxSchedulerSuspended>
    711c:	08 95       	ret

0000711e <xTaskGetTickCount>:
    711e:	0f b6       	in	r0, 0x3f	; 63
    7120:	f8 94       	cli
    7122:	0f 92       	push	r0
    7124:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xTickCount>
    7128:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <xTickCount+0x1>
    712c:	0f 90       	pop	r0
    712e:	0f be       	out	0x3f, r0	; 63
    7130:	08 95       	ret

00007132 <uxTaskGetNumberOfTasks>:
    7132:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    7136:	08 95       	ret

00007138 <pcTaskGetName>:
    7138:	00 97       	sbiw	r24, 0x00	; 0
    713a:	21 f4       	brne	.+8      	; 0x7144 <pcTaskGetName+0xc>
    713c:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7140:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7144:	49 96       	adiw	r24, 0x19	; 25
    7146:	08 95       	ret

00007148 <xTaskIncrementTick>:
    7148:	cf 92       	push	r12
    714a:	df 92       	push	r13
    714c:	ef 92       	push	r14
    714e:	ff 92       	push	r15
    7150:	0f 93       	push	r16
    7152:	1f 93       	push	r17
    7154:	cf 93       	push	r28
    7156:	df 93       	push	r29
    7158:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    715c:	81 11       	cpse	r24, r1
    715e:	80 c0       	rjmp	.+256    	; 0x7260 <xTaskIncrementTick+0x118>
    7160:	e0 90 fc 1f 	lds	r14, 0x1FFC	; 0x801ffc <xTickCount>
    7164:	f0 90 fd 1f 	lds	r15, 0x1FFD	; 0x801ffd <xTickCount+0x1>
    7168:	8f ef       	ldi	r24, 0xFF	; 255
    716a:	e8 1a       	sub	r14, r24
    716c:	f8 0a       	sbc	r15, r24
    716e:	f0 92 fd 1f 	sts	0x1FFD, r15	; 0x801ffd <xTickCount+0x1>
    7172:	e0 92 fc 1f 	sts	0x1FFC, r14	; 0x801ffc <xTickCount>
    7176:	e1 14       	cp	r14, r1
    7178:	f1 04       	cpc	r15, r1
    717a:	b1 f4       	brne	.+44     	; 0x71a8 <xTaskIncrementTick+0x60>
    717c:	80 91 1d 20 	lds	r24, 0x201D	; 0x80201d <pxDelayedTaskList>
    7180:	90 91 1e 20 	lds	r25, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    7184:	20 91 1b 20 	lds	r18, 0x201B	; 0x80201b <pxOverflowDelayedTaskList>
    7188:	30 91 1c 20 	lds	r19, 0x201C	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    718c:	30 93 1e 20 	sts	0x201E, r19	; 0x80201e <pxDelayedTaskList+0x1>
    7190:	20 93 1d 20 	sts	0x201D, r18	; 0x80201d <pxDelayedTaskList>
    7194:	90 93 1c 20 	sts	0x201C, r25	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    7198:	80 93 1b 20 	sts	0x201B, r24	; 0x80201b <pxOverflowDelayedTaskList>
    719c:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <xNumOfOverflows>
    71a0:	8f 5f       	subi	r24, 0xFF	; 255
    71a2:	80 93 f7 1f 	sts	0x1FF7, r24	; 0x801ff7 <xNumOfOverflows>
    71a6:	34 dd       	rcall	.-1432   	; 0x6c10 <prvResetNextTaskUnblockTime>
    71a8:	80 91 f4 1f 	lds	r24, 0x1FF4	; 0x801ff4 <xNextTaskUnblockTime>
    71ac:	90 91 f5 1f 	lds	r25, 0x1FF5	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    71b0:	e8 16       	cp	r14, r24
    71b2:	f9 06       	cpc	r15, r25
    71b4:	10 f4       	brcc	.+4      	; 0x71ba <xTaskIncrementTick+0x72>
    71b6:	d1 2c       	mov	r13, r1
    71b8:	59 c0       	rjmp	.+178    	; 0x726c <xTaskIncrementTick+0x124>
    71ba:	d1 2c       	mov	r13, r1
    71bc:	cc 24       	eor	r12, r12
    71be:	c3 94       	inc	r12
    71c0:	e0 91 1d 20 	lds	r30, 0x201D	; 0x80201d <pxDelayedTaskList>
    71c4:	f0 91 1e 20 	lds	r31, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    71c8:	80 81       	ld	r24, Z
    71ca:	81 11       	cpse	r24, r1
    71cc:	07 c0       	rjmp	.+14     	; 0x71dc <xTaskIncrementTick+0x94>
    71ce:	8f ef       	ldi	r24, 0xFF	; 255
    71d0:	9f ef       	ldi	r25, 0xFF	; 255
    71d2:	90 93 f5 1f 	sts	0x1FF5, r25	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    71d6:	80 93 f4 1f 	sts	0x1FF4, r24	; 0x801ff4 <xNextTaskUnblockTime>
    71da:	48 c0       	rjmp	.+144    	; 0x726c <xTaskIncrementTick+0x124>
    71dc:	e0 91 1d 20 	lds	r30, 0x201D	; 0x80201d <pxDelayedTaskList>
    71e0:	f0 91 1e 20 	lds	r31, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    71e4:	05 80       	ldd	r0, Z+5	; 0x05
    71e6:	f6 81       	ldd	r31, Z+6	; 0x06
    71e8:	e0 2d       	mov	r30, r0
    71ea:	c6 81       	ldd	r28, Z+6	; 0x06
    71ec:	d7 81       	ldd	r29, Z+7	; 0x07
    71ee:	8a 81       	ldd	r24, Y+2	; 0x02
    71f0:	9b 81       	ldd	r25, Y+3	; 0x03
    71f2:	e8 16       	cp	r14, r24
    71f4:	f9 06       	cpc	r15, r25
    71f6:	28 f4       	brcc	.+10     	; 0x7202 <xTaskIncrementTick+0xba>
    71f8:	90 93 f5 1f 	sts	0x1FF5, r25	; 0x801ff5 <xNextTaskUnblockTime+0x1>
    71fc:	80 93 f4 1f 	sts	0x1FF4, r24	; 0x801ff4 <xNextTaskUnblockTime>
    7200:	35 c0       	rjmp	.+106    	; 0x726c <xTaskIncrementTick+0x124>
    7202:	8e 01       	movw	r16, r28
    7204:	0e 5f       	subi	r16, 0xFE	; 254
    7206:	1f 4f       	sbci	r17, 0xFF	; 255
    7208:	c8 01       	movw	r24, r16
    720a:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    720e:	8c 89       	ldd	r24, Y+20	; 0x14
    7210:	9d 89       	ldd	r25, Y+21	; 0x15
    7212:	89 2b       	or	r24, r25
    7214:	21 f0       	breq	.+8      	; 0x721e <xTaskIncrementTick+0xd6>
    7216:	ce 01       	movw	r24, r28
    7218:	0c 96       	adiw	r24, 0x0c	; 12
    721a:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    721e:	8e 89       	ldd	r24, Y+22	; 0x16
    7220:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    7224:	98 17       	cp	r25, r24
    7226:	10 f4       	brcc	.+4      	; 0x722c <xTaskIncrementTick+0xe4>
    7228:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    722c:	90 e0       	ldi	r25, 0x00	; 0
    722e:	9c 01       	movw	r18, r24
    7230:	22 0f       	add	r18, r18
    7232:	33 1f       	adc	r19, r19
    7234:	22 0f       	add	r18, r18
    7236:	33 1f       	adc	r19, r19
    7238:	22 0f       	add	r18, r18
    723a:	33 1f       	adc	r19, r19
    723c:	82 0f       	add	r24, r18
    723e:	93 1f       	adc	r25, r19
    7240:	b8 01       	movw	r22, r16
    7242:	8f 5c       	subi	r24, 0xCF	; 207
    7244:	9f 4d       	sbci	r25, 0xDF	; 223
    7246:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    724a:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    724e:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7252:	9e 89       	ldd	r25, Y+22	; 0x16
    7254:	86 89       	ldd	r24, Z+22	; 0x16
    7256:	98 17       	cp	r25, r24
    7258:	08 f4       	brcc	.+2      	; 0x725c <xTaskIncrementTick+0x114>
    725a:	b2 cf       	rjmp	.-156    	; 0x71c0 <xTaskIncrementTick+0x78>
    725c:	dc 2c       	mov	r13, r12
    725e:	b0 cf       	rjmp	.-160    	; 0x71c0 <xTaskIncrementTick+0x78>
    7260:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <uxPendedTicks>
    7264:	8f 5f       	subi	r24, 0xFF	; 255
    7266:	80 93 f9 1f 	sts	0x1FF9, r24	; 0x801ff9 <uxPendedTicks>
    726a:	d1 2c       	mov	r13, r1
    726c:	80 91 f8 1f 	lds	r24, 0x1FF8	; 0x801ff8 <xYieldPending>
    7270:	88 23       	and	r24, r24
    7272:	11 f0       	breq	.+4      	; 0x7278 <xTaskIncrementTick+0x130>
    7274:	dd 24       	eor	r13, r13
    7276:	d3 94       	inc	r13
    7278:	8d 2d       	mov	r24, r13
    727a:	df 91       	pop	r29
    727c:	cf 91       	pop	r28
    727e:	1f 91       	pop	r17
    7280:	0f 91       	pop	r16
    7282:	ff 90       	pop	r15
    7284:	ef 90       	pop	r14
    7286:	df 90       	pop	r13
    7288:	cf 90       	pop	r12
    728a:	08 95       	ret

0000728c <xTaskResumeAll>:
    728c:	df 92       	push	r13
    728e:	ef 92       	push	r14
    7290:	ff 92       	push	r15
    7292:	0f 93       	push	r16
    7294:	1f 93       	push	r17
    7296:	cf 93       	push	r28
    7298:	df 93       	push	r29
    729a:	0f b6       	in	r0, 0x3f	; 63
    729c:	f8 94       	cli
    729e:	0f 92       	push	r0
    72a0:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    72a4:	81 50       	subi	r24, 0x01	; 1
    72a6:	80 93 f1 1f 	sts	0x1FF1, r24	; 0x801ff1 <uxSchedulerSuspended>
    72aa:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    72ae:	81 11       	cpse	r24, r1
    72b0:	5d c0       	rjmp	.+186    	; 0x736c <xTaskResumeAll+0xe0>
    72b2:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    72b6:	81 11       	cpse	r24, r1
    72b8:	33 c0       	rjmp	.+102    	; 0x7320 <xTaskResumeAll+0x94>
    72ba:	5b c0       	rjmp	.+182    	; 0x7372 <xTaskResumeAll+0xe6>
    72bc:	d7 01       	movw	r26, r14
    72be:	15 96       	adiw	r26, 0x05	; 5
    72c0:	ed 91       	ld	r30, X+
    72c2:	fc 91       	ld	r31, X
    72c4:	16 97       	sbiw	r26, 0x06	; 6
    72c6:	c6 81       	ldd	r28, Z+6	; 0x06
    72c8:	d7 81       	ldd	r29, Z+7	; 0x07
    72ca:	ce 01       	movw	r24, r28
    72cc:	0c 96       	adiw	r24, 0x0c	; 12
    72ce:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    72d2:	8e 01       	movw	r16, r28
    72d4:	0e 5f       	subi	r16, 0xFE	; 254
    72d6:	1f 4f       	sbci	r17, 0xFF	; 255
    72d8:	c8 01       	movw	r24, r16
    72da:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    72de:	8e 89       	ldd	r24, Y+22	; 0x16
    72e0:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    72e4:	98 17       	cp	r25, r24
    72e6:	10 f4       	brcc	.+4      	; 0x72ec <xTaskResumeAll+0x60>
    72e8:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    72ec:	90 e0       	ldi	r25, 0x00	; 0
    72ee:	9c 01       	movw	r18, r24
    72f0:	22 0f       	add	r18, r18
    72f2:	33 1f       	adc	r19, r19
    72f4:	22 0f       	add	r18, r18
    72f6:	33 1f       	adc	r19, r19
    72f8:	22 0f       	add	r18, r18
    72fa:	33 1f       	adc	r19, r19
    72fc:	82 0f       	add	r24, r18
    72fe:	93 1f       	adc	r25, r19
    7300:	b8 01       	movw	r22, r16
    7302:	8f 5c       	subi	r24, 0xCF	; 207
    7304:	9f 4d       	sbci	r25, 0xDF	; 223
    7306:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    730a:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    730e:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7312:	9e 89       	ldd	r25, Y+22	; 0x16
    7314:	86 89       	ldd	r24, Z+22	; 0x16
    7316:	98 17       	cp	r25, r24
    7318:	68 f0       	brcs	.+26     	; 0x7334 <xTaskResumeAll+0xa8>
    731a:	d0 92 f8 1f 	sts	0x1FF8, r13	; 0x801ff8 <xYieldPending>
    731e:	0a c0       	rjmp	.+20     	; 0x7334 <xTaskResumeAll+0xa8>
    7320:	c0 e0       	ldi	r28, 0x00	; 0
    7322:	d0 e0       	ldi	r29, 0x00	; 0
    7324:	0f 2e       	mov	r0, r31
    7326:	f2 e1       	ldi	r31, 0x12	; 18
    7328:	ef 2e       	mov	r14, r31
    732a:	f0 e2       	ldi	r31, 0x20	; 32
    732c:	ff 2e       	mov	r15, r31
    732e:	f0 2d       	mov	r31, r0
    7330:	dd 24       	eor	r13, r13
    7332:	d3 94       	inc	r13
    7334:	f7 01       	movw	r30, r14
    7336:	80 81       	ld	r24, Z
    7338:	81 11       	cpse	r24, r1
    733a:	c0 cf       	rjmp	.-128    	; 0x72bc <xTaskResumeAll+0x30>
    733c:	cd 2b       	or	r28, r29
    733e:	09 f0       	breq	.+2      	; 0x7342 <xTaskResumeAll+0xb6>
    7340:	67 dc       	rcall	.-1842   	; 0x6c10 <prvResetNextTaskUnblockTime>
    7342:	c0 91 f9 1f 	lds	r28, 0x1FF9	; 0x801ff9 <uxPendedTicks>
    7346:	cc 23       	and	r28, r28
    7348:	49 f0       	breq	.+18     	; 0x735c <xTaskResumeAll+0xd0>
    734a:	d1 e0       	ldi	r29, 0x01	; 1
    734c:	fd de       	rcall	.-518    	; 0x7148 <xTaskIncrementTick>
    734e:	81 11       	cpse	r24, r1
    7350:	d0 93 f8 1f 	sts	0x1FF8, r29	; 0x801ff8 <xYieldPending>
    7354:	c1 50       	subi	r28, 0x01	; 1
    7356:	d1 f7       	brne	.-12     	; 0x734c <xTaskResumeAll+0xc0>
    7358:	10 92 f9 1f 	sts	0x1FF9, r1	; 0x801ff9 <uxPendedTicks>
    735c:	80 91 f8 1f 	lds	r24, 0x1FF8	; 0x801ff8 <xYieldPending>
    7360:	88 23       	and	r24, r24
    7362:	31 f0       	breq	.+12     	; 0x7370 <xTaskResumeAll+0xe4>
    7364:	0e 94 fb 30 	call	0x61f6	; 0x61f6 <vPortYield>
    7368:	81 e0       	ldi	r24, 0x01	; 1
    736a:	03 c0       	rjmp	.+6      	; 0x7372 <xTaskResumeAll+0xe6>
    736c:	80 e0       	ldi	r24, 0x00	; 0
    736e:	01 c0       	rjmp	.+2      	; 0x7372 <xTaskResumeAll+0xe6>
    7370:	80 e0       	ldi	r24, 0x00	; 0
    7372:	0f 90       	pop	r0
    7374:	0f be       	out	0x3f, r0	; 63
    7376:	df 91       	pop	r29
    7378:	cf 91       	pop	r28
    737a:	1f 91       	pop	r17
    737c:	0f 91       	pop	r16
    737e:	ff 90       	pop	r15
    7380:	ef 90       	pop	r14
    7382:	df 90       	pop	r13
    7384:	08 95       	ret

00007386 <vTaskDelay>:
    7386:	cf 93       	push	r28
    7388:	df 93       	push	r29
    738a:	ec 01       	movw	r28, r24
    738c:	89 2b       	or	r24, r25
    738e:	39 f0       	breq	.+14     	; 0x739e <vTaskDelay+0x18>
    7390:	c0 de       	rcall	.-640    	; 0x7112 <vTaskSuspendAll>
    7392:	60 e0       	ldi	r22, 0x00	; 0
    7394:	ce 01       	movw	r24, r28
    7396:	8f dc       	rcall	.-1762   	; 0x6cb6 <prvAddCurrentTaskToDelayedList>
    7398:	79 df       	rcall	.-270    	; 0x728c <xTaskResumeAll>
    739a:	81 11       	cpse	r24, r1
    739c:	02 c0       	rjmp	.+4      	; 0x73a2 <vTaskDelay+0x1c>
    739e:	0e 94 fb 30 	call	0x61f6	; 0x61f6 <vPortYield>
    73a2:	df 91       	pop	r29
    73a4:	cf 91       	pop	r28
    73a6:	08 95       	ret

000073a8 <vTaskPlaceOnEventList>:
    73a8:	cf 93       	push	r28
    73aa:	df 93       	push	r29
    73ac:	eb 01       	movw	r28, r22
    73ae:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    73b2:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    73b6:	64 5f       	subi	r22, 0xF4	; 244
    73b8:	7f 4f       	sbci	r23, 0xFF	; 255
    73ba:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <vListInsert>
    73be:	61 e0       	ldi	r22, 0x01	; 1
    73c0:	ce 01       	movw	r24, r28
    73c2:	79 dc       	rcall	.-1806   	; 0x6cb6 <prvAddCurrentTaskToDelayedList>
    73c4:	df 91       	pop	r29
    73c6:	cf 91       	pop	r28
    73c8:	08 95       	ret

000073ca <vTaskPlaceOnEventListRestricted>:
    73ca:	0f 93       	push	r16
    73cc:	1f 93       	push	r17
    73ce:	cf 93       	push	r28
    73d0:	8b 01       	movw	r16, r22
    73d2:	c4 2f       	mov	r28, r20
    73d4:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    73d8:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    73dc:	64 5f       	subi	r22, 0xF4	; 244
    73de:	7f 4f       	sbci	r23, 0xFF	; 255
    73e0:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    73e4:	cc 23       	and	r28, r28
    73e6:	11 f0       	breq	.+4      	; 0x73ec <vTaskPlaceOnEventListRestricted+0x22>
    73e8:	0f ef       	ldi	r16, 0xFF	; 255
    73ea:	1f ef       	ldi	r17, 0xFF	; 255
    73ec:	6c 2f       	mov	r22, r28
    73ee:	c8 01       	movw	r24, r16
    73f0:	62 dc       	rcall	.-1852   	; 0x6cb6 <prvAddCurrentTaskToDelayedList>
    73f2:	cf 91       	pop	r28
    73f4:	1f 91       	pop	r17
    73f6:	0f 91       	pop	r16
    73f8:	08 95       	ret

000073fa <xTaskRemoveFromEventList>:
    73fa:	0f 93       	push	r16
    73fc:	1f 93       	push	r17
    73fe:	cf 93       	push	r28
    7400:	df 93       	push	r29
    7402:	dc 01       	movw	r26, r24
    7404:	15 96       	adiw	r26, 0x05	; 5
    7406:	ed 91       	ld	r30, X+
    7408:	fc 91       	ld	r31, X
    740a:	16 97       	sbiw	r26, 0x06	; 6
    740c:	c6 81       	ldd	r28, Z+6	; 0x06
    740e:	d7 81       	ldd	r29, Z+7	; 0x07
    7410:	8e 01       	movw	r16, r28
    7412:	04 5f       	subi	r16, 0xF4	; 244
    7414:	1f 4f       	sbci	r17, 0xFF	; 255
    7416:	c8 01       	movw	r24, r16
    7418:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    741c:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    7420:	81 11       	cpse	r24, r1
    7422:	1c c0       	rjmp	.+56     	; 0x745c <xTaskRemoveFromEventList+0x62>
    7424:	0a 50       	subi	r16, 0x0A	; 10
    7426:	11 09       	sbc	r17, r1
    7428:	c8 01       	movw	r24, r16
    742a:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    742e:	8e 89       	ldd	r24, Y+22	; 0x16
    7430:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    7434:	98 17       	cp	r25, r24
    7436:	10 f4       	brcc	.+4      	; 0x743c <xTaskRemoveFromEventList+0x42>
    7438:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    743c:	90 e0       	ldi	r25, 0x00	; 0
    743e:	9c 01       	movw	r18, r24
    7440:	22 0f       	add	r18, r18
    7442:	33 1f       	adc	r19, r19
    7444:	22 0f       	add	r18, r18
    7446:	33 1f       	adc	r19, r19
    7448:	22 0f       	add	r18, r18
    744a:	33 1f       	adc	r19, r19
    744c:	82 0f       	add	r24, r18
    744e:	93 1f       	adc	r25, r19
    7450:	b8 01       	movw	r22, r16
    7452:	8f 5c       	subi	r24, 0xCF	; 207
    7454:	9f 4d       	sbci	r25, 0xDF	; 223
    7456:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    745a:	05 c0       	rjmp	.+10     	; 0x7466 <xTaskRemoveFromEventList+0x6c>
    745c:	b8 01       	movw	r22, r16
    745e:	82 e1       	ldi	r24, 0x12	; 18
    7460:	90 e2       	ldi	r25, 0x20	; 32
    7462:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    7466:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    746a:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    746e:	9e 89       	ldd	r25, Y+22	; 0x16
    7470:	86 89       	ldd	r24, Z+22	; 0x16
    7472:	89 17       	cp	r24, r25
    7474:	20 f4       	brcc	.+8      	; 0x747e <xTaskRemoveFromEventList+0x84>
    7476:	81 e0       	ldi	r24, 0x01	; 1
    7478:	80 93 f8 1f 	sts	0x1FF8, r24	; 0x801ff8 <xYieldPending>
    747c:	01 c0       	rjmp	.+2      	; 0x7480 <xTaskRemoveFromEventList+0x86>
    747e:	80 e0       	ldi	r24, 0x00	; 0
    7480:	df 91       	pop	r29
    7482:	cf 91       	pop	r28
    7484:	1f 91       	pop	r17
    7486:	0f 91       	pop	r16
    7488:	08 95       	ret

0000748a <vTaskInternalSetTimeOutState>:
    748a:	20 91 f7 1f 	lds	r18, 0x1FF7	; 0x801ff7 <xNumOfOverflows>
    748e:	fc 01       	movw	r30, r24
    7490:	20 83       	st	Z, r18
    7492:	20 91 fc 1f 	lds	r18, 0x1FFC	; 0x801ffc <xTickCount>
    7496:	30 91 fd 1f 	lds	r19, 0x1FFD	; 0x801ffd <xTickCount+0x1>
    749a:	32 83       	std	Z+2, r19	; 0x02
    749c:	21 83       	std	Z+1, r18	; 0x01
    749e:	08 95       	ret

000074a0 <xTaskCheckForTimeOut>:
    74a0:	cf 93       	push	r28
    74a2:	df 93       	push	r29
    74a4:	0f b6       	in	r0, 0x3f	; 63
    74a6:	f8 94       	cli
    74a8:	0f 92       	push	r0
    74aa:	20 91 fc 1f 	lds	r18, 0x1FFC	; 0x801ffc <xTickCount>
    74ae:	30 91 fd 1f 	lds	r19, 0x1FFD	; 0x801ffd <xTickCount+0x1>
    74b2:	db 01       	movw	r26, r22
    74b4:	4d 91       	ld	r20, X+
    74b6:	5c 91       	ld	r21, X
    74b8:	4f 3f       	cpi	r20, 0xFF	; 255
    74ba:	bf ef       	ldi	r27, 0xFF	; 255
    74bc:	5b 07       	cpc	r21, r27
    74be:	e9 f0       	breq	.+58     	; 0x74fa <xTaskCheckForTimeOut+0x5a>
    74c0:	ec 01       	movw	r28, r24
    74c2:	e9 81       	ldd	r30, Y+1	; 0x01
    74c4:	fa 81       	ldd	r31, Y+2	; 0x02
    74c6:	a0 91 f7 1f 	lds	r26, 0x1FF7	; 0x801ff7 <xNumOfOverflows>
    74ca:	b8 81       	ld	r27, Y
    74cc:	ba 17       	cp	r27, r26
    74ce:	19 f0       	breq	.+6      	; 0x74d6 <xTaskCheckForTimeOut+0x36>
    74d0:	2e 17       	cp	r18, r30
    74d2:	3f 07       	cpc	r19, r31
    74d4:	a0 f4       	brcc	.+40     	; 0x74fe <xTaskCheckForTimeOut+0x5e>
    74d6:	2e 1b       	sub	r18, r30
    74d8:	3f 0b       	sbc	r19, r31
    74da:	24 17       	cp	r18, r20
    74dc:	35 07       	cpc	r19, r21
    74de:	40 f4       	brcc	.+16     	; 0x74f0 <xTaskCheckForTimeOut+0x50>
    74e0:	fb 01       	movw	r30, r22
    74e2:	42 1b       	sub	r20, r18
    74e4:	53 0b       	sbc	r21, r19
    74e6:	51 83       	std	Z+1, r21	; 0x01
    74e8:	40 83       	st	Z, r20
    74ea:	cf df       	rcall	.-98     	; 0x748a <vTaskInternalSetTimeOutState>
    74ec:	80 e0       	ldi	r24, 0x00	; 0
    74ee:	08 c0       	rjmp	.+16     	; 0x7500 <xTaskCheckForTimeOut+0x60>
    74f0:	fb 01       	movw	r30, r22
    74f2:	11 82       	std	Z+1, r1	; 0x01
    74f4:	10 82       	st	Z, r1
    74f6:	81 e0       	ldi	r24, 0x01	; 1
    74f8:	03 c0       	rjmp	.+6      	; 0x7500 <xTaskCheckForTimeOut+0x60>
    74fa:	80 e0       	ldi	r24, 0x00	; 0
    74fc:	01 c0       	rjmp	.+2      	; 0x7500 <xTaskCheckForTimeOut+0x60>
    74fe:	81 e0       	ldi	r24, 0x01	; 1
    7500:	0f 90       	pop	r0
    7502:	0f be       	out	0x3f, r0	; 63
    7504:	df 91       	pop	r29
    7506:	cf 91       	pop	r28
    7508:	08 95       	ret

0000750a <vTaskMissedYield>:
    750a:	81 e0       	ldi	r24, 0x01	; 1
    750c:	80 93 f8 1f 	sts	0x1FF8, r24	; 0x801ff8 <xYieldPending>
    7510:	08 95       	ret

00007512 <vTaskGetInfo>:
    7512:	ff 92       	push	r15
    7514:	0f 93       	push	r16
    7516:	1f 93       	push	r17
    7518:	cf 93       	push	r28
    751a:	df 93       	push	r29
    751c:	8c 01       	movw	r16, r24
    751e:	eb 01       	movw	r28, r22
    7520:	f4 2e       	mov	r15, r20
    7522:	89 2b       	or	r24, r25
    7524:	21 f4       	brne	.+8      	; 0x752e <vTaskGetInfo+0x1c>
    7526:	00 91 55 20 	lds	r16, 0x2055	; 0x802055 <pxCurrentTCB>
    752a:	10 91 56 20 	lds	r17, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    752e:	19 83       	std	Y+1, r17	; 0x01
    7530:	08 83       	st	Y, r16
    7532:	c8 01       	movw	r24, r16
    7534:	49 96       	adiw	r24, 0x19	; 25
    7536:	9b 83       	std	Y+3, r25	; 0x03
    7538:	8a 83       	std	Y+2, r24	; 0x02
    753a:	d8 01       	movw	r26, r16
    753c:	56 96       	adiw	r26, 0x16	; 22
    753e:	8c 91       	ld	r24, X
    7540:	56 97       	sbiw	r26, 0x16	; 22
    7542:	8e 83       	std	Y+6, r24	; 0x06
    7544:	57 96       	adiw	r26, 0x17	; 23
    7546:	8d 91       	ld	r24, X+
    7548:	9c 91       	ld	r25, X
    754a:	58 97       	sbiw	r26, 0x18	; 24
    754c:	9d 87       	std	Y+13, r25	; 0x0d
    754e:	8c 87       	std	Y+12, r24	; 0x0c
    7550:	99 96       	adiw	r26, 0x29	; 41
    7552:	8c 91       	ld	r24, X
    7554:	99 97       	sbiw	r26, 0x29	; 41
    7556:	8c 83       	std	Y+4, r24	; 0x04
    7558:	9b 96       	adiw	r26, 0x2b	; 43
    755a:	8c 91       	ld	r24, X
    755c:	8f 83       	std	Y+7, r24	; 0x07
    755e:	18 86       	std	Y+8, r1	; 0x08
    7560:	19 86       	std	Y+9, r1	; 0x09
    7562:	1a 86       	std	Y+10, r1	; 0x0a
    7564:	1b 86       	std	Y+11, r1	; 0x0b
    7566:	25 30       	cpi	r18, 0x05	; 5
    7568:	b1 f0       	breq	.+44     	; 0x7596 <vTaskGetInfo+0x84>
    756a:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    756e:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7572:	08 17       	cp	r16, r24
    7574:	19 07       	cpc	r17, r25
    7576:	11 f4       	brne	.+4      	; 0x757c <vTaskGetInfo+0x6a>
    7578:	1d 82       	std	Y+5, r1	; 0x05
    757a:	10 c0       	rjmp	.+32     	; 0x759c <vTaskGetInfo+0x8a>
    757c:	2d 83       	std	Y+5, r18	; 0x05
    757e:	23 30       	cpi	r18, 0x03	; 3
    7580:	69 f4       	brne	.+26     	; 0x759c <vTaskGetInfo+0x8a>
    7582:	c7 dd       	rcall	.-1138   	; 0x7112 <vTaskSuspendAll>
    7584:	f8 01       	movw	r30, r16
    7586:	84 89       	ldd	r24, Z+20	; 0x14
    7588:	95 89       	ldd	r25, Z+21	; 0x15
    758a:	89 2b       	or	r24, r25
    758c:	11 f0       	breq	.+4      	; 0x7592 <vTaskGetInfo+0x80>
    758e:	82 e0       	ldi	r24, 0x02	; 2
    7590:	8d 83       	std	Y+5, r24	; 0x05
    7592:	7c de       	rcall	.-776    	; 0x728c <xTaskResumeAll>
    7594:	03 c0       	rjmp	.+6      	; 0x759c <vTaskGetInfo+0x8a>
    7596:	c8 01       	movw	r24, r16
    7598:	f9 dc       	rcall	.-1550   	; 0x6f8c <eTaskGetState>
    759a:	8d 83       	std	Y+5, r24	; 0x05
    759c:	ff 20       	and	r15, r15
    759e:	c9 f0       	breq	.+50     	; 0x75d2 <vTaskGetInfo+0xc0>
    75a0:	d8 01       	movw	r26, r16
    75a2:	57 96       	adiw	r26, 0x17	; 23
    75a4:	ed 91       	ld	r30, X+
    75a6:	fc 91       	ld	r31, X
    75a8:	58 97       	sbiw	r26, 0x18	; 24
    75aa:	80 81       	ld	r24, Z
    75ac:	85 3a       	cpi	r24, 0xA5	; 165
    75ae:	59 f4       	brne	.+22     	; 0x75c6 <vTaskGetInfo+0xb4>
    75b0:	31 96       	adiw	r30, 0x01	; 1
    75b2:	80 e0       	ldi	r24, 0x00	; 0
    75b4:	90 e0       	ldi	r25, 0x00	; 0
    75b6:	dc 01       	movw	r26, r24
    75b8:	01 96       	adiw	r24, 0x01	; 1
    75ba:	a1 1d       	adc	r26, r1
    75bc:	b1 1d       	adc	r27, r1
    75be:	21 91       	ld	r18, Z+
    75c0:	25 3a       	cpi	r18, 0xA5	; 165
    75c2:	d1 f3       	breq	.-12     	; 0x75b8 <vTaskGetInfo+0xa6>
    75c4:	03 c0       	rjmp	.+6      	; 0x75cc <vTaskGetInfo+0xba>
    75c6:	80 e0       	ldi	r24, 0x00	; 0
    75c8:	90 e0       	ldi	r25, 0x00	; 0
    75ca:	dc 01       	movw	r26, r24
    75cc:	9f 87       	std	Y+15, r25	; 0x0f
    75ce:	8e 87       	std	Y+14, r24	; 0x0e
    75d0:	02 c0       	rjmp	.+4      	; 0x75d6 <vTaskGetInfo+0xc4>
    75d2:	1f 86       	std	Y+15, r1	; 0x0f
    75d4:	1e 86       	std	Y+14, r1	; 0x0e
    75d6:	df 91       	pop	r29
    75d8:	cf 91       	pop	r28
    75da:	1f 91       	pop	r17
    75dc:	0f 91       	pop	r16
    75de:	ff 90       	pop	r15
    75e0:	08 95       	ret

000075e2 <prvListTasksWithinSingleList>:
    75e2:	8f 92       	push	r8
    75e4:	9f 92       	push	r9
    75e6:	af 92       	push	r10
    75e8:	bf 92       	push	r11
    75ea:	cf 92       	push	r12
    75ec:	df 92       	push	r13
    75ee:	ef 92       	push	r14
    75f0:	ff 92       	push	r15
    75f2:	0f 93       	push	r16
    75f4:	1f 93       	push	r17
    75f6:	cf 93       	push	r28
    75f8:	df 93       	push	r29
    75fa:	6c 01       	movw	r12, r24
    75fc:	eb 01       	movw	r28, r22
    75fe:	98 81       	ld	r25, Y
    7600:	99 23       	and	r25, r25
    7602:	c1 f1       	breq	.+112    	; 0x7674 <prvListTasksWithinSingleList+0x92>
    7604:	e9 81       	ldd	r30, Y+1	; 0x01
    7606:	fa 81       	ldd	r31, Y+2	; 0x02
    7608:	02 80       	ldd	r0, Z+2	; 0x02
    760a:	f3 81       	ldd	r31, Z+3	; 0x03
    760c:	e0 2d       	mov	r30, r0
    760e:	fa 83       	std	Y+2, r31	; 0x02
    7610:	e9 83       	std	Y+1, r30	; 0x01
    7612:	5b 01       	movw	r10, r22
    7614:	83 e0       	ldi	r24, 0x03	; 3
    7616:	a8 0e       	add	r10, r24
    7618:	b1 1c       	adc	r11, r1
    761a:	ea 15       	cp	r30, r10
    761c:	fb 05       	cpc	r31, r11
    761e:	21 f4       	brne	.+8      	; 0x7628 <prvListTasksWithinSingleList+0x46>
    7620:	82 81       	ldd	r24, Z+2	; 0x02
    7622:	93 81       	ldd	r25, Z+3	; 0x03
    7624:	9a 83       	std	Y+2, r25	; 0x02
    7626:	89 83       	std	Y+1, r24	; 0x01
    7628:	04 2f       	mov	r16, r20
    762a:	e9 81       	ldd	r30, Y+1	; 0x01
    762c:	fa 81       	ldd	r31, Y+2	; 0x02
    762e:	86 80       	ldd	r8, Z+6	; 0x06
    7630:	97 80       	ldd	r9, Z+7	; 0x07
    7632:	10 e0       	ldi	r17, 0x00	; 0
    7634:	e9 81       	ldd	r30, Y+1	; 0x01
    7636:	fa 81       	ldd	r31, Y+2	; 0x02
    7638:	82 81       	ldd	r24, Z+2	; 0x02
    763a:	93 81       	ldd	r25, Z+3	; 0x03
    763c:	9a 83       	std	Y+2, r25	; 0x02
    763e:	89 83       	std	Y+1, r24	; 0x01
    7640:	a8 16       	cp	r10, r24
    7642:	b9 06       	cpc	r11, r25
    7644:	21 f4       	brne	.+8      	; 0x764e <prvListTasksWithinSingleList+0x6c>
    7646:	8d 81       	ldd	r24, Y+5	; 0x05
    7648:	9e 81       	ldd	r25, Y+6	; 0x06
    764a:	9a 83       	std	Y+2, r25	; 0x02
    764c:	89 83       	std	Y+1, r24	; 0x01
    764e:	e9 81       	ldd	r30, Y+1	; 0x01
    7650:	fa 81       	ldd	r31, Y+2	; 0x02
    7652:	e6 80       	ldd	r14, Z+6	; 0x06
    7654:	f7 80       	ldd	r15, Z+7	; 0x07
    7656:	b6 01       	movw	r22, r12
    7658:	80 e1       	ldi	r24, 0x10	; 16
    765a:	18 9f       	mul	r17, r24
    765c:	60 0d       	add	r22, r0
    765e:	71 1d       	adc	r23, r1
    7660:	11 24       	eor	r1, r1
    7662:	20 2f       	mov	r18, r16
    7664:	41 e0       	ldi	r20, 0x01	; 1
    7666:	c7 01       	movw	r24, r14
    7668:	54 df       	rcall	.-344    	; 0x7512 <vTaskGetInfo>
    766a:	1f 5f       	subi	r17, 0xFF	; 255
    766c:	8e 14       	cp	r8, r14
    766e:	9f 04       	cpc	r9, r15
    7670:	09 f7       	brne	.-62     	; 0x7634 <prvListTasksWithinSingleList+0x52>
    7672:	01 c0       	rjmp	.+2      	; 0x7676 <prvListTasksWithinSingleList+0x94>
    7674:	10 e0       	ldi	r17, 0x00	; 0
    7676:	81 2f       	mov	r24, r17
    7678:	df 91       	pop	r29
    767a:	cf 91       	pop	r28
    767c:	1f 91       	pop	r17
    767e:	0f 91       	pop	r16
    7680:	ff 90       	pop	r15
    7682:	ef 90       	pop	r14
    7684:	df 90       	pop	r13
    7686:	cf 90       	pop	r12
    7688:	bf 90       	pop	r11
    768a:	af 90       	pop	r10
    768c:	9f 90       	pop	r9
    768e:	8f 90       	pop	r8
    7690:	08 95       	ret

00007692 <uxTaskGetSystemState>:
    7692:	ef 92       	push	r14
    7694:	ff 92       	push	r15
    7696:	0f 93       	push	r16
    7698:	1f 93       	push	r17
    769a:	cf 93       	push	r28
    769c:	df 93       	push	r29
    769e:	7c 01       	movw	r14, r24
    76a0:	c6 2f       	mov	r28, r22
    76a2:	8a 01       	movw	r16, r20
    76a4:	36 dd       	rcall	.-1428   	; 0x7112 <vTaskSuspendAll>
    76a6:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    76aa:	c8 17       	cp	r28, r24
    76ac:	08 f4       	brcc	.+2      	; 0x76b0 <uxTaskGetSystemState+0x1e>
    76ae:	54 c0       	rjmp	.+168    	; 0x7758 <uxTaskGetSystemState+0xc6>
    76b0:	d4 e0       	ldi	r29, 0x04	; 4
    76b2:	c0 e0       	ldi	r28, 0x00	; 0
    76b4:	d1 50       	subi	r29, 0x01	; 1
    76b6:	6d 2f       	mov	r22, r29
    76b8:	70 e0       	ldi	r23, 0x00	; 0
    76ba:	cb 01       	movw	r24, r22
    76bc:	88 0f       	add	r24, r24
    76be:	99 1f       	adc	r25, r25
    76c0:	88 0f       	add	r24, r24
    76c2:	99 1f       	adc	r25, r25
    76c4:	88 0f       	add	r24, r24
    76c6:	99 1f       	adc	r25, r25
    76c8:	68 0f       	add	r22, r24
    76ca:	79 1f       	adc	r23, r25
    76cc:	6f 5c       	subi	r22, 0xCF	; 207
    76ce:	7f 4d       	sbci	r23, 0xDF	; 223
    76d0:	41 e0       	ldi	r20, 0x01	; 1
    76d2:	c7 01       	movw	r24, r14
    76d4:	20 e1       	ldi	r18, 0x10	; 16
    76d6:	c2 9f       	mul	r28, r18
    76d8:	80 0d       	add	r24, r0
    76da:	91 1d       	adc	r25, r1
    76dc:	11 24       	eor	r1, r1
    76de:	81 df       	rcall	.-254    	; 0x75e2 <prvListTasksWithinSingleList>
    76e0:	c8 0f       	add	r28, r24
    76e2:	d1 11       	cpse	r29, r1
    76e4:	e7 cf       	rjmp	.-50     	; 0x76b4 <uxTaskGetSystemState+0x22>
    76e6:	60 91 1d 20 	lds	r22, 0x201D	; 0x80201d <pxDelayedTaskList>
    76ea:	70 91 1e 20 	lds	r23, 0x201E	; 0x80201e <pxDelayedTaskList+0x1>
    76ee:	42 e0       	ldi	r20, 0x02	; 2
    76f0:	c7 01       	movw	r24, r14
    76f2:	e0 e1       	ldi	r30, 0x10	; 16
    76f4:	ce 9f       	mul	r28, r30
    76f6:	80 0d       	add	r24, r0
    76f8:	91 1d       	adc	r25, r1
    76fa:	11 24       	eor	r1, r1
    76fc:	72 df       	rcall	.-284    	; 0x75e2 <prvListTasksWithinSingleList>
    76fe:	c8 0f       	add	r28, r24
    7700:	60 91 1b 20 	lds	r22, 0x201B	; 0x80201b <pxOverflowDelayedTaskList>
    7704:	70 91 1c 20 	lds	r23, 0x201C	; 0x80201c <pxOverflowDelayedTaskList+0x1>
    7708:	42 e0       	ldi	r20, 0x02	; 2
    770a:	c7 01       	movw	r24, r14
    770c:	f0 e1       	ldi	r31, 0x10	; 16
    770e:	cf 9f       	mul	r28, r31
    7710:	80 0d       	add	r24, r0
    7712:	91 1d       	adc	r25, r1
    7714:	11 24       	eor	r1, r1
    7716:	65 df       	rcall	.-310    	; 0x75e2 <prvListTasksWithinSingleList>
    7718:	c8 0f       	add	r28, r24
    771a:	44 e0       	ldi	r20, 0x04	; 4
    771c:	69 e0       	ldi	r22, 0x09	; 9
    771e:	70 e2       	ldi	r23, 0x20	; 32
    7720:	c7 01       	movw	r24, r14
    7722:	20 e1       	ldi	r18, 0x10	; 16
    7724:	c2 9f       	mul	r28, r18
    7726:	80 0d       	add	r24, r0
    7728:	91 1d       	adc	r25, r1
    772a:	11 24       	eor	r1, r1
    772c:	5a df       	rcall	.-332    	; 0x75e2 <prvListTasksWithinSingleList>
    772e:	c8 0f       	add	r28, r24
    7730:	43 e0       	ldi	r20, 0x03	; 3
    7732:	6f ef       	ldi	r22, 0xFF	; 255
    7734:	7f e1       	ldi	r23, 0x1F	; 31
    7736:	c7 01       	movw	r24, r14
    7738:	e0 e1       	ldi	r30, 0x10	; 16
    773a:	ce 9f       	mul	r28, r30
    773c:	80 0d       	add	r24, r0
    773e:	91 1d       	adc	r25, r1
    7740:	11 24       	eor	r1, r1
    7742:	4f df       	rcall	.-354    	; 0x75e2 <prvListTasksWithinSingleList>
    7744:	c8 0f       	add	r28, r24
    7746:	01 15       	cp	r16, r1
    7748:	11 05       	cpc	r17, r1
    774a:	39 f0       	breq	.+14     	; 0x775a <uxTaskGetSystemState+0xc8>
    774c:	f8 01       	movw	r30, r16
    774e:	10 82       	st	Z, r1
    7750:	11 82       	std	Z+1, r1	; 0x01
    7752:	12 82       	std	Z+2, r1	; 0x02
    7754:	13 82       	std	Z+3, r1	; 0x03
    7756:	01 c0       	rjmp	.+2      	; 0x775a <uxTaskGetSystemState+0xc8>
    7758:	c0 e0       	ldi	r28, 0x00	; 0
    775a:	98 dd       	rcall	.-1232   	; 0x728c <xTaskResumeAll>
    775c:	8c 2f       	mov	r24, r28
    775e:	df 91       	pop	r29
    7760:	cf 91       	pop	r28
    7762:	1f 91       	pop	r17
    7764:	0f 91       	pop	r16
    7766:	ff 90       	pop	r15
    7768:	ef 90       	pop	r14
    776a:	08 95       	ret

0000776c <uxTaskGetStackHighWaterMark2>:
    776c:	00 97       	sbiw	r24, 0x00	; 0
    776e:	21 f4       	brne	.+8      	; 0x7778 <uxTaskGetStackHighWaterMark2+0xc>
    7770:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7774:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7778:	dc 01       	movw	r26, r24
    777a:	57 96       	adiw	r26, 0x17	; 23
    777c:	ed 91       	ld	r30, X+
    777e:	fc 91       	ld	r31, X
    7780:	58 97       	sbiw	r26, 0x18	; 24
    7782:	80 81       	ld	r24, Z
    7784:	85 3a       	cpi	r24, 0xA5	; 165
    7786:	59 f4       	brne	.+22     	; 0x779e <uxTaskGetStackHighWaterMark2+0x32>
    7788:	31 96       	adiw	r30, 0x01	; 1
    778a:	80 e0       	ldi	r24, 0x00	; 0
    778c:	90 e0       	ldi	r25, 0x00	; 0
    778e:	dc 01       	movw	r26, r24
    7790:	01 96       	adiw	r24, 0x01	; 1
    7792:	a1 1d       	adc	r26, r1
    7794:	b1 1d       	adc	r27, r1
    7796:	21 91       	ld	r18, Z+
    7798:	25 3a       	cpi	r18, 0xA5	; 165
    779a:	d1 f3       	breq	.-12     	; 0x7790 <uxTaskGetStackHighWaterMark2+0x24>
    779c:	08 95       	ret
    779e:	80 e0       	ldi	r24, 0x00	; 0
    77a0:	90 e0       	ldi	r25, 0x00	; 0
    77a2:	dc 01       	movw	r26, r24
    77a4:	08 95       	ret

000077a6 <xTaskGetSchedulerState>:
    77a6:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xSchedulerRunning>
    77aa:	88 23       	and	r24, r24
    77ac:	31 f0       	breq	.+12     	; 0x77ba <xTaskGetSchedulerState+0x14>
    77ae:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
    77b2:	88 23       	and	r24, r24
    77b4:	21 f0       	breq	.+8      	; 0x77be <xTaskGetSchedulerState+0x18>
    77b6:	80 e0       	ldi	r24, 0x00	; 0
    77b8:	08 95       	ret
    77ba:	81 e0       	ldi	r24, 0x01	; 1
    77bc:	08 95       	ret
    77be:	82 e0       	ldi	r24, 0x02	; 2
    77c0:	08 95       	ret

000077c2 <xTaskPriorityInherit>:
    77c2:	0f 93       	push	r16
    77c4:	1f 93       	push	r17
    77c6:	cf 93       	push	r28
    77c8:	df 93       	push	r29
    77ca:	fc 01       	movw	r30, r24
    77cc:	89 2b       	or	r24, r25
    77ce:	09 f4       	brne	.+2      	; 0x77d2 <xTaskPriorityInherit+0x10>
    77d0:	64 c0       	rjmp	.+200    	; 0x789a <xTaskPriorityInherit+0xd8>
    77d2:	26 89       	ldd	r18, Z+22	; 0x16
    77d4:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    77d8:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    77dc:	56 96       	adiw	r26, 0x16	; 22
    77de:	8c 91       	ld	r24, X
    77e0:	28 17       	cp	r18, r24
    77e2:	08 f0       	brcs	.+2      	; 0x77e6 <xTaskPriorityInherit+0x24>
    77e4:	4e c0       	rjmp	.+156    	; 0x7882 <xTaskPriorityInherit+0xc0>
    77e6:	84 85       	ldd	r24, Z+12	; 0x0c
    77e8:	95 85       	ldd	r25, Z+13	; 0x0d
    77ea:	99 23       	and	r25, r25
    77ec:	64 f0       	brlt	.+24     	; 0x7806 <xTaskPriorityInherit+0x44>
    77ee:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    77f2:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    77f6:	56 96       	adiw	r26, 0x16	; 22
    77f8:	3c 91       	ld	r19, X
    77fa:	84 e0       	ldi	r24, 0x04	; 4
    77fc:	90 e0       	ldi	r25, 0x00	; 0
    77fe:	83 1b       	sub	r24, r19
    7800:	91 09       	sbc	r25, r1
    7802:	95 87       	std	Z+13, r25	; 0x0d
    7804:	84 87       	std	Z+12, r24	; 0x0c
    7806:	30 e0       	ldi	r19, 0x00	; 0
    7808:	c9 01       	movw	r24, r18
    780a:	88 0f       	add	r24, r24
    780c:	99 1f       	adc	r25, r25
    780e:	88 0f       	add	r24, r24
    7810:	99 1f       	adc	r25, r25
    7812:	88 0f       	add	r24, r24
    7814:	99 1f       	adc	r25, r25
    7816:	28 0f       	add	r18, r24
    7818:	39 1f       	adc	r19, r25
    781a:	2f 5c       	subi	r18, 0xCF	; 207
    781c:	3f 4d       	sbci	r19, 0xDF	; 223
    781e:	82 85       	ldd	r24, Z+10	; 0x0a
    7820:	93 85       	ldd	r25, Z+11	; 0x0b
    7822:	82 17       	cp	r24, r18
    7824:	93 07       	cpc	r25, r19
    7826:	21 f5       	brne	.+72     	; 0x7870 <xTaskPriorityInherit+0xae>
    7828:	8f 01       	movw	r16, r30
    782a:	ef 01       	movw	r28, r30
    782c:	22 96       	adiw	r28, 0x02	; 2
    782e:	ce 01       	movw	r24, r28
    7830:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    7834:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    7838:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    783c:	86 89       	ldd	r24, Z+22	; 0x16
    783e:	f8 01       	movw	r30, r16
    7840:	86 8b       	std	Z+22, r24	; 0x16
    7842:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    7846:	98 17       	cp	r25, r24
    7848:	10 f4       	brcc	.+4      	; 0x784e <xTaskPriorityInherit+0x8c>
    784a:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    784e:	90 e0       	ldi	r25, 0x00	; 0
    7850:	9c 01       	movw	r18, r24
    7852:	22 0f       	add	r18, r18
    7854:	33 1f       	adc	r19, r19
    7856:	22 0f       	add	r18, r18
    7858:	33 1f       	adc	r19, r19
    785a:	22 0f       	add	r18, r18
    785c:	33 1f       	adc	r19, r19
    785e:	82 0f       	add	r24, r18
    7860:	93 1f       	adc	r25, r19
    7862:	be 01       	movw	r22, r28
    7864:	8f 5c       	subi	r24, 0xCF	; 207
    7866:	9f 4d       	sbci	r25, 0xDF	; 223
    7868:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    786c:	81 e0       	ldi	r24, 0x01	; 1
    786e:	16 c0       	rjmp	.+44     	; 0x789c <xTaskPriorityInherit+0xda>
    7870:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    7874:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7878:	56 96       	adiw	r26, 0x16	; 22
    787a:	8c 91       	ld	r24, X
    787c:	86 8b       	std	Z+22, r24	; 0x16
    787e:	81 e0       	ldi	r24, 0x01	; 1
    7880:	0d c0       	rjmp	.+26     	; 0x789c <xTaskPriorityInherit+0xda>
    7882:	a0 91 55 20 	lds	r26, 0x2055	; 0x802055 <pxCurrentTCB>
    7886:	b0 91 56 20 	lds	r27, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    788a:	81 e0       	ldi	r24, 0x01	; 1
    788c:	23 a5       	ldd	r18, Z+43	; 0x2b
    788e:	56 96       	adiw	r26, 0x16	; 22
    7890:	9c 91       	ld	r25, X
    7892:	29 17       	cp	r18, r25
    7894:	18 f0       	brcs	.+6      	; 0x789c <xTaskPriorityInherit+0xda>
    7896:	80 e0       	ldi	r24, 0x00	; 0
    7898:	01 c0       	rjmp	.+2      	; 0x789c <xTaskPriorityInherit+0xda>
    789a:	80 e0       	ldi	r24, 0x00	; 0
    789c:	df 91       	pop	r29
    789e:	cf 91       	pop	r28
    78a0:	1f 91       	pop	r17
    78a2:	0f 91       	pop	r16
    78a4:	08 95       	ret

000078a6 <xTaskPriorityDisinherit>:
    78a6:	0f 93       	push	r16
    78a8:	1f 93       	push	r17
    78aa:	cf 93       	push	r28
    78ac:	df 93       	push	r29
    78ae:	fc 01       	movw	r30, r24
    78b0:	89 2b       	or	r24, r25
    78b2:	79 f1       	breq	.+94     	; 0x7912 <xTaskPriorityDisinherit+0x6c>
    78b4:	84 a5       	ldd	r24, Z+44	; 0x2c
    78b6:	81 50       	subi	r24, 0x01	; 1
    78b8:	84 a7       	std	Z+44, r24	; 0x2c
    78ba:	26 89       	ldd	r18, Z+22	; 0x16
    78bc:	93 a5       	ldd	r25, Z+43	; 0x2b
    78be:	29 17       	cp	r18, r25
    78c0:	51 f1       	breq	.+84     	; 0x7916 <xTaskPriorityDisinherit+0x70>
    78c2:	81 11       	cpse	r24, r1
    78c4:	2a c0       	rjmp	.+84     	; 0x791a <xTaskPriorityDisinherit+0x74>
    78c6:	ef 01       	movw	r28, r30
    78c8:	8f 01       	movw	r16, r30
    78ca:	0e 5f       	subi	r16, 0xFE	; 254
    78cc:	1f 4f       	sbci	r17, 0xFF	; 255
    78ce:	c8 01       	movw	r24, r16
    78d0:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    78d4:	8b a5       	ldd	r24, Y+43	; 0x2b
    78d6:	8e 8b       	std	Y+22, r24	; 0x16
    78d8:	24 e0       	ldi	r18, 0x04	; 4
    78da:	30 e0       	ldi	r19, 0x00	; 0
    78dc:	28 1b       	sub	r18, r24
    78de:	31 09       	sbc	r19, r1
    78e0:	3d 87       	std	Y+13, r19	; 0x0d
    78e2:	2c 87       	std	Y+12, r18	; 0x0c
    78e4:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    78e8:	98 17       	cp	r25, r24
    78ea:	10 f4       	brcc	.+4      	; 0x78f0 <xTaskPriorityDisinherit+0x4a>
    78ec:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    78f0:	90 e0       	ldi	r25, 0x00	; 0
    78f2:	9c 01       	movw	r18, r24
    78f4:	22 0f       	add	r18, r18
    78f6:	33 1f       	adc	r19, r19
    78f8:	22 0f       	add	r18, r18
    78fa:	33 1f       	adc	r19, r19
    78fc:	22 0f       	add	r18, r18
    78fe:	33 1f       	adc	r19, r19
    7900:	82 0f       	add	r24, r18
    7902:	93 1f       	adc	r25, r19
    7904:	b8 01       	movw	r22, r16
    7906:	8f 5c       	subi	r24, 0xCF	; 207
    7908:	9f 4d       	sbci	r25, 0xDF	; 223
    790a:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    790e:	81 e0       	ldi	r24, 0x01	; 1
    7910:	05 c0       	rjmp	.+10     	; 0x791c <xTaskPriorityDisinherit+0x76>
    7912:	80 e0       	ldi	r24, 0x00	; 0
    7914:	03 c0       	rjmp	.+6      	; 0x791c <xTaskPriorityDisinherit+0x76>
    7916:	80 e0       	ldi	r24, 0x00	; 0
    7918:	01 c0       	rjmp	.+2      	; 0x791c <xTaskPriorityDisinherit+0x76>
    791a:	80 e0       	ldi	r24, 0x00	; 0
    791c:	df 91       	pop	r29
    791e:	cf 91       	pop	r28
    7920:	1f 91       	pop	r17
    7922:	0f 91       	pop	r16
    7924:	08 95       	ret

00007926 <vTaskPriorityDisinheritAfterTimeout>:
    7926:	0f 93       	push	r16
    7928:	1f 93       	push	r17
    792a:	cf 93       	push	r28
    792c:	df 93       	push	r29
    792e:	fc 01       	movw	r30, r24
    7930:	89 2b       	or	r24, r25
    7932:	09 f4       	brne	.+2      	; 0x7936 <vTaskPriorityDisinheritAfterTimeout+0x10>
    7934:	43 c0       	rjmp	.+134    	; 0x79bc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7936:	93 a5       	ldd	r25, Z+43	; 0x2b
    7938:	96 17       	cp	r25, r22
    793a:	08 f4       	brcc	.+2      	; 0x793e <vTaskPriorityDisinheritAfterTimeout+0x18>
    793c:	96 2f       	mov	r25, r22
    793e:	86 89       	ldd	r24, Z+22	; 0x16
    7940:	89 17       	cp	r24, r25
    7942:	e1 f1       	breq	.+120    	; 0x79bc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7944:	24 a5       	ldd	r18, Z+44	; 0x2c
    7946:	21 30       	cpi	r18, 0x01	; 1
    7948:	c9 f5       	brne	.+114    	; 0x79bc <vTaskPriorityDisinheritAfterTimeout+0x96>
    794a:	96 8b       	std	Z+22, r25	; 0x16
    794c:	24 85       	ldd	r18, Z+12	; 0x0c
    794e:	35 85       	ldd	r19, Z+13	; 0x0d
    7950:	33 23       	and	r19, r19
    7952:	34 f0       	brlt	.+12     	; 0x7960 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    7954:	24 e0       	ldi	r18, 0x04	; 4
    7956:	30 e0       	ldi	r19, 0x00	; 0
    7958:	29 1b       	sub	r18, r25
    795a:	31 09       	sbc	r19, r1
    795c:	35 87       	std	Z+13, r19	; 0x0d
    795e:	24 87       	std	Z+12, r18	; 0x0c
    7960:	90 e0       	ldi	r25, 0x00	; 0
    7962:	9c 01       	movw	r18, r24
    7964:	22 0f       	add	r18, r18
    7966:	33 1f       	adc	r19, r19
    7968:	22 0f       	add	r18, r18
    796a:	33 1f       	adc	r19, r19
    796c:	22 0f       	add	r18, r18
    796e:	33 1f       	adc	r19, r19
    7970:	82 0f       	add	r24, r18
    7972:	93 1f       	adc	r25, r19
    7974:	8f 5c       	subi	r24, 0xCF	; 207
    7976:	9f 4d       	sbci	r25, 0xDF	; 223
    7978:	22 85       	ldd	r18, Z+10	; 0x0a
    797a:	33 85       	ldd	r19, Z+11	; 0x0b
    797c:	28 17       	cp	r18, r24
    797e:	39 07       	cpc	r19, r25
    7980:	e9 f4       	brne	.+58     	; 0x79bc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7982:	ef 01       	movw	r28, r30
    7984:	8f 01       	movw	r16, r30
    7986:	0e 5f       	subi	r16, 0xFE	; 254
    7988:	1f 4f       	sbci	r17, 0xFF	; 255
    798a:	c8 01       	movw	r24, r16
    798c:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
    7990:	8e 89       	ldd	r24, Y+22	; 0x16
    7992:	90 91 fb 1f 	lds	r25, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    7996:	98 17       	cp	r25, r24
    7998:	10 f4       	brcc	.+4      	; 0x799e <vTaskPriorityDisinheritAfterTimeout+0x78>
    799a:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxTopReadyPriority>
    799e:	90 e0       	ldi	r25, 0x00	; 0
    79a0:	9c 01       	movw	r18, r24
    79a2:	22 0f       	add	r18, r18
    79a4:	33 1f       	adc	r19, r19
    79a6:	22 0f       	add	r18, r18
    79a8:	33 1f       	adc	r19, r19
    79aa:	22 0f       	add	r18, r18
    79ac:	33 1f       	adc	r19, r19
    79ae:	82 0f       	add	r24, r18
    79b0:	93 1f       	adc	r25, r19
    79b2:	b8 01       	movw	r22, r16
    79b4:	8f 5c       	subi	r24, 0xCF	; 207
    79b6:	9f 4d       	sbci	r25, 0xDF	; 223
    79b8:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>
    79bc:	df 91       	pop	r29
    79be:	cf 91       	pop	r28
    79c0:	1f 91       	pop	r17
    79c2:	0f 91       	pop	r16
    79c4:	08 95       	ret

000079c6 <vTaskList>:
    79c6:	3f 92       	push	r3
    79c8:	4f 92       	push	r4
    79ca:	5f 92       	push	r5
    79cc:	6f 92       	push	r6
    79ce:	7f 92       	push	r7
    79d0:	8f 92       	push	r8
    79d2:	9f 92       	push	r9
    79d4:	af 92       	push	r10
    79d6:	bf 92       	push	r11
    79d8:	cf 92       	push	r12
    79da:	df 92       	push	r13
    79dc:	ef 92       	push	r14
    79de:	ff 92       	push	r15
    79e0:	0f 93       	push	r16
    79e2:	1f 93       	push	r17
    79e4:	cf 93       	push	r28
    79e6:	df 93       	push	r29
    79e8:	ec 01       	movw	r28, r24
    79ea:	18 82       	st	Y, r1
    79ec:	10 91 fe 1f 	lds	r17, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    79f0:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    79f4:	20 e1       	ldi	r18, 0x10	; 16
    79f6:	82 9f       	mul	r24, r18
    79f8:	c0 01       	movw	r24, r0
    79fa:	11 24       	eor	r1, r1
    79fc:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <pvPortMalloc>
    7a00:	6c 01       	movw	r12, r24
    7a02:	00 97       	sbiw	r24, 0x00	; 0
    7a04:	09 f4       	brne	.+2      	; 0x7a08 <vTaskList+0x42>
    7a06:	85 c0       	rjmp	.+266    	; 0x7b12 <vTaskList+0x14c>
    7a08:	40 e0       	ldi	r20, 0x00	; 0
    7a0a:	50 e0       	ldi	r21, 0x00	; 0
    7a0c:	61 2f       	mov	r22, r17
    7a0e:	41 de       	rcall	.-894    	; 0x7692 <uxTaskGetSystemState>
    7a10:	68 2e       	mov	r6, r24
    7a12:	88 23       	and	r24, r24
    7a14:	09 f4       	brne	.+2      	; 0x7a18 <vTaskList+0x52>
    7a16:	7a c0       	rjmp	.+244    	; 0x7b0c <vTaskList+0x146>
    7a18:	86 01       	movw	r16, r12
    7a1a:	81 2c       	mov	r8, r1
    7a1c:	31 2c       	mov	r3, r1
    7a1e:	68 94       	set
    7a20:	99 24       	eor	r9, r9
    7a22:	95 f8       	bld	r9, 5
    7a24:	0f 2e       	mov	r0, r31
    7a26:	ff e0       	ldi	r31, 0x0F	; 15
    7a28:	4f 2e       	mov	r4, r31
    7a2a:	f0 2d       	mov	r31, r0
    7a2c:	51 2c       	mov	r5, r1
    7a2e:	0f 2e       	mov	r0, r31
    7a30:	f0 e0       	ldi	r31, 0x00	; 0
    7a32:	ef 2e       	mov	r14, r31
    7a34:	f3 e0       	ldi	r31, 0x03	; 3
    7a36:	ff 2e       	mov	r15, r31
    7a38:	f0 2d       	mov	r31, r0
    7a3a:	58 01       	movw	r10, r16
    7a3c:	f8 01       	movw	r30, r16
    7a3e:	85 81       	ldd	r24, Z+5	; 0x05
    7a40:	82 30       	cpi	r24, 0x02	; 2
    7a42:	81 f0       	breq	.+32     	; 0x7a64 <vTaskList+0x9e>
    7a44:	28 f4       	brcc	.+10     	; 0x7a50 <vTaskList+0x8a>
    7a46:	88 23       	and	r24, r24
    7a48:	f1 f0       	breq	.+60     	; 0x7a86 <vTaskList+0xc0>
    7a4a:	81 30       	cpi	r24, 0x01	; 1
    7a4c:	31 f0       	breq	.+12     	; 0x7a5a <vTaskList+0x94>
    7a4e:	19 c0       	rjmp	.+50     	; 0x7a82 <vTaskList+0xbc>
    7a50:	83 30       	cpi	r24, 0x03	; 3
    7a52:	69 f0       	breq	.+26     	; 0x7a6e <vTaskList+0xa8>
    7a54:	84 30       	cpi	r24, 0x04	; 4
    7a56:	81 f0       	breq	.+32     	; 0x7a78 <vTaskList+0xb2>
    7a58:	14 c0       	rjmp	.+40     	; 0x7a82 <vTaskList+0xbc>
    7a5a:	0f 2e       	mov	r0, r31
    7a5c:	f2 e5       	ldi	r31, 0x52	; 82
    7a5e:	7f 2e       	mov	r7, r31
    7a60:	f0 2d       	mov	r31, r0
    7a62:	15 c0       	rjmp	.+42     	; 0x7a8e <vTaskList+0xc8>
    7a64:	0f 2e       	mov	r0, r31
    7a66:	f2 e4       	ldi	r31, 0x42	; 66
    7a68:	7f 2e       	mov	r7, r31
    7a6a:	f0 2d       	mov	r31, r0
    7a6c:	10 c0       	rjmp	.+32     	; 0x7a8e <vTaskList+0xc8>
    7a6e:	0f 2e       	mov	r0, r31
    7a70:	f3 e5       	ldi	r31, 0x53	; 83
    7a72:	7f 2e       	mov	r7, r31
    7a74:	f0 2d       	mov	r31, r0
    7a76:	0b c0       	rjmp	.+22     	; 0x7a8e <vTaskList+0xc8>
    7a78:	0f 2e       	mov	r0, r31
    7a7a:	f4 e4       	ldi	r31, 0x44	; 68
    7a7c:	7f 2e       	mov	r7, r31
    7a7e:	f0 2d       	mov	r31, r0
    7a80:	06 c0       	rjmp	.+12     	; 0x7a8e <vTaskList+0xc8>
    7a82:	73 2c       	mov	r7, r3
    7a84:	04 c0       	rjmp	.+8      	; 0x7a8e <vTaskList+0xc8>
    7a86:	0f 2e       	mov	r0, r31
    7a88:	f8 e5       	ldi	r31, 0x58	; 88
    7a8a:	7f 2e       	mov	r7, r31
    7a8c:	f0 2d       	mov	r31, r0
    7a8e:	f5 01       	movw	r30, r10
    7a90:	62 81       	ldd	r22, Z+2	; 0x02
    7a92:	73 81       	ldd	r23, Z+3	; 0x03
    7a94:	ce 01       	movw	r24, r28
    7a96:	67 d5       	rcall	.+2766   	; 0x8566 <strcpy>
    7a98:	fe 01       	movw	r30, r28
    7a9a:	01 90       	ld	r0, Z+
    7a9c:	00 20       	and	r0, r0
    7a9e:	e9 f7       	brne	.-6      	; 0x7a9a <vTaskList+0xd4>
    7aa0:	31 97       	sbiw	r30, 0x01	; 1
    7aa2:	ec 1b       	sub	r30, r28
    7aa4:	fd 0b       	sbc	r31, r29
    7aa6:	ef 30       	cpi	r30, 0x0F	; 15
    7aa8:	f1 05       	cpc	r31, r1
    7aaa:	50 f4       	brcc	.+20     	; 0x7ac0 <vTaskList+0xfa>
    7aac:	ec 0f       	add	r30, r28
    7aae:	fd 1f       	adc	r31, r29
    7ab0:	ce 01       	movw	r24, r28
    7ab2:	0f 96       	adiw	r24, 0x0f	; 15
    7ab4:	91 92       	st	Z+, r9
    7ab6:	e8 17       	cp	r30, r24
    7ab8:	f9 07       	cpc	r31, r25
    7aba:	e1 f7       	brne	.-8      	; 0x7ab4 <vTaskList+0xee>
    7abc:	e4 2d       	mov	r30, r4
    7abe:	f5 2d       	mov	r31, r5
    7ac0:	ce 0f       	add	r28, r30
    7ac2:	df 1f       	adc	r29, r31
    7ac4:	18 82       	st	Y, r1
    7ac6:	f5 01       	movw	r30, r10
    7ac8:	84 81       	ldd	r24, Z+4	; 0x04
    7aca:	1f 92       	push	r1
    7acc:	8f 93       	push	r24
    7ace:	87 85       	ldd	r24, Z+15	; 0x0f
    7ad0:	8f 93       	push	r24
    7ad2:	86 85       	ldd	r24, Z+14	; 0x0e
    7ad4:	8f 93       	push	r24
    7ad6:	86 81       	ldd	r24, Z+6	; 0x06
    7ad8:	1f 92       	push	r1
    7ada:	8f 93       	push	r24
    7adc:	1f 92       	push	r1
    7ade:	7f 92       	push	r7
    7ae0:	ff 92       	push	r15
    7ae2:	ef 92       	push	r14
    7ae4:	df 93       	push	r29
    7ae6:	cf 93       	push	r28
    7ae8:	5d d6       	rcall	.+3258   	; 0x87a4 <sprintf>
    7aea:	09 90       	ld	r0, Y+
    7aec:	00 20       	and	r0, r0
    7aee:	e9 f7       	brne	.-6      	; 0x7aea <vTaskList+0x124>
    7af0:	21 97       	sbiw	r28, 0x01	; 1
    7af2:	83 94       	inc	r8
    7af4:	00 5f       	subi	r16, 0xF0	; 240
    7af6:	1f 4f       	sbci	r17, 0xFF	; 255
    7af8:	8d b7       	in	r24, 0x3d	; 61
    7afa:	9e b7       	in	r25, 0x3e	; 62
    7afc:	0c 96       	adiw	r24, 0x0c	; 12
    7afe:	0f b6       	in	r0, 0x3f	; 63
    7b00:	f8 94       	cli
    7b02:	9e bf       	out	0x3e, r25	; 62
    7b04:	0f be       	out	0x3f, r0	; 63
    7b06:	8d bf       	out	0x3d, r24	; 61
    7b08:	68 10       	cpse	r6, r8
    7b0a:	97 cf       	rjmp	.-210    	; 0x7a3a <vTaskList+0x74>
    7b0c:	c6 01       	movw	r24, r12
    7b0e:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <vPortFree>
    7b12:	df 91       	pop	r29
    7b14:	cf 91       	pop	r28
    7b16:	1f 91       	pop	r17
    7b18:	0f 91       	pop	r16
    7b1a:	ff 90       	pop	r15
    7b1c:	ef 90       	pop	r14
    7b1e:	df 90       	pop	r13
    7b20:	cf 90       	pop	r12
    7b22:	bf 90       	pop	r11
    7b24:	af 90       	pop	r10
    7b26:	9f 90       	pop	r9
    7b28:	8f 90       	pop	r8
    7b2a:	7f 90       	pop	r7
    7b2c:	6f 90       	pop	r6
    7b2e:	5f 90       	pop	r5
    7b30:	4f 90       	pop	r4
    7b32:	3f 90       	pop	r3
    7b34:	08 95       	ret

00007b36 <pvTaskIncrementMutexHeldCount>:
    7b36:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7b3a:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7b3e:	89 2b       	or	r24, r25
    7b40:	39 f0       	breq	.+14     	; 0x7b50 <pvTaskIncrementMutexHeldCount+0x1a>
    7b42:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    7b46:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7b4a:	84 a5       	ldd	r24, Z+44	; 0x2c
    7b4c:	8f 5f       	subi	r24, 0xFF	; 255
    7b4e:	84 a7       	std	Z+44, r24	; 0x2c
    7b50:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7b54:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7b58:	08 95       	ret

00007b5a <vApplicationStackOverflowHook>:
	#endif

#endif

extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
	printf("ov %s",pcTaskName);
    7b5a:	7f 93       	push	r23
    7b5c:	6f 93       	push	r22
    7b5e:	8f e0       	ldi	r24, 0x0F	; 15
    7b60:	93 e0       	ldi	r25, 0x03	; 3
    7b62:	9f 93       	push	r25
    7b64:	8f 93       	push	r24
    7b66:	78 d5       	rcall	.+2800   	; 0x8658 <printf>
	FORCERESET
    7b68:	d4 da       	rcall	.-2648   	; 0x7112 <vTaskSuspendAll>
    7b6a:	81 ec       	ldi	r24, 0xC1	; 193
    7b6c:	92 e0       	ldi	r25, 0x02	; 2
    7b6e:	ae d5       	rcall	.+2908   	; 0x86cc <puts>
    7b70:	0f 90       	pop	r0
    7b72:	0f 90       	pop	r0
    7b74:	0f 90       	pop	r0
    7b76:	0f 90       	pop	r0
    7b78:	ff cf       	rjmp	.-2      	; 0x7b78 <vApplicationStackOverflowHook+0x1e>

00007b7a <vTaskSwitchContext>:
    7b7a:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <uxSchedulerSuspended>
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    7b7e:	88 23       	and	r24, r24
    7b80:	21 f0       	breq	.+8      	; 0x7b8a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    7b82:	81 e0       	ldi	r24, 0x01	; 1
    7b84:	80 93 f8 1f 	sts	0x1FF8, r24	; 0x801ff8 <xYieldPending>
    7b88:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    7b8a:	10 92 f8 1f 	sts	0x1FF8, r1	; 0x801ff8 <xYieldPending>
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    7b8e:	e0 91 55 20 	lds	r30, 0x2055	; 0x802055 <pxCurrentTCB>
    7b92:	f0 91 56 20 	lds	r31, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7b96:	07 88       	ldd	r0, Z+23	; 0x17
    7b98:	f0 8d       	ldd	r31, Z+24	; 0x18
    7b9a:	e0 2d       	mov	r30, r0
    7b9c:	80 81       	ld	r24, Z
    7b9e:	91 81       	ldd	r25, Z+1	; 0x01
    7ba0:	a2 81       	ldd	r26, Z+2	; 0x02
    7ba2:	b3 81       	ldd	r27, Z+3	; 0x03
    7ba4:	85 3a       	cpi	r24, 0xA5	; 165
    7ba6:	95 4a       	sbci	r25, 0xA5	; 165
    7ba8:	a5 4a       	sbci	r26, 0xA5	; 165
    7baa:	b5 4a       	sbci	r27, 0xA5	; 165
    7bac:	d9 f4       	brne	.+54     	; 0x7be4 <vTaskSwitchContext+0x6a>
    7bae:	84 81       	ldd	r24, Z+4	; 0x04
    7bb0:	95 81       	ldd	r25, Z+5	; 0x05
    7bb2:	a6 81       	ldd	r26, Z+6	; 0x06
    7bb4:	b7 81       	ldd	r27, Z+7	; 0x07
    7bb6:	85 3a       	cpi	r24, 0xA5	; 165
    7bb8:	95 4a       	sbci	r25, 0xA5	; 165
    7bba:	a5 4a       	sbci	r26, 0xA5	; 165
    7bbc:	b5 4a       	sbci	r27, 0xA5	; 165
    7bbe:	91 f4       	brne	.+36     	; 0x7be4 <vTaskSwitchContext+0x6a>
    7bc0:	80 85       	ldd	r24, Z+8	; 0x08
    7bc2:	91 85       	ldd	r25, Z+9	; 0x09
    7bc4:	a2 85       	ldd	r26, Z+10	; 0x0a
    7bc6:	b3 85       	ldd	r27, Z+11	; 0x0b
    7bc8:	85 3a       	cpi	r24, 0xA5	; 165
    7bca:	95 4a       	sbci	r25, 0xA5	; 165
    7bcc:	a5 4a       	sbci	r26, 0xA5	; 165
    7bce:	b5 4a       	sbci	r27, 0xA5	; 165
    7bd0:	49 f4       	brne	.+18     	; 0x7be4 <vTaskSwitchContext+0x6a>
    7bd2:	84 85       	ldd	r24, Z+12	; 0x0c
    7bd4:	95 85       	ldd	r25, Z+13	; 0x0d
    7bd6:	a6 85       	ldd	r26, Z+14	; 0x0e
    7bd8:	b7 85       	ldd	r27, Z+15	; 0x0f
    7bda:	85 3a       	cpi	r24, 0xA5	; 165
    7bdc:	95 4a       	sbci	r25, 0xA5	; 165
    7bde:	a5 4a       	sbci	r26, 0xA5	; 165
    7be0:	b5 4a       	sbci	r27, 0xA5	; 165
    7be2:	59 f0       	breq	.+22     	; 0x7bfa <vTaskSwitchContext+0x80>
    7be4:	60 91 55 20 	lds	r22, 0x2055	; 0x802055 <pxCurrentTCB>
    7be8:	70 91 56 20 	lds	r23, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7bec:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7bf0:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7bf4:	67 5e       	subi	r22, 0xE7	; 231
    7bf6:	7f 4f       	sbci	r23, 0xFF	; 255
    7bf8:	b0 df       	rcall	.-160    	; 0x7b5a <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7bfa:	20 91 fb 1f 	lds	r18, 0x1FFB	; 0x801ffb <uxTopReadyPriority>
    7bfe:	82 2f       	mov	r24, r18
    7c00:	90 e0       	ldi	r25, 0x00	; 0
    7c02:	fc 01       	movw	r30, r24
    7c04:	ee 0f       	add	r30, r30
    7c06:	ff 1f       	adc	r31, r31
    7c08:	ee 0f       	add	r30, r30
    7c0a:	ff 1f       	adc	r31, r31
    7c0c:	ee 0f       	add	r30, r30
    7c0e:	ff 1f       	adc	r31, r31
    7c10:	e8 0f       	add	r30, r24
    7c12:	f9 1f       	adc	r31, r25
    7c14:	ef 5c       	subi	r30, 0xCF	; 207
    7c16:	ff 4d       	sbci	r31, 0xDF	; 223
    7c18:	30 81       	ld	r19, Z
    7c1a:	31 11       	cpse	r19, r1
    7c1c:	11 c0       	rjmp	.+34     	; 0x7c40 <vTaskSwitchContext+0xc6>
    7c1e:	21 50       	subi	r18, 0x01	; 1
    7c20:	82 2f       	mov	r24, r18
    7c22:	90 e0       	ldi	r25, 0x00	; 0
    7c24:	fc 01       	movw	r30, r24
    7c26:	ee 0f       	add	r30, r30
    7c28:	ff 1f       	adc	r31, r31
    7c2a:	ee 0f       	add	r30, r30
    7c2c:	ff 1f       	adc	r31, r31
    7c2e:	ee 0f       	add	r30, r30
    7c30:	ff 1f       	adc	r31, r31
    7c32:	e8 0f       	add	r30, r24
    7c34:	f9 1f       	adc	r31, r25
    7c36:	ef 5c       	subi	r30, 0xCF	; 207
    7c38:	ff 4d       	sbci	r31, 0xDF	; 223
    7c3a:	30 81       	ld	r19, Z
    7c3c:	33 23       	and	r19, r19
    7c3e:	79 f3       	breq	.-34     	; 0x7c1e <vTaskSwitchContext+0xa4>
    7c40:	ac 01       	movw	r20, r24
    7c42:	44 0f       	add	r20, r20
    7c44:	55 1f       	adc	r21, r21
    7c46:	44 0f       	add	r20, r20
    7c48:	55 1f       	adc	r21, r21
    7c4a:	44 0f       	add	r20, r20
    7c4c:	55 1f       	adc	r21, r21
    7c4e:	48 0f       	add	r20, r24
    7c50:	59 1f       	adc	r21, r25
    7c52:	da 01       	movw	r26, r20
    7c54:	af 5c       	subi	r26, 0xCF	; 207
    7c56:	bf 4d       	sbci	r27, 0xDF	; 223
    7c58:	11 96       	adiw	r26, 0x01	; 1
    7c5a:	ed 91       	ld	r30, X+
    7c5c:	fc 91       	ld	r31, X
    7c5e:	12 97       	sbiw	r26, 0x02	; 2
    7c60:	02 80       	ldd	r0, Z+2	; 0x02
    7c62:	f3 81       	ldd	r31, Z+3	; 0x03
    7c64:	e0 2d       	mov	r30, r0
    7c66:	12 96       	adiw	r26, 0x02	; 2
    7c68:	fc 93       	st	X, r31
    7c6a:	ee 93       	st	-X, r30
    7c6c:	11 97       	sbiw	r26, 0x01	; 1
    7c6e:	4c 5c       	subi	r20, 0xCC	; 204
    7c70:	5f 4d       	sbci	r21, 0xDF	; 223
    7c72:	e4 17       	cp	r30, r20
    7c74:	f5 07       	cpc	r31, r21
    7c76:	29 f4       	brne	.+10     	; 0x7c82 <vTaskSwitchContext+0x108>
    7c78:	42 81       	ldd	r20, Z+2	; 0x02
    7c7a:	53 81       	ldd	r21, Z+3	; 0x03
    7c7c:	fd 01       	movw	r30, r26
    7c7e:	52 83       	std	Z+2, r21	; 0x02
    7c80:	41 83       	std	Z+1, r20	; 0x01
    7c82:	fc 01       	movw	r30, r24
    7c84:	ee 0f       	add	r30, r30
    7c86:	ff 1f       	adc	r31, r31
    7c88:	ee 0f       	add	r30, r30
    7c8a:	ff 1f       	adc	r31, r31
    7c8c:	ee 0f       	add	r30, r30
    7c8e:	ff 1f       	adc	r31, r31
    7c90:	8e 0f       	add	r24, r30
    7c92:	9f 1f       	adc	r25, r31
    7c94:	fc 01       	movw	r30, r24
    7c96:	ef 5c       	subi	r30, 0xCF	; 207
    7c98:	ff 4d       	sbci	r31, 0xDF	; 223
    7c9a:	01 80       	ldd	r0, Z+1	; 0x01
    7c9c:	f2 81       	ldd	r31, Z+2	; 0x02
    7c9e:	e0 2d       	mov	r30, r0
    7ca0:	86 81       	ldd	r24, Z+6	; 0x06
    7ca2:	97 81       	ldd	r25, Z+7	; 0x07
    7ca4:	90 93 56 20 	sts	0x2056, r25	; 0x802056 <pxCurrentTCB+0x1>
    7ca8:	80 93 55 20 	sts	0x2055, r24	; 0x802055 <pxCurrentTCB>
    7cac:	20 93 fb 1f 	sts	0x1FFB, r18	; 0x801ffb <uxTopReadyPriority>
    7cb0:	08 95       	ret

00007cb2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    7cb2:	0f 93       	push	r16
    7cb4:	1f 93       	push	r17
    7cb6:	cf 93       	push	r28
    7cb8:	df 93       	push	r29
    7cba:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    7cbc:	0f b6       	in	r0, 0x3f	; 63
    7cbe:	f8 94       	cli
    7cc0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    7cc2:	89 2b       	or	r24, r25
    7cc4:	21 f4       	brne	.+8      	; 0x7cce <vTaskSuspend+0x1c>
    7cc6:	c0 91 55 20 	lds	r28, 0x2055	; 0x802055 <pxCurrentTCB>
    7cca:	d0 91 56 20 	lds	r29, 0x2056	; 0x802056 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7cce:	8e 01       	movw	r16, r28
    7cd0:	0e 5f       	subi	r16, 0xFE	; 254
    7cd2:	1f 4f       	sbci	r17, 0xFF	; 255
    7cd4:	c8 01       	movw	r24, r16
    7cd6:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    7cda:	8c 89       	ldd	r24, Y+20	; 0x14
    7cdc:	9d 89       	ldd	r25, Y+21	; 0x15
    7cde:	89 2b       	or	r24, r25
    7ce0:	21 f0       	breq	.+8      	; 0x7cea <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    7ce2:	ce 01       	movw	r24, r28
    7ce4:	0c 96       	adiw	r24, 0x0c	; 12
    7ce6:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    7cea:	b8 01       	movw	r22, r16
    7cec:	8f ef       	ldi	r24, 0xFF	; 255
    7cee:	9f e1       	ldi	r25, 0x1F	; 31
    7cf0:	0e 94 d1 2f 	call	0x5fa2	; 0x5fa2 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    7cf4:	8b ad       	ldd	r24, Y+59	; 0x3b
    7cf6:	81 30       	cpi	r24, 0x01	; 1
    7cf8:	09 f4       	brne	.+2      	; 0x7cfc <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    7cfa:	1b ae       	std	Y+59, r1	; 0x3b
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    7cfc:	0f 90       	pop	r0
    7cfe:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    7d00:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xSchedulerRunning>
    7d04:	88 23       	and	r24, r24
    7d06:	39 f0       	breq	.+14     	; 0x7d16 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    7d08:	0f b6       	in	r0, 0x3f	; 63
    7d0a:	f8 94       	cli
    7d0c:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    7d0e:	0e 94 08 36 	call	0x6c10	; 0x6c10 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    7d12:	0f 90       	pop	r0
    7d14:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    7d16:	80 91 55 20 	lds	r24, 0x2055	; 0x802055 <pxCurrentTCB>
    7d1a:	90 91 56 20 	lds	r25, 0x2056	; 0x802056 <pxCurrentTCB+0x1>
    7d1e:	c8 17       	cp	r28, r24
    7d20:	d9 07       	cpc	r29, r25
    7d22:	99 f4       	brne	.+38     	; 0x7d4a <vTaskSuspend+0x98>
		{
			if( xSchedulerRunning != pdFALSE )
    7d24:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xSchedulerRunning>
    7d28:	88 23       	and	r24, r24
    7d2a:	19 f0       	breq	.+6      	; 0x7d32 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    7d2c:	0e 94 fb 30 	call	0x61f6	; 0x61f6 <vPortYield>
    7d30:	0c c0       	rjmp	.+24     	; 0x7d4a <vTaskSuspend+0x98>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    7d32:	90 91 ff 1f 	lds	r25, 0x1FFF	; 0x801fff <xSuspendedTaskList>
    7d36:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <uxCurrentNumberOfTasks>
    7d3a:	98 13       	cpse	r25, r24
    7d3c:	05 c0       	rjmp	.+10     	; 0x7d48 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    7d3e:	10 92 56 20 	sts	0x2056, r1	; 0x802056 <pxCurrentTCB+0x1>
    7d42:	10 92 55 20 	sts	0x2055, r1	; 0x802055 <pxCurrentTCB>
    7d46:	01 c0       	rjmp	.+2      	; 0x7d4a <vTaskSuspend+0x98>
				}
				else
				{
					vTaskSwitchContext();
    7d48:	18 df       	rcall	.-464    	; 0x7b7a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    7d4a:	df 91       	pop	r29
    7d4c:	cf 91       	pop	r28
    7d4e:	1f 91       	pop	r17
    7d50:	0f 91       	pop	r16
    7d52:	08 95       	ret

00007d54 <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    7d54:	fc 01       	movw	r30, r24
    7d56:	73 83       	std	Z+3, r23	; 0x03
    7d58:	62 83       	std	Z+2, r22	; 0x02
    7d5a:	91 87       	std	Z+9, r25	; 0x09
    7d5c:	80 87       	std	Z+8, r24	; 0x08
    7d5e:	46 17       	cp	r20, r22
    7d60:	57 07       	cpc	r21, r23
    7d62:	90 f0       	brcs	.+36     	; 0x7d88 <prvInsertTimerInActiveList+0x34>
    7d64:	42 1b       	sub	r20, r18
    7d66:	53 0b       	sbc	r21, r19
    7d68:	84 85       	ldd	r24, Z+12	; 0x0c
    7d6a:	95 85       	ldd	r25, Z+13	; 0x0d
    7d6c:	48 17       	cp	r20, r24
    7d6e:	59 07       	cpc	r21, r25
    7d70:	e0 f4       	brcc	.+56     	; 0x7daa <prvInsertTimerInActiveList+0x56>
    7d72:	bf 01       	movw	r22, r30
    7d74:	6e 5f       	subi	r22, 0xFE	; 254
    7d76:	7f 4f       	sbci	r23, 0xFF	; 255
    7d78:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <pxOverflowTimerList>
    7d7c:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <pxOverflowTimerList+0x1>
    7d80:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <vListInsert>
    7d84:	80 e0       	ldi	r24, 0x00	; 0
    7d86:	08 95       	ret
    7d88:	42 17       	cp	r20, r18
    7d8a:	53 07       	cpc	r21, r19
    7d8c:	18 f4       	brcc	.+6      	; 0x7d94 <prvInsertTimerInActiveList+0x40>
    7d8e:	62 17       	cp	r22, r18
    7d90:	73 07       	cpc	r23, r19
    7d92:	68 f4       	brcc	.+26     	; 0x7dae <prvInsertTimerInActiveList+0x5a>
    7d94:	bf 01       	movw	r22, r30
    7d96:	6e 5f       	subi	r22, 0xFE	; 254
    7d98:	7f 4f       	sbci	r23, 0xFF	; 255
    7d9a:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <pxCurrentTimerList>
    7d9e:	90 91 60 20 	lds	r25, 0x2060	; 0x802060 <pxCurrentTimerList+0x1>
    7da2:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <vListInsert>
    7da6:	80 e0       	ldi	r24, 0x00	; 0
    7da8:	08 95       	ret
    7daa:	81 e0       	ldi	r24, 0x01	; 1
    7dac:	08 95       	ret
    7dae:	81 e0       	ldi	r24, 0x01	; 1
    7db0:	08 95       	ret

00007db2 <prvCheckForValidListAndQueue>:
    7db2:	0f b6       	in	r0, 0x3f	; 63
    7db4:	f8 94       	cli
    7db6:	0f 92       	push	r0
    7db8:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    7dbc:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    7dc0:	89 2b       	or	r24, r25
    7dc2:	e9 f4       	brne	.+58     	; 0x7dfe <prvCheckForValidListAndQueue+0x4c>
    7dc4:	8a e6       	ldi	r24, 0x6A	; 106
    7dc6:	90 e2       	ldi	r25, 0x20	; 32
    7dc8:	0e 94 bf 2f 	call	0x5f7e	; 0x5f7e <vListInitialise>
    7dcc:	81 e6       	ldi	r24, 0x61	; 97
    7dce:	90 e2       	ldi	r25, 0x20	; 32
    7dd0:	0e 94 bf 2f 	call	0x5f7e	; 0x5f7e <vListInitialise>
    7dd4:	8a e6       	ldi	r24, 0x6A	; 106
    7dd6:	90 e2       	ldi	r25, 0x20	; 32
    7dd8:	90 93 60 20 	sts	0x2060, r25	; 0x802060 <pxCurrentTimerList+0x1>
    7ddc:	80 93 5f 20 	sts	0x205F, r24	; 0x80205f <pxCurrentTimerList>
    7de0:	81 e6       	ldi	r24, 0x61	; 97
    7de2:	90 e2       	ldi	r25, 0x20	; 32
    7de4:	90 93 5e 20 	sts	0x205E, r25	; 0x80205e <pxOverflowTimerList+0x1>
    7de8:	80 93 5d 20 	sts	0x205D, r24	; 0x80205d <pxOverflowTimerList>
    7dec:	40 e0       	ldi	r20, 0x00	; 0
    7dee:	65 e0       	ldi	r22, 0x05	; 5
    7df0:	84 e1       	ldi	r24, 0x14	; 20
    7df2:	0e 94 d2 32 	call	0x65a4	; 0x65a4 <xQueueGenericCreate>
    7df6:	90 93 5c 20 	sts	0x205C, r25	; 0x80205c <xTimerQueue+0x1>
    7dfa:	80 93 5b 20 	sts	0x205B, r24	; 0x80205b <xTimerQueue>
    7dfe:	0f 90       	pop	r0
    7e00:	0f be       	out	0x3f, r0	; 63
    7e02:	08 95       	ret

00007e04 <xTimerCreateTimerTask>:
    7e04:	ef 92       	push	r14
    7e06:	ff 92       	push	r15
    7e08:	0f 93       	push	r16
    7e0a:	d3 df       	rcall	.-90     	; 0x7db2 <prvCheckForValidListAndQueue>
    7e0c:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    7e10:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    7e14:	89 2b       	or	r24, r25
    7e16:	91 f0       	breq	.+36     	; 0x7e3c <xTimerCreateTimerTask+0x38>
    7e18:	0f 2e       	mov	r0, r31
    7e1a:	f9 e5       	ldi	r31, 0x59	; 89
    7e1c:	ef 2e       	mov	r14, r31
    7e1e:	f0 e2       	ldi	r31, 0x20	; 32
    7e20:	ff 2e       	mov	r15, r31
    7e22:	f0 2d       	mov	r31, r0
    7e24:	03 e0       	ldi	r16, 0x03	; 3
    7e26:	20 e0       	ldi	r18, 0x00	; 0
    7e28:	30 e0       	ldi	r19, 0x00	; 0
    7e2a:	48 e7       	ldi	r20, 0x78	; 120
    7e2c:	50 e0       	ldi	r21, 0x00	; 0
    7e2e:	65 e1       	ldi	r22, 0x15	; 21
    7e30:	73 e0       	ldi	r23, 0x03	; 3
    7e32:	88 ed       	ldi	r24, 0xD8	; 216
    7e34:	9f e3       	ldi	r25, 0x3F	; 63
    7e36:	0e 94 af 36 	call	0x6d5e	; 0x6d5e <xTaskCreate>
    7e3a:	01 c0       	rjmp	.+2      	; 0x7e3e <xTimerCreateTimerTask+0x3a>
    7e3c:	80 e0       	ldi	r24, 0x00	; 0
    7e3e:	0f 91       	pop	r16
    7e40:	ff 90       	pop	r15
    7e42:	ef 90       	pop	r14
    7e44:	08 95       	ret

00007e46 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    7e46:	0f 93       	push	r16
    7e48:	1f 93       	push	r17
    7e4a:	cf 93       	push	r28
    7e4c:	df 93       	push	r29
    7e4e:	00 d0       	rcall	.+0      	; 0x7e50 <xTimerGenericCommand+0xa>
    7e50:	1f 92       	push	r1
    7e52:	1f 92       	push	r1
    7e54:	cd b7       	in	r28, 0x3d	; 61
    7e56:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    7e58:	e0 91 5b 20 	lds	r30, 0x205B	; 0x80205b <xTimerQueue>
    7e5c:	f0 91 5c 20 	lds	r31, 0x205C	; 0x80205c <xTimerQueue+0x1>
    7e60:	30 97       	sbiw	r30, 0x00	; 0
    7e62:	69 f1       	breq	.+90     	; 0x7ebe <xTimerGenericCommand+0x78>
    7e64:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    7e66:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    7e68:	5b 83       	std	Y+3, r21	; 0x03
    7e6a:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    7e6c:	9d 83       	std	Y+5, r25	; 0x05
    7e6e:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    7e70:	66 30       	cpi	r22, 0x06	; 6
    7e72:	e4 f4       	brge	.+56     	; 0x7eac <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    7e74:	98 dc       	rcall	.-1744   	; 0x77a6 <xTaskGetSchedulerState>
    7e76:	82 30       	cpi	r24, 0x02	; 2
    7e78:	61 f4       	brne	.+24     	; 0x7e92 <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    7e7a:	20 e0       	ldi	r18, 0x00	; 0
    7e7c:	a8 01       	movw	r20, r16
    7e7e:	be 01       	movw	r22, r28
    7e80:	6f 5f       	subi	r22, 0xFF	; 255
    7e82:	7f 4f       	sbci	r23, 0xFF	; 255
    7e84:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    7e88:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    7e8c:	0e 94 00 33 	call	0x6600	; 0x6600 <xQueueGenericSend>
    7e90:	17 c0       	rjmp	.+46     	; 0x7ec0 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    7e92:	20 e0       	ldi	r18, 0x00	; 0
    7e94:	40 e0       	ldi	r20, 0x00	; 0
    7e96:	50 e0       	ldi	r21, 0x00	; 0
    7e98:	be 01       	movw	r22, r28
    7e9a:	6f 5f       	subi	r22, 0xFF	; 255
    7e9c:	7f 4f       	sbci	r23, 0xFF	; 255
    7e9e:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    7ea2:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    7ea6:	0e 94 00 33 	call	0x6600	; 0x6600 <xQueueGenericSend>
    7eaa:	0a c0       	rjmp	.+20     	; 0x7ec0 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    7eac:	20 e0       	ldi	r18, 0x00	; 0
    7eae:	ad 01       	movw	r20, r26
    7eb0:	be 01       	movw	r22, r28
    7eb2:	6f 5f       	subi	r22, 0xFF	; 255
    7eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    7eb6:	cf 01       	movw	r24, r30
    7eb8:	0e 94 aa 33 	call	0x6754	; 0x6754 <xQueueGenericSendFromISR>
    7ebc:	01 c0       	rjmp	.+2      	; 0x7ec0 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    7ebe:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    7ec0:	0f 90       	pop	r0
    7ec2:	0f 90       	pop	r0
    7ec4:	0f 90       	pop	r0
    7ec6:	0f 90       	pop	r0
    7ec8:	0f 90       	pop	r0
    7eca:	df 91       	pop	r29
    7ecc:	cf 91       	pop	r28
    7ece:	1f 91       	pop	r17
    7ed0:	0f 91       	pop	r16
    7ed2:	08 95       	ret

00007ed4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    7ed4:	af 92       	push	r10
    7ed6:	bf 92       	push	r11
    7ed8:	cf 92       	push	r12
    7eda:	df 92       	push	r13
    7edc:	ef 92       	push	r14
    7ede:	ff 92       	push	r15
    7ee0:	0f 93       	push	r16
    7ee2:	1f 93       	push	r17
    7ee4:	cf 93       	push	r28
    7ee6:	df 93       	push	r29
    7ee8:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    7eea:	19 d9       	rcall	.-3534   	; 0x711e <xTaskGetTickCount>
    7eec:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    7eee:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <xLastTime.2399>
    7ef2:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <xLastTime.2399+0x1>
    7ef6:	e8 16       	cp	r14, r24
    7ef8:	f9 06       	cpc	r15, r25
    7efa:	08 f0       	brcs	.+2      	; 0x7efe <prvSampleTimeNow+0x2a>
    7efc:	47 c0       	rjmp	.+142    	; 0x7f8c <prvSampleTimeNow+0xb8>
    7efe:	2f c0       	rjmp	.+94     	; 0x7f5e <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7f00:	05 80       	ldd	r0, Z+5	; 0x05
    7f02:	f6 81       	ldd	r31, Z+6	; 0x06
    7f04:	e0 2d       	mov	r30, r0
    7f06:	a0 80       	ld	r10, Z
    7f08:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7f0a:	c6 81       	ldd	r28, Z+6	; 0x06
    7f0c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7f0e:	8e 01       	movw	r16, r28
    7f10:	0e 5f       	subi	r16, 0xFE	; 254
    7f12:	1f 4f       	sbci	r17, 0xFF	; 255
    7f14:	c8 01       	movw	r24, r16
    7f16:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    7f1a:	e8 89       	ldd	r30, Y+16	; 0x10
    7f1c:	f9 89       	ldd	r31, Y+17	; 0x11
    7f1e:	ce 01       	movw	r24, r28
    7f20:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    7f22:	8b 89       	ldd	r24, Y+19	; 0x13
    7f24:	82 ff       	sbrs	r24, 2
    7f26:	1b c0       	rjmp	.+54     	; 0x7f5e <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    7f28:	8c 85       	ldd	r24, Y+12	; 0x0c
    7f2a:	9d 85       	ldd	r25, Y+13	; 0x0d
    7f2c:	8a 0d       	add	r24, r10
    7f2e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    7f30:	a8 16       	cp	r10, r24
    7f32:	b9 06       	cpc	r11, r25
    7f34:	60 f4       	brcc	.+24     	; 0x7f4e <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    7f36:	9b 83       	std	Y+3, r25	; 0x03
    7f38:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    7f3a:	d9 87       	std	Y+9, r29	; 0x09
    7f3c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    7f3e:	b8 01       	movw	r22, r16
    7f40:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <pxCurrentTimerList>
    7f44:	90 91 60 20 	lds	r25, 0x2060	; 0x802060 <pxCurrentTimerList+0x1>
    7f48:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <vListInsert>
    7f4c:	08 c0       	rjmp	.+16     	; 0x7f5e <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    7f4e:	00 e0       	ldi	r16, 0x00	; 0
    7f50:	10 e0       	ldi	r17, 0x00	; 0
    7f52:	20 e0       	ldi	r18, 0x00	; 0
    7f54:	30 e0       	ldi	r19, 0x00	; 0
    7f56:	a5 01       	movw	r20, r10
    7f58:	60 e0       	ldi	r22, 0x00	; 0
    7f5a:	ce 01       	movw	r24, r28
    7f5c:	74 df       	rcall	.-280    	; 0x7e46 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    7f5e:	e0 91 5f 20 	lds	r30, 0x205F	; 0x80205f <pxCurrentTimerList>
    7f62:	f0 91 60 20 	lds	r31, 0x2060	; 0x802060 <pxCurrentTimerList+0x1>
    7f66:	80 81       	ld	r24, Z
    7f68:	81 11       	cpse	r24, r1
    7f6a:	ca cf       	rjmp	.-108    	; 0x7f00 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    7f6c:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <pxOverflowTimerList>
    7f70:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <pxOverflowTimerList+0x1>
    7f74:	90 93 60 20 	sts	0x2060, r25	; 0x802060 <pxCurrentTimerList+0x1>
    7f78:	80 93 5f 20 	sts	0x205F, r24	; 0x80205f <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    7f7c:	f0 93 5e 20 	sts	0x205E, r31	; 0x80205e <pxOverflowTimerList+0x1>
    7f80:	e0 93 5d 20 	sts	0x205D, r30	; 0x80205d <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    7f84:	81 e0       	ldi	r24, 0x01	; 1
    7f86:	f6 01       	movw	r30, r12
    7f88:	80 83       	st	Z, r24
    7f8a:	02 c0       	rjmp	.+4      	; 0x7f90 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    7f8c:	f6 01       	movw	r30, r12
    7f8e:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    7f90:	f0 92 58 20 	sts	0x2058, r15	; 0x802058 <xLastTime.2399+0x1>
    7f94:	e0 92 57 20 	sts	0x2057, r14	; 0x802057 <xLastTime.2399>

	return xTimeNow;
}
    7f98:	c7 01       	movw	r24, r14
    7f9a:	df 91       	pop	r29
    7f9c:	cf 91       	pop	r28
    7f9e:	1f 91       	pop	r17
    7fa0:	0f 91       	pop	r16
    7fa2:	ff 90       	pop	r15
    7fa4:	ef 90       	pop	r14
    7fa6:	df 90       	pop	r13
    7fa8:	cf 90       	pop	r12
    7faa:	bf 90       	pop	r11
    7fac:	af 90       	pop	r10
    7fae:	08 95       	ret

00007fb0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    7fb0:	cf 93       	push	r28
    7fb2:	df 93       	push	r29
    7fb4:	00 d0       	rcall	.+0      	; 0x7fb6 <prvTimerTask+0x6>
    7fb6:	00 d0       	rcall	.+0      	; 0x7fb8 <prvTimerTask+0x8>
    7fb8:	cd b7       	in	r28, 0x3d	; 61
    7fba:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    7fbc:	ce 01       	movw	r24, r28
    7fbe:	01 96       	adiw	r24, 0x01	; 1
    7fc0:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    7fc2:	44 24       	eor	r4, r4
    7fc4:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    7fc6:	e1 2c       	mov	r14, r1
    7fc8:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    7fca:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    7fcc:	c8 2e       	mov	r12, r24
    7fce:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    7fd0:	e0 91 5f 20 	lds	r30, 0x205F	; 0x80205f <pxCurrentTimerList>
    7fd4:	f0 91 60 20 	lds	r31, 0x2060	; 0x802060 <pxCurrentTimerList+0x1>
    7fd8:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    7fda:	88 23       	and	r24, r24
    7fdc:	09 f4       	brne	.+2      	; 0x7fe0 <prvTimerTask+0x30>
    7fde:	d1 c0       	rjmp	.+418    	; 0x8182 <prvTimerTask+0x1d2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7fe0:	05 80       	ldd	r0, Z+5	; 0x05
    7fe2:	f6 81       	ldd	r31, Z+6	; 0x06
    7fe4:	e0 2d       	mov	r30, r0
    7fe6:	a0 80       	ld	r10, Z
    7fe8:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    7fea:	93 d8       	rcall	.-3802   	; 0x7112 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    7fec:	c4 01       	movw	r24, r8
    7fee:	72 df       	rcall	.-284    	; 0x7ed4 <prvSampleTimeNow>
    7ff0:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    7ff2:	89 81       	ldd	r24, Y+1	; 0x01
    7ff4:	81 11       	cpse	r24, r1
    7ff6:	47 c0       	rjmp	.+142    	; 0x8086 <prvTimerTask+0xd6>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    7ff8:	0a 15       	cp	r16, r10
    7ffa:	1b 05       	cpc	r17, r11
			{
				( void ) xTaskResumeAll();
    7ffc:	a0 f1       	brcs	.+104    	; 0x8066 <prvTimerTask+0xb6>
    7ffe:	46 d9       	rcall	.-3444   	; 0x728c <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    8000:	e0 91 5f 20 	lds	r30, 0x205F	; 0x80205f <pxCurrentTimerList>
    8004:	f0 91 60 20 	lds	r31, 0x2060	; 0x802060 <pxCurrentTimerList+0x1>
    8008:	05 80       	ldd	r0, Z+5	; 0x05
    800a:	f6 81       	ldd	r31, Z+6	; 0x06
    800c:	e0 2d       	mov	r30, r0
    800e:	66 80       	ldd	r6, Z+6	; 0x06
    8010:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    8012:	c3 01       	movw	r24, r6
    8014:	02 96       	adiw	r24, 0x02	; 2
    8016:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    801a:	d3 01       	movw	r26, r6
    801c:	53 96       	adiw	r26, 0x13	; 19
    801e:	8c 91       	ld	r24, X
    8020:	53 97       	sbiw	r26, 0x13	; 19
    8022:	82 ff       	sbrs	r24, 2
    8024:	15 c0       	rjmp	.+42     	; 0x8050 <prvTimerTask+0xa0>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    8026:	1c 96       	adiw	r26, 0x0c	; 12
    8028:	6d 91       	ld	r22, X+
    802a:	7c 91       	ld	r23, X
    802c:	1d 97       	sbiw	r26, 0x0d	; 13
    802e:	6a 0d       	add	r22, r10
    8030:	7b 1d       	adc	r23, r11
    8032:	95 01       	movw	r18, r10
    8034:	a8 01       	movw	r20, r16
    8036:	c3 01       	movw	r24, r6
    8038:	8d de       	rcall	.-742    	; 0x7d54 <prvInsertTimerInActiveList>
    803a:	88 23       	and	r24, r24
    803c:	61 f0       	breq	.+24     	; 0x8056 <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    803e:	0e 2d       	mov	r16, r14
    8040:	1f 2d       	mov	r17, r15
    8042:	2e 2d       	mov	r18, r14
    8044:	3f 2d       	mov	r19, r15
    8046:	a5 01       	movw	r20, r10
    8048:	65 2d       	mov	r22, r5
    804a:	c3 01       	movw	r24, r6
    804c:	fc de       	rcall	.-520    	; 0x7e46 <xTimerGenericCommand>
    804e:	03 c0       	rjmp	.+6      	; 0x8056 <prvTimerTask+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8050:	8e 7f       	andi	r24, 0xFE	; 254
    8052:	f3 01       	movw	r30, r6
    8054:	83 8b       	std	Z+19, r24	; 0x13
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    8056:	d3 01       	movw	r26, r6
    8058:	50 96       	adiw	r26, 0x10	; 16
    805a:	ed 91       	ld	r30, X+
    805c:	fc 91       	ld	r31, X
    805e:	51 97       	sbiw	r26, 0x11	; 17
    8060:	c3 01       	movw	r24, r6
    8062:	19 95       	eicall
    8064:	81 c0       	rjmp	.+258    	; 0x8168 <prvTimerTask+0x1b8>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    8066:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    8068:	b5 01       	movw	r22, r10
    806a:	60 1b       	sub	r22, r16
    806c:	71 0b       	sbc	r23, r17
    806e:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    8072:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    8076:	0e 94 64 35 	call	0x6ac8	; 0x6ac8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    807a:	08 d9       	rcall	.-3568   	; 0x728c <xTaskResumeAll>
    807c:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    807e:	74 c0       	rjmp	.+232    	; 0x8168 <prvTimerTask+0x1b8>
    8080:	0e 94 fb 30 	call	0x61f6	; 0x61f6 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    8084:	71 c0       	rjmp	.+226    	; 0x8168 <prvTimerTask+0x1b8>
    8086:	02 d9       	rcall	.-3580   	; 0x728c <xTaskResumeAll>
    8088:	6f c0       	rjmp	.+222    	; 0x8168 <prvTimerTask+0x1b8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    808a:	89 81       	ldd	r24, Y+1	; 0x01
    808c:	88 23       	and	r24, r24
    808e:	0c f4       	brge	.+2      	; 0x8092 <prvTimerTask+0xe2>
    8090:	6b c0       	rjmp	.+214    	; 0x8168 <prvTimerTask+0x1b8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    8092:	ac 80       	ldd	r10, Y+4	; 0x04
    8094:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    8096:	f5 01       	movw	r30, r10
    8098:	82 85       	ldd	r24, Z+10	; 0x0a
    809a:	93 85       	ldd	r25, Z+11	; 0x0b
    809c:	89 2b       	or	r24, r25
    809e:	21 f0       	breq	.+8      	; 0x80a8 <prvTimerTask+0xf8>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    80a0:	c5 01       	movw	r24, r10
    80a2:	02 96       	adiw	r24, 0x02	; 2
    80a4:	0e 94 23 30 	call	0x6046	; 0x6046 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    80a8:	ce 01       	movw	r24, r28
    80aa:	06 96       	adiw	r24, 0x06	; 6
    80ac:	13 df       	rcall	.-474    	; 0x7ed4 <prvSampleTimeNow>
    80ae:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    80b0:	e9 81       	ldd	r30, Y+1	; 0x01
    80b2:	0e 2e       	mov	r0, r30
    80b4:	00 0c       	add	r0, r0
    80b6:	ff 0b       	sbc	r31, r31
    80b8:	ea 30       	cpi	r30, 0x0A	; 10
    80ba:	f1 05       	cpc	r31, r1
    80bc:	08 f0       	brcs	.+2      	; 0x80c0 <prvTimerTask+0x110>
    80be:	54 c0       	rjmp	.+168    	; 0x8168 <prvTimerTask+0x1b8>
    80c0:	88 27       	eor	r24, r24
    80c2:	eb 53       	subi	r30, 0x3B	; 59
    80c4:	ff 4f       	sbci	r31, 0xFF	; 255
    80c6:	8f 4f       	sbci	r24, 0xFF	; 255
    80c8:	b1 c1       	rjmp	.+866    	; 0x842c <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    80ca:	d5 01       	movw	r26, r10
    80cc:	53 96       	adiw	r26, 0x13	; 19
    80ce:	8c 91       	ld	r24, X
    80d0:	53 97       	sbiw	r26, 0x13	; 19
    80d2:	81 60       	ori	r24, 0x01	; 1
    80d4:	53 96       	adiw	r26, 0x13	; 19
    80d6:	8c 93       	st	X, r24
    80d8:	53 97       	sbiw	r26, 0x13	; 19
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    80da:	2a 81       	ldd	r18, Y+2	; 0x02
    80dc:	3b 81       	ldd	r19, Y+3	; 0x03
    80de:	1c 96       	adiw	r26, 0x0c	; 12
    80e0:	6d 91       	ld	r22, X+
    80e2:	7c 91       	ld	r23, X
    80e4:	1d 97       	sbiw	r26, 0x0d	; 13
    80e6:	62 0f       	add	r22, r18
    80e8:	73 1f       	adc	r23, r19
    80ea:	c5 01       	movw	r24, r10
    80ec:	33 de       	rcall	.-922    	; 0x7d54 <prvInsertTimerInActiveList>
    80ee:	88 23       	and	r24, r24
    80f0:	d9 f1       	breq	.+118    	; 0x8168 <prvTimerTask+0x1b8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    80f2:	d5 01       	movw	r26, r10
    80f4:	50 96       	adiw	r26, 0x10	; 16
    80f6:	ed 91       	ld	r30, X+
    80f8:	fc 91       	ld	r31, X
    80fa:	51 97       	sbiw	r26, 0x11	; 17
    80fc:	c5 01       	movw	r24, r10
    80fe:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    8100:	f5 01       	movw	r30, r10
    8102:	83 89       	ldd	r24, Z+19	; 0x13
    8104:	82 ff       	sbrs	r24, 2
    8106:	30 c0       	rjmp	.+96     	; 0x8168 <prvTimerTask+0x1b8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    8108:	4a 81       	ldd	r20, Y+2	; 0x02
    810a:	5b 81       	ldd	r21, Y+3	; 0x03
    810c:	84 85       	ldd	r24, Z+12	; 0x0c
    810e:	95 85       	ldd	r25, Z+13	; 0x0d
    8110:	48 0f       	add	r20, r24
    8112:	59 1f       	adc	r21, r25
    8114:	0e 2d       	mov	r16, r14
    8116:	1f 2d       	mov	r17, r15
    8118:	2e 2d       	mov	r18, r14
    811a:	3f 2d       	mov	r19, r15
    811c:	65 2d       	mov	r22, r5
    811e:	c5 01       	movw	r24, r10
    8120:	92 de       	rcall	.-732    	; 0x7e46 <xTimerGenericCommand>
    8122:	22 c0       	rjmp	.+68     	; 0x8168 <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8124:	d5 01       	movw	r26, r10
    8126:	53 96       	adiw	r26, 0x13	; 19
    8128:	8c 91       	ld	r24, X
    812a:	53 97       	sbiw	r26, 0x13	; 19
    812c:	8e 7f       	andi	r24, 0xFE	; 254
    812e:	53 96       	adiw	r26, 0x13	; 19
    8130:	8c 93       	st	X, r24
    8132:	1a c0       	rjmp	.+52     	; 0x8168 <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    8134:	f5 01       	movw	r30, r10
    8136:	83 89       	ldd	r24, Z+19	; 0x13
    8138:	81 60       	ori	r24, 0x01	; 1
    813a:	83 8b       	std	Z+19, r24	; 0x13
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    813c:	6a 81       	ldd	r22, Y+2	; 0x02
    813e:	7b 81       	ldd	r23, Y+3	; 0x03
    8140:	75 87       	std	Z+13, r23	; 0x0d
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    8142:	64 87       	std	Z+12, r22	; 0x0c
    8144:	64 0f       	add	r22, r20
    8146:	75 1f       	adc	r23, r21
    8148:	9a 01       	movw	r18, r20
    814a:	c5 01       	movw	r24, r10
    814c:	03 de       	rcall	.-1018   	; 0x7d54 <prvInsertTimerInActiveList>
    814e:	0c c0       	rjmp	.+24     	; 0x8168 <prvTimerTask+0x1b8>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    8150:	d5 01       	movw	r26, r10
    8152:	53 96       	adiw	r26, 0x13	; 19
    8154:	8c 91       	ld	r24, X
    8156:	81 fd       	sbrc	r24, 1
    8158:	04 c0       	rjmp	.+8      	; 0x8162 <prvTimerTask+0x1b2>
						{
							vPortFree( pxTimer );
    815a:	c5 01       	movw	r24, r10
    815c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <vPortFree>
    8160:	03 c0       	rjmp	.+6      	; 0x8168 <prvTimerTask+0x1b8>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8162:	8e 7f       	andi	r24, 0xFE	; 254
    8164:	f5 01       	movw	r30, r10
    8166:	83 8b       	std	Z+19, r24	; 0x13
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    8168:	4e 2d       	mov	r20, r14
    816a:	5f 2d       	mov	r21, r15
    816c:	6c 2d       	mov	r22, r12
    816e:	7d 2d       	mov	r23, r13
    8170:	80 91 5b 20 	lds	r24, 0x205B	; 0x80205b <xTimerQueue>
    8174:	90 91 5c 20 	lds	r25, 0x205C	; 0x80205c <xTimerQueue+0x1>
    8178:	0e 94 e2 33 	call	0x67c4	; 0x67c4 <xQueueReceive>
    817c:	81 11       	cpse	r24, r1
    817e:	85 cf       	rjmp	.-246    	; 0x808a <prvTimerTask+0xda>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    8180:	27 cf       	rjmp	.-434    	; 0x7fd0 <prvTimerTask+0x20>
    8182:	0e 94 89 38 	call	0x7112	; 0x7112 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    8186:	c4 01       	movw	r24, r8
    8188:	a5 de       	rcall	.-694    	; 0x7ed4 <prvSampleTimeNow>
    818a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    818c:	89 81       	ldd	r24, Y+1	; 0x01
    818e:	81 11       	cpse	r24, r1
    8190:	7a cf       	rjmp	.-268    	; 0x8086 <prvTimerTask+0xd6>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    8192:	e0 91 5d 20 	lds	r30, 0x205D	; 0x80205d <pxOverflowTimerList>
    8196:	f0 91 5e 20 	lds	r31, 0x205E	; 0x80205e <pxOverflowTimerList+0x1>
    819a:	80 81       	ld	r24, Z
    819c:	44 2d       	mov	r20, r4
    819e:	81 11       	cpse	r24, r1
    81a0:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    81a2:	ae 2c       	mov	r10, r14
    81a4:	bf 2c       	mov	r11, r15
    81a6:	60 cf       	rjmp	.-320    	; 0x8068 <prvTimerTask+0xb8>

000081a8 <__floatunsisf>:
    81a8:	e8 94       	clt
    81aa:	09 c0       	rjmp	.+18     	; 0x81be <__floatsisf+0x12>

000081ac <__floatsisf>:
    81ac:	97 fb       	bst	r25, 7
    81ae:	3e f4       	brtc	.+14     	; 0x81be <__floatsisf+0x12>
    81b0:	90 95       	com	r25
    81b2:	80 95       	com	r24
    81b4:	70 95       	com	r23
    81b6:	61 95       	neg	r22
    81b8:	7f 4f       	sbci	r23, 0xFF	; 255
    81ba:	8f 4f       	sbci	r24, 0xFF	; 255
    81bc:	9f 4f       	sbci	r25, 0xFF	; 255
    81be:	99 23       	and	r25, r25
    81c0:	a9 f0       	breq	.+42     	; 0x81ec <__floatsisf+0x40>
    81c2:	f9 2f       	mov	r31, r25
    81c4:	96 e9       	ldi	r25, 0x96	; 150
    81c6:	bb 27       	eor	r27, r27
    81c8:	93 95       	inc	r25
    81ca:	f6 95       	lsr	r31
    81cc:	87 95       	ror	r24
    81ce:	77 95       	ror	r23
    81d0:	67 95       	ror	r22
    81d2:	b7 95       	ror	r27
    81d4:	f1 11       	cpse	r31, r1
    81d6:	f8 cf       	rjmp	.-16     	; 0x81c8 <__floatsisf+0x1c>
    81d8:	fa f4       	brpl	.+62     	; 0x8218 <__floatsisf+0x6c>
    81da:	bb 0f       	add	r27, r27
    81dc:	11 f4       	brne	.+4      	; 0x81e2 <__floatsisf+0x36>
    81de:	60 ff       	sbrs	r22, 0
    81e0:	1b c0       	rjmp	.+54     	; 0x8218 <__floatsisf+0x6c>
    81e2:	6f 5f       	subi	r22, 0xFF	; 255
    81e4:	7f 4f       	sbci	r23, 0xFF	; 255
    81e6:	8f 4f       	sbci	r24, 0xFF	; 255
    81e8:	9f 4f       	sbci	r25, 0xFF	; 255
    81ea:	16 c0       	rjmp	.+44     	; 0x8218 <__floatsisf+0x6c>
    81ec:	88 23       	and	r24, r24
    81ee:	11 f0       	breq	.+4      	; 0x81f4 <__floatsisf+0x48>
    81f0:	96 e9       	ldi	r25, 0x96	; 150
    81f2:	11 c0       	rjmp	.+34     	; 0x8216 <__floatsisf+0x6a>
    81f4:	77 23       	and	r23, r23
    81f6:	21 f0       	breq	.+8      	; 0x8200 <__floatsisf+0x54>
    81f8:	9e e8       	ldi	r25, 0x8E	; 142
    81fa:	87 2f       	mov	r24, r23
    81fc:	76 2f       	mov	r23, r22
    81fe:	05 c0       	rjmp	.+10     	; 0x820a <__floatsisf+0x5e>
    8200:	66 23       	and	r22, r22
    8202:	71 f0       	breq	.+28     	; 0x8220 <__floatsisf+0x74>
    8204:	96 e8       	ldi	r25, 0x86	; 134
    8206:	86 2f       	mov	r24, r22
    8208:	70 e0       	ldi	r23, 0x00	; 0
    820a:	60 e0       	ldi	r22, 0x00	; 0
    820c:	2a f0       	brmi	.+10     	; 0x8218 <__floatsisf+0x6c>
    820e:	9a 95       	dec	r25
    8210:	66 0f       	add	r22, r22
    8212:	77 1f       	adc	r23, r23
    8214:	88 1f       	adc	r24, r24
    8216:	da f7       	brpl	.-10     	; 0x820e <__floatsisf+0x62>
    8218:	88 0f       	add	r24, r24
    821a:	96 95       	lsr	r25
    821c:	87 95       	ror	r24
    821e:	97 f9       	bld	r25, 7
    8220:	08 95       	ret

00008222 <__mulsf3>:
    8222:	0b d0       	rcall	.+22     	; 0x823a <__mulsf3x>
    8224:	78 c0       	rjmp	.+240    	; 0x8316 <__fp_round>
    8226:	69 d0       	rcall	.+210    	; 0x82fa <__fp_pscA>
    8228:	28 f0       	brcs	.+10     	; 0x8234 <__mulsf3+0x12>
    822a:	6e d0       	rcall	.+220    	; 0x8308 <__fp_pscB>
    822c:	18 f0       	brcs	.+6      	; 0x8234 <__mulsf3+0x12>
    822e:	95 23       	and	r25, r21
    8230:	09 f0       	breq	.+2      	; 0x8234 <__mulsf3+0x12>
    8232:	5a c0       	rjmp	.+180    	; 0x82e8 <__fp_inf>
    8234:	5f c0       	rjmp	.+190    	; 0x82f4 <__fp_nan>
    8236:	11 24       	eor	r1, r1
    8238:	a2 c0       	rjmp	.+324    	; 0x837e <__fp_szero>

0000823a <__mulsf3x>:
    823a:	7e d0       	rcall	.+252    	; 0x8338 <__fp_split3>
    823c:	a0 f3       	brcs	.-24     	; 0x8226 <__mulsf3+0x4>

0000823e <__mulsf3_pse>:
    823e:	95 9f       	mul	r25, r21
    8240:	d1 f3       	breq	.-12     	; 0x8236 <__mulsf3+0x14>
    8242:	95 0f       	add	r25, r21
    8244:	50 e0       	ldi	r21, 0x00	; 0
    8246:	55 1f       	adc	r21, r21
    8248:	62 9f       	mul	r22, r18
    824a:	f0 01       	movw	r30, r0
    824c:	72 9f       	mul	r23, r18
    824e:	bb 27       	eor	r27, r27
    8250:	f0 0d       	add	r31, r0
    8252:	b1 1d       	adc	r27, r1
    8254:	63 9f       	mul	r22, r19
    8256:	aa 27       	eor	r26, r26
    8258:	f0 0d       	add	r31, r0
    825a:	b1 1d       	adc	r27, r1
    825c:	aa 1f       	adc	r26, r26
    825e:	64 9f       	mul	r22, r20
    8260:	66 27       	eor	r22, r22
    8262:	b0 0d       	add	r27, r0
    8264:	a1 1d       	adc	r26, r1
    8266:	66 1f       	adc	r22, r22
    8268:	82 9f       	mul	r24, r18
    826a:	22 27       	eor	r18, r18
    826c:	b0 0d       	add	r27, r0
    826e:	a1 1d       	adc	r26, r1
    8270:	62 1f       	adc	r22, r18
    8272:	73 9f       	mul	r23, r19
    8274:	b0 0d       	add	r27, r0
    8276:	a1 1d       	adc	r26, r1
    8278:	62 1f       	adc	r22, r18
    827a:	83 9f       	mul	r24, r19
    827c:	a0 0d       	add	r26, r0
    827e:	61 1d       	adc	r22, r1
    8280:	22 1f       	adc	r18, r18
    8282:	74 9f       	mul	r23, r20
    8284:	33 27       	eor	r19, r19
    8286:	a0 0d       	add	r26, r0
    8288:	61 1d       	adc	r22, r1
    828a:	23 1f       	adc	r18, r19
    828c:	84 9f       	mul	r24, r20
    828e:	60 0d       	add	r22, r0
    8290:	21 1d       	adc	r18, r1
    8292:	82 2f       	mov	r24, r18
    8294:	76 2f       	mov	r23, r22
    8296:	6a 2f       	mov	r22, r26
    8298:	11 24       	eor	r1, r1
    829a:	9f 57       	subi	r25, 0x7F	; 127
    829c:	50 40       	sbci	r21, 0x00	; 0
    829e:	8a f0       	brmi	.+34     	; 0x82c2 <__mulsf3_pse+0x84>
    82a0:	e1 f0       	breq	.+56     	; 0x82da <__mulsf3_pse+0x9c>
    82a2:	88 23       	and	r24, r24
    82a4:	4a f0       	brmi	.+18     	; 0x82b8 <__mulsf3_pse+0x7a>
    82a6:	ee 0f       	add	r30, r30
    82a8:	ff 1f       	adc	r31, r31
    82aa:	bb 1f       	adc	r27, r27
    82ac:	66 1f       	adc	r22, r22
    82ae:	77 1f       	adc	r23, r23
    82b0:	88 1f       	adc	r24, r24
    82b2:	91 50       	subi	r25, 0x01	; 1
    82b4:	50 40       	sbci	r21, 0x00	; 0
    82b6:	a9 f7       	brne	.-22     	; 0x82a2 <__mulsf3_pse+0x64>
    82b8:	9e 3f       	cpi	r25, 0xFE	; 254
    82ba:	51 05       	cpc	r21, r1
    82bc:	70 f0       	brcs	.+28     	; 0x82da <__mulsf3_pse+0x9c>
    82be:	14 c0       	rjmp	.+40     	; 0x82e8 <__fp_inf>
    82c0:	5e c0       	rjmp	.+188    	; 0x837e <__fp_szero>
    82c2:	5f 3f       	cpi	r21, 0xFF	; 255
    82c4:	ec f3       	brlt	.-6      	; 0x82c0 <__mulsf3_pse+0x82>
    82c6:	98 3e       	cpi	r25, 0xE8	; 232
    82c8:	dc f3       	brlt	.-10     	; 0x82c0 <__mulsf3_pse+0x82>
    82ca:	86 95       	lsr	r24
    82cc:	77 95       	ror	r23
    82ce:	67 95       	ror	r22
    82d0:	b7 95       	ror	r27
    82d2:	f7 95       	ror	r31
    82d4:	e7 95       	ror	r30
    82d6:	9f 5f       	subi	r25, 0xFF	; 255
    82d8:	c1 f7       	brne	.-16     	; 0x82ca <__mulsf3_pse+0x8c>
    82da:	fe 2b       	or	r31, r30
    82dc:	88 0f       	add	r24, r24
    82de:	91 1d       	adc	r25, r1
    82e0:	96 95       	lsr	r25
    82e2:	87 95       	ror	r24
    82e4:	97 f9       	bld	r25, 7
    82e6:	08 95       	ret

000082e8 <__fp_inf>:
    82e8:	97 f9       	bld	r25, 7
    82ea:	9f 67       	ori	r25, 0x7F	; 127
    82ec:	80 e8       	ldi	r24, 0x80	; 128
    82ee:	70 e0       	ldi	r23, 0x00	; 0
    82f0:	60 e0       	ldi	r22, 0x00	; 0
    82f2:	08 95       	ret

000082f4 <__fp_nan>:
    82f4:	9f ef       	ldi	r25, 0xFF	; 255
    82f6:	80 ec       	ldi	r24, 0xC0	; 192
    82f8:	08 95       	ret

000082fa <__fp_pscA>:
    82fa:	00 24       	eor	r0, r0
    82fc:	0a 94       	dec	r0
    82fe:	16 16       	cp	r1, r22
    8300:	17 06       	cpc	r1, r23
    8302:	18 06       	cpc	r1, r24
    8304:	09 06       	cpc	r0, r25
    8306:	08 95       	ret

00008308 <__fp_pscB>:
    8308:	00 24       	eor	r0, r0
    830a:	0a 94       	dec	r0
    830c:	12 16       	cp	r1, r18
    830e:	13 06       	cpc	r1, r19
    8310:	14 06       	cpc	r1, r20
    8312:	05 06       	cpc	r0, r21
    8314:	08 95       	ret

00008316 <__fp_round>:
    8316:	09 2e       	mov	r0, r25
    8318:	03 94       	inc	r0
    831a:	00 0c       	add	r0, r0
    831c:	11 f4       	brne	.+4      	; 0x8322 <__fp_round+0xc>
    831e:	88 23       	and	r24, r24
    8320:	52 f0       	brmi	.+20     	; 0x8336 <__fp_round+0x20>
    8322:	bb 0f       	add	r27, r27
    8324:	40 f4       	brcc	.+16     	; 0x8336 <__fp_round+0x20>
    8326:	bf 2b       	or	r27, r31
    8328:	11 f4       	brne	.+4      	; 0x832e <__fp_round+0x18>
    832a:	60 ff       	sbrs	r22, 0
    832c:	04 c0       	rjmp	.+8      	; 0x8336 <__fp_round+0x20>
    832e:	6f 5f       	subi	r22, 0xFF	; 255
    8330:	7f 4f       	sbci	r23, 0xFF	; 255
    8332:	8f 4f       	sbci	r24, 0xFF	; 255
    8334:	9f 4f       	sbci	r25, 0xFF	; 255
    8336:	08 95       	ret

00008338 <__fp_split3>:
    8338:	57 fd       	sbrc	r21, 7
    833a:	90 58       	subi	r25, 0x80	; 128
    833c:	44 0f       	add	r20, r20
    833e:	55 1f       	adc	r21, r21
    8340:	59 f0       	breq	.+22     	; 0x8358 <__fp_splitA+0x10>
    8342:	5f 3f       	cpi	r21, 0xFF	; 255
    8344:	71 f0       	breq	.+28     	; 0x8362 <__fp_splitA+0x1a>
    8346:	47 95       	ror	r20

00008348 <__fp_splitA>:
    8348:	88 0f       	add	r24, r24
    834a:	97 fb       	bst	r25, 7
    834c:	99 1f       	adc	r25, r25
    834e:	61 f0       	breq	.+24     	; 0x8368 <__fp_splitA+0x20>
    8350:	9f 3f       	cpi	r25, 0xFF	; 255
    8352:	79 f0       	breq	.+30     	; 0x8372 <__fp_splitA+0x2a>
    8354:	87 95       	ror	r24
    8356:	08 95       	ret
    8358:	12 16       	cp	r1, r18
    835a:	13 06       	cpc	r1, r19
    835c:	14 06       	cpc	r1, r20
    835e:	55 1f       	adc	r21, r21
    8360:	f2 cf       	rjmp	.-28     	; 0x8346 <__fp_split3+0xe>
    8362:	46 95       	lsr	r20
    8364:	f1 df       	rcall	.-30     	; 0x8348 <__fp_splitA>
    8366:	08 c0       	rjmp	.+16     	; 0x8378 <__fp_splitA+0x30>
    8368:	16 16       	cp	r1, r22
    836a:	17 06       	cpc	r1, r23
    836c:	18 06       	cpc	r1, r24
    836e:	99 1f       	adc	r25, r25
    8370:	f1 cf       	rjmp	.-30     	; 0x8354 <__fp_splitA+0xc>
    8372:	86 95       	lsr	r24
    8374:	71 05       	cpc	r23, r1
    8376:	61 05       	cpc	r22, r1
    8378:	08 94       	sec
    837a:	08 95       	ret

0000837c <__fp_zero>:
    837c:	e8 94       	clt

0000837e <__fp_szero>:
    837e:	bb 27       	eor	r27, r27
    8380:	66 27       	eor	r22, r22
    8382:	77 27       	eor	r23, r23
    8384:	cb 01       	movw	r24, r22
    8386:	97 f9       	bld	r25, 7
    8388:	08 95       	ret

0000838a <__divmodhi4>:
    838a:	97 fb       	bst	r25, 7
    838c:	07 2e       	mov	r0, r23
    838e:	16 f4       	brtc	.+4      	; 0x8394 <__divmodhi4+0xa>
    8390:	00 94       	com	r0
    8392:	06 d0       	rcall	.+12     	; 0x83a0 <__divmodhi4_neg1>
    8394:	77 fd       	sbrc	r23, 7
    8396:	08 d0       	rcall	.+16     	; 0x83a8 <__divmodhi4_neg2>
    8398:	60 d0       	rcall	.+192    	; 0x845a <__udivmodhi4>
    839a:	07 fc       	sbrc	r0, 7
    839c:	05 d0       	rcall	.+10     	; 0x83a8 <__divmodhi4_neg2>
    839e:	3e f4       	brtc	.+14     	; 0x83ae <__divmodhi4_exit>

000083a0 <__divmodhi4_neg1>:
    83a0:	90 95       	com	r25
    83a2:	81 95       	neg	r24
    83a4:	9f 4f       	sbci	r25, 0xFF	; 255
    83a6:	08 95       	ret

000083a8 <__divmodhi4_neg2>:
    83a8:	70 95       	com	r23
    83aa:	61 95       	neg	r22
    83ac:	7f 4f       	sbci	r23, 0xFF	; 255

000083ae <__divmodhi4_exit>:
    83ae:	08 95       	ret

000083b0 <__udivmodsi4>:
    83b0:	a1 e2       	ldi	r26, 0x21	; 33
    83b2:	1a 2e       	mov	r1, r26
    83b4:	aa 1b       	sub	r26, r26
    83b6:	bb 1b       	sub	r27, r27
    83b8:	fd 01       	movw	r30, r26
    83ba:	0d c0       	rjmp	.+26     	; 0x83d6 <__udivmodsi4_ep>

000083bc <__udivmodsi4_loop>:
    83bc:	aa 1f       	adc	r26, r26
    83be:	bb 1f       	adc	r27, r27
    83c0:	ee 1f       	adc	r30, r30
    83c2:	ff 1f       	adc	r31, r31
    83c4:	a2 17       	cp	r26, r18
    83c6:	b3 07       	cpc	r27, r19
    83c8:	e4 07       	cpc	r30, r20
    83ca:	f5 07       	cpc	r31, r21
    83cc:	20 f0       	brcs	.+8      	; 0x83d6 <__udivmodsi4_ep>
    83ce:	a2 1b       	sub	r26, r18
    83d0:	b3 0b       	sbc	r27, r19
    83d2:	e4 0b       	sbc	r30, r20
    83d4:	f5 0b       	sbc	r31, r21

000083d6 <__udivmodsi4_ep>:
    83d6:	66 1f       	adc	r22, r22
    83d8:	77 1f       	adc	r23, r23
    83da:	88 1f       	adc	r24, r24
    83dc:	99 1f       	adc	r25, r25
    83de:	1a 94       	dec	r1
    83e0:	69 f7       	brne	.-38     	; 0x83bc <__udivmodsi4_loop>
    83e2:	60 95       	com	r22
    83e4:	70 95       	com	r23
    83e6:	80 95       	com	r24
    83e8:	90 95       	com	r25
    83ea:	9b 01       	movw	r18, r22
    83ec:	ac 01       	movw	r20, r24
    83ee:	bd 01       	movw	r22, r26
    83f0:	cf 01       	movw	r24, r30
    83f2:	08 95       	ret

000083f4 <__divmodsi4>:
    83f4:	05 2e       	mov	r0, r21
    83f6:	97 fb       	bst	r25, 7
    83f8:	16 f4       	brtc	.+4      	; 0x83fe <__divmodsi4+0xa>
    83fa:	00 94       	com	r0
    83fc:	0f d0       	rcall	.+30     	; 0x841c <__negsi2>
    83fe:	57 fd       	sbrc	r21, 7
    8400:	05 d0       	rcall	.+10     	; 0x840c <__divmodsi4_neg2>
    8402:	d6 df       	rcall	.-84     	; 0x83b0 <__udivmodsi4>
    8404:	07 fc       	sbrc	r0, 7
    8406:	02 d0       	rcall	.+4      	; 0x840c <__divmodsi4_neg2>
    8408:	46 f4       	brtc	.+16     	; 0x841a <__divmodsi4_exit>
    840a:	08 c0       	rjmp	.+16     	; 0x841c <__negsi2>

0000840c <__divmodsi4_neg2>:
    840c:	50 95       	com	r21
    840e:	40 95       	com	r20
    8410:	30 95       	com	r19
    8412:	21 95       	neg	r18
    8414:	3f 4f       	sbci	r19, 0xFF	; 255
    8416:	4f 4f       	sbci	r20, 0xFF	; 255
    8418:	5f 4f       	sbci	r21, 0xFF	; 255

0000841a <__divmodsi4_exit>:
    841a:	08 95       	ret

0000841c <__negsi2>:
    841c:	90 95       	com	r25
    841e:	80 95       	com	r24
    8420:	70 95       	com	r23
    8422:	61 95       	neg	r22
    8424:	7f 4f       	sbci	r23, 0xFF	; 255
    8426:	8f 4f       	sbci	r24, 0xFF	; 255
    8428:	9f 4f       	sbci	r25, 0xFF	; 255
    842a:	08 95       	ret

0000842c <__tablejump2__>:
    842c:	ee 0f       	add	r30, r30
    842e:	ff 1f       	adc	r31, r31
    8430:	88 1f       	adc	r24, r24
    8432:	8b bf       	out	0x3b, r24	; 59
    8434:	07 90       	elpm	r0, Z+
    8436:	f6 91       	elpm	r31, Z
    8438:	e0 2d       	mov	r30, r0
    843a:	19 94       	eijmp

0000843c <__umulhisi3>:
    843c:	a2 9f       	mul	r26, r18
    843e:	b0 01       	movw	r22, r0
    8440:	b3 9f       	mul	r27, r19
    8442:	c0 01       	movw	r24, r0
    8444:	a3 9f       	mul	r26, r19
    8446:	70 0d       	add	r23, r0
    8448:	81 1d       	adc	r24, r1
    844a:	11 24       	eor	r1, r1
    844c:	91 1d       	adc	r25, r1
    844e:	b2 9f       	mul	r27, r18
    8450:	70 0d       	add	r23, r0
    8452:	81 1d       	adc	r24, r1
    8454:	11 24       	eor	r1, r1
    8456:	91 1d       	adc	r25, r1
    8458:	08 95       	ret

0000845a <__udivmodhi4>:
    845a:	aa 1b       	sub	r26, r26
    845c:	bb 1b       	sub	r27, r27
    845e:	51 e1       	ldi	r21, 0x11	; 17
    8460:	07 c0       	rjmp	.+14     	; 0x8470 <__udivmodhi4_ep>

00008462 <__udivmodhi4_loop>:
    8462:	aa 1f       	adc	r26, r26
    8464:	bb 1f       	adc	r27, r27
    8466:	a6 17       	cp	r26, r22
    8468:	b7 07       	cpc	r27, r23
    846a:	10 f0       	brcs	.+4      	; 0x8470 <__udivmodhi4_ep>
    846c:	a6 1b       	sub	r26, r22
    846e:	b7 0b       	sbc	r27, r23

00008470 <__udivmodhi4_ep>:
    8470:	88 1f       	adc	r24, r24
    8472:	99 1f       	adc	r25, r25
    8474:	5a 95       	dec	r21
    8476:	a9 f7       	brne	.-22     	; 0x8462 <__udivmodhi4_loop>
    8478:	80 95       	com	r24
    847a:	90 95       	com	r25
    847c:	bc 01       	movw	r22, r24
    847e:	cd 01       	movw	r24, r26
    8480:	08 95       	ret

00008482 <do_rand>:
    8482:	8f 92       	push	r8
    8484:	9f 92       	push	r9
    8486:	af 92       	push	r10
    8488:	bf 92       	push	r11
    848a:	cf 92       	push	r12
    848c:	df 92       	push	r13
    848e:	ef 92       	push	r14
    8490:	ff 92       	push	r15
    8492:	cf 93       	push	r28
    8494:	df 93       	push	r29
    8496:	ec 01       	movw	r28, r24
    8498:	68 81       	ld	r22, Y
    849a:	79 81       	ldd	r23, Y+1	; 0x01
    849c:	8a 81       	ldd	r24, Y+2	; 0x02
    849e:	9b 81       	ldd	r25, Y+3	; 0x03
    84a0:	61 15       	cp	r22, r1
    84a2:	71 05       	cpc	r23, r1
    84a4:	81 05       	cpc	r24, r1
    84a6:	91 05       	cpc	r25, r1
    84a8:	21 f4       	brne	.+8      	; 0x84b2 <do_rand+0x30>
    84aa:	64 e2       	ldi	r22, 0x24	; 36
    84ac:	79 ed       	ldi	r23, 0xD9	; 217
    84ae:	8b e5       	ldi	r24, 0x5B	; 91
    84b0:	97 e0       	ldi	r25, 0x07	; 7
    84b2:	2d e1       	ldi	r18, 0x1D	; 29
    84b4:	33 ef       	ldi	r19, 0xF3	; 243
    84b6:	41 e0       	ldi	r20, 0x01	; 1
    84b8:	50 e0       	ldi	r21, 0x00	; 0
    84ba:	9c df       	rcall	.-200    	; 0x83f4 <__divmodsi4>
    84bc:	49 01       	movw	r8, r18
    84be:	5a 01       	movw	r10, r20
    84c0:	9b 01       	movw	r18, r22
    84c2:	ac 01       	movw	r20, r24
    84c4:	a7 ea       	ldi	r26, 0xA7	; 167
    84c6:	b1 e4       	ldi	r27, 0x41	; 65
    84c8:	86 d5       	rcall	.+2828   	; 0x8fd6 <__muluhisi3>
    84ca:	6b 01       	movw	r12, r22
    84cc:	7c 01       	movw	r14, r24
    84ce:	ac ee       	ldi	r26, 0xEC	; 236
    84d0:	b4 ef       	ldi	r27, 0xF4	; 244
    84d2:	a5 01       	movw	r20, r10
    84d4:	94 01       	movw	r18, r8
    84d6:	8b d5       	rcall	.+2838   	; 0x8fee <__mulohisi3>
    84d8:	dc 01       	movw	r26, r24
    84da:	cb 01       	movw	r24, r22
    84dc:	8c 0d       	add	r24, r12
    84de:	9d 1d       	adc	r25, r13
    84e0:	ae 1d       	adc	r26, r14
    84e2:	bf 1d       	adc	r27, r15
    84e4:	b7 ff       	sbrs	r27, 7
    84e6:	03 c0       	rjmp	.+6      	; 0x84ee <do_rand+0x6c>
    84e8:	01 97       	sbiw	r24, 0x01	; 1
    84ea:	a1 09       	sbc	r26, r1
    84ec:	b0 48       	sbci	r27, 0x80	; 128
    84ee:	88 83       	st	Y, r24
    84f0:	99 83       	std	Y+1, r25	; 0x01
    84f2:	aa 83       	std	Y+2, r26	; 0x02
    84f4:	bb 83       	std	Y+3, r27	; 0x03
    84f6:	9f 77       	andi	r25, 0x7F	; 127
    84f8:	df 91       	pop	r29
    84fa:	cf 91       	pop	r28
    84fc:	ff 90       	pop	r15
    84fe:	ef 90       	pop	r14
    8500:	df 90       	pop	r13
    8502:	cf 90       	pop	r12
    8504:	bf 90       	pop	r11
    8506:	af 90       	pop	r10
    8508:	9f 90       	pop	r9
    850a:	8f 90       	pop	r8
    850c:	08 95       	ret

0000850e <rand_r>:
    850e:	b9 cf       	rjmp	.-142    	; 0x8482 <do_rand>

00008510 <rand>:
    8510:	80 e0       	ldi	r24, 0x00	; 0
    8512:	92 e0       	ldi	r25, 0x02	; 2
    8514:	b6 cf       	rjmp	.-148    	; 0x8482 <do_rand>

00008516 <srand>:
    8516:	a0 e0       	ldi	r26, 0x00	; 0
    8518:	b0 e0       	ldi	r27, 0x00	; 0
    851a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    851e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    8522:	a0 93 02 02 	sts	0x0202, r26	; 0x800202 <__DATA_REGION_ORIGIN__+0x2>
    8526:	b0 93 03 02 	sts	0x0203, r27	; 0x800203 <__DATA_REGION_ORIGIN__+0x3>
    852a:	08 95       	ret

0000852c <memcmp>:
    852c:	fb 01       	movw	r30, r22
    852e:	dc 01       	movw	r26, r24
    8530:	04 c0       	rjmp	.+8      	; 0x853a <memcmp+0xe>
    8532:	8d 91       	ld	r24, X+
    8534:	01 90       	ld	r0, Z+
    8536:	80 19       	sub	r24, r0
    8538:	21 f4       	brne	.+8      	; 0x8542 <memcmp+0x16>
    853a:	41 50       	subi	r20, 0x01	; 1
    853c:	50 40       	sbci	r21, 0x00	; 0
    853e:	c8 f7       	brcc	.-14     	; 0x8532 <memcmp+0x6>
    8540:	88 1b       	sub	r24, r24
    8542:	99 0b       	sbc	r25, r25
    8544:	08 95       	ret

00008546 <memcpy>:
    8546:	fb 01       	movw	r30, r22
    8548:	dc 01       	movw	r26, r24
    854a:	02 c0       	rjmp	.+4      	; 0x8550 <memcpy+0xa>
    854c:	01 90       	ld	r0, Z+
    854e:	0d 92       	st	X+, r0
    8550:	41 50       	subi	r20, 0x01	; 1
    8552:	50 40       	sbci	r21, 0x00	; 0
    8554:	d8 f7       	brcc	.-10     	; 0x854c <memcpy+0x6>
    8556:	08 95       	ret

00008558 <memset>:
    8558:	dc 01       	movw	r26, r24
    855a:	01 c0       	rjmp	.+2      	; 0x855e <memset+0x6>
    855c:	6d 93       	st	X+, r22
    855e:	41 50       	subi	r20, 0x01	; 1
    8560:	50 40       	sbci	r21, 0x00	; 0
    8562:	e0 f7       	brcc	.-8      	; 0x855c <memset+0x4>
    8564:	08 95       	ret

00008566 <strcpy>:
    8566:	fb 01       	movw	r30, r22
    8568:	dc 01       	movw	r26, r24
    856a:	01 90       	ld	r0, Z+
    856c:	0d 92       	st	X+, r0
    856e:	00 20       	and	r0, r0
    8570:	e1 f7       	brne	.-8      	; 0x856a <strcpy+0x4>
    8572:	08 95       	ret

00008574 <strncmp>:
    8574:	fb 01       	movw	r30, r22
    8576:	dc 01       	movw	r26, r24
    8578:	41 50       	subi	r20, 0x01	; 1
    857a:	50 40       	sbci	r21, 0x00	; 0
    857c:	30 f0       	brcs	.+12     	; 0x858a <strncmp+0x16>
    857e:	8d 91       	ld	r24, X+
    8580:	01 90       	ld	r0, Z+
    8582:	80 19       	sub	r24, r0
    8584:	19 f4       	brne	.+6      	; 0x858c <strncmp+0x18>
    8586:	00 20       	and	r0, r0
    8588:	b9 f7       	brne	.-18     	; 0x8578 <strncmp+0x4>
    858a:	88 1b       	sub	r24, r24
    858c:	99 0b       	sbc	r25, r25
    858e:	08 95       	ret

00008590 <strncpy>:
    8590:	fb 01       	movw	r30, r22
    8592:	dc 01       	movw	r26, r24
    8594:	41 50       	subi	r20, 0x01	; 1
    8596:	50 40       	sbci	r21, 0x00	; 0
    8598:	48 f0       	brcs	.+18     	; 0x85ac <strncpy+0x1c>
    859a:	01 90       	ld	r0, Z+
    859c:	0d 92       	st	X+, r0
    859e:	00 20       	and	r0, r0
    85a0:	c9 f7       	brne	.-14     	; 0x8594 <strncpy+0x4>
    85a2:	01 c0       	rjmp	.+2      	; 0x85a6 <strncpy+0x16>
    85a4:	1d 92       	st	X+, r1
    85a6:	41 50       	subi	r20, 0x01	; 1
    85a8:	50 40       	sbci	r21, 0x00	; 0
    85aa:	e0 f7       	brcc	.-8      	; 0x85a4 <strncpy+0x14>
    85ac:	08 95       	ret

000085ae <strnlen>:
    85ae:	fc 01       	movw	r30, r24
    85b0:	61 50       	subi	r22, 0x01	; 1
    85b2:	70 40       	sbci	r23, 0x00	; 0
    85b4:	01 90       	ld	r0, Z+
    85b6:	01 10       	cpse	r0, r1
    85b8:	d8 f7       	brcc	.-10     	; 0x85b0 <strnlen+0x2>
    85ba:	80 95       	com	r24
    85bc:	90 95       	com	r25
    85be:	8e 0f       	add	r24, r30
    85c0:	9f 1f       	adc	r25, r31
    85c2:	08 95       	ret

000085c4 <fdevopen>:
    85c4:	0f 93       	push	r16
    85c6:	1f 93       	push	r17
    85c8:	cf 93       	push	r28
    85ca:	df 93       	push	r29
    85cc:	00 97       	sbiw	r24, 0x00	; 0
    85ce:	31 f4       	brne	.+12     	; 0x85dc <fdevopen+0x18>
    85d0:	61 15       	cp	r22, r1
    85d2:	71 05       	cpc	r23, r1
    85d4:	19 f4       	brne	.+6      	; 0x85dc <fdevopen+0x18>
    85d6:	80 e0       	ldi	r24, 0x00	; 0
    85d8:	90 e0       	ldi	r25, 0x00	; 0
    85da:	39 c0       	rjmp	.+114    	; 0x864e <fdevopen+0x8a>
    85dc:	8b 01       	movw	r16, r22
    85de:	ec 01       	movw	r28, r24
    85e0:	6e e0       	ldi	r22, 0x0E	; 14
    85e2:	70 e0       	ldi	r23, 0x00	; 0
    85e4:	81 e0       	ldi	r24, 0x01	; 1
    85e6:	90 e0       	ldi	r25, 0x00	; 0
    85e8:	16 d3       	rcall	.+1580   	; 0x8c16 <calloc>
    85ea:	fc 01       	movw	r30, r24
    85ec:	89 2b       	or	r24, r25
    85ee:	99 f3       	breq	.-26     	; 0x85d6 <fdevopen+0x12>
    85f0:	80 e8       	ldi	r24, 0x80	; 128
    85f2:	83 83       	std	Z+3, r24	; 0x03
    85f4:	01 15       	cp	r16, r1
    85f6:	11 05       	cpc	r17, r1
    85f8:	71 f0       	breq	.+28     	; 0x8616 <fdevopen+0x52>
    85fa:	13 87       	std	Z+11, r17	; 0x0b
    85fc:	02 87       	std	Z+10, r16	; 0x0a
    85fe:	81 e8       	ldi	r24, 0x81	; 129
    8600:	83 83       	std	Z+3, r24	; 0x03
    8602:	80 91 73 20 	lds	r24, 0x2073	; 0x802073 <__iob>
    8606:	90 91 74 20 	lds	r25, 0x2074	; 0x802074 <__iob+0x1>
    860a:	89 2b       	or	r24, r25
    860c:	21 f4       	brne	.+8      	; 0x8616 <fdevopen+0x52>
    860e:	f0 93 74 20 	sts	0x2074, r31	; 0x802074 <__iob+0x1>
    8612:	e0 93 73 20 	sts	0x2073, r30	; 0x802073 <__iob>
    8616:	20 97       	sbiw	r28, 0x00	; 0
    8618:	c9 f0       	breq	.+50     	; 0x864c <fdevopen+0x88>
    861a:	d1 87       	std	Z+9, r29	; 0x09
    861c:	c0 87       	std	Z+8, r28	; 0x08
    861e:	83 81       	ldd	r24, Z+3	; 0x03
    8620:	82 60       	ori	r24, 0x02	; 2
    8622:	83 83       	std	Z+3, r24	; 0x03
    8624:	80 91 75 20 	lds	r24, 0x2075	; 0x802075 <__iob+0x2>
    8628:	90 91 76 20 	lds	r25, 0x2076	; 0x802076 <__iob+0x3>
    862c:	89 2b       	or	r24, r25
    862e:	71 f4       	brne	.+28     	; 0x864c <fdevopen+0x88>
    8630:	f0 93 76 20 	sts	0x2076, r31	; 0x802076 <__iob+0x3>
    8634:	e0 93 75 20 	sts	0x2075, r30	; 0x802075 <__iob+0x2>
    8638:	80 91 77 20 	lds	r24, 0x2077	; 0x802077 <__iob+0x4>
    863c:	90 91 78 20 	lds	r25, 0x2078	; 0x802078 <__iob+0x5>
    8640:	89 2b       	or	r24, r25
    8642:	21 f4       	brne	.+8      	; 0x864c <fdevopen+0x88>
    8644:	f0 93 78 20 	sts	0x2078, r31	; 0x802078 <__iob+0x5>
    8648:	e0 93 77 20 	sts	0x2077, r30	; 0x802077 <__iob+0x4>
    864c:	cf 01       	movw	r24, r30
    864e:	df 91       	pop	r29
    8650:	cf 91       	pop	r28
    8652:	1f 91       	pop	r17
    8654:	0f 91       	pop	r16
    8656:	08 95       	ret

00008658 <printf>:
    8658:	cf 93       	push	r28
    865a:	df 93       	push	r29
    865c:	cd b7       	in	r28, 0x3d	; 61
    865e:	de b7       	in	r29, 0x3e	; 62
    8660:	ae 01       	movw	r20, r28
    8662:	4a 5f       	subi	r20, 0xFA	; 250
    8664:	5f 4f       	sbci	r21, 0xFF	; 255
    8666:	fa 01       	movw	r30, r20
    8668:	61 91       	ld	r22, Z+
    866a:	71 91       	ld	r23, Z+
    866c:	af 01       	movw	r20, r30
    866e:	80 91 75 20 	lds	r24, 0x2075	; 0x802075 <__iob+0x2>
    8672:	90 91 76 20 	lds	r25, 0x2076	; 0x802076 <__iob+0x3>
    8676:	d2 d0       	rcall	.+420    	; 0x881c <vfprintf>
    8678:	df 91       	pop	r29
    867a:	cf 91       	pop	r28
    867c:	08 95       	ret

0000867e <printf_P>:
    867e:	0f 93       	push	r16
    8680:	1f 93       	push	r17
    8682:	cf 93       	push	r28
    8684:	df 93       	push	r29
    8686:	cd b7       	in	r28, 0x3d	; 61
    8688:	de b7       	in	r29, 0x3e	; 62
    868a:	ae 01       	movw	r20, r28
    868c:	48 5f       	subi	r20, 0xF8	; 248
    868e:	5f 4f       	sbci	r21, 0xFF	; 255
    8690:	da 01       	movw	r26, r20
    8692:	6d 91       	ld	r22, X+
    8694:	7d 91       	ld	r23, X+
    8696:	ad 01       	movw	r20, r26
    8698:	03 e7       	ldi	r16, 0x73	; 115
    869a:	10 e2       	ldi	r17, 0x20	; 32
    869c:	f8 01       	movw	r30, r16
    869e:	82 81       	ldd	r24, Z+2	; 0x02
    86a0:	93 81       	ldd	r25, Z+3	; 0x03
    86a2:	dc 01       	movw	r26, r24
    86a4:	13 96       	adiw	r26, 0x03	; 3
    86a6:	2c 91       	ld	r18, X
    86a8:	13 97       	sbiw	r26, 0x03	; 3
    86aa:	28 60       	ori	r18, 0x08	; 8
    86ac:	13 96       	adiw	r26, 0x03	; 3
    86ae:	2c 93       	st	X, r18
    86b0:	b5 d0       	rcall	.+362    	; 0x881c <vfprintf>
    86b2:	d8 01       	movw	r26, r16
    86b4:	12 96       	adiw	r26, 0x02	; 2
    86b6:	ed 91       	ld	r30, X+
    86b8:	fc 91       	ld	r31, X
    86ba:	13 97       	sbiw	r26, 0x03	; 3
    86bc:	23 81       	ldd	r18, Z+3	; 0x03
    86be:	27 7f       	andi	r18, 0xF7	; 247
    86c0:	23 83       	std	Z+3, r18	; 0x03
    86c2:	df 91       	pop	r29
    86c4:	cf 91       	pop	r28
    86c6:	1f 91       	pop	r17
    86c8:	0f 91       	pop	r16
    86ca:	08 95       	ret

000086cc <puts>:
    86cc:	0f 93       	push	r16
    86ce:	1f 93       	push	r17
    86d0:	cf 93       	push	r28
    86d2:	df 93       	push	r29
    86d4:	e0 91 75 20 	lds	r30, 0x2075	; 0x802075 <__iob+0x2>
    86d8:	f0 91 76 20 	lds	r31, 0x2076	; 0x802076 <__iob+0x3>
    86dc:	23 81       	ldd	r18, Z+3	; 0x03
    86de:	21 ff       	sbrs	r18, 1
    86e0:	1b c0       	rjmp	.+54     	; 0x8718 <puts+0x4c>
    86e2:	8c 01       	movw	r16, r24
    86e4:	d0 e0       	ldi	r29, 0x00	; 0
    86e6:	c0 e0       	ldi	r28, 0x00	; 0
    86e8:	f8 01       	movw	r30, r16
    86ea:	81 91       	ld	r24, Z+
    86ec:	8f 01       	movw	r16, r30
    86ee:	60 91 75 20 	lds	r22, 0x2075	; 0x802075 <__iob+0x2>
    86f2:	70 91 76 20 	lds	r23, 0x2076	; 0x802076 <__iob+0x3>
    86f6:	db 01       	movw	r26, r22
    86f8:	18 96       	adiw	r26, 0x08	; 8
    86fa:	ed 91       	ld	r30, X+
    86fc:	fc 91       	ld	r31, X
    86fe:	19 97       	sbiw	r26, 0x09	; 9
    8700:	88 23       	and	r24, r24
    8702:	31 f0       	breq	.+12     	; 0x8710 <puts+0x44>
    8704:	19 95       	eicall
    8706:	89 2b       	or	r24, r25
    8708:	79 f3       	breq	.-34     	; 0x86e8 <puts+0x1c>
    870a:	df ef       	ldi	r29, 0xFF	; 255
    870c:	cf ef       	ldi	r28, 0xFF	; 255
    870e:	ec cf       	rjmp	.-40     	; 0x86e8 <puts+0x1c>
    8710:	8a e0       	ldi	r24, 0x0A	; 10
    8712:	19 95       	eicall
    8714:	89 2b       	or	r24, r25
    8716:	19 f0       	breq	.+6      	; 0x871e <puts+0x52>
    8718:	8f ef       	ldi	r24, 0xFF	; 255
    871a:	9f ef       	ldi	r25, 0xFF	; 255
    871c:	02 c0       	rjmp	.+4      	; 0x8722 <puts+0x56>
    871e:	8d 2f       	mov	r24, r29
    8720:	9c 2f       	mov	r25, r28
    8722:	df 91       	pop	r29
    8724:	cf 91       	pop	r28
    8726:	1f 91       	pop	r17
    8728:	0f 91       	pop	r16
    872a:	08 95       	ret

0000872c <snprintf_P>:
    872c:	0f 93       	push	r16
    872e:	1f 93       	push	r17
    8730:	cf 93       	push	r28
    8732:	df 93       	push	r29
    8734:	cd b7       	in	r28, 0x3d	; 61
    8736:	de b7       	in	r29, 0x3e	; 62
    8738:	2e 97       	sbiw	r28, 0x0e	; 14
    873a:	0f b6       	in	r0, 0x3f	; 63
    873c:	f8 94       	cli
    873e:	de bf       	out	0x3e, r29	; 62
    8740:	0f be       	out	0x3f, r0	; 63
    8742:	cd bf       	out	0x3d, r28	; 61
    8744:	0e 89       	ldd	r16, Y+22	; 0x16
    8746:	1f 89       	ldd	r17, Y+23	; 0x17
    8748:	88 8d       	ldd	r24, Y+24	; 0x18
    874a:	99 8d       	ldd	r25, Y+25	; 0x19
    874c:	2e e0       	ldi	r18, 0x0E	; 14
    874e:	2c 83       	std	Y+4, r18	; 0x04
    8750:	1a 83       	std	Y+2, r17	; 0x02
    8752:	09 83       	std	Y+1, r16	; 0x01
    8754:	97 ff       	sbrs	r25, 7
    8756:	02 c0       	rjmp	.+4      	; 0x875c <snprintf_P+0x30>
    8758:	80 e0       	ldi	r24, 0x00	; 0
    875a:	90 e8       	ldi	r25, 0x80	; 128
    875c:	01 97       	sbiw	r24, 0x01	; 1
    875e:	9e 83       	std	Y+6, r25	; 0x06
    8760:	8d 83       	std	Y+5, r24	; 0x05
    8762:	ae 01       	movw	r20, r28
    8764:	44 5e       	subi	r20, 0xE4	; 228
    8766:	5f 4f       	sbci	r21, 0xFF	; 255
    8768:	6a 8d       	ldd	r22, Y+26	; 0x1a
    876a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    876c:	ce 01       	movw	r24, r28
    876e:	01 96       	adiw	r24, 0x01	; 1
    8770:	55 d0       	rcall	.+170    	; 0x881c <vfprintf>
    8772:	4d 81       	ldd	r20, Y+5	; 0x05
    8774:	5e 81       	ldd	r21, Y+6	; 0x06
    8776:	57 fd       	sbrc	r21, 7
    8778:	0a c0       	rjmp	.+20     	; 0x878e <snprintf_P+0x62>
    877a:	2f 81       	ldd	r18, Y+7	; 0x07
    877c:	38 85       	ldd	r19, Y+8	; 0x08
    877e:	42 17       	cp	r20, r18
    8780:	53 07       	cpc	r21, r19
    8782:	0c f4       	brge	.+2      	; 0x8786 <snprintf_P+0x5a>
    8784:	9a 01       	movw	r18, r20
    8786:	f8 01       	movw	r30, r16
    8788:	e2 0f       	add	r30, r18
    878a:	f3 1f       	adc	r31, r19
    878c:	10 82       	st	Z, r1
    878e:	2e 96       	adiw	r28, 0x0e	; 14
    8790:	0f b6       	in	r0, 0x3f	; 63
    8792:	f8 94       	cli
    8794:	de bf       	out	0x3e, r29	; 62
    8796:	0f be       	out	0x3f, r0	; 63
    8798:	cd bf       	out	0x3d, r28	; 61
    879a:	df 91       	pop	r29
    879c:	cf 91       	pop	r28
    879e:	1f 91       	pop	r17
    87a0:	0f 91       	pop	r16
    87a2:	08 95       	ret

000087a4 <sprintf>:
    87a4:	0f 93       	push	r16
    87a6:	1f 93       	push	r17
    87a8:	cf 93       	push	r28
    87aa:	df 93       	push	r29
    87ac:	cd b7       	in	r28, 0x3d	; 61
    87ae:	de b7       	in	r29, 0x3e	; 62
    87b0:	2e 97       	sbiw	r28, 0x0e	; 14
    87b2:	0f b6       	in	r0, 0x3f	; 63
    87b4:	f8 94       	cli
    87b6:	de bf       	out	0x3e, r29	; 62
    87b8:	0f be       	out	0x3f, r0	; 63
    87ba:	cd bf       	out	0x3d, r28	; 61
    87bc:	0e 89       	ldd	r16, Y+22	; 0x16
    87be:	1f 89       	ldd	r17, Y+23	; 0x17
    87c0:	86 e0       	ldi	r24, 0x06	; 6
    87c2:	8c 83       	std	Y+4, r24	; 0x04
    87c4:	1a 83       	std	Y+2, r17	; 0x02
    87c6:	09 83       	std	Y+1, r16	; 0x01
    87c8:	8f ef       	ldi	r24, 0xFF	; 255
    87ca:	9f e7       	ldi	r25, 0x7F	; 127
    87cc:	9e 83       	std	Y+6, r25	; 0x06
    87ce:	8d 83       	std	Y+5, r24	; 0x05
    87d0:	ae 01       	movw	r20, r28
    87d2:	46 5e       	subi	r20, 0xE6	; 230
    87d4:	5f 4f       	sbci	r21, 0xFF	; 255
    87d6:	68 8d       	ldd	r22, Y+24	; 0x18
    87d8:	79 8d       	ldd	r23, Y+25	; 0x19
    87da:	ce 01       	movw	r24, r28
    87dc:	01 96       	adiw	r24, 0x01	; 1
    87de:	1e d0       	rcall	.+60     	; 0x881c <vfprintf>
    87e0:	ef 81       	ldd	r30, Y+7	; 0x07
    87e2:	f8 85       	ldd	r31, Y+8	; 0x08
    87e4:	e0 0f       	add	r30, r16
    87e6:	f1 1f       	adc	r31, r17
    87e8:	10 82       	st	Z, r1
    87ea:	2e 96       	adiw	r28, 0x0e	; 14
    87ec:	0f b6       	in	r0, 0x3f	; 63
    87ee:	f8 94       	cli
    87f0:	de bf       	out	0x3e, r29	; 62
    87f2:	0f be       	out	0x3f, r0	; 63
    87f4:	cd bf       	out	0x3d, r28	; 61
    87f6:	df 91       	pop	r29
    87f8:	cf 91       	pop	r28
    87fa:	1f 91       	pop	r17
    87fc:	0f 91       	pop	r16
    87fe:	08 95       	ret

00008800 <vfprintf_P>:
    8800:	cf 93       	push	r28
    8802:	df 93       	push	r29
    8804:	ec 01       	movw	r28, r24
    8806:	8b 81       	ldd	r24, Y+3	; 0x03
    8808:	88 60       	ori	r24, 0x08	; 8
    880a:	8b 83       	std	Y+3, r24	; 0x03
    880c:	ce 01       	movw	r24, r28
    880e:	06 d0       	rcall	.+12     	; 0x881c <vfprintf>
    8810:	2b 81       	ldd	r18, Y+3	; 0x03
    8812:	27 7f       	andi	r18, 0xF7	; 247
    8814:	2b 83       	std	Y+3, r18	; 0x03
    8816:	df 91       	pop	r29
    8818:	cf 91       	pop	r28
    881a:	08 95       	ret

0000881c <vfprintf>:
    881c:	2f 92       	push	r2
    881e:	3f 92       	push	r3
    8820:	4f 92       	push	r4
    8822:	5f 92       	push	r5
    8824:	6f 92       	push	r6
    8826:	7f 92       	push	r7
    8828:	8f 92       	push	r8
    882a:	9f 92       	push	r9
    882c:	af 92       	push	r10
    882e:	bf 92       	push	r11
    8830:	cf 92       	push	r12
    8832:	df 92       	push	r13
    8834:	ef 92       	push	r14
    8836:	ff 92       	push	r15
    8838:	0f 93       	push	r16
    883a:	1f 93       	push	r17
    883c:	cf 93       	push	r28
    883e:	df 93       	push	r29
    8840:	cd b7       	in	r28, 0x3d	; 61
    8842:	de b7       	in	r29, 0x3e	; 62
    8844:	2b 97       	sbiw	r28, 0x0b	; 11
    8846:	0f b6       	in	r0, 0x3f	; 63
    8848:	f8 94       	cli
    884a:	de bf       	out	0x3e, r29	; 62
    884c:	0f be       	out	0x3f, r0	; 63
    884e:	cd bf       	out	0x3d, r28	; 61
    8850:	6c 01       	movw	r12, r24
    8852:	7b 01       	movw	r14, r22
    8854:	8a 01       	movw	r16, r20
    8856:	fc 01       	movw	r30, r24
    8858:	17 82       	std	Z+7, r1	; 0x07
    885a:	16 82       	std	Z+6, r1	; 0x06
    885c:	83 81       	ldd	r24, Z+3	; 0x03
    885e:	81 ff       	sbrs	r24, 1
    8860:	bf c1       	rjmp	.+894    	; 0x8be0 <vfprintf+0x3c4>
    8862:	ce 01       	movw	r24, r28
    8864:	01 96       	adiw	r24, 0x01	; 1
    8866:	3c 01       	movw	r6, r24
    8868:	f6 01       	movw	r30, r12
    886a:	93 81       	ldd	r25, Z+3	; 0x03
    886c:	f7 01       	movw	r30, r14
    886e:	93 fd       	sbrc	r25, 3
    8870:	85 91       	lpm	r24, Z+
    8872:	93 ff       	sbrs	r25, 3
    8874:	81 91       	ld	r24, Z+
    8876:	7f 01       	movw	r14, r30
    8878:	88 23       	and	r24, r24
    887a:	09 f4       	brne	.+2      	; 0x887e <vfprintf+0x62>
    887c:	ad c1       	rjmp	.+858    	; 0x8bd8 <vfprintf+0x3bc>
    887e:	85 32       	cpi	r24, 0x25	; 37
    8880:	39 f4       	brne	.+14     	; 0x8890 <vfprintf+0x74>
    8882:	93 fd       	sbrc	r25, 3
    8884:	85 91       	lpm	r24, Z+
    8886:	93 ff       	sbrs	r25, 3
    8888:	81 91       	ld	r24, Z+
    888a:	7f 01       	movw	r14, r30
    888c:	85 32       	cpi	r24, 0x25	; 37
    888e:	21 f4       	brne	.+8      	; 0x8898 <vfprintf+0x7c>
    8890:	b6 01       	movw	r22, r12
    8892:	90 e0       	ldi	r25, 0x00	; 0
    8894:	06 d3       	rcall	.+1548   	; 0x8ea2 <fputc>
    8896:	e8 cf       	rjmp	.-48     	; 0x8868 <vfprintf+0x4c>
    8898:	91 2c       	mov	r9, r1
    889a:	21 2c       	mov	r2, r1
    889c:	31 2c       	mov	r3, r1
    889e:	ff e1       	ldi	r31, 0x1F	; 31
    88a0:	f3 15       	cp	r31, r3
    88a2:	d8 f0       	brcs	.+54     	; 0x88da <vfprintf+0xbe>
    88a4:	8b 32       	cpi	r24, 0x2B	; 43
    88a6:	79 f0       	breq	.+30     	; 0x88c6 <vfprintf+0xaa>
    88a8:	38 f4       	brcc	.+14     	; 0x88b8 <vfprintf+0x9c>
    88aa:	80 32       	cpi	r24, 0x20	; 32
    88ac:	79 f0       	breq	.+30     	; 0x88cc <vfprintf+0xb0>
    88ae:	83 32       	cpi	r24, 0x23	; 35
    88b0:	a1 f4       	brne	.+40     	; 0x88da <vfprintf+0xbe>
    88b2:	23 2d       	mov	r18, r3
    88b4:	20 61       	ori	r18, 0x10	; 16
    88b6:	1d c0       	rjmp	.+58     	; 0x88f2 <vfprintf+0xd6>
    88b8:	8d 32       	cpi	r24, 0x2D	; 45
    88ba:	61 f0       	breq	.+24     	; 0x88d4 <vfprintf+0xb8>
    88bc:	80 33       	cpi	r24, 0x30	; 48
    88be:	69 f4       	brne	.+26     	; 0x88da <vfprintf+0xbe>
    88c0:	23 2d       	mov	r18, r3
    88c2:	21 60       	ori	r18, 0x01	; 1
    88c4:	16 c0       	rjmp	.+44     	; 0x88f2 <vfprintf+0xd6>
    88c6:	83 2d       	mov	r24, r3
    88c8:	82 60       	ori	r24, 0x02	; 2
    88ca:	38 2e       	mov	r3, r24
    88cc:	e3 2d       	mov	r30, r3
    88ce:	e4 60       	ori	r30, 0x04	; 4
    88d0:	3e 2e       	mov	r3, r30
    88d2:	2a c0       	rjmp	.+84     	; 0x8928 <vfprintf+0x10c>
    88d4:	f3 2d       	mov	r31, r3
    88d6:	f8 60       	ori	r31, 0x08	; 8
    88d8:	1d c0       	rjmp	.+58     	; 0x8914 <vfprintf+0xf8>
    88da:	37 fc       	sbrc	r3, 7
    88dc:	2d c0       	rjmp	.+90     	; 0x8938 <vfprintf+0x11c>
    88de:	20 ed       	ldi	r18, 0xD0	; 208
    88e0:	28 0f       	add	r18, r24
    88e2:	2a 30       	cpi	r18, 0x0A	; 10
    88e4:	40 f0       	brcs	.+16     	; 0x88f6 <vfprintf+0xda>
    88e6:	8e 32       	cpi	r24, 0x2E	; 46
    88e8:	b9 f4       	brne	.+46     	; 0x8918 <vfprintf+0xfc>
    88ea:	36 fc       	sbrc	r3, 6
    88ec:	75 c1       	rjmp	.+746    	; 0x8bd8 <vfprintf+0x3bc>
    88ee:	23 2d       	mov	r18, r3
    88f0:	20 64       	ori	r18, 0x40	; 64
    88f2:	32 2e       	mov	r3, r18
    88f4:	19 c0       	rjmp	.+50     	; 0x8928 <vfprintf+0x10c>
    88f6:	36 fe       	sbrs	r3, 6
    88f8:	06 c0       	rjmp	.+12     	; 0x8906 <vfprintf+0xea>
    88fa:	8a e0       	ldi	r24, 0x0A	; 10
    88fc:	98 9e       	mul	r9, r24
    88fe:	20 0d       	add	r18, r0
    8900:	11 24       	eor	r1, r1
    8902:	92 2e       	mov	r9, r18
    8904:	11 c0       	rjmp	.+34     	; 0x8928 <vfprintf+0x10c>
    8906:	ea e0       	ldi	r30, 0x0A	; 10
    8908:	2e 9e       	mul	r2, r30
    890a:	20 0d       	add	r18, r0
    890c:	11 24       	eor	r1, r1
    890e:	22 2e       	mov	r2, r18
    8910:	f3 2d       	mov	r31, r3
    8912:	f0 62       	ori	r31, 0x20	; 32
    8914:	3f 2e       	mov	r3, r31
    8916:	08 c0       	rjmp	.+16     	; 0x8928 <vfprintf+0x10c>
    8918:	8c 36       	cpi	r24, 0x6C	; 108
    891a:	21 f4       	brne	.+8      	; 0x8924 <vfprintf+0x108>
    891c:	83 2d       	mov	r24, r3
    891e:	80 68       	ori	r24, 0x80	; 128
    8920:	38 2e       	mov	r3, r24
    8922:	02 c0       	rjmp	.+4      	; 0x8928 <vfprintf+0x10c>
    8924:	88 36       	cpi	r24, 0x68	; 104
    8926:	41 f4       	brne	.+16     	; 0x8938 <vfprintf+0x11c>
    8928:	f7 01       	movw	r30, r14
    892a:	93 fd       	sbrc	r25, 3
    892c:	85 91       	lpm	r24, Z+
    892e:	93 ff       	sbrs	r25, 3
    8930:	81 91       	ld	r24, Z+
    8932:	7f 01       	movw	r14, r30
    8934:	81 11       	cpse	r24, r1
    8936:	b3 cf       	rjmp	.-154    	; 0x889e <vfprintf+0x82>
    8938:	98 2f       	mov	r25, r24
    893a:	9f 7d       	andi	r25, 0xDF	; 223
    893c:	95 54       	subi	r25, 0x45	; 69
    893e:	93 30       	cpi	r25, 0x03	; 3
    8940:	28 f4       	brcc	.+10     	; 0x894c <vfprintf+0x130>
    8942:	0c 5f       	subi	r16, 0xFC	; 252
    8944:	1f 4f       	sbci	r17, 0xFF	; 255
    8946:	9f e3       	ldi	r25, 0x3F	; 63
    8948:	99 83       	std	Y+1, r25	; 0x01
    894a:	0d c0       	rjmp	.+26     	; 0x8966 <vfprintf+0x14a>
    894c:	83 36       	cpi	r24, 0x63	; 99
    894e:	31 f0       	breq	.+12     	; 0x895c <vfprintf+0x140>
    8950:	83 37       	cpi	r24, 0x73	; 115
    8952:	71 f0       	breq	.+28     	; 0x8970 <vfprintf+0x154>
    8954:	83 35       	cpi	r24, 0x53	; 83
    8956:	09 f0       	breq	.+2      	; 0x895a <vfprintf+0x13e>
    8958:	55 c0       	rjmp	.+170    	; 0x8a04 <vfprintf+0x1e8>
    895a:	20 c0       	rjmp	.+64     	; 0x899c <vfprintf+0x180>
    895c:	f8 01       	movw	r30, r16
    895e:	80 81       	ld	r24, Z
    8960:	89 83       	std	Y+1, r24	; 0x01
    8962:	0e 5f       	subi	r16, 0xFE	; 254
    8964:	1f 4f       	sbci	r17, 0xFF	; 255
    8966:	88 24       	eor	r8, r8
    8968:	83 94       	inc	r8
    896a:	91 2c       	mov	r9, r1
    896c:	53 01       	movw	r10, r6
    896e:	12 c0       	rjmp	.+36     	; 0x8994 <vfprintf+0x178>
    8970:	28 01       	movw	r4, r16
    8972:	f2 e0       	ldi	r31, 0x02	; 2
    8974:	4f 0e       	add	r4, r31
    8976:	51 1c       	adc	r5, r1
    8978:	f8 01       	movw	r30, r16
    897a:	a0 80       	ld	r10, Z
    897c:	b1 80       	ldd	r11, Z+1	; 0x01
    897e:	36 fe       	sbrs	r3, 6
    8980:	03 c0       	rjmp	.+6      	; 0x8988 <vfprintf+0x16c>
    8982:	69 2d       	mov	r22, r9
    8984:	70 e0       	ldi	r23, 0x00	; 0
    8986:	02 c0       	rjmp	.+4      	; 0x898c <vfprintf+0x170>
    8988:	6f ef       	ldi	r22, 0xFF	; 255
    898a:	7f ef       	ldi	r23, 0xFF	; 255
    898c:	c5 01       	movw	r24, r10
    898e:	0f de       	rcall	.-994    	; 0x85ae <strnlen>
    8990:	4c 01       	movw	r8, r24
    8992:	82 01       	movw	r16, r4
    8994:	f3 2d       	mov	r31, r3
    8996:	ff 77       	andi	r31, 0x7F	; 127
    8998:	3f 2e       	mov	r3, r31
    899a:	15 c0       	rjmp	.+42     	; 0x89c6 <vfprintf+0x1aa>
    899c:	28 01       	movw	r4, r16
    899e:	22 e0       	ldi	r18, 0x02	; 2
    89a0:	42 0e       	add	r4, r18
    89a2:	51 1c       	adc	r5, r1
    89a4:	f8 01       	movw	r30, r16
    89a6:	a0 80       	ld	r10, Z
    89a8:	b1 80       	ldd	r11, Z+1	; 0x01
    89aa:	36 fe       	sbrs	r3, 6
    89ac:	03 c0       	rjmp	.+6      	; 0x89b4 <vfprintf+0x198>
    89ae:	69 2d       	mov	r22, r9
    89b0:	70 e0       	ldi	r23, 0x00	; 0
    89b2:	02 c0       	rjmp	.+4      	; 0x89b8 <vfprintf+0x19c>
    89b4:	6f ef       	ldi	r22, 0xFF	; 255
    89b6:	7f ef       	ldi	r23, 0xFF	; 255
    89b8:	c5 01       	movw	r24, r10
    89ba:	68 d2       	rcall	.+1232   	; 0x8e8c <strnlen_P>
    89bc:	4c 01       	movw	r8, r24
    89be:	f3 2d       	mov	r31, r3
    89c0:	f0 68       	ori	r31, 0x80	; 128
    89c2:	3f 2e       	mov	r3, r31
    89c4:	82 01       	movw	r16, r4
    89c6:	33 fc       	sbrc	r3, 3
    89c8:	19 c0       	rjmp	.+50     	; 0x89fc <vfprintf+0x1e0>
    89ca:	82 2d       	mov	r24, r2
    89cc:	90 e0       	ldi	r25, 0x00	; 0
    89ce:	88 16       	cp	r8, r24
    89d0:	99 06       	cpc	r9, r25
    89d2:	a0 f4       	brcc	.+40     	; 0x89fc <vfprintf+0x1e0>
    89d4:	b6 01       	movw	r22, r12
    89d6:	80 e2       	ldi	r24, 0x20	; 32
    89d8:	90 e0       	ldi	r25, 0x00	; 0
    89da:	63 d2       	rcall	.+1222   	; 0x8ea2 <fputc>
    89dc:	2a 94       	dec	r2
    89de:	f5 cf       	rjmp	.-22     	; 0x89ca <vfprintf+0x1ae>
    89e0:	f5 01       	movw	r30, r10
    89e2:	37 fc       	sbrc	r3, 7
    89e4:	85 91       	lpm	r24, Z+
    89e6:	37 fe       	sbrs	r3, 7
    89e8:	81 91       	ld	r24, Z+
    89ea:	5f 01       	movw	r10, r30
    89ec:	b6 01       	movw	r22, r12
    89ee:	90 e0       	ldi	r25, 0x00	; 0
    89f0:	58 d2       	rcall	.+1200   	; 0x8ea2 <fputc>
    89f2:	21 10       	cpse	r2, r1
    89f4:	2a 94       	dec	r2
    89f6:	21 e0       	ldi	r18, 0x01	; 1
    89f8:	82 1a       	sub	r8, r18
    89fa:	91 08       	sbc	r9, r1
    89fc:	81 14       	cp	r8, r1
    89fe:	91 04       	cpc	r9, r1
    8a00:	79 f7       	brne	.-34     	; 0x89e0 <vfprintf+0x1c4>
    8a02:	e1 c0       	rjmp	.+450    	; 0x8bc6 <vfprintf+0x3aa>
    8a04:	84 36       	cpi	r24, 0x64	; 100
    8a06:	11 f0       	breq	.+4      	; 0x8a0c <vfprintf+0x1f0>
    8a08:	89 36       	cpi	r24, 0x69	; 105
    8a0a:	39 f5       	brne	.+78     	; 0x8a5a <vfprintf+0x23e>
    8a0c:	f8 01       	movw	r30, r16
    8a0e:	37 fe       	sbrs	r3, 7
    8a10:	07 c0       	rjmp	.+14     	; 0x8a20 <vfprintf+0x204>
    8a12:	60 81       	ld	r22, Z
    8a14:	71 81       	ldd	r23, Z+1	; 0x01
    8a16:	82 81       	ldd	r24, Z+2	; 0x02
    8a18:	93 81       	ldd	r25, Z+3	; 0x03
    8a1a:	0c 5f       	subi	r16, 0xFC	; 252
    8a1c:	1f 4f       	sbci	r17, 0xFF	; 255
    8a1e:	08 c0       	rjmp	.+16     	; 0x8a30 <vfprintf+0x214>
    8a20:	60 81       	ld	r22, Z
    8a22:	71 81       	ldd	r23, Z+1	; 0x01
    8a24:	07 2e       	mov	r0, r23
    8a26:	00 0c       	add	r0, r0
    8a28:	88 0b       	sbc	r24, r24
    8a2a:	99 0b       	sbc	r25, r25
    8a2c:	0e 5f       	subi	r16, 0xFE	; 254
    8a2e:	1f 4f       	sbci	r17, 0xFF	; 255
    8a30:	f3 2d       	mov	r31, r3
    8a32:	ff 76       	andi	r31, 0x6F	; 111
    8a34:	3f 2e       	mov	r3, r31
    8a36:	97 ff       	sbrs	r25, 7
    8a38:	09 c0       	rjmp	.+18     	; 0x8a4c <vfprintf+0x230>
    8a3a:	90 95       	com	r25
    8a3c:	80 95       	com	r24
    8a3e:	70 95       	com	r23
    8a40:	61 95       	neg	r22
    8a42:	7f 4f       	sbci	r23, 0xFF	; 255
    8a44:	8f 4f       	sbci	r24, 0xFF	; 255
    8a46:	9f 4f       	sbci	r25, 0xFF	; 255
    8a48:	f0 68       	ori	r31, 0x80	; 128
    8a4a:	3f 2e       	mov	r3, r31
    8a4c:	2a e0       	ldi	r18, 0x0A	; 10
    8a4e:	30 e0       	ldi	r19, 0x00	; 0
    8a50:	a3 01       	movw	r20, r6
    8a52:	63 d2       	rcall	.+1222   	; 0x8f1a <__ultoa_invert>
    8a54:	88 2e       	mov	r8, r24
    8a56:	86 18       	sub	r8, r6
    8a58:	44 c0       	rjmp	.+136    	; 0x8ae2 <vfprintf+0x2c6>
    8a5a:	85 37       	cpi	r24, 0x75	; 117
    8a5c:	31 f4       	brne	.+12     	; 0x8a6a <vfprintf+0x24e>
    8a5e:	23 2d       	mov	r18, r3
    8a60:	2f 7e       	andi	r18, 0xEF	; 239
    8a62:	b2 2e       	mov	r11, r18
    8a64:	2a e0       	ldi	r18, 0x0A	; 10
    8a66:	30 e0       	ldi	r19, 0x00	; 0
    8a68:	25 c0       	rjmp	.+74     	; 0x8ab4 <vfprintf+0x298>
    8a6a:	93 2d       	mov	r25, r3
    8a6c:	99 7f       	andi	r25, 0xF9	; 249
    8a6e:	b9 2e       	mov	r11, r25
    8a70:	8f 36       	cpi	r24, 0x6F	; 111
    8a72:	c1 f0       	breq	.+48     	; 0x8aa4 <vfprintf+0x288>
    8a74:	18 f4       	brcc	.+6      	; 0x8a7c <vfprintf+0x260>
    8a76:	88 35       	cpi	r24, 0x58	; 88
    8a78:	79 f0       	breq	.+30     	; 0x8a98 <vfprintf+0x27c>
    8a7a:	ae c0       	rjmp	.+348    	; 0x8bd8 <vfprintf+0x3bc>
    8a7c:	80 37       	cpi	r24, 0x70	; 112
    8a7e:	19 f0       	breq	.+6      	; 0x8a86 <vfprintf+0x26a>
    8a80:	88 37       	cpi	r24, 0x78	; 120
    8a82:	21 f0       	breq	.+8      	; 0x8a8c <vfprintf+0x270>
    8a84:	a9 c0       	rjmp	.+338    	; 0x8bd8 <vfprintf+0x3bc>
    8a86:	e9 2f       	mov	r30, r25
    8a88:	e0 61       	ori	r30, 0x10	; 16
    8a8a:	be 2e       	mov	r11, r30
    8a8c:	b4 fe       	sbrs	r11, 4
    8a8e:	0d c0       	rjmp	.+26     	; 0x8aaa <vfprintf+0x28e>
    8a90:	fb 2d       	mov	r31, r11
    8a92:	f4 60       	ori	r31, 0x04	; 4
    8a94:	bf 2e       	mov	r11, r31
    8a96:	09 c0       	rjmp	.+18     	; 0x8aaa <vfprintf+0x28e>
    8a98:	34 fe       	sbrs	r3, 4
    8a9a:	0a c0       	rjmp	.+20     	; 0x8ab0 <vfprintf+0x294>
    8a9c:	29 2f       	mov	r18, r25
    8a9e:	26 60       	ori	r18, 0x06	; 6
    8aa0:	b2 2e       	mov	r11, r18
    8aa2:	06 c0       	rjmp	.+12     	; 0x8ab0 <vfprintf+0x294>
    8aa4:	28 e0       	ldi	r18, 0x08	; 8
    8aa6:	30 e0       	ldi	r19, 0x00	; 0
    8aa8:	05 c0       	rjmp	.+10     	; 0x8ab4 <vfprintf+0x298>
    8aaa:	20 e1       	ldi	r18, 0x10	; 16
    8aac:	30 e0       	ldi	r19, 0x00	; 0
    8aae:	02 c0       	rjmp	.+4      	; 0x8ab4 <vfprintf+0x298>
    8ab0:	20 e1       	ldi	r18, 0x10	; 16
    8ab2:	32 e0       	ldi	r19, 0x02	; 2
    8ab4:	f8 01       	movw	r30, r16
    8ab6:	b7 fe       	sbrs	r11, 7
    8ab8:	07 c0       	rjmp	.+14     	; 0x8ac8 <vfprintf+0x2ac>
    8aba:	60 81       	ld	r22, Z
    8abc:	71 81       	ldd	r23, Z+1	; 0x01
    8abe:	82 81       	ldd	r24, Z+2	; 0x02
    8ac0:	93 81       	ldd	r25, Z+3	; 0x03
    8ac2:	0c 5f       	subi	r16, 0xFC	; 252
    8ac4:	1f 4f       	sbci	r17, 0xFF	; 255
    8ac6:	06 c0       	rjmp	.+12     	; 0x8ad4 <vfprintf+0x2b8>
    8ac8:	60 81       	ld	r22, Z
    8aca:	71 81       	ldd	r23, Z+1	; 0x01
    8acc:	80 e0       	ldi	r24, 0x00	; 0
    8ace:	90 e0       	ldi	r25, 0x00	; 0
    8ad0:	0e 5f       	subi	r16, 0xFE	; 254
    8ad2:	1f 4f       	sbci	r17, 0xFF	; 255
    8ad4:	a3 01       	movw	r20, r6
    8ad6:	21 d2       	rcall	.+1090   	; 0x8f1a <__ultoa_invert>
    8ad8:	88 2e       	mov	r8, r24
    8ada:	86 18       	sub	r8, r6
    8adc:	fb 2d       	mov	r31, r11
    8ade:	ff 77       	andi	r31, 0x7F	; 127
    8ae0:	3f 2e       	mov	r3, r31
    8ae2:	36 fe       	sbrs	r3, 6
    8ae4:	0d c0       	rjmp	.+26     	; 0x8b00 <vfprintf+0x2e4>
    8ae6:	23 2d       	mov	r18, r3
    8ae8:	2e 7f       	andi	r18, 0xFE	; 254
    8aea:	a2 2e       	mov	r10, r18
    8aec:	89 14       	cp	r8, r9
    8aee:	58 f4       	brcc	.+22     	; 0x8b06 <vfprintf+0x2ea>
    8af0:	34 fe       	sbrs	r3, 4
    8af2:	0b c0       	rjmp	.+22     	; 0x8b0a <vfprintf+0x2ee>
    8af4:	32 fc       	sbrc	r3, 2
    8af6:	09 c0       	rjmp	.+18     	; 0x8b0a <vfprintf+0x2ee>
    8af8:	83 2d       	mov	r24, r3
    8afa:	8e 7e       	andi	r24, 0xEE	; 238
    8afc:	a8 2e       	mov	r10, r24
    8afe:	05 c0       	rjmp	.+10     	; 0x8b0a <vfprintf+0x2ee>
    8b00:	b8 2c       	mov	r11, r8
    8b02:	a3 2c       	mov	r10, r3
    8b04:	03 c0       	rjmp	.+6      	; 0x8b0c <vfprintf+0x2f0>
    8b06:	b8 2c       	mov	r11, r8
    8b08:	01 c0       	rjmp	.+2      	; 0x8b0c <vfprintf+0x2f0>
    8b0a:	b9 2c       	mov	r11, r9
    8b0c:	a4 fe       	sbrs	r10, 4
    8b0e:	0f c0       	rjmp	.+30     	; 0x8b2e <vfprintf+0x312>
    8b10:	fe 01       	movw	r30, r28
    8b12:	e8 0d       	add	r30, r8
    8b14:	f1 1d       	adc	r31, r1
    8b16:	80 81       	ld	r24, Z
    8b18:	80 33       	cpi	r24, 0x30	; 48
    8b1a:	21 f4       	brne	.+8      	; 0x8b24 <vfprintf+0x308>
    8b1c:	9a 2d       	mov	r25, r10
    8b1e:	99 7e       	andi	r25, 0xE9	; 233
    8b20:	a9 2e       	mov	r10, r25
    8b22:	09 c0       	rjmp	.+18     	; 0x8b36 <vfprintf+0x31a>
    8b24:	a2 fe       	sbrs	r10, 2
    8b26:	06 c0       	rjmp	.+12     	; 0x8b34 <vfprintf+0x318>
    8b28:	b3 94       	inc	r11
    8b2a:	b3 94       	inc	r11
    8b2c:	04 c0       	rjmp	.+8      	; 0x8b36 <vfprintf+0x31a>
    8b2e:	8a 2d       	mov	r24, r10
    8b30:	86 78       	andi	r24, 0x86	; 134
    8b32:	09 f0       	breq	.+2      	; 0x8b36 <vfprintf+0x31a>
    8b34:	b3 94       	inc	r11
    8b36:	a3 fc       	sbrc	r10, 3
    8b38:	10 c0       	rjmp	.+32     	; 0x8b5a <vfprintf+0x33e>
    8b3a:	a0 fe       	sbrs	r10, 0
    8b3c:	06 c0       	rjmp	.+12     	; 0x8b4a <vfprintf+0x32e>
    8b3e:	b2 14       	cp	r11, r2
    8b40:	80 f4       	brcc	.+32     	; 0x8b62 <vfprintf+0x346>
    8b42:	28 0c       	add	r2, r8
    8b44:	92 2c       	mov	r9, r2
    8b46:	9b 18       	sub	r9, r11
    8b48:	0d c0       	rjmp	.+26     	; 0x8b64 <vfprintf+0x348>
    8b4a:	b2 14       	cp	r11, r2
    8b4c:	58 f4       	brcc	.+22     	; 0x8b64 <vfprintf+0x348>
    8b4e:	b6 01       	movw	r22, r12
    8b50:	80 e2       	ldi	r24, 0x20	; 32
    8b52:	90 e0       	ldi	r25, 0x00	; 0
    8b54:	a6 d1       	rcall	.+844    	; 0x8ea2 <fputc>
    8b56:	b3 94       	inc	r11
    8b58:	f8 cf       	rjmp	.-16     	; 0x8b4a <vfprintf+0x32e>
    8b5a:	b2 14       	cp	r11, r2
    8b5c:	18 f4       	brcc	.+6      	; 0x8b64 <vfprintf+0x348>
    8b5e:	2b 18       	sub	r2, r11
    8b60:	02 c0       	rjmp	.+4      	; 0x8b66 <vfprintf+0x34a>
    8b62:	98 2c       	mov	r9, r8
    8b64:	21 2c       	mov	r2, r1
    8b66:	a4 fe       	sbrs	r10, 4
    8b68:	0f c0       	rjmp	.+30     	; 0x8b88 <vfprintf+0x36c>
    8b6a:	b6 01       	movw	r22, r12
    8b6c:	80 e3       	ldi	r24, 0x30	; 48
    8b6e:	90 e0       	ldi	r25, 0x00	; 0
    8b70:	98 d1       	rcall	.+816    	; 0x8ea2 <fputc>
    8b72:	a2 fe       	sbrs	r10, 2
    8b74:	16 c0       	rjmp	.+44     	; 0x8ba2 <vfprintf+0x386>
    8b76:	a1 fc       	sbrc	r10, 1
    8b78:	03 c0       	rjmp	.+6      	; 0x8b80 <vfprintf+0x364>
    8b7a:	88 e7       	ldi	r24, 0x78	; 120
    8b7c:	90 e0       	ldi	r25, 0x00	; 0
    8b7e:	02 c0       	rjmp	.+4      	; 0x8b84 <vfprintf+0x368>
    8b80:	88 e5       	ldi	r24, 0x58	; 88
    8b82:	90 e0       	ldi	r25, 0x00	; 0
    8b84:	b6 01       	movw	r22, r12
    8b86:	0c c0       	rjmp	.+24     	; 0x8ba0 <vfprintf+0x384>
    8b88:	8a 2d       	mov	r24, r10
    8b8a:	86 78       	andi	r24, 0x86	; 134
    8b8c:	51 f0       	breq	.+20     	; 0x8ba2 <vfprintf+0x386>
    8b8e:	a1 fe       	sbrs	r10, 1
    8b90:	02 c0       	rjmp	.+4      	; 0x8b96 <vfprintf+0x37a>
    8b92:	8b e2       	ldi	r24, 0x2B	; 43
    8b94:	01 c0       	rjmp	.+2      	; 0x8b98 <vfprintf+0x37c>
    8b96:	80 e2       	ldi	r24, 0x20	; 32
    8b98:	a7 fc       	sbrc	r10, 7
    8b9a:	8d e2       	ldi	r24, 0x2D	; 45
    8b9c:	b6 01       	movw	r22, r12
    8b9e:	90 e0       	ldi	r25, 0x00	; 0
    8ba0:	80 d1       	rcall	.+768    	; 0x8ea2 <fputc>
    8ba2:	89 14       	cp	r8, r9
    8ba4:	30 f4       	brcc	.+12     	; 0x8bb2 <vfprintf+0x396>
    8ba6:	b6 01       	movw	r22, r12
    8ba8:	80 e3       	ldi	r24, 0x30	; 48
    8baa:	90 e0       	ldi	r25, 0x00	; 0
    8bac:	7a d1       	rcall	.+756    	; 0x8ea2 <fputc>
    8bae:	9a 94       	dec	r9
    8bb0:	f8 cf       	rjmp	.-16     	; 0x8ba2 <vfprintf+0x386>
    8bb2:	8a 94       	dec	r8
    8bb4:	f3 01       	movw	r30, r6
    8bb6:	e8 0d       	add	r30, r8
    8bb8:	f1 1d       	adc	r31, r1
    8bba:	80 81       	ld	r24, Z
    8bbc:	b6 01       	movw	r22, r12
    8bbe:	90 e0       	ldi	r25, 0x00	; 0
    8bc0:	70 d1       	rcall	.+736    	; 0x8ea2 <fputc>
    8bc2:	81 10       	cpse	r8, r1
    8bc4:	f6 cf       	rjmp	.-20     	; 0x8bb2 <vfprintf+0x396>
    8bc6:	22 20       	and	r2, r2
    8bc8:	09 f4       	brne	.+2      	; 0x8bcc <vfprintf+0x3b0>
    8bca:	4e ce       	rjmp	.-868    	; 0x8868 <vfprintf+0x4c>
    8bcc:	b6 01       	movw	r22, r12
    8bce:	80 e2       	ldi	r24, 0x20	; 32
    8bd0:	90 e0       	ldi	r25, 0x00	; 0
    8bd2:	67 d1       	rcall	.+718    	; 0x8ea2 <fputc>
    8bd4:	2a 94       	dec	r2
    8bd6:	f7 cf       	rjmp	.-18     	; 0x8bc6 <vfprintf+0x3aa>
    8bd8:	f6 01       	movw	r30, r12
    8bda:	86 81       	ldd	r24, Z+6	; 0x06
    8bdc:	97 81       	ldd	r25, Z+7	; 0x07
    8bde:	02 c0       	rjmp	.+4      	; 0x8be4 <vfprintf+0x3c8>
    8be0:	8f ef       	ldi	r24, 0xFF	; 255
    8be2:	9f ef       	ldi	r25, 0xFF	; 255
    8be4:	2b 96       	adiw	r28, 0x0b	; 11
    8be6:	0f b6       	in	r0, 0x3f	; 63
    8be8:	f8 94       	cli
    8bea:	de bf       	out	0x3e, r29	; 62
    8bec:	0f be       	out	0x3f, r0	; 63
    8bee:	cd bf       	out	0x3d, r28	; 61
    8bf0:	df 91       	pop	r29
    8bf2:	cf 91       	pop	r28
    8bf4:	1f 91       	pop	r17
    8bf6:	0f 91       	pop	r16
    8bf8:	ff 90       	pop	r15
    8bfa:	ef 90       	pop	r14
    8bfc:	df 90       	pop	r13
    8bfe:	cf 90       	pop	r12
    8c00:	bf 90       	pop	r11
    8c02:	af 90       	pop	r10
    8c04:	9f 90       	pop	r9
    8c06:	8f 90       	pop	r8
    8c08:	7f 90       	pop	r7
    8c0a:	6f 90       	pop	r6
    8c0c:	5f 90       	pop	r5
    8c0e:	4f 90       	pop	r4
    8c10:	3f 90       	pop	r3
    8c12:	2f 90       	pop	r2
    8c14:	08 95       	ret

00008c16 <calloc>:
    8c16:	0f 93       	push	r16
    8c18:	1f 93       	push	r17
    8c1a:	cf 93       	push	r28
    8c1c:	df 93       	push	r29
    8c1e:	86 9f       	mul	r24, r22
    8c20:	80 01       	movw	r16, r0
    8c22:	87 9f       	mul	r24, r23
    8c24:	10 0d       	add	r17, r0
    8c26:	96 9f       	mul	r25, r22
    8c28:	10 0d       	add	r17, r0
    8c2a:	11 24       	eor	r1, r1
    8c2c:	c8 01       	movw	r24, r16
    8c2e:	0d d0       	rcall	.+26     	; 0x8c4a <malloc>
    8c30:	ec 01       	movw	r28, r24
    8c32:	00 97       	sbiw	r24, 0x00	; 0
    8c34:	21 f0       	breq	.+8      	; 0x8c3e <calloc+0x28>
    8c36:	a8 01       	movw	r20, r16
    8c38:	60 e0       	ldi	r22, 0x00	; 0
    8c3a:	70 e0       	ldi	r23, 0x00	; 0
    8c3c:	8d dc       	rcall	.-1766   	; 0x8558 <memset>
    8c3e:	ce 01       	movw	r24, r28
    8c40:	df 91       	pop	r29
    8c42:	cf 91       	pop	r28
    8c44:	1f 91       	pop	r17
    8c46:	0f 91       	pop	r16
    8c48:	08 95       	ret

00008c4a <malloc>:
    8c4a:	0f 93       	push	r16
    8c4c:	1f 93       	push	r17
    8c4e:	cf 93       	push	r28
    8c50:	df 93       	push	r29
    8c52:	82 30       	cpi	r24, 0x02	; 2
    8c54:	91 05       	cpc	r25, r1
    8c56:	10 f4       	brcc	.+4      	; 0x8c5c <malloc+0x12>
    8c58:	82 e0       	ldi	r24, 0x02	; 2
    8c5a:	90 e0       	ldi	r25, 0x00	; 0
    8c5c:	e0 91 7b 20 	lds	r30, 0x207B	; 0x80207b <__flp>
    8c60:	f0 91 7c 20 	lds	r31, 0x207C	; 0x80207c <__flp+0x1>
    8c64:	20 e0       	ldi	r18, 0x00	; 0
    8c66:	30 e0       	ldi	r19, 0x00	; 0
    8c68:	a0 e0       	ldi	r26, 0x00	; 0
    8c6a:	b0 e0       	ldi	r27, 0x00	; 0
    8c6c:	30 97       	sbiw	r30, 0x00	; 0
    8c6e:	19 f1       	breq	.+70     	; 0x8cb6 <malloc+0x6c>
    8c70:	40 81       	ld	r20, Z
    8c72:	51 81       	ldd	r21, Z+1	; 0x01
    8c74:	02 81       	ldd	r16, Z+2	; 0x02
    8c76:	13 81       	ldd	r17, Z+3	; 0x03
    8c78:	48 17       	cp	r20, r24
    8c7a:	59 07       	cpc	r21, r25
    8c7c:	c8 f0       	brcs	.+50     	; 0x8cb0 <malloc+0x66>
    8c7e:	84 17       	cp	r24, r20
    8c80:	95 07       	cpc	r25, r21
    8c82:	69 f4       	brne	.+26     	; 0x8c9e <malloc+0x54>
    8c84:	10 97       	sbiw	r26, 0x00	; 0
    8c86:	31 f0       	breq	.+12     	; 0x8c94 <malloc+0x4a>
    8c88:	12 96       	adiw	r26, 0x02	; 2
    8c8a:	0c 93       	st	X, r16
    8c8c:	12 97       	sbiw	r26, 0x02	; 2
    8c8e:	13 96       	adiw	r26, 0x03	; 3
    8c90:	1c 93       	st	X, r17
    8c92:	27 c0       	rjmp	.+78     	; 0x8ce2 <malloc+0x98>
    8c94:	00 93 7b 20 	sts	0x207B, r16	; 0x80207b <__flp>
    8c98:	10 93 7c 20 	sts	0x207C, r17	; 0x80207c <__flp+0x1>
    8c9c:	22 c0       	rjmp	.+68     	; 0x8ce2 <malloc+0x98>
    8c9e:	21 15       	cp	r18, r1
    8ca0:	31 05       	cpc	r19, r1
    8ca2:	19 f0       	breq	.+6      	; 0x8caa <malloc+0x60>
    8ca4:	42 17       	cp	r20, r18
    8ca6:	53 07       	cpc	r21, r19
    8ca8:	18 f4       	brcc	.+6      	; 0x8cb0 <malloc+0x66>
    8caa:	9a 01       	movw	r18, r20
    8cac:	bd 01       	movw	r22, r26
    8cae:	ef 01       	movw	r28, r30
    8cb0:	df 01       	movw	r26, r30
    8cb2:	f8 01       	movw	r30, r16
    8cb4:	db cf       	rjmp	.-74     	; 0x8c6c <malloc+0x22>
    8cb6:	21 15       	cp	r18, r1
    8cb8:	31 05       	cpc	r19, r1
    8cba:	f9 f0       	breq	.+62     	; 0x8cfa <malloc+0xb0>
    8cbc:	28 1b       	sub	r18, r24
    8cbe:	39 0b       	sbc	r19, r25
    8cc0:	24 30       	cpi	r18, 0x04	; 4
    8cc2:	31 05       	cpc	r19, r1
    8cc4:	80 f4       	brcc	.+32     	; 0x8ce6 <malloc+0x9c>
    8cc6:	8a 81       	ldd	r24, Y+2	; 0x02
    8cc8:	9b 81       	ldd	r25, Y+3	; 0x03
    8cca:	61 15       	cp	r22, r1
    8ccc:	71 05       	cpc	r23, r1
    8cce:	21 f0       	breq	.+8      	; 0x8cd8 <malloc+0x8e>
    8cd0:	fb 01       	movw	r30, r22
    8cd2:	93 83       	std	Z+3, r25	; 0x03
    8cd4:	82 83       	std	Z+2, r24	; 0x02
    8cd6:	04 c0       	rjmp	.+8      	; 0x8ce0 <malloc+0x96>
    8cd8:	90 93 7c 20 	sts	0x207C, r25	; 0x80207c <__flp+0x1>
    8cdc:	80 93 7b 20 	sts	0x207B, r24	; 0x80207b <__flp>
    8ce0:	fe 01       	movw	r30, r28
    8ce2:	32 96       	adiw	r30, 0x02	; 2
    8ce4:	44 c0       	rjmp	.+136    	; 0x8d6e <malloc+0x124>
    8ce6:	fe 01       	movw	r30, r28
    8ce8:	e2 0f       	add	r30, r18
    8cea:	f3 1f       	adc	r31, r19
    8cec:	81 93       	st	Z+, r24
    8cee:	91 93       	st	Z+, r25
    8cf0:	22 50       	subi	r18, 0x02	; 2
    8cf2:	31 09       	sbc	r19, r1
    8cf4:	39 83       	std	Y+1, r19	; 0x01
    8cf6:	28 83       	st	Y, r18
    8cf8:	3a c0       	rjmp	.+116    	; 0x8d6e <malloc+0x124>
    8cfa:	20 91 79 20 	lds	r18, 0x2079	; 0x802079 <__brkval>
    8cfe:	30 91 7a 20 	lds	r19, 0x207A	; 0x80207a <__brkval+0x1>
    8d02:	23 2b       	or	r18, r19
    8d04:	41 f4       	brne	.+16     	; 0x8d16 <malloc+0xcc>
    8d06:	20 91 06 02 	lds	r18, 0x0206	; 0x800206 <__malloc_heap_start>
    8d0a:	30 91 07 02 	lds	r19, 0x0207	; 0x800207 <__malloc_heap_start+0x1>
    8d0e:	30 93 7a 20 	sts	0x207A, r19	; 0x80207a <__brkval+0x1>
    8d12:	20 93 79 20 	sts	0x2079, r18	; 0x802079 <__brkval>
    8d16:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <__malloc_heap_end>
    8d1a:	30 91 05 02 	lds	r19, 0x0205	; 0x800205 <__malloc_heap_end+0x1>
    8d1e:	21 15       	cp	r18, r1
    8d20:	31 05       	cpc	r19, r1
    8d22:	41 f4       	brne	.+16     	; 0x8d34 <malloc+0xea>
    8d24:	2d b7       	in	r18, 0x3d	; 61
    8d26:	3e b7       	in	r19, 0x3e	; 62
    8d28:	40 91 08 02 	lds	r20, 0x0208	; 0x800208 <__malloc_margin>
    8d2c:	50 91 09 02 	lds	r21, 0x0209	; 0x800209 <__malloc_margin+0x1>
    8d30:	24 1b       	sub	r18, r20
    8d32:	35 0b       	sbc	r19, r21
    8d34:	e0 91 79 20 	lds	r30, 0x2079	; 0x802079 <__brkval>
    8d38:	f0 91 7a 20 	lds	r31, 0x207A	; 0x80207a <__brkval+0x1>
    8d3c:	e2 17       	cp	r30, r18
    8d3e:	f3 07       	cpc	r31, r19
    8d40:	a0 f4       	brcc	.+40     	; 0x8d6a <malloc+0x120>
    8d42:	2e 1b       	sub	r18, r30
    8d44:	3f 0b       	sbc	r19, r31
    8d46:	28 17       	cp	r18, r24
    8d48:	39 07       	cpc	r19, r25
    8d4a:	78 f0       	brcs	.+30     	; 0x8d6a <malloc+0x120>
    8d4c:	ac 01       	movw	r20, r24
    8d4e:	4e 5f       	subi	r20, 0xFE	; 254
    8d50:	5f 4f       	sbci	r21, 0xFF	; 255
    8d52:	24 17       	cp	r18, r20
    8d54:	35 07       	cpc	r19, r21
    8d56:	48 f0       	brcs	.+18     	; 0x8d6a <malloc+0x120>
    8d58:	4e 0f       	add	r20, r30
    8d5a:	5f 1f       	adc	r21, r31
    8d5c:	50 93 7a 20 	sts	0x207A, r21	; 0x80207a <__brkval+0x1>
    8d60:	40 93 79 20 	sts	0x2079, r20	; 0x802079 <__brkval>
    8d64:	81 93       	st	Z+, r24
    8d66:	91 93       	st	Z+, r25
    8d68:	02 c0       	rjmp	.+4      	; 0x8d6e <malloc+0x124>
    8d6a:	e0 e0       	ldi	r30, 0x00	; 0
    8d6c:	f0 e0       	ldi	r31, 0x00	; 0
    8d6e:	cf 01       	movw	r24, r30
    8d70:	df 91       	pop	r29
    8d72:	cf 91       	pop	r28
    8d74:	1f 91       	pop	r17
    8d76:	0f 91       	pop	r16
    8d78:	08 95       	ret

00008d7a <free>:
    8d7a:	cf 93       	push	r28
    8d7c:	df 93       	push	r29
    8d7e:	00 97       	sbiw	r24, 0x00	; 0
    8d80:	09 f4       	brne	.+2      	; 0x8d84 <free+0xa>
    8d82:	81 c0       	rjmp	.+258    	; 0x8e86 <free+0x10c>
    8d84:	fc 01       	movw	r30, r24
    8d86:	32 97       	sbiw	r30, 0x02	; 2
    8d88:	13 82       	std	Z+3, r1	; 0x03
    8d8a:	12 82       	std	Z+2, r1	; 0x02
    8d8c:	a0 91 7b 20 	lds	r26, 0x207B	; 0x80207b <__flp>
    8d90:	b0 91 7c 20 	lds	r27, 0x207C	; 0x80207c <__flp+0x1>
    8d94:	10 97       	sbiw	r26, 0x00	; 0
    8d96:	81 f4       	brne	.+32     	; 0x8db8 <free+0x3e>
    8d98:	20 81       	ld	r18, Z
    8d9a:	31 81       	ldd	r19, Z+1	; 0x01
    8d9c:	82 0f       	add	r24, r18
    8d9e:	93 1f       	adc	r25, r19
    8da0:	20 91 79 20 	lds	r18, 0x2079	; 0x802079 <__brkval>
    8da4:	30 91 7a 20 	lds	r19, 0x207A	; 0x80207a <__brkval+0x1>
    8da8:	28 17       	cp	r18, r24
    8daa:	39 07       	cpc	r19, r25
    8dac:	51 f5       	brne	.+84     	; 0x8e02 <free+0x88>
    8dae:	f0 93 7a 20 	sts	0x207A, r31	; 0x80207a <__brkval+0x1>
    8db2:	e0 93 79 20 	sts	0x2079, r30	; 0x802079 <__brkval>
    8db6:	67 c0       	rjmp	.+206    	; 0x8e86 <free+0x10c>
    8db8:	ed 01       	movw	r28, r26
    8dba:	20 e0       	ldi	r18, 0x00	; 0
    8dbc:	30 e0       	ldi	r19, 0x00	; 0
    8dbe:	ce 17       	cp	r28, r30
    8dc0:	df 07       	cpc	r29, r31
    8dc2:	40 f4       	brcc	.+16     	; 0x8dd4 <free+0x5a>
    8dc4:	4a 81       	ldd	r20, Y+2	; 0x02
    8dc6:	5b 81       	ldd	r21, Y+3	; 0x03
    8dc8:	9e 01       	movw	r18, r28
    8dca:	41 15       	cp	r20, r1
    8dcc:	51 05       	cpc	r21, r1
    8dce:	f1 f0       	breq	.+60     	; 0x8e0c <free+0x92>
    8dd0:	ea 01       	movw	r28, r20
    8dd2:	f5 cf       	rjmp	.-22     	; 0x8dbe <free+0x44>
    8dd4:	d3 83       	std	Z+3, r29	; 0x03
    8dd6:	c2 83       	std	Z+2, r28	; 0x02
    8dd8:	40 81       	ld	r20, Z
    8dda:	51 81       	ldd	r21, Z+1	; 0x01
    8ddc:	84 0f       	add	r24, r20
    8dde:	95 1f       	adc	r25, r21
    8de0:	c8 17       	cp	r28, r24
    8de2:	d9 07       	cpc	r29, r25
    8de4:	59 f4       	brne	.+22     	; 0x8dfc <free+0x82>
    8de6:	88 81       	ld	r24, Y
    8de8:	99 81       	ldd	r25, Y+1	; 0x01
    8dea:	84 0f       	add	r24, r20
    8dec:	95 1f       	adc	r25, r21
    8dee:	02 96       	adiw	r24, 0x02	; 2
    8df0:	91 83       	std	Z+1, r25	; 0x01
    8df2:	80 83       	st	Z, r24
    8df4:	8a 81       	ldd	r24, Y+2	; 0x02
    8df6:	9b 81       	ldd	r25, Y+3	; 0x03
    8df8:	93 83       	std	Z+3, r25	; 0x03
    8dfa:	82 83       	std	Z+2, r24	; 0x02
    8dfc:	21 15       	cp	r18, r1
    8dfe:	31 05       	cpc	r19, r1
    8e00:	29 f4       	brne	.+10     	; 0x8e0c <free+0x92>
    8e02:	f0 93 7c 20 	sts	0x207C, r31	; 0x80207c <__flp+0x1>
    8e06:	e0 93 7b 20 	sts	0x207B, r30	; 0x80207b <__flp>
    8e0a:	3d c0       	rjmp	.+122    	; 0x8e86 <free+0x10c>
    8e0c:	e9 01       	movw	r28, r18
    8e0e:	fb 83       	std	Y+3, r31	; 0x03
    8e10:	ea 83       	std	Y+2, r30	; 0x02
    8e12:	49 91       	ld	r20, Y+
    8e14:	59 91       	ld	r21, Y+
    8e16:	c4 0f       	add	r28, r20
    8e18:	d5 1f       	adc	r29, r21
    8e1a:	ec 17       	cp	r30, r28
    8e1c:	fd 07       	cpc	r31, r29
    8e1e:	61 f4       	brne	.+24     	; 0x8e38 <free+0xbe>
    8e20:	80 81       	ld	r24, Z
    8e22:	91 81       	ldd	r25, Z+1	; 0x01
    8e24:	84 0f       	add	r24, r20
    8e26:	95 1f       	adc	r25, r21
    8e28:	02 96       	adiw	r24, 0x02	; 2
    8e2a:	e9 01       	movw	r28, r18
    8e2c:	99 83       	std	Y+1, r25	; 0x01
    8e2e:	88 83       	st	Y, r24
    8e30:	82 81       	ldd	r24, Z+2	; 0x02
    8e32:	93 81       	ldd	r25, Z+3	; 0x03
    8e34:	9b 83       	std	Y+3, r25	; 0x03
    8e36:	8a 83       	std	Y+2, r24	; 0x02
    8e38:	e0 e0       	ldi	r30, 0x00	; 0
    8e3a:	f0 e0       	ldi	r31, 0x00	; 0
    8e3c:	12 96       	adiw	r26, 0x02	; 2
    8e3e:	8d 91       	ld	r24, X+
    8e40:	9c 91       	ld	r25, X
    8e42:	13 97       	sbiw	r26, 0x03	; 3
    8e44:	00 97       	sbiw	r24, 0x00	; 0
    8e46:	19 f0       	breq	.+6      	; 0x8e4e <free+0xd4>
    8e48:	fd 01       	movw	r30, r26
    8e4a:	dc 01       	movw	r26, r24
    8e4c:	f7 cf       	rjmp	.-18     	; 0x8e3c <free+0xc2>
    8e4e:	8d 91       	ld	r24, X+
    8e50:	9c 91       	ld	r25, X
    8e52:	11 97       	sbiw	r26, 0x01	; 1
    8e54:	9d 01       	movw	r18, r26
    8e56:	2e 5f       	subi	r18, 0xFE	; 254
    8e58:	3f 4f       	sbci	r19, 0xFF	; 255
    8e5a:	82 0f       	add	r24, r18
    8e5c:	93 1f       	adc	r25, r19
    8e5e:	20 91 79 20 	lds	r18, 0x2079	; 0x802079 <__brkval>
    8e62:	30 91 7a 20 	lds	r19, 0x207A	; 0x80207a <__brkval+0x1>
    8e66:	28 17       	cp	r18, r24
    8e68:	39 07       	cpc	r19, r25
    8e6a:	69 f4       	brne	.+26     	; 0x8e86 <free+0x10c>
    8e6c:	30 97       	sbiw	r30, 0x00	; 0
    8e6e:	29 f4       	brne	.+10     	; 0x8e7a <free+0x100>
    8e70:	10 92 7c 20 	sts	0x207C, r1	; 0x80207c <__flp+0x1>
    8e74:	10 92 7b 20 	sts	0x207B, r1	; 0x80207b <__flp>
    8e78:	02 c0       	rjmp	.+4      	; 0x8e7e <free+0x104>
    8e7a:	13 82       	std	Z+3, r1	; 0x03
    8e7c:	12 82       	std	Z+2, r1	; 0x02
    8e7e:	b0 93 7a 20 	sts	0x207A, r27	; 0x80207a <__brkval+0x1>
    8e82:	a0 93 79 20 	sts	0x2079, r26	; 0x802079 <__brkval>
    8e86:	df 91       	pop	r29
    8e88:	cf 91       	pop	r28
    8e8a:	08 95       	ret

00008e8c <strnlen_P>:
    8e8c:	fc 01       	movw	r30, r24
    8e8e:	05 90       	lpm	r0, Z+
    8e90:	61 50       	subi	r22, 0x01	; 1
    8e92:	70 40       	sbci	r23, 0x00	; 0
    8e94:	01 10       	cpse	r0, r1
    8e96:	d8 f7       	brcc	.-10     	; 0x8e8e <strnlen_P+0x2>
    8e98:	80 95       	com	r24
    8e9a:	90 95       	com	r25
    8e9c:	8e 0f       	add	r24, r30
    8e9e:	9f 1f       	adc	r25, r31
    8ea0:	08 95       	ret

00008ea2 <fputc>:
    8ea2:	0f 93       	push	r16
    8ea4:	1f 93       	push	r17
    8ea6:	cf 93       	push	r28
    8ea8:	df 93       	push	r29
    8eaa:	fb 01       	movw	r30, r22
    8eac:	23 81       	ldd	r18, Z+3	; 0x03
    8eae:	21 fd       	sbrc	r18, 1
    8eb0:	03 c0       	rjmp	.+6      	; 0x8eb8 <fputc+0x16>
    8eb2:	8f ef       	ldi	r24, 0xFF	; 255
    8eb4:	9f ef       	ldi	r25, 0xFF	; 255
    8eb6:	2c c0       	rjmp	.+88     	; 0x8f10 <fputc+0x6e>
    8eb8:	22 ff       	sbrs	r18, 2
    8eba:	16 c0       	rjmp	.+44     	; 0x8ee8 <fputc+0x46>
    8ebc:	46 81       	ldd	r20, Z+6	; 0x06
    8ebe:	57 81       	ldd	r21, Z+7	; 0x07
    8ec0:	24 81       	ldd	r18, Z+4	; 0x04
    8ec2:	35 81       	ldd	r19, Z+5	; 0x05
    8ec4:	42 17       	cp	r20, r18
    8ec6:	53 07       	cpc	r21, r19
    8ec8:	44 f4       	brge	.+16     	; 0x8eda <fputc+0x38>
    8eca:	a0 81       	ld	r26, Z
    8ecc:	b1 81       	ldd	r27, Z+1	; 0x01
    8ece:	9d 01       	movw	r18, r26
    8ed0:	2f 5f       	subi	r18, 0xFF	; 255
    8ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    8ed4:	31 83       	std	Z+1, r19	; 0x01
    8ed6:	20 83       	st	Z, r18
    8ed8:	8c 93       	st	X, r24
    8eda:	26 81       	ldd	r18, Z+6	; 0x06
    8edc:	37 81       	ldd	r19, Z+7	; 0x07
    8ede:	2f 5f       	subi	r18, 0xFF	; 255
    8ee0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ee2:	37 83       	std	Z+7, r19	; 0x07
    8ee4:	26 83       	std	Z+6, r18	; 0x06
    8ee6:	14 c0       	rjmp	.+40     	; 0x8f10 <fputc+0x6e>
    8ee8:	8b 01       	movw	r16, r22
    8eea:	ec 01       	movw	r28, r24
    8eec:	fb 01       	movw	r30, r22
    8eee:	00 84       	ldd	r0, Z+8	; 0x08
    8ef0:	f1 85       	ldd	r31, Z+9	; 0x09
    8ef2:	e0 2d       	mov	r30, r0
    8ef4:	19 95       	eicall
    8ef6:	89 2b       	or	r24, r25
    8ef8:	e1 f6       	brne	.-72     	; 0x8eb2 <fputc+0x10>
    8efa:	d8 01       	movw	r26, r16
    8efc:	16 96       	adiw	r26, 0x06	; 6
    8efe:	8d 91       	ld	r24, X+
    8f00:	9c 91       	ld	r25, X
    8f02:	17 97       	sbiw	r26, 0x07	; 7
    8f04:	01 96       	adiw	r24, 0x01	; 1
    8f06:	17 96       	adiw	r26, 0x07	; 7
    8f08:	9c 93       	st	X, r25
    8f0a:	8e 93       	st	-X, r24
    8f0c:	16 97       	sbiw	r26, 0x06	; 6
    8f0e:	ce 01       	movw	r24, r28
    8f10:	df 91       	pop	r29
    8f12:	cf 91       	pop	r28
    8f14:	1f 91       	pop	r17
    8f16:	0f 91       	pop	r16
    8f18:	08 95       	ret

00008f1a <__ultoa_invert>:
    8f1a:	fa 01       	movw	r30, r20
    8f1c:	aa 27       	eor	r26, r26
    8f1e:	28 30       	cpi	r18, 0x08	; 8
    8f20:	51 f1       	breq	.+84     	; 0x8f76 <__ultoa_invert+0x5c>
    8f22:	20 31       	cpi	r18, 0x10	; 16
    8f24:	81 f1       	breq	.+96     	; 0x8f86 <__ultoa_invert+0x6c>
    8f26:	e8 94       	clt
    8f28:	6f 93       	push	r22
    8f2a:	6e 7f       	andi	r22, 0xFE	; 254
    8f2c:	6e 5f       	subi	r22, 0xFE	; 254
    8f2e:	7f 4f       	sbci	r23, 0xFF	; 255
    8f30:	8f 4f       	sbci	r24, 0xFF	; 255
    8f32:	9f 4f       	sbci	r25, 0xFF	; 255
    8f34:	af 4f       	sbci	r26, 0xFF	; 255
    8f36:	b1 e0       	ldi	r27, 0x01	; 1
    8f38:	3e d0       	rcall	.+124    	; 0x8fb6 <__ultoa_invert+0x9c>
    8f3a:	b4 e0       	ldi	r27, 0x04	; 4
    8f3c:	3c d0       	rcall	.+120    	; 0x8fb6 <__ultoa_invert+0x9c>
    8f3e:	67 0f       	add	r22, r23
    8f40:	78 1f       	adc	r23, r24
    8f42:	89 1f       	adc	r24, r25
    8f44:	9a 1f       	adc	r25, r26
    8f46:	a1 1d       	adc	r26, r1
    8f48:	68 0f       	add	r22, r24
    8f4a:	79 1f       	adc	r23, r25
    8f4c:	8a 1f       	adc	r24, r26
    8f4e:	91 1d       	adc	r25, r1
    8f50:	a1 1d       	adc	r26, r1
    8f52:	6a 0f       	add	r22, r26
    8f54:	71 1d       	adc	r23, r1
    8f56:	81 1d       	adc	r24, r1
    8f58:	91 1d       	adc	r25, r1
    8f5a:	a1 1d       	adc	r26, r1
    8f5c:	20 d0       	rcall	.+64     	; 0x8f9e <__ultoa_invert+0x84>
    8f5e:	09 f4       	brne	.+2      	; 0x8f62 <__ultoa_invert+0x48>
    8f60:	68 94       	set
    8f62:	3f 91       	pop	r19
    8f64:	2a e0       	ldi	r18, 0x0A	; 10
    8f66:	26 9f       	mul	r18, r22
    8f68:	11 24       	eor	r1, r1
    8f6a:	30 19       	sub	r19, r0
    8f6c:	30 5d       	subi	r19, 0xD0	; 208
    8f6e:	31 93       	st	Z+, r19
    8f70:	de f6       	brtc	.-74     	; 0x8f28 <__ultoa_invert+0xe>
    8f72:	cf 01       	movw	r24, r30
    8f74:	08 95       	ret
    8f76:	46 2f       	mov	r20, r22
    8f78:	47 70       	andi	r20, 0x07	; 7
    8f7a:	40 5d       	subi	r20, 0xD0	; 208
    8f7c:	41 93       	st	Z+, r20
    8f7e:	b3 e0       	ldi	r27, 0x03	; 3
    8f80:	0f d0       	rcall	.+30     	; 0x8fa0 <__ultoa_invert+0x86>
    8f82:	c9 f7       	brne	.-14     	; 0x8f76 <__ultoa_invert+0x5c>
    8f84:	f6 cf       	rjmp	.-20     	; 0x8f72 <__ultoa_invert+0x58>
    8f86:	46 2f       	mov	r20, r22
    8f88:	4f 70       	andi	r20, 0x0F	; 15
    8f8a:	40 5d       	subi	r20, 0xD0	; 208
    8f8c:	4a 33       	cpi	r20, 0x3A	; 58
    8f8e:	18 f0       	brcs	.+6      	; 0x8f96 <__ultoa_invert+0x7c>
    8f90:	49 5d       	subi	r20, 0xD9	; 217
    8f92:	31 fd       	sbrc	r19, 1
    8f94:	40 52       	subi	r20, 0x20	; 32
    8f96:	41 93       	st	Z+, r20
    8f98:	02 d0       	rcall	.+4      	; 0x8f9e <__ultoa_invert+0x84>
    8f9a:	a9 f7       	brne	.-22     	; 0x8f86 <__ultoa_invert+0x6c>
    8f9c:	ea cf       	rjmp	.-44     	; 0x8f72 <__ultoa_invert+0x58>
    8f9e:	b4 e0       	ldi	r27, 0x04	; 4
    8fa0:	a6 95       	lsr	r26
    8fa2:	97 95       	ror	r25
    8fa4:	87 95       	ror	r24
    8fa6:	77 95       	ror	r23
    8fa8:	67 95       	ror	r22
    8faa:	ba 95       	dec	r27
    8fac:	c9 f7       	brne	.-14     	; 0x8fa0 <__ultoa_invert+0x86>
    8fae:	00 97       	sbiw	r24, 0x00	; 0
    8fb0:	61 05       	cpc	r22, r1
    8fb2:	71 05       	cpc	r23, r1
    8fb4:	08 95       	ret
    8fb6:	9b 01       	movw	r18, r22
    8fb8:	ac 01       	movw	r20, r24
    8fba:	0a 2e       	mov	r0, r26
    8fbc:	06 94       	lsr	r0
    8fbe:	57 95       	ror	r21
    8fc0:	47 95       	ror	r20
    8fc2:	37 95       	ror	r19
    8fc4:	27 95       	ror	r18
    8fc6:	ba 95       	dec	r27
    8fc8:	c9 f7       	brne	.-14     	; 0x8fbc <__ultoa_invert+0xa2>
    8fca:	62 0f       	add	r22, r18
    8fcc:	73 1f       	adc	r23, r19
    8fce:	84 1f       	adc	r24, r20
    8fd0:	95 1f       	adc	r25, r21
    8fd2:	a0 1d       	adc	r26, r0
    8fd4:	08 95       	ret

00008fd6 <__muluhisi3>:
    8fd6:	32 da       	rcall	.-2972   	; 0x843c <__umulhisi3>
    8fd8:	a5 9f       	mul	r26, r21
    8fda:	90 0d       	add	r25, r0
    8fdc:	b4 9f       	mul	r27, r20
    8fde:	90 0d       	add	r25, r0
    8fe0:	a4 9f       	mul	r26, r20
    8fe2:	80 0d       	add	r24, r0
    8fe4:	91 1d       	adc	r25, r1
    8fe6:	11 24       	eor	r1, r1
    8fe8:	08 95       	ret

00008fea <__mulshisi3>:
    8fea:	b7 ff       	sbrs	r27, 7
    8fec:	f4 cf       	rjmp	.-24     	; 0x8fd6 <__muluhisi3>

00008fee <__mulohisi3>:
    8fee:	f3 df       	rcall	.-26     	; 0x8fd6 <__muluhisi3>
    8ff0:	82 1b       	sub	r24, r18
    8ff2:	93 0b       	sbc	r25, r19
    8ff4:	08 95       	ret

00008ff6 <_exit>:
    8ff6:	f8 94       	cli

00008ff8 <__stop_program>:
    8ff8:	ff cf       	rjmp	.-2      	; 0x8ff8 <__stop_program>
