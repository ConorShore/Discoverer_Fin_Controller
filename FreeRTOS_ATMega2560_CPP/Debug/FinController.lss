
FinController.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000011e  00800200  000095d0  00009684  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000095d0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001d61  0080031e  0080031e  000097a6  2**3
                  ALLOC
  3 .fuse         00000003  00820000  00820000  000097a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  000097a5  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00009804  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000c48  00000000  00000000  00009844  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0001646a  00000000  00000000  0000a48c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00005b33  00000000  00000000  000208f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00008ae3  00000000  00000000  00026429  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000034a4  00000000  00000000  0002ef0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00005863  00000000  00000000  000323b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000115f1  00000000  00000000  00037c13  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000cf8  00000000  00000000  00049204  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c5 09 	jmp	0x138a	; 0x138a <__ctors_end>
       4:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
       8:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
       c:	0c 94 52 10 	jmp	0x20a4	; 0x20a4 <__vector_3>
      10:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      14:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      18:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      1c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      20:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      24:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      28:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      2c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      30:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      34:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      38:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      3c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      40:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      44:	0c 94 aa 34 	jmp	0x6954	; 0x6954 <__vector_17>
      48:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      4c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      50:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      54:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      58:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      5c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      60:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      64:	0c 94 6a 38 	jmp	0x70d4	; 0x70d4 <__vector_25>
      68:	0c 94 ad 38 	jmp	0x715a	; 0x715a <__vector_26>
      6c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      70:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      74:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      78:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      7c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      80:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      84:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      88:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      8c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      90:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      94:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      98:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      9c:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      a0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      a4:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      a8:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      ac:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      b0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      b4:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      b8:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      bc:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      c0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      c4:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      c8:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      cc:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      d0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      d4:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      d8:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      dc:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      e0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__bad_interrupt>
      e4:	90 1d       	adc	r25, r0
      e6:	92 1d       	adc	r25, r2
      e8:	9c 1d       	adc	r25, r12
      ea:	94 1d       	adc	r25, r4
      ec:	96 1d       	adc	r25, r6
      ee:	98 1d       	adc	r25, r8
      f0:	90 1d       	adc	r25, r0
      f2:	9a 1d       	adc	r25, r10
      f4:	ac 2d       	mov	r26, r12
      f6:	27 2f       	mov	r18, r23
      f8:	33 2f       	mov	r19, r19
      fa:	9a 2f       	mov	r25, r26
      fc:	a6 2f       	mov	r26, r22
      fe:	c0 2f       	mov	r28, r16
     100:	d1 2f       	mov	r29, r17
     102:	be 30       	cpi	r27, 0x0E	; 14
     104:	a6 30       	cpi	r26, 0x06	; 6
     106:	a9 30       	cpi	r26, 0x09	; 9
     108:	ac 30       	cpi	r26, 0x0C	; 12
     10a:	af 30       	cpi	r26, 0x0F	; 15
     10c:	b2 30       	cpi	r27, 0x02	; 2
     10e:	b5 30       	cpi	r27, 0x05	; 5
     110:	b8 30       	cpi	r27, 0x08	; 8
     112:	ac 13       	cpse	r26, r28
     114:	de 13       	cpse	r29, r30
     116:	7f 12       	cpse	r7, r31
     118:	e8 13       	cpse	r30, r24
     11a:	89 12       	cpse	r8, r25
     11c:	93 12       	cpse	r9, r19
     11e:	9d 12       	cpse	r9, r29
     120:	a7 12       	cpse	r10, r23
     122:	d6 13       	cpse	r29, r22
     124:	d6 13       	cpse	r29, r22
     126:	af 12       	cpse	r10, r31
     128:	b7 12       	cpse	r11, r23
     12a:	bf 12       	cpse	r11, r31
     12c:	c6 12       	cpse	r12, r22
     12e:	cd 12       	cpse	r12, r29
     130:	d4 12       	cpse	r13, r20
     132:	b6 13       	cpse	r27, r22
     134:	f2 13       	cpse	r31, r18
     136:	e7 12       	cpse	r14, r23
     138:	d8 13       	cpse	r29, r24
     13a:	ef 12       	cpse	r14, r31
     13c:	f9 12       	cpse	r15, r25
     13e:	01 13       	cpse	r16, r17
     140:	0b 13       	cpse	r16, r27
     142:	13 13       	cpse	r17, r19
     144:	d8 13       	cpse	r29, r24
     146:	1d 13       	cpse	r17, r29
     148:	27 13       	cpse	r18, r23
     14a:	31 13       	cpse	r19, r17
     14c:	39 13       	cpse	r19, r25
     14e:	43 13       	cpse	r20, r19
     150:	4a 13       	cpse	r20, r26
     152:	be 13       	cpse	r27, r30
     154:	fa 13       	cpse	r31, r26
     156:	5f 13       	cpse	r21, r31
     158:	69 13       	cpse	r22, r25
     15a:	70 13       	cpse	r23, r16
     15c:	da 13       	cpse	r29, r26
     15e:	79 13       	cpse	r23, r25
     160:	82 13       	cpse	r24, r18
     162:	8c 13       	cpse	r24, r28
     164:	92 13       	cpse	r25, r18
     166:	9c 13       	cpse	r25, r28
     168:	a3 13       	cpse	r26, r19
     16a:	1e 17       	cp	r17, r30
     16c:	0b 17       	cp	r16, r27
     16e:	0d 17       	cp	r16, r29
     170:	0f 17       	cp	r16, r31
     172:	11 17       	cp	r17, r17
     174:	13 17       	cp	r17, r19
     176:	15 17       	cp	r17, r21
     178:	17 17       	cp	r17, r23
     17a:	3e 17       	cp	r19, r30
     17c:	40 17       	cp	r20, r16
     17e:	42 17       	cp	r20, r18
     180:	44 17       	cp	r20, r20
     182:	46 17       	cp	r20, r22
     184:	48 17       	cp	r20, r24
     186:	4a 17       	cp	r20, r26
     188:	4c 17       	cp	r20, r28
     18a:	50 43       	sbci	r21, 0x30	; 48
     18c:	50 43       	sbci	r21, 0x30	; 48
     18e:	50 43       	sbci	r21, 0x30	; 48
     190:	7d 43       	sbci	r23, 0x3D	; 61
     192:	85 43       	sbci	r24, 0x35	; 53
     194:	93 43       	sbci	r25, 0x33	; 51
     196:	50 43       	sbci	r21, 0x30	; 48
     198:	50 43       	sbci	r21, 0x30	; 48
     19a:	7d 43       	sbci	r23, 0x3D	; 61
     19c:	85 43       	sbci	r24, 0x35	; 53

0000019e <__trampolines_end>:
     19e:	71 75       	andi	r23, 0x51	; 81
     1a0:	65 75       	andi	r22, 0x55	; 85
     1a2:	65 20       	and	r6, r5
     1a4:	66 61       	ori	r22, 0x16	; 22
     1a6:	69 6c       	ori	r22, 0xC9	; 201
	...

000001a9 <_ZZ9CanRxFuncE3__c_6>:
     1a9:	71 75 65 75 65 20 66 61 69 6c 00                    queue fail.

000001b4 <_ZZ9CanRxFuncE3__c_5>:
     1b4:	44 61 74 61 20 25 64 20 3d 20 25 78 00              Data %d = %x.

000001c1 <_ZZ9CanRxFuncE3__c_4>:
     1c1:	44 4c 43 20 3d 20 25 75 78 0d 0a 00                 DLC = %ux...

000001cd <_ZZ9CanRxFuncE3__c_3>:
     1cd:	49 64 20 3d 20 25 75 78 0d 0a 00                    Id = %ux...

000001d8 <_ZZ9CanRxFuncE3__c_2>:
     1d8:	69 6d 70 6f 73 73 69 62 6c 65 20 70 6f 73 20 25     impossible pos %
     1e8:	64 09 63 6f 75 6e 74 20 3d 20 25 64 0d 0a 00        d.count = %d...

000001f7 <_ZZ9CanRxFuncE3__c_1>:
     1f7:	43 41 4e 20 52 65 63 20 3d 20 25 64 00              CAN Rec = %d.

00000204 <_ZZ9CanRxFuncE3__c_0>:
     204:	54 6f 6f 20 4d 61 6e 79 20 46 72 61 6d 65 73 20     Too Many Frames 
     214:	6f 72 20 77 72 6f 6e 67 20 6f 72 64 65 72 00        or wrong order.

00000223 <_ZZ9CanRxFuncE3__c>:
     223:	25 73 20 25 64 0a 00                                %s %d..

0000022a <_ZZ8can_sendE3__c>:
     22a:	63 61 6e 20 74 78 20 65 72 72 6f 72 00              can tx error.

00000237 <__c.3148>:
     237:	46 52 45 45 3a 20 25 70 00                          FREE: %p.

00000240 <__c.3146>:
     240:	46 52 45 45 3a 20 42 75 66 66 65 72 20 25 70 20     FREE: Buffer %p 
     250:	69 6e 20 75 73 65 20 62 79 20 25 75 20 75 73 65     in use by %u use
     260:	72 73 00                                            rs.

00000263 <__c.3144>:
     263:	46 52 45 45 3a 20 42 75 66 66 65 72 20 61 6c 72     FREE: Buffer alr
     273:	65 61 64 79 20 66 72 65 65 20 25 70 00              eady free %p.

00000280 <__c.3142>:
     280:	46 52 45 45 3a 20 49 6e 76 61 6c 69 64 20 43 53     FREE: Invalid CS
     290:	50 20 62 75 66 66 65 72 20 70 6f 69 6e 74 65 72     P buffer pointer
     2a0:	20 25 70 00                                          %p.

000002a4 <__c.3137>:
     2a4:	41 74 74 65 6d 70 74 20 74 6f 20 66 72 65 65 20     Attempt to free 
     2b4:	6e 75 6c 6c 20 70 6f 69 6e 74 65 72 00              null pointer.

000002c1 <__c.3127>:
     2c1:	43 6f 72 72 75 70 74 20 43 53 50 20 62 75 66 66     Corrupt CSP buff
     2d1:	65 72 00                                            er.

000002d4 <__c.3125>:
     2d4:	47 45 54 3a 20 25 70 20 25 70 00                    GET: %p %p.

000002df <__c.3123>:
     2df:	4f 75 74 20 6f 66 20 62 75 66 66 65 72 73 00        Out of buffers.

000002ee <__c.3121>:
     2ee:	41 74 74 65 6d 70 74 20 74 6f 20 61 6c 6c 6f 63     Attempt to alloc
     2fe:	61 74 65 20 74 6f 6f 20 6c 61 72 67 65 20 62 6c     ate too large bl
     30e:	6f 63 6b 20 25 75 00                                ock %u.

00000315 <__c.3326>:
     315:	5b 25 30 32 75 20 25 70 5d 20 53 3a 25 75 2c 20     [%02u %p] S:%u, 
     325:	25 75 20 2d 3e 20 25 75 2c 20 25 75 20 2d 3e 20     %u -> %u, %u -> 
     335:	25 75 2c 20 73 6f 63 6b 3a 20 25 70 0a 00           %u, sock: %p..

00000343 <__c.3299>:
     343:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     353:	65 20 58 54 45 41 20 65 6e 63 72 79 70 74 65 64     e XTEA encrypted
     363:	20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74      connection, but
     373:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     383:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     393:	75 70 70 6f 72 74 00                                upport.

0000039a <__c.3297>:
     39a:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     3aa:	65 20 48 4d 41 43 20 61 75 74 68 65 6e 74 69 63     e HMAC authentic
     3ba:	61 74 65 64 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c     ated connection,
     3ca:	20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d      but CSP was com
     3da:	70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48 4d     piled without HM
     3ea:	41 43 20 73 75 70 70 6f 72 74 00                    AC support.

000003f5 <__c.3295>:
     3f5:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     405:	65 20 52 44 50 20 63 6f 6e 6e 65 63 74 69 6f 6e     e RDP connection
     415:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     425:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 52     mpiled without R
     435:	44 50 20 73 75 70 70 6f 72 74 00                    DP support.

00000440 <__c.3284>:
     440:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     450:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

0000045a <__c.3282>:
     45a:	43 6f 6e 6e 20 61 6c 72 65 61 64 79 20 63 6c 6f     Conn already clo
     46a:	73 65 64 00                                         sed.

0000046e <__c.3280>:
     46e:	4e 55 4c 4c 20 50 6f 69 6e 74 65 72 20 67 69 76     NULL Pointer giv
     47e:	65 6e 20 74 6f 20 63 73 70 5f 63 6c 6f 73 65 00     en to csp_close.

0000048e <__c.3270>:
     48e:	4e 6f 20 6d 6f 72 65 20 66 72 65 65 20 63 6f 6e     No more free con
     49e:	6e 65 63 74 69 6f 6e 73 00                          nections.

000004a7 <__c.3265>:
     4a7:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     4b7:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

000004c1 <__c.3236>:
     4c1:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     4d1:	6f 72 20 63 6f 6e 6e 20 73 65 6d 61 70 68 6f 72     or conn semaphor
     4e1:	65 00                                               e.

000004e3 <__c.3231>:
     4e3:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
     4f3:	20 63 6f 6e 6e 65 63 74 69 6f 6e 20 6c 6f 63 6b      connection lock
	...

00000504 <__c.3224>:
     504:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     514:	6f 72 20 73 70 6f 72 74 20 73 65 6d 61 70 68 6f     or sport semapho
     524:	72 65 00                                            re.

00000527 <__c.3219>:
     527:	52 58 20 71 75 65 75 65 20 25 70 20 66 75 6c 6c     RX queue %p full
     537:	20 77 69 74 68 20 25 75 20 69 74 65 6d 73 00         with %u items.

00000546 <crc_tab>:
     546:	00 00 00 00 03 83 6b f2 f7 70 3b e1 f4 f3 50 13     ......k..p;...P.
     556:	1f 97 9a c7 1c 14 f1 35 e8 e7 a1 26 eb 64 ca d4     .......5...&.d..
     566:	cf 58 d9 8a cc db b2 78 38 28 e2 6b 3b ab 89 99     .X.....x8(.k;...
     576:	d0 cf 43 4d d3 4c 28 bf 27 bf 78 ac 24 3c 13 5e     ..CM.L(.'.x.$<.^
     586:	6f c7 5e 10 6c 44 35 e2 98 b7 65 f1 9b 34 0e 03     o.^.lD5...e..4..
     596:	70 50 c4 d7 73 d3 af 25 87 20 ff 36 84 a3 94 c4     pP..s..%. .6....
     5a6:	a0 9f 87 9a a3 1c ec 68 57 ef bc 7b 54 6c d7 89     .......hW..{Tl..
     5b6:	bf 08 1d 5d bc 8b 76 af 48 78 26 bc 4b fb 4d 4e     ...]..v.Hx&.K.MN
     5c6:	de 8e bd 20 dd 0d d6 d2 29 fe 86 c1 2a 7d ed 33     ... ....)...*}.3
     5d6:	c1 19 27 e7 c2 9a 4c 15 36 69 1c 06 35 ea 77 f4     ..'...L.6i..5.w.
     5e6:	11 d6 64 aa 12 55 0f 58 e6 a6 5f 4b e5 25 34 b9     ..d..U.X.._K.%4.
     5f6:	0e 41 fe 6d 0d c2 95 9f f9 31 c5 8c fa b2 ae 7e     .A.m.....1.....~
     606:	b1 49 e3 30 b2 ca 88 c2 46 39 d8 d1 45 ba b3 23     .I.0....F9..E..#
     616:	ae de 79 f7 ad 5d 12 05 59 ae 42 16 5a 2d 29 e4     ..y..]..Y.B.Z-).
     626:	7e 11 3a ba 7d 92 51 48 89 61 01 5b 8a e2 6a a9     ~.:.}.QH.a.[..j.
     636:	61 86 a0 7d 62 05 cb 8f 96 f6 9b 9c 95 75 f0 6e     a..}b........u.n
     646:	bc 1d 7b 41 bf 9e 10 b3 4b 6d 40 a0 48 ee 2b 52     ..{A....Km@.H.+R
     656:	a3 8a e1 86 a0 09 8a 74 54 fa da 67 57 79 b1 95     .......tT..gWy..
     666:	73 45 a2 cb 70 c6 c9 39 84 35 99 2a 87 b6 f2 d8     sE..p..9.5.*....
     676:	6c d2 38 0c 6f 51 53 fe 9b a2 03 ed 98 21 68 1f     l.8.oQS......!h.
     686:	d3 da 25 51 d0 59 4e a3 24 aa 1e b0 27 29 75 42     ..%Q.YN.$...')uB
     696:	cc 4d bf 96 cf ce d4 64 3b 3d 84 77 38 be ef 85     .M.....d;=.w8...
     6a6:	1c 82 fc db 1f 01 97 29 eb f2 c7 3a e8 71 ac c8     .......)...:.q..
     6b6:	03 15 66 1c 00 96 0d ee f4 65 5d fd f7 e6 36 0f     ..f......e]...6.
     6c6:	62 93 c6 61 61 10 ad 93 95 e3 fd 80 96 60 96 72     b..aa........`.r
     6d6:	7d 04 5c a6 7e 87 37 54 8a 74 67 47 89 f7 0c b5     }.\.~.7T.tgG....
     6e6:	ad cb 1f eb ae 48 74 19 5a bb 24 0a 59 38 4f f8     .....Ht.Z.$.Y8O.
     6f6:	b2 5c 85 2c b1 df ee de 45 2c be cd 46 af d5 3f     .\.,....E,..F..?
     706:	0d 54 98 71 0e d7 f3 83 fa 24 a3 90 f9 a7 c8 62     .T.q.....$.....b
     716:	12 c3 02 b6 11 40 69 44 e5 b3 39 57 e6 30 52 a5     .....@iD..9W.0R.
     726:	c2 0c 41 fb c1 8f 2a 09 35 7c 7a 1a 36 ff 11 e8     ..A...*.5|z.6...
     736:	dd 9b db 3c de 18 b0 ce 2a eb e0 dd 29 68 8b 2f     ...<....*...)h./
     746:	78 3b f6 82 7b b8 9d 70 8f 4b cd 63 8c c8 a6 91     x;..{..p.K.c....
     756:	67 ac 6c 45 64 2f 07 b7 90 dc 57 a4 93 5f 3c 56     g.lEd/....W.._<V
     766:	b7 63 2f 08 b4 e0 44 fa 40 13 14 e9 43 90 7f 1b     .c/...D.@...C...
     776:	a8 f4 b5 cf ab 77 de 3d 5f 84 8e 2e 5c 07 e5 dc     .....w.=_...\...
     786:	17 fc a8 92 14 7f c3 60 e0 8c 93 73 e3 0f f8 81     .......`...s....
     796:	08 6b 32 55 0b e8 59 a7 ff 1b 09 b4 fc 98 62 46     .k2U..Y.......bF
     7a6:	d8 a4 71 18 db 27 1a ea 2f d4 4a f9 2c 57 21 0b     ..q..'../.J.,W!.
     7b6:	c7 33 eb df c4 b0 80 2d 30 43 d0 3e 33 c0 bb cc     .3.....-0C.>3...
     7c6:	a6 b5 4b a2 a5 36 20 50 51 c5 70 43 52 46 1b b1     ..K..6 PQ.pCRF..
     7d6:	b9 22 d1 65 ba a1 ba 97 4e 52 ea 84 4d d1 81 76     .".e....NR..M..v
     7e6:	69 ed 92 28 6a 6e f9 da 9e 9d a9 c9 9d 1e c2 3b     i..(jn.........;
     7f6:	76 7a 08 ef 75 f9 63 1d 81 0a 33 0e 82 89 58 fc     vz..u.c...3...X.
     806:	c9 72 15 b2 ca f1 7e 40 3e 02 2e 53 3d 81 45 a1     .r....~@>..S=.E.
     816:	d6 e5 8f 75 d5 66 e4 87 21 95 b4 94 22 16 df 66     ...u.f..!..."..f
     826:	06 2a cc 38 05 a9 a7 ca f1 5a f7 d9 f2 d9 9c 2b     .*.8.....Z.....+
     836:	19 bd 56 ff 1a 3e 3d 0d ee cd 6d 1e ed 4e 06 ec     ..V..>=...m..N..
     846:	c4 26 8d c3 c7 a5 e6 31 33 56 b6 22 30 d5 dd d0     .&.....13V."0...
     856:	db b1 17 04 d8 32 7c f6 2c c1 2c e5 2f 42 47 17     .....2|.,.,./BG.
     866:	0b 7e 54 49 08 fd 3f bb fc 0e 6f a8 ff 8d 04 5a     .~TI..?...o....Z
     876:	14 e9 ce 8e 17 6a a5 7c e3 99 f5 6f e0 1a 9e 9d     .....j.|...o....
     886:	ab e1 d3 d3 a8 62 b8 21 5c 91 e8 32 5f 12 83 c0     .....b.!\..2_...
     896:	b4 76 49 14 b7 f5 22 e6 43 06 72 f5 40 85 19 07     .vI...".C.r.@...
     8a6:	64 b9 0a 59 67 3a 61 ab 93 c9 31 b8 90 4a 5a 4a     d..Yg:a...1..JZJ
     8b6:	7b 2e 90 9e 78 ad fb 6c 8c 5e ab 7f 8f dd c0 8d     {...x..l.^......
     8c6:	1a a8 30 e3 19 2b 5b 11 ed d8 0b 02 ee 5b 60 f0     ..0..+[......[`.
     8d6:	05 3f aa 24 06 bc c1 d6 f2 4f 91 c5 f1 cc fa 37     .?.$.....O.....7
     8e6:	d5 f0 e9 69 d6 73 82 9b 22 80 d2 88 21 03 b9 7a     ...i.s.."...!..z
     8f6:	ca 67 73 ae c9 e4 18 5c 3d 17 48 4f 3e 94 23 bd     .gs....\=.HO>.#.
     906:	75 6f 6e f3 76 ec 05 01 82 1f 55 12 81 9c 3e e0     uon.v.....U...>.
     916:	6a f8 f4 34 69 7b 9f c6 9d 88 cf d5 9e 0b a4 27     j..4i{.........'
     926:	ba 37 b7 79 b9 b4 dc 8b 4d 47 8c 98 4e c4 e7 6a     .7.y....MG..N..j
     936:	a5 a0 2d be a6 23 46 4c 52 d0 16 5f 51 53 7d ad     ..-..#FLR.._QS}.

00000946 <__c.2576>:
     946:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

00000953 <__c.2572>:
     953:	43 53 50 20 52 45 53 45 54 20 25 73 00              CSP RESET %s.

00000960 <__c.2570>:
     960:	0d 0a 00                                            ...

00000963 <__c.2543>:
     963:	25 2e 31 66 25 63 00                                %.1f%c.

0000096a <__c.2551>:
     96a:	25 2d 35 73 20 20 20 74 78 3a 20 25 30 35 6c 75     %-5s   tx: %05lu
     97a:	20 72 78 3a 20 25 30 35 6c 75 20 74 78 65 3a 20      rx: %05lu txe: 
     98a:	25 30 35 6c 75 20 72 78 65 3a 20 25 30 35 6c 75     %05lu rxe: %05lu
     99a:	0d 0a 20 20 20 20 20 20 20 20 64 72 6f 70 3a 20     ..        drop: 
     9aa:	25 30 35 6c 75 20 61 75 74 68 65 72 72 3a 20 25     %05lu autherr: %
     9ba:	30 35 6c 75 20 66 72 61 6d 65 3a 20 25 30 35 6c     05lu frame: %05l
     9ca:	75 0d 0a 20 20 20 20 20 20 20 20 74 78 62 3a 20     u..        txb: 
     9da:	25 6c 75 20 28 25 73 29 20 72 78 62 3a 20 25 6c     %lu (%s) rxb: %l
     9ea:	75 20 28 25 73 29 0d 0a 0d 0a 00                    u (%s).....

000009f5 <__c.3321>:
     9f5:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
     a05:	41 4e 20 66 72 61 6d 65 20 69 6e 20 54 78 20 63     AN frame in Tx c
     a15:	61 6c 6c 62 61 63 6b 00                             allback.

00000a1d <__c.3318>:
     a1d:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
     a2d:	41 4e 20 66 72 61 6d 65 20 69 6e 20 63 73 70 5f     AN frame in csp_
     a3d:	74 78 5f 63 61 6e 00                                tx_can.

00000a44 <__c.3313>:
     a44:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 43 46     Failed to get CF
     a54:	50 20 69 64 65 6e 74 69 66 69 63 61 74 69 6f 6e     P identification
     a64:	20 6e 75 6d 62 65 72 00                              number.

00000a6c <__c.3200>:
     a6c:	43 6f 75 6c 64 20 6e 6f 74 20 69 6e 69 74 69 61     Could not initia
     a7c:	6c 69 7a 65 20 43 46 50 20 69 64 20 73 65 6d 61     lize CFP id sema
     a8c:	70 68 6f 72 65 00                                   phore.

00000a92 <__c.3288>:
     a92:	52 65 63 65 69 76 65 64 20 75 6e 6b 6e 6f 77 6e     Received unknown
     aa2:	20 43 46 50 20 6d 65 73 73 61 67 65 20 74 79 70      CFP message typ
     ab2:	65 00                                               e.

00000ab4 <__c.3285>:
     ab4:	52 58 20 62 75 66 66 65 72 20 6f 76 65 72 66 6c     RX buffer overfl
     ac4:	6f 77 00                                            ow.

00000ac7 <__c.3283>:
     ac7:	43 41 4e 20 66 72 61 6d 65 20 6c 6f 73 74 20 69     CAN frame lost i
     ad7:	6e 20 43 53 50 20 70 61 63 6b 65 74 00              n CSP packet.

00000ae4 <__c.3280>:
     ae4:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 62 75     Failed to get bu
     af4:	66 66 65 72 20 66 6f 72 20 43 53 50 5f 42 45 47     ffer for CSP_BEG
     b04:	49 4e 20 70 61 63 6b 65 74 00                       IN packet.

00000b0e <__c.3278>:
     b0e:	49 6e 63 6f 6d 70 6c 65 74 65 20 66 72 61 6d 65     Incomplete frame
	...

00000b1f <__c.3275>:
     b1f:	53 68 6f 72 74 20 42 45 47 49 4e 20 66 72 61 6d     Short BEGIN fram
     b2f:	65 20 72 65 63 65 69 76 65 64 00                    e received.

00000b3a <__c.3272>:
     b3a:	4f 75 74 20 6f 66 20 6f 72 64 65 72 20 4d 4f 52     Out of order MOR
     b4a:	45 20 66 72 61 6d 65 20 72 65 63 65 69 76 65 64     E frame received
	...

00000b5b <__c.3270>:
     b5b:	4e 6f 20 61 76 61 69 6c 61 62 6c 65 20 70 61 63     No available pac
     b6b:	6b 65 74 20 62 75 66 66 65 72 20 66 6f 72 20 43     ket buffer for C
     b7b:	41 4e 00                                            AN.

00000b7e <__c.3259>:
     b7e:	43 41 4e 20 42 75 66 66 65 72 20 65 6c 65 6d 65     CAN Buffer eleme
     b8e:	6e 74 20 74 69 6d 65 64 20 6f 75 74 00              nt timed out.

00000b9b <__c.3343>:
     b9b:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
     bab:	6c 69 7a 65 20 43 41 4e 20 64 72 69 76 65 72 00     lize CAN driver.

00000bbb <__c.3340>:
     bbb:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 20 43     Failed to init C
     bcb:	41 4e 20 52 58 20 74 61 73 6b 00                    AN RX task.

00000bd6 <__c.3338>:
     bd6:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
     be6:	20 43 41 4e 20 52 58 20 71 75 65 75 65 00            CAN RX queue.

00000bf4 <__c.3336>:
     bf4:	55 6e 6b 6e 6f 77 6e 20 43 41 4e 20 6d 6f 64 65     Unknown CAN mode
	...

00000c05 <__c.3334>:
     c05:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
     c15:	6c 69 7a 65 20 43 41 4e 20 69 64 65 6e 74 69 66     lize CAN identif
     c25:	69 63 61 74 69 6f 6e 20 6e 75 6d 62 65 72 00        ication number.

00000c34 <__c.3384>:
     c34:	49 6e 76 61 6c 69 64 20 63 61 6c 6c 20 74 6f 20     Invalid call to 
     c44:	63 73 70 5f 73 65 6e 64 00                          csp_send.

00000c4d <__c.3374>:
     c4d:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     c5d:	58 54 45 41 20 65 6e 63 72 79 70 74 65 64 20 70     XTEA encrypted p
     c6d:	61 63 6b 65 74 2c 20 62 75 74 20 43 53 50 20 77     acket, but CSP w
     c7d:	61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68     as compiled with
     c8d:	6f 75 74 20 58 54 45 41 20 73 75 70 70 6f 72 74     out XTEA support
     c9d:	2e 20 44 69 73 63 61 72 64 69 6e 67 20 70 61 63     . Discarding pac
     cad:	6b 65 74 00                                         ket.

00000cb1 <__c.3372>:
     cb1:	43 52 43 33 32 20 61 70 70 65 6e 64 20 66 61 69     CRC32 append fai
     cc1:	6c 65 64 21 00                                      led!.

00000cc6 <__c.3369>:
     cc6:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     cd6:	70 61 63 6b 65 74 20 77 69 74 68 20 48 4d 41 43     packet with HMAC
     ce6:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     cf6:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48     mpiled without H
     d06:	4d 41 43 20 73 75 70 70 6f 72 74 2e 20 44 69 73     MAC support. Dis
     d16:	63 61 72 64 69 6e 67 20 70 61 63 6b 65 74 00        carding packet.

00000d25 <__c.3367>:
     d25:	4f 55 54 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     OUT: S %u, D %u,
     d35:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
     d45:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
     d55:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

00000d64 <__c.3365>:
     d64:	4e 6f 20 72 6f 75 74 65 20 74 6f 20 68 6f 73 74     No route to host
     d74:	3a 20 25 23 30 38 78 00                             : %#08x.

00000d7c <__c.3362>:
     d7c:	63 73 70 5f 73 65 6e 64 5f 64 69 72 65 63 74 20     csp_send_direct 
     d8c:	63 61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c     called with NULL
     d9c:	20 70 61 63 6b 65 74 00                              packet.

00000da4 <__c.3343>:
     da4:	49 6e 76 61 6c 69 64 20 73 6f 63 6b 65 74 20 6f     Invalid socket o
     db4:	70 74 69 6f 6e 00                                   ption.

00000dba <__c.3341>:
     dba:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     dca:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     dda:	71 75 69 72 65 73 20 48 4d 41 43 2c 20 62 75 74     quires HMAC, but
     dea:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     dfa:	64 20 77 69 74 68 6f 75 74 20 48 4d 41 43 20 73     d without HMAC s
     e0a:	75 70 70 6f 72 74 00                                upport.

00000e11 <__c.3339>:
     e11:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     e21:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     e31:	71 75 69 72 65 73 20 58 54 45 41 2c 20 62 75 74     quires XTEA, but
     e41:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     e51:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     e61:	75 70 70 6f 72 74 00                                upport.

00000e68 <__c.3337>:
     e68:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     e78:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     e88:	71 75 69 72 65 73 20 52 44 50 2c 20 62 75 74 20     quires RDP, but 
     e98:	43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64     CSP was compiled
     ea8:	20 77 69 74 68 6f 75 74 20 52 44 50 20 73 75 70      without RDP sup
     eb8:	70 6f 72 74 00                                      port.

00000ebd <__c.3192>:
     ebd:	42 69 6e 64 69 6e 67 20 73 6f 63 6b 65 74 20 25     Binding socket %
     ecd:	70 20 74 6f 20 70 6f 72 74 20 25 75 00              p to port %u.

00000eda <__c.3190>:
     eda:	50 6f 72 74 20 25 64 20 69 73 20 61 6c 72 65 61     Port %d is alrea
     eea:	64 79 20 69 6e 20 75 73 65 00                       dy in use.

00000ef4 <__c.3188>:
     ef4:	4f 6e 6c 79 20 70 6f 72 74 73 20 66 72 6f 6d 20     Only ports from 
     f04:	30 2d 25 75 20 28 61 6e 64 20 43 53 50 5f 41 4e     0-%u (and CSP_AN
     f14:	59 20 66 6f 72 20 64 65 66 61 75 6c 74 29 20 61     Y for default) a
     f24:	72 65 20 61 76 61 69 6c 61 62 6c 65 20 66 6f 72     re available for
     f34:	20 69 6e 63 6f 6d 69 6e 67 20 70 6f 72 74 73 00      incoming ports.

00000f44 <__c.2386>:
     f44:	45 52 52 4f 52 3a 20 52 6f 75 74 69 6e 67 20 69     ERROR: Routing i
     f54:	6e 70 75 74 20 46 49 46 4f 20 69 73 20 46 55 4c     nput FIFO is FUL
     f64:	4c 2e 20 44 72 6f 70 70 69 6e 67 20 70 61 63 6b     L. Dropping pack
     f74:	65 74 2e 00                                         et..

00000f78 <__c.2382>:
     f78:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     f88:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     f98:	69 6e 74 65 72 66 61 63 65 00                       interface.

00000fa2 <__c.2380>:
     fa2:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     fb2:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     fc2:	70 61 63 6b 65 74 00                                packet.

00000fc9 <__c.3124>:
     fc9:	25 73 20 25 64 0a 00                                %s %d..

00000fd0 <__c.3133>:
     fd0:	46 61 69 6c 65 64 20 74 6f 20 73 74 61 72 74 20     Failed to start 
     fe0:	72 6f 75 74 65 72 20 74 61 73 6b 00                 router task.

00000fec <__c.3102>:
     fec:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
     ffc:	77 69 74 68 6f 75 74 20 43 52 43 33 32 2e 20 41     without CRC32. A
    100c:	63 63 65 70 74 69 6e 67 20 70 61 63 6b 65 74 00     ccepting packet.

0000101c <__c.3100>:
    101c:	43 52 43 33 32 20 76 65 72 69 66 69 63 61 74 69     CRC32 verificati
    102c:	6f 6e 20 65 72 72 6f 72 21 20 44 69 73 63 61 72     on error! Discar
    103c:	64 69 6e 67 20 70 61 63 6b 65 74 00                 ding packet.

00001048 <__c.3098>:
    1048:	54 6f 6f 20 73 68 6f 72 74 20 70 61 63 6b 65 74     Too short packet
    1058:	20 66 6f 72 20 43 52 43 33 32 2c 20 25 75 00         for CRC32, %u.

00001067 <__c.3091>:
    1067:	52 65 63 65 69 76 65 64 20 52 44 50 20 70 61 63     Received RDP pac
    1077:	6b 65 74 2c 20 62 75 74 20 43 53 50 20 77 61 73     ket, but CSP was
    1087:	20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68 6f 75      compiled withou
    1097:	74 20 52 44 50 20 73 75 70 70 6f 72 74 2e 20 44     t RDP support. D
    10a7:	69 73 63 61 72 64 69 6e 67 20 70 61 63 6b 65 74     iscarding packet
	...

000010b8 <__c.3089>:
    10b8:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
    10c8:	77 69 74 68 20 48 4d 41 43 2c 20 62 75 74 20 43     with HMAC, but C
    10d8:	53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20     SP was compiled 
    10e8:	77 69 74 68 6f 75 74 20 48 4d 41 43 20 73 75 70     without HMAC sup
    10f8:	70 6f 72 74 2e 20 44 69 73 63 61 72 64 69 6e 67     port. Discarding
    1108:	20 70 61 63 6b 65 74 00                              packet.

00001110 <__c.3087>:
    1110:	52 65 63 65 69 76 65 64 20 58 54 45 41 20 65 6e     Received XTEA en
    1120:	63 72 79 70 74 65 64 20 70 61 63 6b 65 74 2c 20     crypted packet, 
    1130:	62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70     but CSP was comp
    1140:	69 6c 65 64 20 77 69 74 68 6f 75 74 20 58 54 45     iled without XTE
    1150:	41 20 73 75 70 70 6f 72 74 2e 20 44 69 73 63 61     A support. Disca
    1160:	72 64 69 6e 67 20 70 61 63 6b 65 74 00              rding packet.

0000116d <__c.3119>:
    116d:	4e 6f 20 6d 6f 72 65 20 63 6f 6e 6e 65 63 74 69     No more connecti
    117d:	6f 6e 73 20 61 76 61 69 6c 61 62 6c 65 00           ons available.

0000118b <__c.3116>:
    118b:	43 6f 6e 6e 2d 6c 65 73 73 20 73 6f 63 6b 65 74     Conn-less socket
    119b:	20 71 75 65 75 65 20 66 75 6c 6c 00                  queue full.

000011a7 <__c.3114>:
    11a7:	52 6f 75 74 65 72 20 66 61 69 6c 65 64 20 74 6f     Router failed to
    11b7:	20 73 65 6e 64 00                                    send.

000011bd <__c.3111>:
    11bd:	49 4e 50 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     INP: S %u, D %u,
    11cd:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
    11dd:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
    11ed:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

000011fc <__c.2565>:
    11fc:	20 20 20 2a 20 20 25 2d 39 73 20 20 25 75 0d 0a        *  %-9s  %u..
	...

0000120d <__c.2560>:
    120d:	25 34 75 20 20 25 2d 39 73 20 20 25 75 0d 0a 00     %4u  %-9s  %u...

0000121d <__c.2558>:
    121d:	4e 6f 64 65 20 20 49 6e 74 65 72 66 61 63 65 20     Node  Interface 
    122d:	20 41 64 64 72 65 73 73 0d 0a 00                     Address...

00001238 <__c.2552>:
    1238:	46 61 69 6c 65 64 20 74 6f 20 73 65 74 20 72 6f     Failed to set ro
    1248:	75 74 65 3a 20 69 6e 76 61 6c 69 64 20 6e 6f 64     ute: invalid nod
    1258:	65 20 69 64 20 25 75 00                             e id %u.

00001260 <__c.3117>:
    1260:	50 6f 73 74 3a 20 25 70 00                          Post: %p.

00001269 <__c.3112>:
    1269:	57 61 69 74 3a 20 25 70 00                          Wait: %p.

00001272 <__c.3139>:
    1272:	53 45 52 56 49 43 45 3a 20 50 69 6e 67 20 72 65     SERVICE: Ping re
    1282:	63 65 69 76 65 64 00                                ceived.

00001289 <__c.2850>:
    1289:	1b 5b 25 75 3b 25 75 6d 00                          .[%u;%um.

00001292 <__c.2824>:
    1292:	46 61 69 6c 65 64 20 74 6f 20 73 68 75 74 64 6f     Failed to shutdo
    12a2:	77 6e 00                                            wn.

000012a5 <__c.2814>:
    12a5:	46 61 69 6c 65 64 20 74 6f 20 72 65 62 6f 6f 74     Failed to reboot
	...

000012b6 <__c.2836>:
    12b6:	57 61 72 6e 69 6e 67 20 73 6f 63 6b 65 74 20 63     Warning socket c
    12c6:	6f 6e 6e 65 63 74 69 6f 6e 20 71 75 65 75 65 20     onnection queue 
    12d6:	66 75 6c 6c 00                                      full.

000012db <__c.2834>:
    12db:	43 6f 6e 6e 65 63 74 69 6f 6e 20 62 75 66 66 65     Connection buffe
    12eb:	72 20 71 75 65 75 65 20 66 75 6c 6c 21 00           r queue full!.

000012f9 <_ZZ11task_serverPvE3__c>:
    12f9:	25 73 20 25 64 0a 00                                %s %d..

00001300 <_ZZ16__vector_defaultE3__c_0>:
    1300:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

0000130d <_ZZ16__vector_defaultE3__c>:
    130d:	55 6e 65 78 20 56 65 63 74 6f 72 00                 Unex Vector.

00001319 <_ZZ11task_clientPvE3__c_2>:
    1319:	50 69 6e 67 20 72 65 73 75 6c 74 20 25 64 20 5b     Ping result %d [
    1329:	6d 73 5d 0d 0a 00                                   ms]...

0000132f <_ZZ11task_clientPvE3__c_1>:
    132f:	50 69 6e 67 20 46 61 69 6c 65 64 0a 00              Ping Failed..

0000133c <_ZZ11task_clientPvE3__c_0>:
    133c:	53 50 20 3d 20 30 78 25 30 34 78 0a 00              SP = 0x%04x..

00001349 <_ZZ11task_clientPvE3__c>:
    1349:	25 73 20 25 64 0a 00                                %s %d..

00001350 <_ZZ4mainE3__c_3>:
    1350:	49 6e 74 65 72 66 61 63 65 73 0d 0a 00              Interfaces...

0000135d <_ZZ4mainE3__c_2>:
    135d:	52 6f 75 74 65 20 74 61 62 6c 65 0d 0a 00           Route table...

0000136b <_ZZ4mainE3__c_1>:
    136b:	43 6f 6e 6e 20 74 61 62 6c 65 0d 0a 00              Conn table...

00001378 <_ZZ4mainE3__c_0>:
    1378:	53 65 74 75 70 20 45 72 72 6f 72 00                 Setup Error.

00001384 <_ZZ4mainE3__c>:
    1384:	25 64 00 00                                         %d..

00001388 <__ctors_start>:
    1388:	cc 0c       	add	r12, r12

0000138a <__ctors_end>:
    138a:	11 24       	eor	r1, r1
    138c:	1f be       	out	0x3f, r1	; 63
    138e:	cf ef       	ldi	r28, 0xFF	; 255
    1390:	d1 e2       	ldi	r29, 0x21	; 33
    1392:	de bf       	out	0x3e, r29	; 62
    1394:	cd bf       	out	0x3d, r28	; 61
    1396:	00 e0       	ldi	r16, 0x00	; 0
    1398:	0c bf       	out	0x3c, r16	; 60

0000139a <__do_copy_data>:
    139a:	13 e0       	ldi	r17, 0x03	; 3
    139c:	a0 e0       	ldi	r26, 0x00	; 0
    139e:	b2 e0       	ldi	r27, 0x02	; 2
    13a0:	e0 ed       	ldi	r30, 0xD0	; 208
    13a2:	f5 e9       	ldi	r31, 0x95	; 149
    13a4:	00 e0       	ldi	r16, 0x00	; 0
    13a6:	0b bf       	out	0x3b, r16	; 59
    13a8:	02 c0       	rjmp	.+4      	; 0x13ae <__do_copy_data+0x14>
    13aa:	07 90       	elpm	r0, Z+
    13ac:	0d 92       	st	X+, r0
    13ae:	ae 31       	cpi	r26, 0x1E	; 30
    13b0:	b1 07       	cpc	r27, r17
    13b2:	d9 f7       	brne	.-10     	; 0x13aa <__do_copy_data+0x10>

000013b4 <__do_clear_bss>:
    13b4:	20 e2       	ldi	r18, 0x20	; 32
    13b6:	ae e1       	ldi	r26, 0x1E	; 30
    13b8:	b3 e0       	ldi	r27, 0x03	; 3
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <.do_clear_bss_start>

000013bc <.do_clear_bss_loop>:
    13bc:	1d 92       	st	X+, r1

000013be <.do_clear_bss_start>:
    13be:	af 37       	cpi	r26, 0x7F	; 127
    13c0:	b2 07       	cpc	r27, r18
    13c2:	e1 f7       	brne	.-8      	; 0x13bc <.do_clear_bss_loop>

000013c4 <__do_global_ctors>:
    13c4:	19 e0       	ldi	r17, 0x09	; 9
    13c6:	c5 ec       	ldi	r28, 0xC5	; 197
    13c8:	d9 e0       	ldi	r29, 0x09	; 9
    13ca:	00 e0       	ldi	r16, 0x00	; 0
    13cc:	06 c0       	rjmp	.+12     	; 0x13da <__do_global_ctors+0x16>
    13ce:	21 97       	sbiw	r28, 0x01	; 1
    13d0:	01 09       	sbc	r16, r1
    13d2:	80 2f       	mov	r24, r16
    13d4:	fe 01       	movw	r30, r28
    13d6:	0e 94 01 45 	call	0x8a02	; 0x8a02 <__tablejump2__>
    13da:	c4 3c       	cpi	r28, 0xC4	; 196
    13dc:	d1 07       	cpc	r29, r17
    13de:	80 e0       	ldi	r24, 0x00	; 0
    13e0:	08 07       	cpc	r16, r24
    13e2:	a9 f7       	brne	.-22     	; 0x13ce <__do_global_ctors+0xa>
    13e4:	9a d5       	rcall	.+2868   	; 0x1f1a <main>
    13e6:	0c 94 e6 4a 	jmp	0x95cc	; 0x95cc <_exit>

000013ea <__bad_interrupt>:
    13ea:	97 c6       	rjmp	.+3374   	; 0x211a <__vector_default>

000013ec <can_init>:
	
#define RETRY_NO 8



int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
    13ec:	8f 92       	push	r8
    13ee:	9f 92       	push	r9
    13f0:	af 92       	push	r10
    13f2:	bf 92       	push	r11
    13f4:	cf 92       	push	r12
    13f6:	df 92       	push	r13
    13f8:	ef 92       	push	r14
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	6b 01       	movw	r12, r22
    1406:	7c 01       	movw	r14, r24
    1408:	49 01       	movw	r8, r18
    140a:	5a 01       	movw	r10, r20
	int error = 0;
	portENTER_CRITICAL();
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	f8 94       	cli
    1410:	0f 92       	push	r0
		SPI.begin();
    1412:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <_ZN8SPIClass5beginEv>
			errorfunc(mcp2515.reset(),error);
    1416:	80 ef       	ldi	r24, 0xF0	; 240
    1418:	93 e0       	ldi	r25, 0x03	; 3
    141a:	ac d7       	rcall	.+3928   	; 0x2374 <_ZN7MCP25155resetEv>
    141c:	d8 2f       	mov	r29, r24
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    141e:	6f e0       	ldi	r22, 0x0F	; 15
    1420:	80 ef       	ldi	r24, 0xF0	; 240
    1422:	93 e0       	ldi	r25, 0x03	; 3
    1424:	0e 94 09 14 	call	0x2812	; 0x2812 <_ZN7MCP251510setBitrateE9CAN_SPEED>
    1428:	81 11       	cpse	r24, r1
    142a:	0b c0       	rjmp	.+22     	; 0x1442 <can_init+0x56>

int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
	int error = 0;
	portENTER_CRITICAL();
		SPI.begin();
			errorfunc(mcp2515.reset(),error);
    142c:	81 e0       	ldi	r24, 0x01	; 1
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	d1 11       	cpse	r29, r1
    1432:	02 c0       	rjmp	.+4      	; 0x1438 <can_init+0x4c>
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	cc 27       	eor	r28, r28
    143a:	dd 27       	eor	r29, r29
    143c:	c8 1b       	sub	r28, r24
    143e:	d9 0b       	sbc	r29, r25
    1440:	02 c0       	rjmp	.+4      	; 0x1446 <can_init+0x5a>
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    1442:	cf ef       	ldi	r28, 0xFF	; 255
    1444:	df ef       	ldi	r29, 0xFF	; 255
			//printf(" mask = %lx",mask);
			//while(1);
			errorfunc(mcp2515.setFilterMask(MCP2515::MASK0,1,mask),error);
    1446:	95 01       	movw	r18, r10
    1448:	84 01       	movw	r16, r8
    144a:	41 e0       	ldi	r20, 0x01	; 1
    144c:	60 e0       	ldi	r22, 0x00	; 0
    144e:	80 ef       	ldi	r24, 0xF0	; 240
    1450:	93 e0       	ldi	r25, 0x03	; 3
    1452:	0e 94 5c 14 	call	0x28b8	; 0x28b8 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    1456:	88 23       	and	r24, r24
    1458:	11 f0       	breq	.+4      	; 0x145e <can_init+0x72>
    145a:	cf ef       	ldi	r28, 0xFF	; 255
    145c:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilterMask(MCP2515::MASK1,1,mask),error);
    145e:	95 01       	movw	r18, r10
    1460:	84 01       	movw	r16, r8
    1462:	41 e0       	ldi	r20, 0x01	; 1
    1464:	61 e0       	ldi	r22, 0x01	; 1
    1466:	80 ef       	ldi	r24, 0xF0	; 240
    1468:	93 e0       	ldi	r25, 0x03	; 3
    146a:	0e 94 5c 14 	call	0x28b8	; 0x28b8 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    146e:	88 23       	and	r24, r24
    1470:	11 f0       	breq	.+4      	; 0x1476 <can_init+0x8a>
    1472:	cf ef       	ldi	r28, 0xFF	; 255
    1474:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF0,1,id),error);
    1476:	97 01       	movw	r18, r14
    1478:	86 01       	movw	r16, r12
    147a:	41 e0       	ldi	r20, 0x01	; 1
    147c:	60 e0       	ldi	r22, 0x00	; 0
    147e:	80 ef       	ldi	r24, 0xF0	; 240
    1480:	93 e0       	ldi	r25, 0x03	; 3
    1482:	0e 94 9e 14 	call	0x293c	; 0x293c <_ZN7MCP25159setFilterENS_3RXFEbm>
    1486:	88 23       	and	r24, r24
    1488:	11 f0       	breq	.+4      	; 0x148e <can_init+0xa2>
    148a:	cf ef       	ldi	r28, 0xFF	; 255
    148c:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF2,1,id),error);
    148e:	97 01       	movw	r18, r14
    1490:	86 01       	movw	r16, r12
    1492:	41 e0       	ldi	r20, 0x01	; 1
    1494:	62 e0       	ldi	r22, 0x02	; 2
    1496:	80 ef       	ldi	r24, 0xF0	; 240
    1498:	93 e0       	ldi	r25, 0x03	; 3
    149a:	0e 94 9e 14 	call	0x293c	; 0x293c <_ZN7MCP25159setFilterENS_3RXFEbm>
    149e:	88 23       	and	r24, r24
    14a0:	11 f0       	breq	.+4      	; 0x14a6 <can_init+0xba>
    14a2:	cf ef       	ldi	r28, 0xFF	; 255
    14a4:	df ef       	ldi	r29, 0xFF	; 255
			errorfunc(mcp2515.setNormalMode(),error);
    14a6:	80 ef       	ldi	r24, 0xF0	; 240
    14a8:	93 e0       	ldi	r25, 0x03	; 3
    14aa:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <_ZN7MCP251513setNormalModeEv>
    14ae:	88 23       	and	r24, r24
    14b0:	11 f0       	breq	.+4      	; 0x14b6 <can_init+0xca>
    14b2:	cf ef       	ldi	r28, 0xFF	; 255
    14b4:	df ef       	ldi	r29, 0xFF	; 255
			
	portEXIT_CRITICAL();
    14b6:	0f 90       	pop	r0
    14b8:	0f be       	out	0x3f, r0	; 63
			


			
	return error;
}
    14ba:	ce 01       	movw	r24, r28
    14bc:	df 91       	pop	r29
    14be:	cf 91       	pop	r28
    14c0:	1f 91       	pop	r17
    14c2:	0f 91       	pop	r16
    14c4:	ff 90       	pop	r15
    14c6:	ef 90       	pop	r14
    14c8:	df 90       	pop	r13
    14ca:	cf 90       	pop	r12
    14cc:	bf 90       	pop	r11
    14ce:	af 90       	pop	r10
    14d0:	9f 90       	pop	r9
    14d2:	8f 90       	pop	r8
    14d4:	08 95       	ret

000014d6 <can_send>:


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    14d6:	cf 92       	push	r12
    14d8:	df 92       	push	r13
    14da:	ef 92       	push	r14
    14dc:	ff 92       	push	r15
    14de:	0f 93       	push	r16
    14e0:	1f 93       	push	r17
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	cd b7       	in	r28, 0x3d	; 61
    14e8:	de b7       	in	r29, 0x3e	; 62
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    14ea:	cd b6       	in	r12, 0x3d	; 61
    14ec:	de b6       	in	r13, 0x3e	; 62
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    14ee:	ed b7       	in	r30, 0x3d	; 61
    14f0:	fe b7       	in	r31, 0x3e	; 62
    14f2:	77 97       	sbiw	r30, 0x17	; 23
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	fe bf       	out	0x3e, r31	; 62
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	ed bf       	out	0x3d, r30	; 61
    14fe:	ed b6       	in	r14, 0x3d	; 61
    1500:	fe b6       	in	r15, 0x3e	; 62
    1502:	f8 e0       	ldi	r31, 0x08	; 8
    1504:	ef 0e       	add	r14, r31
    1506:	f1 1c       	adc	r15, r1
    1508:	38 ef       	ldi	r19, 0xF8	; 248
    150a:	e3 22       	and	r14, r19
	int error=0;
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	0f 92       	push	r0
	canMsg.can_id=id | CAN_EFF_FLAG;
    1512:	dc 01       	movw	r26, r24
    1514:	cb 01       	movw	r24, r22
    1516:	b0 68       	ori	r27, 0x80	; 128
    1518:	f7 01       	movw	r30, r14
    151a:	80 83       	st	Z, r24
    151c:	91 83       	std	Z+1, r25	; 0x01
    151e:	a2 83       	std	Z+2, r26	; 0x02
    1520:	b3 83       	std	Z+3, r27	; 0x03
	canMsg.can_dlc=dlc;
    1522:	24 83       	std	Z+4, r18	; 0x04
	for (int i=0;i<dlc;i++) {
    1524:	22 23       	and	r18, r18
    1526:	09 f4       	brne	.+2      	; 0x152a <can_send+0x54>
    1528:	3f c0       	rjmp	.+126    	; 0x15a8 <can_send+0xd2>
    152a:	a4 2f       	mov	r26, r20
    152c:	b5 2f       	mov	r27, r21
    152e:	38 96       	adiw	r30, 0x08	; 8
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	28 5f       	subi	r18, 0xF8	; 248
    1534:	3f 4f       	sbci	r19, 0xFF	; 255
    1536:	2e 0d       	add	r18, r14
    1538:	3f 1d       	adc	r19, r15
	
		canMsg.data[i]=*(data+i);
    153a:	8d 91       	ld	r24, X+
    153c:	81 93       	st	Z+, r24
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
	canMsg.can_id=id | CAN_EFF_FLAG;
	canMsg.can_dlc=dlc;
	for (int i=0;i<dlc;i++) {
    153e:	e2 17       	cp	r30, r18
    1540:	f3 07       	cpc	r31, r19
    1542:	d9 f7       	brne	.-10     	; 0x153a <can_send+0x64>
    1544:	31 c0       	rjmp	.+98     	; 0x15a8 <can_send+0xd2>
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
	if(mcp2515.checktxava()==MCP2515::ERROR_OK){
    1546:	80 ef       	ldi	r24, 0xF0	; 240
    1548:	93 e0       	ldi	r25, 0x03	; 3
    154a:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <_ZN7MCP251510checktxavaEv>
    154e:	81 11       	cpse	r24, r1
    1550:	16 c0       	rjmp	.+44     	; 0x157e <can_send+0xa8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1552:	8f e8       	ldi	r24, 0x8F	; 143
    1554:	91 e0       	ldi	r25, 0x01	; 1
    1556:	01 97       	sbiw	r24, 0x01	; 1
    1558:	f1 f7       	brne	.-4      	; 0x1556 <can_send+0x80>
    155a:	00 c0       	rjmp	.+0      	; 0x155c <can_send+0x86>
    155c:	00 00       	nop
		_delay_us(100); //magic number because even if the MCP2515 reports complete tx it can ignore if data written too quickly
			errorfunc(mcp2515.sendMessage(tx0,&canMsg),error);
    155e:	a7 01       	movw	r20, r14
    1560:	60 e0       	ldi	r22, 0x00	; 0
    1562:	80 ef       	ldi	r24, 0xF0	; 240
    1564:	93 e0       	ldi	r25, 0x03	; 3
    1566:	0e 94 04 15 	call	0x2a08	; 0x2a08 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    156a:	01 e0       	ldi	r16, 0x01	; 1
    156c:	10 e0       	ldi	r17, 0x00	; 0
    156e:	81 11       	cpse	r24, r1
    1570:	02 c0       	rjmp	.+4      	; 0x1576 <can_send+0xa0>
    1572:	00 e0       	ldi	r16, 0x00	; 0
    1574:	10 e0       	ldi	r17, 0x00	; 0
    1576:	11 95       	neg	r17
    1578:	01 95       	neg	r16
    157a:	11 09       	sbc	r17, r1
    157c:	05 c0       	rjmp	.+10     	; 0x1588 <can_send+0xb2>
    157e:	01 50       	subi	r16, 0x01	; 1
    1580:	11 09       	sbc	r17, r1
	for (int i=0;i<dlc;i++) {
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
    1582:	09 f7       	brne	.-62     	; 0x1546 <can_send+0x70>
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
	int error=0;
    1584:	00 e0       	ldi	r16, 0x00	; 0
    1586:	10 e0       	ldi	r17, 0x00	; 0
		break;
		}
	}*/
	
	
	portEXIT_CRITICAL();
    1588:	0f 90       	pop	r0
    158a:	0f be       	out	0x3f, r0	; 63
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
    158c:	01 15       	cp	r16, r1
    158e:	11 05       	cpc	r17, r1
    1590:	71 f0       	breq	.+28     	; 0x15ae <can_send+0xd8>
    1592:	8a e2       	ldi	r24, 0x2A	; 42
    1594:	92 e0       	ldi	r25, 0x02	; 2
    1596:	9f 93       	push	r25
    1598:	8f 93       	push	r24
    159a:	1f 92       	push	r1
    159c:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	0f 90       	pop	r0
	return error;
    15a6:	03 c0       	rjmp	.+6      	; 0x15ae <can_send+0xd8>
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    15a8:	08 e0       	ldi	r16, 0x08	; 8
    15aa:	10 e0       	ldi	r17, 0x00	; 0
    15ac:	cc cf       	rjmp	.-104    	; 0x1546 <can_send+0x70>
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    15ae:	c8 01       	movw	r24, r16
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	de be       	out	0x3e, r13	; 62
    15b6:	0f be       	out	0x3f, r0	; 63
    15b8:	cd be       	out	0x3d, r12	; 61
    15ba:	df 91       	pop	r29
    15bc:	cf 91       	pop	r28
    15be:	1f 91       	pop	r17
    15c0:	0f 91       	pop	r16
    15c2:	ff 90       	pop	r15
    15c4:	ef 90       	pop	r14
    15c6:	df 90       	pop	r13
    15c8:	cf 90       	pop	r12
    15ca:	08 95       	ret

000015cc <CanRxFunc>:



void CanRxFunc(void* pvParameters) {
    15cc:	cf 93       	push	r28
    15ce:	df 93       	push	r29
    15d0:	00 d0       	rcall	.+0      	; 0x15d2 <CanRxFunc+0x6>
    15d2:	1f 92       	push	r1
    15d4:	1f 92       	push	r1
    15d6:	cd b7       	in	r28, 0x3d	; 61
    15d8:	de b7       	in	r29, 0x3e	; 62
	

	DDRD&=~(1<<PD2);
    15da:	52 98       	cbi	0x0a, 2	; 10
	EICRA|=(2<<ISC20);
    15dc:	e9 e6       	ldi	r30, 0x69	; 105
    15de:	f0 e0       	ldi	r31, 0x00	; 0
    15e0:	80 81       	ld	r24, Z
    15e2:	80 62       	ori	r24, 0x20	; 32
    15e4:	80 83       	st	Z, r24
	EIMSK|=(1<<INT2);
    15e6:	ea 9a       	sbi	0x1d, 2	; 29
	
	mcp2515.clearInterrupts();
    15e8:	80 ef       	ldi	r24, 0xF0	; 240
    15ea:	93 e0       	ldi	r25, 0x03	; 3
    15ec:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <_ZN7MCP251515clearInterruptsEv>
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
    15f0:	21 e0       	ldi	r18, 0x01	; 1
    15f2:	29 83       	std	Y+1, r18	; 0x01
    15f4:	1a 82       	std	Y+2, r1	; 0x02
				if(pos>=count) {
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
					for (int a=0;a<frame[i].can_dlc;a++) {
						csp_log_error("Data %d = %x",a,frame[i].data[a]);
    15f6:	0f 2e       	mov	r0, r31
    15f8:	f4 eb       	ldi	r31, 0xB4	; 180
    15fa:	2f 2e       	mov	r2, r31
    15fc:	f1 e0       	ldi	r31, 0x01	; 1
    15fe:	3f 2e       	mov	r3, r31
    1600:	f0 2d       	mov	r31, r0
	

	for(;;){
		

		mcp2515.clearInterrupts();
    1602:	80 ef       	ldi	r24, 0xF0	; 240
    1604:	93 e0       	ldi	r25, 0x03	; 3
    1606:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <_ZN7MCP251515clearInterruptsEv>
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    160a:	80 e0       	ldi	r24, 0x00	; 0
    160c:	90 e0       	ldi	r25, 0x00	; 0
    160e:	0e 94 a1 3e 	call	0x7d42	; 0x7d42 <uxTaskGetStackHighWaterMark2>
    1612:	8b 83       	std	Y+3, r24	; 0x03
    1614:	9d 83       	std	Y+5, r25	; 0x05
    1616:	80 e0       	ldi	r24, 0x00	; 0
    1618:	90 e0       	ldi	r25, 0x00	; 0
    161a:	0e 94 87 3b 	call	0x770e	; 0x770e <pcTaskGetName>
    161e:	3d 81       	ldd	r19, Y+5	; 0x05
    1620:	3f 93       	push	r19
    1622:	4b 81       	ldd	r20, Y+3	; 0x03
    1624:	4f 93       	push	r20
    1626:	9f 93       	push	r25
    1628:	8f 93       	push	r24
    162a:	83 e2       	ldi	r24, 0x23	; 35
    162c:	92 e0       	ldi	r25, 0x02	; 2
    162e:	9f 93       	push	r25
    1630:	8f 93       	push	r24
    1632:	82 e0       	ldi	r24, 0x02	; 2
    1634:	8f 93       	push	r24
    1636:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		vTaskSuspend(NULL);
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	0e 94 44 41 	call	0x8288	; 0x8288 <vTaskSuspend>
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int errorb=0;
			int dlcsum=0;
			portENTER_CRITICAL();
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	0f 92       	push	r0
			timeoutstart(MAX_DELAY); // 256*n/16M for time
    1648:	86 e0       	ldi	r24, 0x06	; 6
    164a:	91 e0       	ldi	r25, 0x01	; 1
    164c:	fd d1       	rcall	.+1018   	; 0x1a48 <_Z12timeoutstarti>
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	f8 94       	cli
    1652:	de bf       	out	0x3e, r29	; 62
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	cd bf       	out	0x3d, r28	; 61
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
    1658:	00 e0       	ldi	r16, 0x00	; 0
    165a:	10 e0       	ldi	r17, 0x00	; 0
		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
    165c:	0f 2e       	mov	r0, r31
    165e:	f6 e0       	ldi	r31, 0x06	; 6
    1660:	ff 2e       	mov	r15, r31

		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
    1662:	f0 2d       	mov	r31, r0
			int error=0;
			int errorb=0;
			int dlcsum=0;
			portENTER_CRITICAL();
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
    1664:	51 2c       	mov	r5, r1
    1666:	12 d2       	rcall	.+1060   	; 0x1a8c <_Z12timeoutcheckv>
    1668:	89 2b       	or	r24, r25
    166a:	b1 f5       	brne	.+108    	; 0x16d8 <CanRxFunc+0x10c>
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
    166c:	45 2d       	mov	r20, r5
    166e:	50 e0       	ldi	r21, 0x00	; 0
    1670:	5c 83       	std	Y+4, r21	; 0x04
    1672:	4b 83       	std	Y+3, r20	; 0x03
    1674:	ba 01       	movw	r22, r20
    1676:	62 95       	swap	r22
    1678:	72 95       	swap	r23
    167a:	70 7f       	andi	r23, 0xF0	; 240
    167c:	76 27       	eor	r23, r22
    167e:	60 7f       	andi	r22, 0xF0	; 240
    1680:	76 27       	eor	r23, r22
    1682:	60 58       	subi	r22, 0x80	; 128
    1684:	7c 4f       	sbci	r23, 0xFC	; 252
    1686:	80 ef       	ldi	r24, 0xF0	; 240
    1688:	93 e0       	ldi	r25, 0x03	; 3
    168a:	0e 94 75 16 	call	0x2cea	; 0x2cea <_ZN7MCP251511readMessageEP9can_frame>
    168e:	81 11       	cpse	r24, r1
    1690:	1e c0       	rjmp	.+60     	; 0x16ce <CanRxFunc+0x102>
    1692:	01 15       	cp	r16, r1
    1694:	11 05       	cpc	r17, r1
    1696:	09 f4       	brne	.+2      	; 0x169a <CanRxFunc+0xce>
    1698:	62 c1       	rjmp	.+708    	; 0x195e <CanRxFunc+0x392>
    169a:	19 c0       	rjmp	.+50     	; 0x16ce <CanRxFunc+0x102>
					//dlcsum+=frame[count].can_dlc;
					 uint8_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
    169c:	51 10       	cpse	r5, r1
    169e:	15 c0       	rjmp	.+42     	; 0x16ca <CanRxFunc+0xfe>
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
    16a0:	07 2e       	mov	r0, r23
    16a2:	7a e0       	ldi	r23, 0x0A	; 10
    16a4:	b6 95       	lsr	r27
    16a6:	a7 95       	ror	r26
    16a8:	97 95       	ror	r25
    16aa:	87 95       	ror	r24
    16ac:	7a 95       	dec	r23
    16ae:	d1 f7       	brne	.-12     	; 0x16a4 <CanRxFunc+0xd8>
    16b0:	70 2d       	mov	r23, r0
    16b2:	f8 2e       	mov	r15, r24
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
    16b4:	56 e0       	ldi	r21, 0x06	; 6
    16b6:	58 17       	cp	r21, r24
    16b8:	20 f0       	brcs	.+8      	; 0x16c2 <CanRxFunc+0xf6>
    16ba:	07 c0       	rjmp	.+14     	; 0x16ca <CanRxFunc+0xfe>
								error=1;
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
    16bc:	51 10       	cpse	r5, r1
    16be:	05 c0       	rjmp	.+10     	; 0x16ca <CanRxFunc+0xfe>
    16c0:	0e c0       	rjmp	.+28     	; 0x16de <CanRxFunc+0x112>
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
    16c2:	09 81       	ldd	r16, Y+1	; 0x01
    16c4:	1a 81       	ldd	r17, Y+2	; 0x02
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
						if (error==1) {count=1;}
    16c6:	55 24       	eor	r5, r5

						count++; // increment number of messages received
    16c8:	53 94       	inc	r5
						timeoutreset(); //if there is a new message, reset the timer
    16ca:	53 94       	inc	r5
    16cc:	da d1       	rcall	.+948    	; 0x1a82 <_Z12timeoutresetv>
					}		
					if (count>remain){break;} // this is used to break out of the timeout if we've received all frames or if there's too many
    16ce:	f5 14       	cp	r15, r5
    16d0:	50 f6       	brcc	.-108    	; 0x1666 <CanRxFunc+0x9a>
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int errorb=0;
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	05 c0       	rjmp	.+10     	; 0x16e2 <CanRxFunc+0x116>
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	02 c0       	rjmp	.+4      	; 0x16e2 <CanRxFunc+0x116>
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	90 e0       	ldi	r25, 0x00	; 0
						count++; // increment number of messages received
						timeoutreset(); //if there is a new message, reset the timer
					}		
					if (count>remain){break;} // this is used to break out of the timeout if we've received all frames or if there's too many
			}
			portEXIT_CRITICAL();
    16e2:	0f 90       	pop	r0
    16e4:	0f be       	out	0x3f, r0	; 63
			//csp_log_info("DLC = %d",dlcsum);
			if(error!=0||errorb!=0) { // if too many frames come it, it wont process them. saves time handling these useless requests
    16e6:	01 2b       	or	r16, r17
    16e8:	11 f4       	brne	.+4      	; 0x16ee <CanRxFunc+0x122>
    16ea:	89 2b       	or	r24, r25
    16ec:	59 f0       	breq	.+22     	; 0x1704 <CanRxFunc+0x138>
 				csp_log_error("Too Many Frames or wrong order");
    16ee:	84 e0       	ldi	r24, 0x04	; 4
    16f0:	92 e0       	ldi	r25, 0x02	; 2
    16f2:	9f 93       	push	r25
    16f4:	8f 93       	push	r24
    16f6:	1f 92       	push	r1
    16f8:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	7f cf       	rjmp	.-258    	; 0x1602 <CanRxFunc+0x36>
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
    1704:	c5 2c       	mov	r12, r5
    1706:	d1 2c       	mov	r13, r1
    1708:	1f 92       	push	r1
    170a:	5f 92       	push	r5
    170c:	87 ef       	ldi	r24, 0xF7	; 247
    170e:	91 e0       	ldi	r25, 0x01	; 1
    1710:	9f 93       	push	r25
    1712:	8f 93       	push	r24
    1714:	82 e0       	ldi	r24, 0x02	; 2
    1716:	8f 93       	push	r24
    1718:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			for (int i=0;i<count;i++){
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	0f 90       	pop	r0
    1724:	0f 90       	pop	r0
    1726:	1c 14       	cp	r1, r12
    1728:	1d 04       	cpc	r1, r13
    172a:	0c f0       	brlt	.+2      	; 0x172e <CanRxFunc+0x162>
    172c:	a5 c0       	rjmp	.+330    	; 0x1878 <CanRxFunc+0x2ac>
    172e:	80 e8       	ldi	r24, 0x80	; 128
    1730:	93 e0       	ldi	r25, 0x03	; 3
    1732:	0f 2e       	mov	r0, r31
    1734:	f8 e8       	ldi	r31, 0x88	; 136
    1736:	8f 2e       	mov	r8, r31
    1738:	f3 e0       	ldi	r31, 0x03	; 3
    173a:	9f 2e       	mov	r9, r31
    173c:	f0 2d       	mov	r31, r0
    173e:	a1 2c       	mov	r10, r1
    1740:	b1 2c       	mov	r11, r1
				
				//csp_log_info("pos = %d	count=%d",pos,count);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    1742:	9c 83       	std	Y+4, r25	; 0x04
    1744:	8b 83       	std	Y+3, r24	; 0x03
    1746:	0b 81       	ldd	r16, Y+3	; 0x03
    1748:	1c 81       	ldd	r17, Y+4	; 0x04
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
				uint8_t pos = count-((uint8_t)((frame[i].can_id >> 10) & 0xFF))-1;
    174a:	f8 01       	movw	r30, r16
    174c:	80 81       	ld	r24, Z
    174e:	91 81       	ldd	r25, Z+1	; 0x01
    1750:	a2 81       	ldd	r26, Z+2	; 0x02
    1752:	b3 81       	ldd	r27, Z+3	; 0x03
    1754:	07 2e       	mov	r0, r23
    1756:	7a e0       	ldi	r23, 0x0A	; 10
    1758:	b6 95       	lsr	r27
    175a:	a7 95       	ror	r26
    175c:	97 95       	ror	r25
    175e:	87 95       	ror	r24
    1760:	7a 95       	dec	r23
    1762:	d1 f7       	brne	.-12     	; 0x1758 <CanRxFunc+0x18c>
    1764:	70 2d       	mov	r23, r0
    1766:	e8 2f       	mov	r30, r24
    1768:	e0 95       	com	r30
    176a:	4e 2e       	mov	r4, r30
    176c:	45 0c       	add	r4, r5
				if(pos>=count) {
    176e:	45 14       	cp	r4, r5
    1770:	08 f4       	brcc	.+2      	; 0x1774 <CanRxFunc+0x1a8>
    1772:	4f c0       	rjmp	.+158    	; 0x1812 <CanRxFunc+0x246>
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
    1774:	df 92       	push	r13
    1776:	cf 92       	push	r12
    1778:	1f 92       	push	r1
    177a:	4f 92       	push	r4
    177c:	28 ed       	ldi	r18, 0xD8	; 216
    177e:	31 e0       	ldi	r19, 0x01	; 1
    1780:	3f 93       	push	r19
    1782:	2f 93       	push	r18
    1784:	1f 92       	push	r1
    1786:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
    178a:	eb 81       	ldd	r30, Y+3	; 0x03
    178c:	fc 81       	ldd	r31, Y+4	; 0x04
    178e:	83 81       	ldd	r24, Z+3	; 0x03
    1790:	8f 93       	push	r24
    1792:	82 81       	ldd	r24, Z+2	; 0x02
    1794:	8f 93       	push	r24
    1796:	81 81       	ldd	r24, Z+1	; 0x01
    1798:	8f 93       	push	r24
    179a:	80 81       	ld	r24, Z
    179c:	8f 93       	push	r24
    179e:	2d ec       	ldi	r18, 0xCD	; 205
    17a0:	31 e0       	ldi	r19, 0x01	; 1
    17a2:	3f 93       	push	r19
    17a4:	2f 93       	push	r18
    17a6:	1f 92       	push	r1
    17a8:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
    17ac:	eb 81       	ldd	r30, Y+3	; 0x03
    17ae:	fc 81       	ldd	r31, Y+4	; 0x04
    17b0:	84 81       	ldd	r24, Z+4	; 0x04
    17b2:	1f 92       	push	r1
    17b4:	8f 93       	push	r24
    17b6:	21 ec       	ldi	r18, 0xC1	; 193
    17b8:	31 e0       	ldi	r19, 0x01	; 1
    17ba:	3f 93       	push	r19
    17bc:	2f 93       	push	r18
    17be:	1f 92       	push	r1
    17c0:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
					for (int a=0;a<frame[i].can_dlc;a++) {
    17c4:	eb 81       	ldd	r30, Y+3	; 0x03
    17c6:	fc 81       	ldd	r31, Y+4	; 0x04
    17c8:	84 81       	ldd	r24, Z+4	; 0x04
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	f8 94       	cli
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	0f be       	out	0x3f, r0	; 63
    17d2:	cd bf       	out	0x3d, r28	; 61
    17d4:	88 23       	and	r24, r24
    17d6:	e9 f0       	breq	.+58     	; 0x1812 <CanRxFunc+0x246>
    17d8:	74 01       	movw	r14, r8
    17da:	61 2c       	mov	r6, r1
    17dc:	71 2c       	mov	r7, r1
						csp_log_error("Data %d = %x",a,frame[i].data[a]);
    17de:	f7 01       	movw	r30, r14
    17e0:	81 91       	ld	r24, Z+
    17e2:	7f 01       	movw	r14, r30
    17e4:	1f 92       	push	r1
    17e6:	8f 93       	push	r24
    17e8:	7f 92       	push	r7
    17ea:	6f 92       	push	r6
    17ec:	3f 92       	push	r3
    17ee:	2f 92       	push	r2
    17f0:	1f 92       	push	r1
    17f2:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
				uint8_t pos = count-((uint8_t)((frame[i].can_id >> 10) & 0xFF))-1;
				if(pos>=count) {
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
					for (int a=0;a<frame[i].can_dlc;a++) {
    17f6:	ff ef       	ldi	r31, 0xFF	; 255
    17f8:	6f 1a       	sub	r6, r31
    17fa:	7f 0a       	sbc	r7, r31
    17fc:	f8 01       	movw	r30, r16
    17fe:	84 81       	ldd	r24, Z+4	; 0x04
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	de bf       	out	0x3e, r29	; 62
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	cd bf       	out	0x3d, r28	; 61
    180c:	68 16       	cp	r6, r24
    180e:	79 06       	cpc	r7, r25
    1810:	34 f3       	brlt	.-52     	; 0x17de <CanRxFunc+0x212>
				
				//csp_log_info("pos = %d	count=%d",pos,count);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    1812:	5d e0       	ldi	r21, 0x0D	; 13
    1814:	54 9d       	mul	r21, r4
    1816:	f0 01       	movw	r30, r0
    1818:	11 24       	eor	r1, r1
    181a:	af 01       	movw	r20, r30
    181c:	42 5e       	subi	r20, 0xE2	; 226
    181e:	5c 4f       	sbci	r21, 0xFC	; 252
    1820:	f8 01       	movw	r30, r16
    1822:	80 81       	ld	r24, Z
    1824:	91 81       	ldd	r25, Z+1	; 0x01
    1826:	a2 81       	ldd	r26, Z+2	; 0x02
    1828:	b3 81       	ldd	r27, Z+3	; 0x03
    182a:	fa 01       	movw	r30, r20
    182c:	80 83       	st	Z, r24
    182e:	91 83       	std	Z+1, r25	; 0x01
    1830:	a2 83       	std	Z+2, r26	; 0x02
    1832:	b3 83       	std	Z+3, r27	; 0x03
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
    1834:	f8 01       	movw	r30, r16
    1836:	24 81       	ldd	r18, Z+4	; 0x04
    1838:	fa 01       	movw	r30, r20
    183a:	24 83       	std	Z+4, r18	; 0x04
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    183c:	22 23       	and	r18, r18
    183e:	69 f0       	breq	.+26     	; 0x185a <CanRxFunc+0x28e>
    1840:	3d e0       	ldi	r19, 0x0D	; 13
    1842:	34 9d       	mul	r19, r4
    1844:	f0 01       	movw	r30, r0
    1846:	11 24       	eor	r1, r1
    1848:	ed 5d       	subi	r30, 0xDD	; 221
    184a:	fc 4f       	sbci	r31, 0xFC	; 252
    184c:	d4 01       	movw	r26, r8
    184e:	80 e0       	ldi	r24, 0x00	; 0
						frameo[pos].data[a]=frame[i].data[a];
    1850:	9d 91       	ld	r25, X+
    1852:	91 93       	st	Z+, r25
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    1854:	8f 5f       	subi	r24, 0xFF	; 255
    1856:	28 13       	cpse	r18, r24
    1858:	fb cf       	rjmp	.-10     	; 0x1850 <CanRxFunc+0x284>
 				csp_log_error("Too Many Frames or wrong order");
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
    185a:	9f ef       	ldi	r25, 0xFF	; 255
    185c:	a9 1a       	sub	r10, r25
    185e:	b9 0a       	sbc	r11, r25
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	70 96       	adiw	r30, 0x10	; 16
    1866:	fc 83       	std	Y+4, r31	; 0x04
    1868:	eb 83       	std	Y+3, r30	; 0x03
    186a:	f0 e1       	ldi	r31, 0x10	; 16
    186c:	8f 0e       	add	r8, r31
    186e:	91 1c       	adc	r9, r1
    1870:	ca 14       	cp	r12, r10
    1872:	db 04       	cpc	r13, r11
    1874:	09 f0       	breq	.+2      	; 0x1878 <CanRxFunc+0x2ac>
    1876:	67 cf       	rjmp	.-306    	; 0x1746 <CanRxFunc+0x17a>
						csp_log_info(" %x",frameo[count].data[a]);
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
			for (int i=0;i<count;i++){ //send of the frames to be processed
    187e:	1c 14       	cp	r1, r12
    1880:	1d 04       	cpc	r1, r13
    1882:	f4 f5       	brge	.+124    	; 0x1900 <CanRxFunc+0x334>
    1884:	0e e1       	ldi	r16, 0x1E	; 30
    1886:	13 e0       	ldi	r17, 0x03	; 3
    1888:	1c 82       	std	Y+4, r1	; 0x04
    188a:	1b 82       	std	Y+3, r1	; 0x03
				if(i==count-1){
    188c:	76 01       	movw	r14, r12
    188e:	21 e0       	ldi	r18, 0x01	; 1
    1890:	e2 1a       	sub	r14, r18
    1892:	f1 08       	sbc	r15, r1
					
					if(csp_can_rx_frame(&frameo[i],"CAN")!=0) {csp_log_reset("queue fail");}
					
					} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
    1894:	0f 2e       	mov	r0, r31
    1896:	f6 e0       	ldi	r31, 0x06	; 6
    1898:	bf 2e       	mov	r11, r31
    189a:	f0 2d       	mov	r31, r0
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
			for (int i=0;i<count;i++){ //send of the frames to be processed
				if(i==count-1){
    189c:	8b 81       	ldd	r24, Y+3	; 0x03
    189e:	9c 81       	ldd	r25, Y+4	; 0x04
    18a0:	e8 16       	cp	r14, r24
    18a2:	f9 06       	cpc	r15, r25
    18a4:	91 f4       	brne	.+36     	; 0x18ca <CanRxFunc+0x2fe>
					
					if(csp_can_rx_frame(&frameo[i],"CAN")!=0) {csp_log_reset("queue fail");}
    18a6:	66 e8       	ldi	r22, 0x86	; 134
    18a8:	72 e0       	ldi	r23, 0x02	; 2
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 98 23 	call	0x4730	; 0x4730 <csp_can_rx_frame>
    18b0:	89 2b       	or	r24, r25
    18b2:	e1 f0       	breq	.+56     	; 0x18ec <CanRxFunc+0x320>
    18b4:	e9 ea       	ldi	r30, 0xA9	; 169
    18b6:	f1 e0       	ldi	r31, 0x01	; 1
    18b8:	ff 93       	push	r31
    18ba:	ef 93       	push	r30
    18bc:	bf 92       	push	r11
    18be:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    18c2:	0f 90       	pop	r0
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	11 c0       	rjmp	.+34     	; 0x18ec <CanRxFunc+0x320>
					
					} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
    18ca:	60 e0       	ldi	r22, 0x00	; 0
    18cc:	70 e0       	ldi	r23, 0x00	; 0
    18ce:	c8 01       	movw	r24, r16
    18d0:	0e 94 98 23 	call	0x4730	; 0x4730 <csp_can_rx_frame>
    18d4:	89 2b       	or	r24, r25
    18d6:	51 f0       	breq	.+20     	; 0x18ec <CanRxFunc+0x320>
    18d8:	4e e9       	ldi	r20, 0x9E	; 158
    18da:	51 e0       	ldi	r21, 0x01	; 1
    18dc:	5f 93       	push	r21
    18de:	4f 93       	push	r20
    18e0:	bf 92       	push	r11
    18e2:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    18e6:	0f 90       	pop	r0
    18e8:	0f 90       	pop	r0
    18ea:	0f 90       	pop	r0
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
			for (int i=0;i<count;i++){ //send of the frames to be processed
    18ec:	eb 81       	ldd	r30, Y+3	; 0x03
    18ee:	fc 81       	ldd	r31, Y+4	; 0x04
    18f0:	31 96       	adiw	r30, 0x01	; 1
    18f2:	fc 83       	std	Y+4, r31	; 0x04
    18f4:	eb 83       	std	Y+3, r30	; 0x03
    18f6:	03 5f       	subi	r16, 0xF3	; 243
    18f8:	1f 4f       	sbci	r17, 0xFF	; 255
    18fa:	ce 16       	cp	r12, r30
    18fc:	df 06       	cpc	r13, r31
    18fe:	71 f6       	brne	.-100    	; 0x189c <CanRxFunc+0x2d0>
					}
					
					
				
			}
			portEXIT_CRITICAL();
    1900:	0f 90       	pop	r0
    1902:	0f be       	out	0x3f, r0	; 63
    1904:	8e e1       	ldi	r24, 0x1E	; 30
    1906:	93 e0       	ldi	r25, 0x03	; 3
    1908:	20 e8       	ldi	r18, 0x80	; 128
    190a:	33 e0       	ldi	r19, 0x03	; 3
    190c:	3c 83       	std	Y+4, r19	; 0x04
    190e:	2b 83       	std	Y+3, r18	; 0x03
    1910:	29 e7       	ldi	r18, 0x79	; 121
    1912:	33 e0       	ldi	r19, 0x03	; 3
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
    1914:	fc 01       	movw	r30, r24
    1916:	10 82       	st	Z, r1
    1918:	11 82       	std	Z+1, r1	; 0x01
    191a:	12 82       	std	Z+2, r1	; 0x02
    191c:	13 82       	std	Z+3, r1	; 0x03
				frame[i].can_id=0;
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	10 82       	st	Z, r1
    1924:	11 82       	std	Z+1, r1	; 0x01
    1926:	12 82       	std	Z+2, r1	; 0x02
    1928:	13 82       	std	Z+3, r1	; 0x03
				frameo[i].dlc=0;
    192a:	fc 01       	movw	r30, r24
    192c:	14 82       	std	Z+4, r1	; 0x04
				frame[i].can_dlc=0;
    192e:	eb 81       	ldd	r30, Y+3	; 0x03
    1930:	fc 81       	ldd	r31, Y+4	; 0x04
    1932:	14 82       	std	Z+4, r1	; 0x04
    1934:	dc 01       	movw	r26, r24
    1936:	15 96       	adiw	r26, 0x05	; 5
    1938:	38 96       	adiw	r30, 0x08	; 8
    193a:	4b 81       	ldd	r20, Y+3	; 0x03
    193c:	5c 81       	ldd	r21, Y+4	; 0x04
    193e:	40 5f       	subi	r20, 0xF0	; 240
    1940:	5f 4f       	sbci	r21, 0xFF	; 255
    1942:	5c 83       	std	Y+4, r21	; 0x04
    1944:	4b 83       	std	Y+3, r20	; 0x03
				for (int a=0;a<8;a++) {
					frameo[i].data[a]=0;
    1946:	1d 92       	st	X+, r1
					frame[i].data[a]=0;
    1948:	11 92       	st	Z+, r1
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
				frame[i].can_id=0;
				frameo[i].dlc=0;
				frame[i].can_dlc=0;
				for (int a=0;a<8;a++) {
    194a:	4b 81       	ldd	r20, Y+3	; 0x03
    194c:	5c 81       	ldd	r21, Y+4	; 0x04
    194e:	e4 17       	cp	r30, r20
    1950:	f5 07       	cpc	r31, r21
    1952:	c9 f7       	brne	.-14     	; 0x1946 <CanRxFunc+0x37a>
    1954:	0d 96       	adiw	r24, 0x0d	; 13
					
				
			}
			portEXIT_CRITICAL();
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
    1956:	82 17       	cp	r24, r18
    1958:	93 07       	cpc	r25, r19
    195a:	e1 f6       	brne	.-72     	; 0x1914 <CanRxFunc+0x348>
    195c:	52 ce       	rjmp	.-860    	; 0x1602 <CanRxFunc+0x36>
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
					//dlcsum+=frame[count].can_dlc;
					 uint8_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
    195e:	8b 81       	ldd	r24, Y+3	; 0x03
    1960:	9c 81       	ldd	r25, Y+4	; 0x04
    1962:	82 95       	swap	r24
    1964:	92 95       	swap	r25
    1966:	90 7f       	andi	r25, 0xF0	; 240
    1968:	98 27       	eor	r25, r24
    196a:	80 7f       	andi	r24, 0xF0	; 240
    196c:	98 27       	eor	r25, r24
    196e:	80 58       	subi	r24, 0x80	; 128
    1970:	9c 4f       	sbci	r25, 0xFC	; 252
    1972:	fc 01       	movw	r30, r24
    1974:	80 81       	ld	r24, Z
    1976:	91 81       	ldd	r25, Z+1	; 0x01
    1978:	a2 81       	ldd	r26, Z+2	; 0x02
    197a:	b3 81       	ldd	r27, Z+3	; 0x03
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
    197c:	ac 01       	movw	r20, r24
    197e:	bd 01       	movw	r22, r26
    1980:	03 2e       	mov	r0, r19
    1982:	32 e1       	ldi	r19, 0x12	; 18
    1984:	76 95       	lsr	r23
    1986:	67 95       	ror	r22
    1988:	57 95       	ror	r21
    198a:	47 95       	ror	r20
    198c:	3a 95       	dec	r19
    198e:	d1 f7       	brne	.-12     	; 0x1984 <CanRxFunc+0x3b8>
    1990:	30 2d       	mov	r19, r0
    1992:	40 ff       	sbrs	r20, 0
    1994:	83 ce       	rjmp	.-762    	; 0x169c <CanRxFunc+0xd0>

//static csp_queue_handle_t csp_can_rx_queue;



MCP2515 mcp2515;
    1996:	92 ce       	rjmp	.-732    	; 0x16bc <CanRxFunc+0xf0>

00001998 <_GLOBAL__sub_I_mcp2515>:
    1998:	80 ef       	ldi	r24, 0xF0	; 240
    199a:	93 e0       	ldi	r25, 0x03	; 3
    199c:	0a c4       	rjmp	.+2068   	; 0x21b2 <_ZN7MCP2515C1Ev>
    199e:	08 95       	ret

000019a0 <_Z10enableledsv>:
#include <avr/interrupt.h>

int leden=0;

void enableleds(void) {
	DDRD|= (1<<PD5) | (1<<PD6) | (1<<PD7);
    19a0:	8a b1       	in	r24, 0x0a	; 10
    19a2:	80 6e       	ori	r24, 0xE0	; 224
    19a4:	8a b9       	out	0x0a, r24	; 10
	leden=1;
    19a6:	81 e0       	ldi	r24, 0x01	; 1
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	90 93 75 06 	sts	0x0675, r25	; 0x800675 <leden+0x1>
    19ae:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <leden>
    19b2:	08 95       	ret

000019b4 <_Z7contledii>:
}

void contled(int con, int led) {
	if (leden==0) {return;}
    19b4:	20 91 74 06 	lds	r18, 0x0674	; 0x800674 <leden>
    19b8:	30 91 75 06 	lds	r19, 0x0675	; 0x800675 <leden+0x1>
    19bc:	23 2b       	or	r18, r19
    19be:	c1 f1       	breq	.+112    	; 0x1a30 <_Z7contledii+0x7c>
	char tarled = 0;
	switch (led)
    19c0:	61 30       	cpi	r22, 0x01	; 1
    19c2:	71 05       	cpc	r23, r1
    19c4:	39 f0       	breq	.+14     	; 0x19d4 <_Z7contledii+0x20>
    19c6:	62 30       	cpi	r22, 0x02	; 2
    19c8:	71 05       	cpc	r23, r1
    19ca:	31 f0       	breq	.+12     	; 0x19d8 <_Z7contledii+0x24>
    19cc:	67 2b       	or	r22, r23
    19ce:	31 f4       	brne	.+12     	; 0x19dc <_Z7contledii+0x28>
	{
	case 0 : tarled = PD5;
    19d0:	25 e0       	ldi	r18, 0x05	; 5
    19d2:	05 c0       	rjmp	.+10     	; 0x19de <_Z7contledii+0x2a>
		break;
	case 1 : tarled = PD6;
    19d4:	26 e0       	ldi	r18, 0x06	; 6
		break;
    19d6:	03 c0       	rjmp	.+6      	; 0x19de <_Z7contledii+0x2a>
	case 2 : tarled = PD7;
    19d8:	27 e0       	ldi	r18, 0x07	; 7
		break;
    19da:	01 c0       	rjmp	.+2      	; 0x19de <_Z7contledii+0x2a>
	leden=1;
}

void contled(int con, int led) {
	if (leden==0) {return;}
	char tarled = 0;
    19dc:	20 e0       	ldi	r18, 0x00	; 0
	case 1 : tarled = PD6;
		break;
	case 2 : tarled = PD7;
		break;
	}
		switch (con)
    19de:	81 30       	cpi	r24, 0x01	; 1
    19e0:	91 05       	cpc	r25, r1
    19e2:	81 f0       	breq	.+32     	; 0x1a04 <_Z7contledii+0x50>
    19e4:	82 30       	cpi	r24, 0x02	; 2
    19e6:	91 05       	cpc	r25, r1
    19e8:	c1 f0       	breq	.+48     	; 0x1a1a <_Z7contledii+0x66>
    19ea:	89 2b       	or	r24, r25
    19ec:	09 f5       	brne	.+66     	; 0x1a30 <_Z7contledii+0x7c>
		{
	case 0 : PORTD ^= (1<<tarled);
    19ee:	3b b1       	in	r19, 0x0b	; 11
    19f0:	81 e0       	ldi	r24, 0x01	; 1
    19f2:	90 e0       	ldi	r25, 0x00	; 0
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <_Z7contledii+0x46>
    19f6:	88 0f       	add	r24, r24
    19f8:	99 1f       	adc	r25, r25
    19fa:	2a 95       	dec	r18
    19fc:	e2 f7       	brpl	.-8      	; 0x19f6 <_Z7contledii+0x42>
    19fe:	83 27       	eor	r24, r19
    1a00:	8b b9       	out	0x0b, r24	; 11
		break;
    1a02:	08 95       	ret
	case 1 : PORTD |= (1<<tarled);
    1a04:	3b b1       	in	r19, 0x0b	; 11
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	02 c0       	rjmp	.+4      	; 0x1a10 <_Z7contledii+0x5c>
    1a0c:	88 0f       	add	r24, r24
    1a0e:	99 1f       	adc	r25, r25
    1a10:	2a 95       	dec	r18
    1a12:	e2 f7       	brpl	.-8      	; 0x1a0c <_Z7contledii+0x58>
    1a14:	83 2b       	or	r24, r19
    1a16:	8b b9       	out	0x0b, r24	; 11
		break;
    1a18:	08 95       	ret
	case 2 : PORTD &= ~(1<<tarled);
    1a1a:	3b b1       	in	r19, 0x0b	; 11
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	02 c0       	rjmp	.+4      	; 0x1a26 <_Z7contledii+0x72>
    1a22:	88 0f       	add	r24, r24
    1a24:	99 1f       	adc	r25, r25
    1a26:	2a 95       	dec	r18
    1a28:	e2 f7       	brpl	.-8      	; 0x1a22 <_Z7contledii+0x6e>
    1a2a:	80 95       	com	r24
    1a2c:	83 23       	and	r24, r19
    1a2e:	8b b9       	out	0x0b, r24	; 11
    1a30:	08 95       	ret

00001a32 <_Z10pwrredinitv>:
	}
	
}

void pwrredinit(void) {
	PRR0|=0b01100000; //shuts down TIM0 and 2
    1a32:	e4 e6       	ldi	r30, 0x64	; 100
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	80 81       	ld	r24, Z
    1a38:	80 66       	ori	r24, 0x60	; 96
    1a3a:	80 83       	st	Z, r24
	PRR1|=0b00111111; //shuts down TIM3-5 and USART1-3
    1a3c:	e5 e6       	ldi	r30, 0x65	; 101
    1a3e:	f0 e0       	ldi	r31, 0x00	; 0
    1a40:	80 81       	ld	r24, Z
    1a42:	8f 63       	ori	r24, 0x3F	; 63
    1a44:	80 83       	st	Z, r24
    1a46:	08 95       	ret

00001a48 <_Z12timeoutstarti>:
	
}

void timeoutstart(int tim) {
    1a48:	9c 01       	movw	r18, r24
	// remember power save
	cli();
    1a4a:	f8 94       	cli
	PRR1&=~(1<<PRTIM3);
    1a4c:	e5 e6       	ldi	r30, 0x65	; 101
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	90 81       	ld	r25, Z
    1a52:	97 7f       	andi	r25, 0xF7	; 247
    1a54:	90 83       	st	Z, r25
	
	TCCR3A = 0;
    1a56:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
	TCCR3B = 0;
    1a5a:	e1 e9       	ldi	r30, 0x91	; 145
    1a5c:	f0 e0       	ldi	r31, 0x00	; 0
    1a5e:	10 82       	st	Z, r1
	TCNT3 = 0;
    1a60:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    1a64:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	
	OCR3A=tim;
    1a68:	30 93 99 00 	sts	0x0099, r19	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    1a6c:	20 93 98 00 	sts	0x0098, r18	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	
	TCCR3B|=(1<<WGM32);	
    1a70:	80 81       	ld	r24, Z
    1a72:	88 60       	ori	r24, 0x08	; 8
    1a74:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS32);
    1a76:	80 81       	ld	r24, Z
    1a78:	84 60       	ori	r24, 0x04	; 4
    1a7a:	80 83       	st	Z, r24
	TIFR3|=(1<<OCF3A);
    1a7c:	c1 9a       	sbi	0x18, 1	; 24
	sei();
    1a7e:	78 94       	sei
    1a80:	08 95       	ret

00001a82 <_Z12timeoutresetv>:
	
}

void timeoutreset(void) {
		TCNT3 = 0;
    1a82:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    1a86:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
    1a8a:	08 95       	ret

00001a8c <_Z12timeoutcheckv>:
}

int timeoutcheck(void) {
	
	if((TIFR3&2)>>OCF3A) {
    1a8c:	28 b3       	in	r18, 0x18	; 24
    1a8e:	21 fb       	bst	r18, 1
    1a90:	88 27       	eor	r24, r24
    1a92:	80 f9       	bld	r24, 0
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	21 ff       	sbrs	r18, 1
    1a98:	11 c0       	rjmp	.+34     	; 0x1abc <_Z12timeoutcheckv+0x30>
		cli();
    1a9a:	f8 94       	cli
			TCCR3A = 0;
    1a9c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
			TCCR3B = 0;
    1aa0:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x7c0091>
			TCNT3 = 0;
    1aa4:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    1aa8:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
			TIFR3&=~(1<<OCF3A);
    1aac:	c1 98       	cbi	0x18, 1	; 24
			PRR1|=(1<<PRTIM3);
    1aae:	e5 e6       	ldi	r30, 0x65	; 101
    1ab0:	f0 e0       	ldi	r31, 0x00	; 0
    1ab2:	80 81       	ld	r24, Z
    1ab4:	88 60       	ori	r24, 0x08	; 8
    1ab6:	80 83       	st	Z, r24
			sei();
    1ab8:	78 94       	sei
		return 1;
    1aba:	81 e0       	ldi	r24, 0x01	; 1
	} else {
		return 0;
		}
return 0;
}
    1abc:	08 95       	ret

00001abe <_Z11task_serverPv>:

   Handles generic CSP cmds and fin controller cmds.
   CSP must be enabled prior to creation of this task.
 */
CSP_DEFINE_TASK(task_server)
{
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
    1ac6:	a8 97       	sbiw	r28, 0x28	; 40
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	de bf       	out	0x3e, r29	; 62
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	cd bf       	out	0x3d, r28	; 61
    /* Create socket without any socket options */
    csp_socket_t *sock = csp_socket(CSP_SO_NONE);
    1ad2:	60 e0       	ldi	r22, 0x00	; 0
    1ad4:	70 e0       	ldi	r23, 0x00	; 0
    1ad6:	cb 01       	movw	r24, r22
    1ad8:	0e 94 dc 24 	call	0x49b8	; 0x49b8 <csp_socket>
    1adc:	5c 01       	movw	r10, r24

    /* Bind all ports to socket */
    csp_bind(sock, CSP_ANY);
    1ade:	60 e2       	ldi	r22, 0x20	; 32
    1ae0:	0e 94 41 27 	call	0x4e82	; 0x4e82 <csp_bind>

    /* Create 10 connections backlog queue */
    csp_listen(sock, 10);
    1ae4:	6a e0       	ldi	r22, 0x0A	; 10
    1ae6:	70 e0       	ldi	r23, 0x00	; 0
    1ae8:	c5 01       	movw	r24, r10
    1aea:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <csp_listen>
    csp_conn_t * conn;
    csp_packet_t * packet;

    /* Process incoming connections */
    while (1) {
csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1aee:	0f 2e       	mov	r0, r31
    1af0:	f9 ef       	ldi	r31, 0xF9	; 249
    1af2:	cf 2e       	mov	r12, r31
    1af4:	f2 e1       	ldi	r31, 0x12	; 18
    1af6:	df 2e       	mov	r13, r31
    1af8:	f0 2d       	mov	r31, r0
    1afa:	68 94       	set
    1afc:	55 24       	eor	r5, r5
    1afe:	51 f8       	bld	r5, 1

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    1b00:	ce 01       	movw	r24, r28
    1b02:	01 96       	adiw	r24, 0x01	; 1
    1b04:	9c a3       	std	Y+36, r25	; 0x24
    1b06:	8b a3       	std	Y+35, r24	; 0x23
    1b08:	3e 01       	movw	r6, r28
    1b0a:	99 e0       	ldi	r25, 0x09	; 9
    1b0c:	69 0e       	add	r6, r25
    1b0e:	71 1c       	adc	r7, r1
            break;
        }

        default: {
            /* Set error code in response to no command found */
            packet->data[0] = FIN_CMD_NOT_FOUND;
    1b10:	0f 2e       	mov	r0, r31
    1b12:	fe ef       	ldi	r31, 0xFE	; 254
    1b14:	2f 2e       	mov	r2, r31
    1b16:	f0 2d       	mov	r31, r0

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    1b18:	eb a1       	ldd	r30, Y+35	; 0x23
    1b1a:	ed a3       	std	Y+37, r30	; 0x25
    1b1c:	fc a1       	ldd	r31, Y+36	; 0x24
    1b1e:	fe a3       	std	Y+38, r31	; 0x26
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    1b20:	33 24       	eor	r3, r3
    1b22:	33 94       	inc	r3
    1b24:	41 2c       	mov	r4, r1
    1b26:	83 e2       	ldi	r24, 0x23	; 35
    1b28:	8f a3       	std	Y+39, r24	; 0x27
    1b2a:	18 a6       	std	Y+40, r1	; 0x28
    csp_conn_t * conn;
    csp_packet_t * packet;

    /* Process incoming connections */
    while (1) {
csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1b2c:	80 e0       	ldi	r24, 0x00	; 0
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	0e 94 a1 3e 	call	0x7d42	; 0x7d42 <uxTaskGetStackHighWaterMark2>
    1b34:	18 2f       	mov	r17, r24
    1b36:	09 2f       	mov	r16, r25
    1b38:	80 e0       	ldi	r24, 0x00	; 0
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	0e 94 87 3b 	call	0x770e	; 0x770e <pcTaskGetName>
    1b40:	0f 93       	push	r16
    1b42:	1f 93       	push	r17
    1b44:	9f 93       	push	r25
    1b46:	8f 93       	push	r24
    1b48:	df 92       	push	r13
    1b4a:	cf 92       	push	r12
    1b4c:	5f 92       	push	r5
    1b4e:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
        /* Wait for connection, 10000 ms timeout */
        if ((conn = csp_accept(sock, 10000)) == NULL) {
    1b52:	40 e1       	ldi	r20, 0x10	; 16
    1b54:	57 e2       	ldi	r21, 0x27	; 39
    1b56:	60 e0       	ldi	r22, 0x00	; 0
    1b58:	70 e0       	ldi	r23, 0x00	; 0
    1b5a:	c5 01       	movw	r24, r10
    1b5c:	0e 94 49 25 	call	0x4a92	; 0x4a92 <csp_accept>
    1b60:	8c 01       	movw	r16, r24
    1b62:	0f b6       	in	r0, 0x3f	; 63
    1b64:	f8 94       	cli
    1b66:	de bf       	out	0x3e, r29	; 62
    1b68:	0f be       	out	0x3f, r0	; 63
    1b6a:	cd bf       	out	0x3d, r28	; 61
    1b6c:	89 2b       	or	r24, r25
    1b6e:	f1 f2       	breq	.-68     	; 0x1b2c <_Z11task_serverPv+0x6e>
            continue;
        }

        /* Read packets */
        while ((packet = csp_read(conn, 0)) != NULL) { //was 100 in my code
    1b70:	40 e0       	ldi	r20, 0x00	; 0
    1b72:	50 e0       	ldi	r21, 0x00	; 0
    1b74:	ba 01       	movw	r22, r20
    1b76:	c8 01       	movw	r24, r16
    1b78:	0e 94 6e 25 	call	0x4adc	; 0x4adc <csp_read>
    1b7c:	7c 01       	movw	r14, r24
    1b7e:	89 2b       	or	r24, r25
    1b80:	09 f4       	brne	.+2      	; 0x1b84 <_Z11task_serverPv+0xc6>
    1b82:	62 c0       	rjmp	.+196    	; 0x1c48 <_Z11task_serverPv+0x18a>
            switch (csp_conn_dport(conn)) {
    1b84:	c8 01       	movw	r24, r16
    1b86:	0e 94 13 1c 	call	0x3826	; 0x3826 <csp_conn_dport>
    1b8a:	4f 97       	sbiw	r24, 0x1f	; 31
    1b8c:	09 f0       	breq	.+2      	; 0x1b90 <_Z11task_serverPv+0xd2>
    1b8e:	57 c0       	rjmp	.+174    	; 0x1c3e <_Z11task_serverPv+0x180>
static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    uint8_t cmd_id = packet->data[0]; // First byte is command ID

    switch(cmd_id) {
    1b90:	f7 01       	movw	r30, r14
    1b92:	86 85       	ldd	r24, Z+14	; 0x0e
    1b94:	81 30       	cpi	r24, 0x01	; 1
    1b96:	b9 f0       	breq	.+46     	; 0x1bc6 <_Z11task_serverPv+0x108>
    1b98:	28 f0       	brcs	.+10     	; 0x1ba4 <_Z11task_serverPv+0xe6>
    1b9a:	82 30       	cpi	r24, 0x02	; 2
    1b9c:	89 f1       	breq	.+98     	; 0x1c00 <_Z11task_serverPv+0x142>
    1b9e:	83 30       	cpi	r24, 0x03	; 3
    1ba0:	a1 f1       	breq	.+104    	; 0x1c0a <_Z11task_serverPv+0x14c>
    1ba2:	38 c0       	rjmp	.+112    	; 0x1c14 <_Z11task_serverPv+0x156>

            /* Get status internally */
            int8_t error = get_fin_status(&status);

            /* Set error code in response */
            packet->data[0] = error;
    1ba4:	80 e0       	ldi	r24, 0x00	; 0
    1ba6:	f7 01       	movw	r30, r14
    1ba8:	86 87       	std	Z+14, r24	; 0x0e

            if (error == FIN_CMD_OK) {
    1baa:	81 11       	cpse	r24, r1
    1bac:	09 c0       	rjmp	.+18     	; 0x1bc0 <_Z11task_serverPv+0x102>
                /* Copy status to response buffer */
                memcpy(&packet->data[1], &status, sizeof(status));
    1bae:	82 e2       	ldi	r24, 0x22	; 34
    1bb0:	ed a1       	ldd	r30, Y+37	; 0x25
    1bb2:	fe a1       	ldd	r31, Y+38	; 0x26
    1bb4:	d7 01       	movw	r26, r14
    1bb6:	1f 96       	adiw	r26, 0x0f	; 15
    1bb8:	01 90       	ld	r0, Z+
    1bba:	0d 92       	st	X+, r0
    1bbc:	8a 95       	dec	r24
    1bbe:	e1 f7       	brne	.-8      	; 0x1bb8 <_Z11task_serverPv+0xfa>
    1bc0:	9f a1       	ldd	r25, Y+39	; 0x27
    1bc2:	88 a5       	ldd	r24, Y+40	; 0x28
    1bc4:	2b c0       	rjmp	.+86     	; 0x1c1c <_Z11task_serverPv+0x15e>

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    1bc6:	88 e0       	ldi	r24, 0x08	; 8
    1bc8:	f7 01       	movw	r30, r14
    1bca:	3f 96       	adiw	r30, 0x0f	; 15
    1bcc:	ad a1       	ldd	r26, Y+37	; 0x25
    1bce:	be a1       	ldd	r27, Y+38	; 0x26
    1bd0:	01 90       	ld	r0, Z+
    1bd2:	0d 92       	st	X+, r0
    1bd4:	8a 95       	dec	r24
    1bd6:	e1 f7       	brne	.-8      	; 0x1bd0 <_Z11task_serverPv+0x112>
    1bd8:	ce 01       	movw	r24, r28
    1bda:	01 96       	adiw	r24, 0x01	; 1
    1bdc:	4c 01       	movw	r8, r24

            /* Ensure correct endianness */
            uint16_t * pos_array = (uint16_t *) &pos; //(void *)
            for (int i = 0; i < 4; i++) {
                pos_array[i] = csp_ntoh16(pos_array[i]);
    1bde:	f4 01       	movw	r30, r8
    1be0:	80 81       	ld	r24, Z
    1be2:	91 81       	ldd	r25, Z+1	; 0x01
    1be4:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <csp_ntoh16>
    1be8:	f4 01       	movw	r30, r8
    1bea:	81 93       	st	Z+, r24
    1bec:	91 93       	st	Z+, r25
    1bee:	4f 01       	movw	r8, r30
            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));

            /* Ensure correct endianness */
            uint16_t * pos_array = (uint16_t *) &pos; //(void *)
            for (int i = 0; i < 4; i++) {
    1bf0:	e6 15       	cp	r30, r6
    1bf2:	f7 05       	cpc	r31, r7
    1bf4:	a1 f7       	brne	.-24     	; 0x1bde <_Z11task_serverPv+0x120>
            }
            /* Pass positions to internal layer */
            int8_t error = set_fin_pos(&pos);

            /* Set error code in response */
            packet->data[0] = error;
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    1bfa:	93 2d       	mov	r25, r3
    1bfc:	84 2d       	mov	r24, r4
    1bfe:	0e c0       	rjmp	.+28     	; 0x1c1c <_Z11task_serverPv+0x15e>
        case GS_FIN_CMD_SET_MAX_DRAG: {
            /* Pass command to internal layer */
            int8_t error = set_max_drag();

            /* Set error code in response */
            packet->data[0] = error;
    1c00:	f7 01       	movw	r30, r14
    1c02:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    1c04:	93 2d       	mov	r25, r3
    1c06:	84 2d       	mov	r24, r4
    1c08:	09 c0       	rjmp	.+18     	; 0x1c1c <_Z11task_serverPv+0x15e>
        case GS_FIN_CMD_SET_MIN_DRAG: {
            /* Pass command to internal layer */
            int8_t error = set_min_drag();

            /* Set error code in response */
            packet->data[0] = error;
    1c0a:	f7 01       	movw	r30, r14
    1c0c:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    1c0e:	93 2d       	mov	r25, r3
    1c10:	84 2d       	mov	r24, r4
    1c12:	04 c0       	rjmp	.+8      	; 0x1c1c <_Z11task_serverPv+0x15e>
            break;
        }

        default: {
            /* Set error code in response to no command found */
            packet->data[0] = FIN_CMD_NOT_FOUND;
    1c14:	f7 01       	movw	r30, r14
    1c16:	26 86       	std	Z+14, r2	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    1c18:	93 2d       	mov	r25, r3
    1c1a:	84 2d       	mov	r24, r4
            break;
        }
    }

    /* Send response */
    packet->length = reply_length;
    1c1c:	f7 01       	movw	r30, r14
    1c1e:	90 87       	std	Z+8, r25	; 0x08
    1c20:	81 87       	std	Z+9, r24	; 0x09
    if (!csp_send(conn, packet, 0)) {
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	30 e0       	ldi	r19, 0x00	; 0
    1c26:	a9 01       	movw	r20, r18
    1c28:	b7 01       	movw	r22, r14
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <csp_send>
    1c30:	89 2b       	or	r24, r25
    1c32:	09 f0       	breq	.+2      	; 0x1c36 <_Z11task_serverPv+0x178>
    1c34:	9d cf       	rjmp	.-198    	; 0x1b70 <_Z11task_serverPv+0xb2>
        csp_buffer_free(packet);
    1c36:	c7 01       	movw	r24, r14
    1c38:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    1c3c:	99 cf       	rjmp	.-206    	; 0x1b70 <_Z11task_serverPv+0xb2>
                    process_fin_cmd(conn, packet);
                    break;

                default:
                    /* Let the service handler reply pings, buffer use, etc. */
                    csp_service_handler(conn, packet);
    1c3e:	b7 01       	movw	r22, r14
    1c40:	c8 01       	movw	r24, r16
    1c42:	0e 94 8f 2d 	call	0x5b1e	; 0x5b1e <csp_service_handler>
                    break;
    1c46:	94 cf       	rjmp	.-216    	; 0x1b70 <_Z11task_serverPv+0xb2>
            }
        }

        /* Close current connection, and handle next */
        csp_close(conn);
    1c48:	c8 01       	movw	r24, r16
    1c4a:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <csp_close>
    1c4e:	6e cf       	rjmp	.-292    	; 0x1b2c <_Z11task_serverPv+0x6e>

00001c50 <_Z17stepper_1_cs_initv>:
};

//functions for controlling certain pins of steppers

void stepper_1_cs_init(void) {
	PORTJ|=(1<<PJ6); //for enable pin
    1c50:	e5 e0       	ldi	r30, 0x05	; 5
    1c52:	f1 e0       	ldi	r31, 0x01	; 1
    1c54:	80 81       	ld	r24, Z
    1c56:	80 64       	ori	r24, 0x40	; 64
    1c58:	80 83       	st	Z, r24
	PORTH|=(1<<PH6); // for cs pin
    1c5a:	e2 e0       	ldi	r30, 0x02	; 2
    1c5c:	f1 e0       	ldi	r31, 0x01	; 1
    1c5e:	80 81       	ld	r24, Z
    1c60:	80 64       	ori	r24, 0x40	; 64
    1c62:	80 83       	st	Z, r24
	DDRJ&=~(1<<PJ6);
    1c64:	e4 e0       	ldi	r30, 0x04	; 4
    1c66:	f1 e0       	ldi	r31, 0x01	; 1
    1c68:	80 81       	ld	r24, Z
    1c6a:	8f 7b       	andi	r24, 0xBF	; 191
    1c6c:	80 83       	st	Z, r24
	DDRH|=(1<<PH6);
    1c6e:	e1 e0       	ldi	r30, 0x01	; 1
    1c70:	f1 e0       	ldi	r31, 0x01	; 1
    1c72:	80 81       	ld	r24, Z
    1c74:	80 64       	ori	r24, 0x40	; 64
    1c76:	80 83       	st	Z, r24
    1c78:	08 95       	ret

00001c7a <_Z14stepper_1_csonv>:
}

void stepper_1_cson(void) {
	DDRH&=~(1<<PH6);
    1c7a:	e1 e0       	ldi	r30, 0x01	; 1
    1c7c:	f1 e0       	ldi	r31, 0x01	; 1
    1c7e:	80 81       	ld	r24, Z
    1c80:	8f 7b       	andi	r24, 0xBF	; 191
    1c82:	80 83       	st	Z, r24
    1c84:	08 95       	ret

00001c86 <_Z15stepper_1_csoffv>:
}

void stepper_1_csoff(void) {
	DDRH|=(1<<PH6);
    1c86:	e1 e0       	ldi	r30, 0x01	; 1
    1c88:	f1 e0       	ldi	r31, 0x01	; 1
    1c8a:	80 81       	ld	r24, Z
    1c8c:	80 64       	ori	r24, 0x40	; 64
    1c8e:	80 83       	st	Z, r24
    1c90:	08 95       	ret

00001c92 <_Z12stepper_1_env>:
}

void stepper_1_en(void) {
	DDRJ&=~(1<<PJ6);
    1c92:	e4 e0       	ldi	r30, 0x04	; 4
    1c94:	f1 e0       	ldi	r31, 0x01	; 1
    1c96:	80 81       	ld	r24, Z
    1c98:	8f 7b       	andi	r24, 0xBF	; 191
    1c9a:	80 83       	st	Z, r24
    1c9c:	08 95       	ret

00001c9e <_Z13stepper_1_disv>:
}

void stepper_1_dis(void) {
	DDRJ|=(1<<PJ6);
    1c9e:	e4 e0       	ldi	r30, 0x04	; 4
    1ca0:	f1 e0       	ldi	r31, 0x01	; 1
    1ca2:	80 81       	ld	r24, Z
    1ca4:	80 64       	ori	r24, 0x40	; 64
    1ca6:	80 83       	st	Z, r24
    1ca8:	08 95       	ret

00001caa <_Z17stepper_2_cs_initv>:
}

void stepper_2_cs_init(void) {
	PORTJ|=(1<<PJ5); //for enable pin
    1caa:	e5 e0       	ldi	r30, 0x05	; 5
    1cac:	f1 e0       	ldi	r31, 0x01	; 1
    1cae:	80 81       	ld	r24, Z
    1cb0:	80 62       	ori	r24, 0x20	; 32
    1cb2:	80 83       	st	Z, r24
	PORTL|=(1<<PL5); // for cs pin
    1cb4:	eb e0       	ldi	r30, 0x0B	; 11
    1cb6:	f1 e0       	ldi	r31, 0x01	; 1
    1cb8:	80 81       	ld	r24, Z
    1cba:	80 62       	ori	r24, 0x20	; 32
    1cbc:	80 83       	st	Z, r24
	DDRJ&=~(1<<PJ5);
    1cbe:	e4 e0       	ldi	r30, 0x04	; 4
    1cc0:	f1 e0       	ldi	r31, 0x01	; 1
    1cc2:	80 81       	ld	r24, Z
    1cc4:	8f 7d       	andi	r24, 0xDF	; 223
    1cc6:	80 83       	st	Z, r24
	DDRL|=(1<<PL5);
    1cc8:	ea e0       	ldi	r30, 0x0A	; 10
    1cca:	f1 e0       	ldi	r31, 0x01	; 1
    1ccc:	80 81       	ld	r24, Z
    1cce:	80 62       	ori	r24, 0x20	; 32
    1cd0:	80 83       	st	Z, r24
    1cd2:	08 95       	ret

00001cd4 <_Z14stepper_2_csonv>:
}

void stepper_2_cson(void) {
	DDRL&=~(1<<PL5);
    1cd4:	ea e0       	ldi	r30, 0x0A	; 10
    1cd6:	f1 e0       	ldi	r31, 0x01	; 1
    1cd8:	80 81       	ld	r24, Z
    1cda:	8f 7d       	andi	r24, 0xDF	; 223
    1cdc:	80 83       	st	Z, r24
    1cde:	08 95       	ret

00001ce0 <_Z15stepper_2_csoffv>:
	
}

void stepper_2_csoff(void) {
	DDRL|=(1<<PL5);
    1ce0:	ea e0       	ldi	r30, 0x0A	; 10
    1ce2:	f1 e0       	ldi	r31, 0x01	; 1
    1ce4:	80 81       	ld	r24, Z
    1ce6:	80 62       	ori	r24, 0x20	; 32
    1ce8:	80 83       	st	Z, r24
    1cea:	08 95       	ret

00001cec <_Z12stepper_2_env>:
}

void stepper_2_en(void) {
	DDRJ&=~(1<<PJ5);
    1cec:	e4 e0       	ldi	r30, 0x04	; 4
    1cee:	f1 e0       	ldi	r31, 0x01	; 1
    1cf0:	80 81       	ld	r24, Z
    1cf2:	8f 7d       	andi	r24, 0xDF	; 223
    1cf4:	80 83       	st	Z, r24
    1cf6:	08 95       	ret

00001cf8 <_Z13stepper_2_disv>:
}

void stepper_2_dis(void) {
	DDRJ|=(1<<PJ5);
    1cf8:	e4 e0       	ldi	r30, 0x04	; 4
    1cfa:	f1 e0       	ldi	r31, 0x01	; 1
    1cfc:	80 81       	ld	r24, Z
    1cfe:	80 62       	ori	r24, 0x20	; 32
    1d00:	80 83       	st	Z, r24
    1d02:	08 95       	ret

00001d04 <_Z14get_fin_statusP13gs_fin_status>:

//get currents

//get mode

}
    1d04:	08 95       	ret

00001d06 <_Z11set_fin_posPK16gs_fin_positions>:



gs_fin_cmd_error_t set_fin_pos(const gs_fin_positions_t * pos) {}
    1d06:	08 95       	ret

00001d08 <_Z12set_max_dragv>:

gs_fin_cmd_error_t set_max_drag(void) {}
    1d08:	08 95       	ret

00001d0a <_Z12set_min_dragv>:

gs_fin_cmd_error_t set_min_drag(void) {}
    1d0a:	08 95       	ret

00001d0c <_Z12change_ustepv>:
	
gs_fin_cmd_error_t change_ustep(void) {
	
	//When operating at less than 16 times microstepping, be sure to first position to a suitable, symmetric switching position, before changing MRES, otherwise the motor behavior may differ for left and right rotation. For 16 times microstepping, interpolation to 256 microsteps gives best results!
	
}
    1d0c:	08 95       	ret

00001d0e <_Z18setup_temp_sensorsv>:

	void setup_temp_sensors(void) {
		ADMUX=0x40;
    1d0e:	80 e4       	ldi	r24, 0x40	; 64
    1d10:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7c007c>
		ADCSRA=0b10000100; //set adc clock
    1d14:	84 e8       	ldi	r24, 0x84	; 132
    1d16:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7c007a>
		ADCSRB=0x00; 
    1d1a:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7c007b>
		DIDR0=0x0F; //turn of digital input bufs
    1d1e:	8f e0       	ldi	r24, 0x0F	; 15
    1d20:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7c007e>
    1d24:	08 95       	ret

00001d26 <_Z17read_temp_sensorsPj>:
		
	}

	void read_temp_sensors(uint16_t *array){
    1d26:	dc 01       	movw	r26, r24
		double tempstore=0;
		portENTER_CRITICAL();
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	0f 92       	push	r0
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK1;
    1d2e:	ec e7       	ldi	r30, 0x7C	; 124
    1d30:	f0 e0       	ldi	r31, 0x00	; 0
    1d32:	80 81       	ld	r24, Z
    1d34:	80 7f       	andi	r24, 0xF0	; 240
    1d36:	83 60       	ori	r24, 0x03	; 3
    1d38:	80 83       	st	Z, r24
		ADCSRA|=(1<<ADSC);
    1d3a:	ea e7       	ldi	r30, 0x7A	; 122
    1d3c:	f0 e0       	ldi	r31, 0x00	; 0
    1d3e:	80 81       	ld	r24, Z
    1d40:	80 64       	ori	r24, 0x40	; 64
    1d42:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    1d44:	90 81       	ld	r25, Z
    1d46:	96 fd       	sbrc	r25, 6
    1d48:	fd cf       	rjmp	.-6      	; 0x1d44 <_Z17read_temp_sensorsPj+0x1e>
		//tempstore=(TEMP_RES_VAL*ADC)/(1024-ADC);    //sort this out
		//*(array)=(uint16_t)(TEMP_CAL_BETA/(log((tempstore)/TEMP_RES_INF));
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK2;
    1d4a:	ec e7       	ldi	r30, 0x7C	; 124
    1d4c:	f0 e0       	ldi	r31, 0x00	; 0
    1d4e:	90 81       	ld	r25, Z
    1d50:	90 7f       	andi	r25, 0xF0	; 240
    1d52:	92 60       	ori	r25, 0x02	; 2
    1d54:	90 83       	st	Z, r25
		ADCSRA|=(1<<ADSC);
    1d56:	ea e7       	ldi	r30, 0x7A	; 122
    1d58:	f0 e0       	ldi	r31, 0x00	; 0
    1d5a:	80 81       	ld	r24, Z
    1d5c:	80 64       	ori	r24, 0x40	; 64
    1d5e:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    1d60:	90 81       	ld	r25, Z
    1d62:	96 fd       	sbrc	r25, 6
    1d64:	fd cf       	rjmp	.-6      	; 0x1d60 <_Z17read_temp_sensorsPj+0x3a>
		*(array+1)=ADC;
    1d66:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    1d6a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    1d6e:	13 96       	adiw	r26, 0x03	; 3
    1d70:	9c 93       	st	X, r25
    1d72:	8e 93       	st	-X, r24
    1d74:	12 97       	sbiw	r26, 0x02	; 2
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK3;
    1d76:	ec e7       	ldi	r30, 0x7C	; 124
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	90 81       	ld	r25, Z
    1d7c:	90 7f       	andi	r25, 0xF0	; 240
    1d7e:	91 60       	ori	r25, 0x01	; 1
    1d80:	90 83       	st	Z, r25
		ADCSRA|=(1<<ADSC);
    1d82:	ea e7       	ldi	r30, 0x7A	; 122
    1d84:	f0 e0       	ldi	r31, 0x00	; 0
    1d86:	80 81       	ld	r24, Z
    1d88:	80 64       	ori	r24, 0x40	; 64
    1d8a:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    1d8c:	90 81       	ld	r25, Z
    1d8e:	96 fd       	sbrc	r25, 6
    1d90:	fd cf       	rjmp	.-6      	; 0x1d8c <_Z17read_temp_sensorsPj+0x66>
		*(array+2)=ADC;
    1d92:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    1d96:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    1d9a:	15 96       	adiw	r26, 0x05	; 5
    1d9c:	9c 93       	st	X, r25
    1d9e:	8e 93       	st	-X, r24
    1da0:	14 97       	sbiw	r26, 0x04	; 4
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK4;
    1da2:	ec e7       	ldi	r30, 0x7C	; 124
    1da4:	f0 e0       	ldi	r31, 0x00	; 0
    1da6:	80 81       	ld	r24, Z
    1da8:	80 7f       	andi	r24, 0xF0	; 240
    1daa:	80 83       	st	Z, r24
		ADCSRA|=(1<<ADSC);
    1dac:	ea e7       	ldi	r30, 0x7A	; 122
    1dae:	f0 e0       	ldi	r31, 0x00	; 0
    1db0:	80 81       	ld	r24, Z
    1db2:	80 64       	ori	r24, 0x40	; 64
    1db4:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    1db6:	90 81       	ld	r25, Z
    1db8:	96 fd       	sbrc	r25, 6
    1dba:	fd cf       	rjmp	.-6      	; 0x1db6 <_Z17read_temp_sensorsPj+0x90>
		*(array+3)=ADC;
    1dbc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    1dc0:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    1dc4:	17 96       	adiw	r26, 0x07	; 7
    1dc6:	9c 93       	st	X, r25
    1dc8:	8e 93       	st	-X, r24
    1dca:	16 97       	sbiw	r26, 0x06	; 6
		portEXIT_CRITICAL();
    1dcc:	0f 90       	pop	r0
    1dce:	0f be       	out	0x3f, r0	; 63
    1dd0:	08 95       	ret

00001dd2 <_Z11init_serverv>:
    return CSP_TASK_RETURN;
}



gs_fin_cmd_error_t init_server(void) {
    1dd2:	ef 92       	push	r14
    1dd4:	ff 92       	push	r15
    1dd6:	0f 93       	push	r16
    1dd8:	1f 93       	push	r17
	public:
	tmc2041(void (csinitin()),void (csonin()),void (csoffin()),void (enstepin()), void (disstepin()),
	uniman_step_config_t configin) : csinit(csinitin), cson(csonin), csoff(csoffin) , enstep(enstepin),
	disstep(disstepin) {
		config=configin;
		csinit();
    1dda:	3a df       	rcall	.-396    	; 0x1c50 <_Z17stepper_1_cs_initv>
    1ddc:	66 df       	rcall	.-308    	; 0x1caa <_Z17stepper_2_cs_initv>
		
	tmc2041 stepper1(&stepper_1_cs_init,&stepper_1_cson,&stepper_1_csoff,&stepper_1_en, &stepper_1_dis,  uniman_step1_conf);
	tmc2041 stepper2(&stepper_2_cs_init,&stepper_2_cson,&stepper_2_csoff,&stepper_2_en, &stepper_2_dis,  uniman_step2_conf);	
	
	
	if(!csp_thread_create(task_server, "SERVER", 270, NULL, 2, &handle_server)) {
    1dde:	0f 2e       	mov	r0, r31
    1de0:	f6 e7       	ldi	r31, 0x76	; 118
    1de2:	ef 2e       	mov	r14, r31
    1de4:	f6 e0       	ldi	r31, 0x06	; 6
    1de6:	ff 2e       	mov	r15, r31
    1de8:	f0 2d       	mov	r31, r0
    1dea:	02 e0       	ldi	r16, 0x02	; 2
    1dec:	10 e0       	ldi	r17, 0x00	; 0
    1dee:	20 e0       	ldi	r18, 0x00	; 0
    1df0:	30 e0       	ldi	r19, 0x00	; 0
    1df2:	4e e0       	ldi	r20, 0x0E	; 14
    1df4:	51 e0       	ldi	r21, 0x01	; 1
    1df6:	6a eb       	ldi	r22, 0xBA	; 186
    1df8:	72 e0       	ldi	r23, 0x02	; 2
    1dfa:	8f e5       	ldi	r24, 0x5F	; 95
    1dfc:	9d e0       	ldi	r25, 0x0D	; 13
    1dfe:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <csp_thread_create>
    1e02:	21 e0       	ldi	r18, 0x01	; 1
    1e04:	89 2b       	or	r24, r25
    1e06:	09 f4       	brne	.+2      	; 0x1e0a <_Z11init_serverv+0x38>
    1e08:	20 e0       	ldi	r18, 0x00	; 0

	//should also initalise other things such as temp sensors and steppers here
	
	//also remember to initalise the status frame
	
}
    1e0a:	82 2f       	mov	r24, r18
    1e0c:	81 95       	neg	r24
    1e0e:	1f 91       	pop	r17
    1e10:	0f 91       	pop	r16
    1e12:	ff 90       	pop	r15
    1e14:	ef 90       	pop	r14
    1e16:	08 95       	ret

00001e18 <_ZL4wdtrPv>:
}
/*-----------------------------------------------------------*/


static void wdtr(void* pvParameters) {
	 wdt_reset();
    1e18:	a8 95       	wdr
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
    1e1a:	9d e0       	ldi	r25, 0x0D	; 13
    1e1c:	88 e1       	ldi	r24, 0x18	; 24
    1e1e:	0f b6       	in	r0, 0x3f	; 63
    1e20:	f8 94       	cli
    1e22:	a8 95       	wdr
    1e24:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    1e28:	0f be       	out	0x3f, r0	; 63
    1e2a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
	 wdt_enable(WDTO_500MS);
	 
	 int a =0;
	 
	for(;;) {
	wdt_reset();
    1e2e:	a8 95       	wdr
	vTaskDelay(200/ portTICK_PERIOD_MS);
    1e30:	84 e1       	ldi	r24, 0x14	; 20
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	0e 94 ae 3c 	call	0x795c	; 0x795c <vTaskDelay>
	contled(TOGCON,0);
    1e38:	60 e0       	ldi	r22, 0x00	; 0
    1e3a:	70 e0       	ldi	r23, 0x00	; 0
    1e3c:	80 e0       	ldi	r24, 0x00	; 0
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	b9 dd       	rcall	.-1166   	; 0x19b4 <_Z7contledii>
    1e42:	f5 cf       	rjmp	.-22     	; 0x1e2e <_ZL4wdtrPv+0x16>

00001e44 <_Z11task_clientPv>:
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1e44:	0f 2e       	mov	r0, r31
    1e46:	f9 e4       	ldi	r31, 0x49	; 73
    1e48:	af 2e       	mov	r10, r31
    1e4a:	f3 e1       	ldi	r31, 0x13	; 19
    1e4c:	bf 2e       	mov	r11, r31
    1e4e:	f0 2d       	mov	r31, r0
    1e50:	12 e0       	ldi	r17, 0x02	; 2
		volatile unsigned int *sp=(volatile unsigned int *)SP;
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
		csp_log_info("SP = 0x%04x\n",StackP);;
    1e52:	0f 2e       	mov	r0, r31
    1e54:	fc e3       	ldi	r31, 0x3C	; 60
    1e56:	cf 2e       	mov	r12, r31
    1e58:	f3 e1       	ldi	r31, 0x13	; 19
    1e5a:	df 2e       	mov	r13, r31
    1e5c:	f0 2d       	mov	r31, r0
		int result = csp_ping(1, 100, 10, CSP_O_NONE);

		if (result==-1) {csp_log_error("Ping Failed\n");}
    1e5e:	0f 2e       	mov	r0, r31
    1e60:	ff e2       	ldi	r31, 0x2F	; 47
    1e62:	8f 2e       	mov	r8, r31
    1e64:	f3 e1       	ldi	r31, 0x13	; 19
    1e66:	9f 2e       	mov	r9, r31
    1e68:	f0 2d       	mov	r31, r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    1e6a:	0f 2e       	mov	r0, r31
    1e6c:	f9 e1       	ldi	r31, 0x19	; 25
    1e6e:	ef 2e       	mov	r14, r31
    1e70:	f3 e1       	ldi	r31, 0x13	; 19
    1e72:	ff 2e       	mov	r15, r31
    1e74:	f0 2d       	mov	r31, r0
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    1e76:	80 e0       	ldi	r24, 0x00	; 0
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	0e 94 a1 3e 	call	0x7d42	; 0x7d42 <uxTaskGetStackHighWaterMark2>
    1e7e:	c8 2f       	mov	r28, r24
    1e80:	d9 2f       	mov	r29, r25
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	0e 94 87 3b 	call	0x770e	; 0x770e <pcTaskGetName>
    1e8a:	df 93       	push	r29
    1e8c:	cf 93       	push	r28
    1e8e:	9f 93       	push	r25
    1e90:	8f 93       	push	r24
    1e92:	bf 92       	push	r11
    1e94:	af 92       	push	r10
    1e96:	1f 93       	push	r17
    1e98:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		csp_sleep_ms(1000);
    1e9c:	84 e6       	ldi	r24, 0x64	; 100
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	0e 94 ae 3c 	call	0x795c	; 0x795c <vTaskDelay>
		
		//int *sph = 0x3E;
		//volatile unsigned int *sph = (volatile unsigned int *)0x5E;
		//volatile unsigned int *spl = (volatile unsigned int *)0x5D;
		volatile unsigned int *sp=(volatile unsigned int *)SP;
    1ea4:	ed b7       	in	r30, 0x3d	; 61
    1ea6:	fe b7       	in	r31, 0x3e	; 62
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
    1ea8:	80 81       	ld	r24, Z
    1eaa:	91 81       	ldd	r25, Z+1	; 0x01
		csp_log_info("SP = 0x%04x\n",StackP);;
    1eac:	9f 93       	push	r25
    1eae:	8f 93       	push	r24
    1eb0:	df 92       	push	r13
    1eb2:	cf 92       	push	r12
    1eb4:	1f 93       	push	r17
    1eb6:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		int result = csp_ping(1, 100, 10, CSP_O_NONE);
    1eba:	00 e0       	ldi	r16, 0x00	; 0
    1ebc:	2a e0       	ldi	r18, 0x0A	; 10
    1ebe:	30 e0       	ldi	r19, 0x00	; 0
    1ec0:	44 e6       	ldi	r20, 0x64	; 100
    1ec2:	50 e0       	ldi	r21, 0x00	; 0
    1ec4:	60 e0       	ldi	r22, 0x00	; 0
    1ec6:	70 e0       	ldi	r23, 0x00	; 0
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	0e 94 d6 2c 	call	0x59ac	; 0x59ac <csp_ping>
    1ece:	ec 01       	movw	r28, r24

		if (result==-1) {csp_log_error("Ping Failed\n");}
    1ed0:	8d b7       	in	r24, 0x3d	; 61
    1ed2:	9e b7       	in	r25, 0x3e	; 62
    1ed4:	0c 96       	adiw	r24, 0x0c	; 12
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	9e bf       	out	0x3e, r25	; 62
    1edc:	0f be       	out	0x3f, r0	; 63
    1ede:	8d bf       	out	0x3d, r24	; 61
    1ee0:	cf 3f       	cpi	r28, 0xFF	; 255
    1ee2:	9f ef       	ldi	r25, 0xFF	; 255
    1ee4:	d9 07       	cpc	r29, r25
    1ee6:	41 f4       	brne	.+16     	; 0x1ef8 <_Z11task_clientPv+0xb4>
    1ee8:	9f 92       	push	r9
    1eea:	8f 92       	push	r8
    1eec:	1f 92       	push	r1
    1eee:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    1ef2:	0f 90       	pop	r0
    1ef4:	0f 90       	pop	r0
    1ef6:	0f 90       	pop	r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    1ef8:	df 93       	push	r29
    1efa:	cf 93       	push	r28
    1efc:	ff 92       	push	r15
    1efe:	ef 92       	push	r14
    1f00:	1f 93       	push	r17
    1f02:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>

		csp_sleep_ms(1000);
    1f06:	84 e6       	ldi	r24, 0x64	; 100
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	0e 94 ae 3c 	call	0x795c	; 0x795c <vTaskDelay>

	csp_packet_t * packet;
	csp_conn_t * conn;
	//usart_pstr_p(PSTR("client task init"),1);

	for(;;) {
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0f 90       	pop	r0
    1f14:	0f 90       	pop	r0
    1f16:	0f 90       	pop	r0
    1f18:	ae cf       	rjmp	.-164    	; 0x1e76 <_Z11task_clientPv+0x32>

00001f1a <main>:

	


int main( void )
{
    1f1a:	cf 92       	push	r12
    1f1c:	df 92       	push	r13
    1f1e:	ef 92       	push	r14
    1f20:	ff 92       	push	r15
    1f22:	0f 93       	push	r16
    1f24:	1f 93       	push	r17
    1f26:	cf 93       	push	r28
    1f28:	df 93       	push	r29
    1f2a:	1f 92       	push	r1
    1f2c:	1f 92       	push	r1
    1f2e:	cd b7       	in	r28, 0x3d	; 61
    1f30:	de b7       	in	r29, 0x3e	; 62
	usart_init(MYUBRR);
    1f32:	83 e0       	ldi	r24, 0x03	; 3
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	bf d7       	rcall	.+3966   	; 0x2eb6 <usart_init>
fdevopen( &usart_putchar_printf,0);
    1f38:	60 e0       	ldi	r22, 0x00	; 0
    1f3a:	70 e0       	ldi	r23, 0x00	; 0
    1f3c:	83 e7       	ldi	r24, 0x73	; 115
    1f3e:	97 e1       	ldi	r25, 0x17	; 23
    1f40:	0e 94 cd 45 	call	0x8b9a	; 0x8b9a <fdevopen>
    1f44:	9d e0       	ldi	r25, 0x0D	; 13
    1f46:	88 e1       	ldi	r24, 0x18	; 24
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	a8 95       	wdr
    1f4e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>


	
	wdt_enable(WDTO_500MS); // set watchdog up to reset if not called after 2s
	//pwrredinit();
	enableleds();
    1f58:	23 dd       	rcall	.-1466   	; 0x19a0 <_Z10enableledsv>



		int error=0;
		
		error+=csp_buffer_init(4, MSGMAX);
    1f5a:	62 e3       	ldi	r22, 0x32	; 50
    1f5c:	70 e0       	ldi	r23, 0x00	; 0
    1f5e:	84 e0       	ldi	r24, 0x04	; 4
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	cd d7       	rcall	.+3994   	; 0x2efe <csp_buffer_init>
    1f64:	6c 01       	movw	r12, r24

	
		// Init CSP with address MY_ADDRESS 
		error+=csp_init(MY_ADDRESS);
    1f66:	86 e0       	ldi	r24, 0x06	; 6
    1f68:	0e 94 b6 24 	call	0x496c	; 0x496c <csp_init>
    1f6c:	c8 0e       	add	r12, r24
    1f6e:	d9 1e       	adc	r13, r25
		
		error+=csp_can_init(0,&can_conf);
    1f70:	6c e7       	ldi	r22, 0x7C	; 124
    1f72:	72 e0       	ldi	r23, 0x02	; 2
    1f74:	80 e0       	ldi	r24, 0x00	; 0
    1f76:	0e 94 aa 23 	call	0x4754	; 0x4754 <csp_can_init>
    1f7a:	c8 0e       	add	r12, r24
    1f7c:	d9 1e       	adc	r13, r25
		
		error+=csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_can, 0xFF);
    1f7e:	2f ef       	ldi	r18, 0xFF	; 255
    1f80:	42 e1       	ldi	r20, 0x12	; 18
    1f82:	52 e0       	ldi	r21, 0x02	; 2
    1f84:	65 e0       	ldi	r22, 0x05	; 5
    1f86:	80 e2       	ldi	r24, 0x20	; 32
    1f88:	0e 94 b8 2b 	call	0x5770	; 0x5770 <csp_rtable_set>
    1f8c:	c8 0e       	add	r12, r24
    1f8e:	d9 1e       	adc	r13, r25

		// Start router task with 500 word stack, OS task priority 1 		
		error+=csp_route_start_task(180, 1);
    1f90:	61 e0       	ldi	r22, 0x01	; 1
    1f92:	70 e0       	ldi	r23, 0x00	; 0
    1f94:	84 eb       	ldi	r24, 0xB4	; 180
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	0e 94 4e 2b 	call	0x569c	; 0x569c <csp_route_start_task>
    1f9c:	c8 0e       	add	r12, r24
		
		
		
		error-=init_server();
    1f9e:	d9 1e       	adc	r13, r25
    1fa0:	18 df       	rcall	.-464    	; 0x1dd2 <_Z11init_serverv>
    1fa2:	c8 1a       	sub	r12, r24
    1fa4:	d1 08       	sbc	r13, r1
    1fa6:	87 fd       	sbrc	r24, 7
    1fa8:	d3 94       	inc	r13
		printf("%d",error);
    1faa:	df 92       	push	r13
    1fac:	cf 92       	push	r12
    1fae:	84 e8       	ldi	r24, 0x84	; 132
    1fb0:	93 e1       	ldi	r25, 0x13	; 19
    1fb2:	9f 93       	push	r25
    1fb4:	8f 93       	push	r24
    1fb6:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>

		// Client 
		
		csp_thread_handle_t handle_client;
		error+=csp_thread_create(task_client, "CLIENT", 220, NULL, 1, &handle_client);
    1fba:	ce 01       	movw	r24, r28
    1fbc:	01 96       	adiw	r24, 0x01	; 1
    1fbe:	7c 01       	movw	r14, r24
    1fc0:	01 e0       	ldi	r16, 0x01	; 1
    1fc2:	10 e0       	ldi	r17, 0x00	; 0
    1fc4:	20 e0       	ldi	r18, 0x00	; 0
    1fc6:	30 e0       	ldi	r19, 0x00	; 0
    1fc8:	4c ed       	ldi	r20, 0xDC	; 220
    1fca:	50 e0       	ldi	r21, 0x00	; 0
    1fcc:	64 ed       	ldi	r22, 0xD4	; 212
    1fce:	72 e0       	ldi	r23, 0x02	; 2
    1fd0:	82 e2       	ldi	r24, 0x22	; 34
    1fd2:	9f e0       	ldi	r25, 0x0F	; 15
    1fd4:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <csp_thread_create>
    1fd8:	c8 0e       	add	r12, r24
    1fda:	d9 1e       	adc	r13, r25
		
		//csp_log_reset("test");
		error+=csp_thread_create(CanRxFunc,"CANRX",180,NULL,3,&handle_canrx);
    1fdc:	0f 2e       	mov	r0, r31
    1fde:	f8 ee       	ldi	r31, 0xE8	; 232
    1fe0:	ef 2e       	mov	r14, r31
    1fe2:	ff e1       	ldi	r31, 0x1F	; 31
    1fe4:	ff 2e       	mov	r15, r31
    1fe6:	f0 2d       	mov	r31, r0
    1fe8:	03 e0       	ldi	r16, 0x03	; 3
    1fea:	10 e0       	ldi	r17, 0x00	; 0
    1fec:	20 e0       	ldi	r18, 0x00	; 0
    1fee:	30 e0       	ldi	r19, 0x00	; 0
    1ff0:	44 eb       	ldi	r20, 0xB4	; 180
    1ff2:	50 e0       	ldi	r21, 0x00	; 0
    1ff4:	6b ed       	ldi	r22, 0xDB	; 219
    1ff6:	72 e0       	ldi	r23, 0x02	; 2
    1ff8:	86 ee       	ldi	r24, 0xE6	; 230
    1ffa:	9a e0       	ldi	r25, 0x0A	; 10
    1ffc:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <csp_thread_create>
		
		if(error!=0) {
    2000:	8c 0d       	add	r24, r12
    2002:	9d 1d       	adc	r25, r13
    2004:	0f 90       	pop	r0
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	0f 90       	pop	r0
    200c:	89 2b       	or	r24, r25
    200e:	81 f0       	breq	.+32     	; 0x2030 <__DATA_REGION_LENGTH__+0x30>
			contled(ONCON,2);
    2010:	62 e0       	ldi	r22, 0x02	; 2
    2012:	70 e0       	ldi	r23, 0x00	; 0
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	cd dc       	rcall	.-1638   	; 0x19b4 <_Z7contledii>
			csp_log_reset("Setup Error");
    201a:	88 e7       	ldi	r24, 0x78	; 120
    201c:	93 e1       	ldi	r25, 0x13	; 19
    201e:	9f 93       	push	r25
    2020:	8f 93       	push	r24
    2022:	86 e0       	ldi	r24, 0x06	; 6
    2024:	8f 93       	push	r24
    2026:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    202a:	0f 90       	pop	r0
    202c:	0f 90       	pop	r0
    202e:	0f 90       	pop	r0
		//csp_debug_toggle_level(CSP_INFO);
		//csp_debug_toggle_level(CSP_WARN);
		//csp_debug_toggle_level(CSP_ERROR);

		
		printf("Conn table\r\n");
    2030:	8b e6       	ldi	r24, 0x6B	; 107
    2032:	93 e1       	ldi	r25, 0x13	; 19
    2034:	9f 93       	push	r25
    2036:	8f 93       	push	r24
    2038:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
		csp_conn_print_table();
    203c:	0e 94 20 1c 	call	0x3840	; 0x3840 <csp_conn_print_table>

		printf("Route table\r\n");
    2040:	8d e5       	ldi	r24, 0x5D	; 93
    2042:	93 e1       	ldi	r25, 0x13	; 19
    2044:	9f 93       	push	r25
    2046:	8f 93       	push	r24
    2048:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
		csp_route_print_table();
    204c:	0e 94 ee 2b 	call	0x57dc	; 0x57dc <csp_rtable_print>

		printf("Interfaces\r\n");
    2050:	80 e5       	ldi	r24, 0x50	; 80
    2052:	93 e1       	ldi	r25, 0x13	; 19
    2054:	9f 93       	push	r25
    2056:	8f 93       	push	r24
    2058:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
		csp_route_print_interfaces();
    205c:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <csp_iflist_print>
		
		
		xTaskCreate(wdtr,"WDT",configMINIMAL_STACK_SIZE,NULL,3,NULL);
    2060:	e1 2c       	mov	r14, r1
    2062:	f1 2c       	mov	r15, r1
    2064:	03 e0       	ldi	r16, 0x03	; 3
    2066:	20 e0       	ldi	r18, 0x00	; 0
    2068:	30 e0       	ldi	r19, 0x00	; 0
    206a:	44 e6       	ldi	r20, 0x64	; 100
    206c:	50 e0       	ldi	r21, 0x00	; 0
    206e:	61 ee       	ldi	r22, 0xE1	; 225
    2070:	72 e0       	ldi	r23, 0x02	; 2
    2072:	8c e0       	ldi	r24, 0x0C	; 12
    2074:	9f e0       	ldi	r25, 0x0F	; 15
    2076:	0e 94 9a 39 	call	0x7334	; 0x7334 <xTaskCreate>
		//while(1);
	 	 //xTaskCreate(TaskBlinkserial, "blinks", 128, NULL, 3, NULL);
	// usart_pstr_p(PSTR("LED init"),1);


	vTaskStartScheduler();
    207a:	0e 94 49 3b 	call	0x7692	; 0x7692 <vTaskStartScheduler>
    207e:	0f 90       	pop	r0
    2080:	0f 90       	pop	r0
    2082:	0f 90       	pop	r0
    2084:	0f 90       	pop	r0
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
	
	

	return 0;
}
    208a:	80 e0       	ldi	r24, 0x00	; 0
    208c:	90 e0       	ldi	r25, 0x00	; 0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	df 91       	pop	r29
    2094:	cf 91       	pop	r28
    2096:	1f 91       	pop	r17
    2098:	0f 91       	pop	r16
    209a:	ff 90       	pop	r15
    209c:	ef 90       	pop	r14
    209e:	df 90       	pop	r13
    20a0:	cf 90       	pop	r12
    20a2:	08 95       	ret

000020a4 <__vector_3>:
	vTaskDelete(NULL);
}



ISR(INT2_vect){
    20a4:	1f 92       	push	r1
    20a6:	0f 92       	push	r0
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	0f 92       	push	r0
    20ac:	11 24       	eor	r1, r1
    20ae:	0b b6       	in	r0, 0x3b	; 59
    20b0:	0f 92       	push	r0
    20b2:	2f 93       	push	r18
    20b4:	3f 93       	push	r19
    20b6:	4f 93       	push	r20
    20b8:	5f 93       	push	r21
    20ba:	6f 93       	push	r22
    20bc:	7f 93       	push	r23
    20be:	8f 93       	push	r24
    20c0:	9f 93       	push	r25
    20c2:	af 93       	push	r26
    20c4:	bf 93       	push	r27
    20c6:	ef 93       	push	r30
    20c8:	ff 93       	push	r31
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
    20ce:	1f 92       	push	r1
    20d0:	cd b7       	in	r28, 0x3d	; 61
    20d2:	de b7       	in	r29, 0x3e	; 62
	//if((PORTB&PB5)>>PB5) return;
		
	PCIFR&=~(1<<PCIF0);
    20d4:	d8 98       	cbi	0x1b, 0	; 27
	//while(1);

	volatile BaseType_t xYieldRequired;

	 // Resume the suspended task.
	 xYieldRequired = xTaskResumeFromISR(handle_canrx);
    20d6:	80 91 e8 1f 	lds	r24, 0x1FE8	; 0x801fe8 <handle_canrx>
    20da:	90 91 e9 1f 	lds	r25, 0x1FE9	; 0x801fe9 <handle_canrx+0x1>
    20de:	0e 94 f2 3a 	call	0x75e4	; 0x75e4 <xTaskResumeFromISR>
    20e2:	89 83       	std	Y+1, r24	; 0x01

	 if( xYieldRequired == pdTRUE )
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	81 30       	cpi	r24, 0x01	; 1
    20e8:	11 f4       	brne	.+4      	; 0x20ee <__vector_3+0x4a>
	 {
		 // We should switch context so the ISR returns to a different task.
		 // NOTE:  How this is done depends on the port you are using.  Check
		 // the documentation and examples for your port.
		 taskYIELD();
    20ea:	0e 94 e6 33 	call	0x67cc	; 0x67cc <vPortYield>
	 }

}
    20ee:	0f 90       	pop	r0
    20f0:	df 91       	pop	r29
    20f2:	cf 91       	pop	r28
    20f4:	ff 91       	pop	r31
    20f6:	ef 91       	pop	r30
    20f8:	bf 91       	pop	r27
    20fa:	af 91       	pop	r26
    20fc:	9f 91       	pop	r25
    20fe:	8f 91       	pop	r24
    2100:	7f 91       	pop	r23
    2102:	6f 91       	pop	r22
    2104:	5f 91       	pop	r21
    2106:	4f 91       	pop	r20
    2108:	3f 91       	pop	r19
    210a:	2f 91       	pop	r18
    210c:	0f 90       	pop	r0
    210e:	0b be       	out	0x3b, r0	; 59
    2110:	0f 90       	pop	r0
    2112:	0f be       	out	0x3f, r0	; 63
    2114:	0f 90       	pop	r0
    2116:	1f 90       	pop	r1
    2118:	18 95       	reti

0000211a <__vector_default>:
}



ISR(BADISR_vect)
{
    211a:	1f 92       	push	r1
    211c:	0f 92       	push	r0
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	0f 92       	push	r0
    2122:	11 24       	eor	r1, r1
	//FORCERESET
 printf("Unex Vector");
    2124:	8d e0       	ldi	r24, 0x0D	; 13
    2126:	93 e1       	ldi	r25, 0x13	; 19
    2128:	9f 93       	push	r25
    212a:	8f 93       	push	r24
    212c:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
	FORCERESET
    2130:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
    2134:	80 e0       	ldi	r24, 0x00	; 0
    2136:	93 e1       	ldi	r25, 0x13	; 19
    2138:	9f 93       	push	r25
    213a:	8f 93       	push	r24
    213c:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
    2140:	0f 90       	pop	r0
    2142:	0f 90       	pop	r0
    2144:	0f 90       	pop	r0
    2146:	0f 90       	pop	r0
    2148:	ff cf       	rjmp	.-2      	; 0x2148 <__vector_default+0x2e>

0000214a <_ZN7MCP25158startSPIEv>:
    // Compensate for the duplicate fosc/64
    if (clockDiv == 6)
    clockDiv = 7;

    // Invert the SPI2X bit
    clockDiv ^= 0x1;
    214a:	81 e0       	ldi	r24, 0x01	; 1
    214c:	80 93 ea 1f 	sts	0x1FEA, r24	; 0x801fea <_ZZN11SPISettings17init_AlwaysInlineEmhhE8clockDiv>

  // Before using SPI.transfer() or asserting chip select pins,
  // this function is used to gain exclusive access to the SPI bus
  // and configure the correct settings.
  inline static void beginTransaction(SPISettings settings) {
    if (interruptMode > 0) {
    2150:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    2154:	88 23       	and	r24, r24
    2156:	99 f0       	breq	.+38     	; 0x217e <_ZN7MCP25158startSPIEv+0x34>
      uint8_t sreg = SREG;
    2158:	8f b7       	in	r24, 0x3f	; 63
      cli();
    215a:	f8 94       	cli

      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    215c:	90 91 f1 1f 	lds	r25, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    2160:	91 30       	cpi	r25, 0x01	; 1
    2162:	59 f4       	brne	.+22     	; 0x217a <_ZN7MCP25158startSPIEv+0x30>
        interruptSave = SPI_AVR_EIMSK;
    2164:	9d b3       	in	r25, 0x1d	; 29
    2166:	90 93 ef 1f 	sts	0x1FEF, r25	; 0x801fef <_ZN8SPIClass13interruptSaveE>
        SPI_AVR_EIMSK &= ~interruptMask;
    216a:	2d b3       	in	r18, 0x1d	; 29
    216c:	90 91 f0 1f 	lds	r25, 0x1FF0	; 0x801ff0 <_ZN8SPIClass13interruptMaskE>
    2170:	90 95       	com	r25
    2172:	92 23       	and	r25, r18
    2174:	9d bb       	out	0x1d, r25	; 29
        SREG = sreg;
    2176:	8f bf       	out	0x3f, r24	; 63
    2178:	02 c0       	rjmp	.+4      	; 0x217e <_ZN7MCP25158startSPIEv+0x34>
      } else
      #endif
      {
        interruptSave = sreg;
    217a:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <_ZN8SPIClass13interruptSaveE>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
    217e:	80 e5       	ldi	r24, 0x50	; 80
    2180:	8c bd       	out	0x2c, r24	; 44
    SPSR = settings.spsr;
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	8d bd       	out	0x2d, r24	; 45
}

void MCP2515::startSPI(void) {
    SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0));
   // digitalWrite(SPICS, LOW);
   PORTB&=~(1<<PB4);
    2186:	2c 98       	cbi	0x05, 4	; 5
    2188:	08 95       	ret

0000218a <_ZN7MCP25156endSPIEv>:
}

void MCP2515::endSPI() {
     PORTB|=(1<<PB4);
    218a:	2c 9a       	sbi	0x05, 4	; 5
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
    218c:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    2190:	88 23       	and	r24, r24
    2192:	71 f0       	breq	.+28     	; 0x21b0 <_ZN7MCP25156endSPIEv+0x26>
      #ifdef SPI_AVR_EIMSK
      uint8_t sreg = SREG;
    2194:	9f b7       	in	r25, 0x3f	; 63
      #endif
      cli();
    2196:	f8 94       	cli
      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    2198:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    219c:	81 30       	cpi	r24, 0x01	; 1
    219e:	29 f4       	brne	.+10     	; 0x21aa <_ZN7MCP25156endSPIEv+0x20>
        SPI_AVR_EIMSK = interruptSave;
    21a0:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptSaveE>
    21a4:	8d bb       	out	0x1d, r24	; 29
        SREG = sreg;
    21a6:	9f bf       	out	0x3f, r25	; 63
    21a8:	08 95       	ret
      } else
      #endif
      {
        SREG = interruptSave;
    21aa:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <_ZN8SPIClass13interruptSaveE>
    21ae:	8f bf       	out	0x3f, r24	; 63
    21b0:	08 95       	ret

000021b2 <_ZN7MCP2515C1Ev>:
const struct MCP2515::RXBn_REGS MCP2515::RXB[N_RXBUFFERS] = {
    {MCP_RXB0CTRL, MCP_RXB0SIDH, MCP_RXB0DATA, CANINTF_RX0IF},
    {MCP_RXB1CTRL, MCP_RXB1SIDH, MCP_RXB1DATA, CANINTF_RX1IF}
};

MCP2515::MCP2515(void)
    21b2:	cf 93       	push	r28
    21b4:	df 93       	push	r29
    21b6:	ec 01       	movw	r28, r24
{
    SPI.begin();
    21b8:	f3 d5       	rcall	.+3046   	; 0x2da0 <_ZN8SPIClass5beginEv>

   //SPICS = _CS;
    //pinMode(SPICS, OUTPUT);
	DDRB|=(1<<PB4);
    21ba:	24 9a       	sbi	0x04, 4	; 4
    endSPI();
    21bc:	ce 01       	movw	r24, r28
    21be:	e5 df       	rcall	.-54     	; 0x218a <_ZN7MCP25156endSPIEv>
}
    21c0:	df 91       	pop	r29
    21c2:	cf 91       	pop	r28
    21c4:	08 95       	ret

000021c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>:

    return ERROR_OK;
}

uint8_t MCP2515::readRegister(const REGISTER reg)
{
    21c6:	1f 93       	push	r17
    21c8:	cf 93       	push	r28
    21ca:	df 93       	push	r29
    21cc:	ec 01       	movw	r28, r24
    startSPI();
    21ce:	16 2f       	mov	r17, r22
    21d0:	bc df       	rcall	.-136    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    21d2:	83 e0       	ldi	r24, 0x03	; 3
    21d4:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    21d6:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    21d8:	0d b4       	in	r0, 0x2d	; 45
    21da:	07 fe       	sbrs	r0, 7
    21dc:	fd cf       	rjmp	.-6      	; 0x21d8 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x12>
    return SPDR;
    21de:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    21e0:	1e bd       	out	0x2e, r17	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    21e2:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    21e4:	0d b4       	in	r0, 0x2d	; 45
    21e6:	07 fe       	sbrs	r0, 7
    21e8:	fd cf       	rjmp	.-6      	; 0x21e4 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x1e>
    return SPDR;
    21ea:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    21ec:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    21ee:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    21f0:	0d b4       	in	r0, 0x2d	; 45
    21f2:	07 fe       	sbrs	r0, 7
    return SPDR;
    21f4:	fd cf       	rjmp	.-6      	; 0x21f0 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x2a>
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    uint8_t ret = SPI.transfer(0x00);
    endSPI();
    21f6:	1e b5       	in	r17, 0x2e	; 46
    21f8:	ce 01       	movw	r24, r28
    21fa:	c7 df       	rcall	.-114    	; 0x218a <_ZN7MCP25156endSPIEv>

    return ret;
}
    21fc:	81 2f       	mov	r24, r17
    21fe:	df 91       	pop	r29
    2200:	cf 91       	pop	r28
    2202:	1f 91       	pop	r17
    2204:	08 95       	ret

00002206 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>:

void MCP2515::readRegisters(const REGISTER reg, uint8_t values[], const uint8_t n)
{
    2206:	ef 92       	push	r14
    2208:	ff 92       	push	r15
    220a:	0f 93       	push	r16
    220c:	1f 93       	push	r17
    220e:	cf 93       	push	r28
    2210:	df 93       	push	r29
    2212:	ec 01       	movw	r28, r24
    2214:	06 2f       	mov	r16, r22
    2216:	7a 01       	movw	r14, r20
    startSPI();
    2218:	12 2f       	mov	r17, r18
    221a:	97 df       	rcall	.-210    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    221c:	83 e0       	ldi	r24, 0x03	; 3
    221e:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2220:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2222:	0d b4       	in	r0, 0x2d	; 45
    2224:	07 fe       	sbrs	r0, 7
    2226:	fd cf       	rjmp	.-6      	; 0x2222 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x1c>
    return SPDR;
    2228:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    222a:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    222c:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    222e:	0d b4       	in	r0, 0x2d	; 45
    2230:	07 fe       	sbrs	r0, 7
    2232:	fd cf       	rjmp	.-6      	; 0x222e <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x28>
    return SPDR;
    2234:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    // mcp2515 has auto-increment of address-pointer
    for (uint8_t i=0; i<n; i++) {
    2236:	11 23       	and	r17, r17
    2238:	91 f0       	breq	.+36     	; 0x225e <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x58>
    223a:	f7 01       	movw	r30, r14
    223c:	11 50       	subi	r17, 0x01	; 1
    223e:	41 2f       	mov	r20, r17
    2240:	50 e0       	ldi	r21, 0x00	; 0
    2242:	4f 5f       	subi	r20, 0xFF	; 255
    2244:	5f 4f       	sbci	r21, 0xFF	; 255
    2246:	4e 0d       	add	r20, r14
    2248:	5f 1d       	adc	r21, r15
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    224a:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    224c:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    224e:	0d b4       	in	r0, 0x2d	; 45
    2250:	07 fe       	sbrs	r0, 7
    2252:	fd cf       	rjmp	.-6      	; 0x224e <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x48>
    return SPDR;
    2254:	8e b5       	in	r24, 0x2e	; 46
    2256:	81 93       	st	Z+, r24
    2258:	e4 17       	cp	r30, r20
    225a:	f5 07       	cpc	r31, r21
        values[i] = SPI.transfer(0x00);
    }
    endSPI();
    225c:	b1 f7       	brne	.-20     	; 0x224a <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x44>
    225e:	ce 01       	movw	r24, r28
    2260:	94 df       	rcall	.-216    	; 0x218a <_ZN7MCP25156endSPIEv>
}
    2262:	df 91       	pop	r29
    2264:	cf 91       	pop	r28
    2266:	1f 91       	pop	r17
    2268:	0f 91       	pop	r16
    226a:	ff 90       	pop	r15
    226c:	ef 90       	pop	r14
    226e:	08 95       	ret

00002270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>:

void MCP2515::setRegister(const REGISTER reg, const uint8_t value)
{
    2270:	0f 93       	push	r16
    2272:	1f 93       	push	r17
    2274:	cf 93       	push	r28
    2276:	df 93       	push	r29
    2278:	ec 01       	movw	r28, r24
    227a:	06 2f       	mov	r16, r22
    startSPI();
    227c:	14 2f       	mov	r17, r20
    227e:	65 df       	rcall	.-310    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2280:	82 e0       	ldi	r24, 0x02	; 2
    2282:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2284:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2286:	0d b4       	in	r0, 0x2d	; 45
    2288:	07 fe       	sbrs	r0, 7
    228a:	fd cf       	rjmp	.-6      	; 0x2286 <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x16>
    return SPDR;
    228c:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    228e:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2290:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2292:	0d b4       	in	r0, 0x2d	; 45
    2294:	07 fe       	sbrs	r0, 7
    2296:	fd cf       	rjmp	.-6      	; 0x2292 <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x22>
    return SPDR;
    2298:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    229a:	1e bd       	out	0x2e, r17	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    229c:	00 00       	nop
    229e:	0d b4       	in	r0, 0x2d	; 45
    22a0:	07 fe       	sbrs	r0, 7
    return SPDR;
    22a2:	fd cf       	rjmp	.-6      	; 0x229e <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x2e>
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    SPI.transfer(value);
    endSPI();
    22a4:	8e b5       	in	r24, 0x2e	; 46
    22a6:	ce 01       	movw	r24, r28
    22a8:	70 df       	rcall	.-288    	; 0x218a <_ZN7MCP25156endSPIEv>
}
    22aa:	df 91       	pop	r29
    22ac:	cf 91       	pop	r28
    22ae:	1f 91       	pop	r17
    22b0:	0f 91       	pop	r16
    22b2:	08 95       	ret

000022b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>:

void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    22b4:	ef 92       	push	r14
    22b6:	ff 92       	push	r15
    22b8:	0f 93       	push	r16
    22ba:	1f 93       	push	r17
    22bc:	cf 93       	push	r28
    22be:	df 93       	push	r29
    22c0:	ec 01       	movw	r28, r24
    22c2:	06 2f       	mov	r16, r22
    22c4:	7a 01       	movw	r14, r20
    startSPI();
    22c6:	12 2f       	mov	r17, r18
    22c8:	40 df       	rcall	.-384    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    22ca:	82 e0       	ldi	r24, 0x02	; 2
    22cc:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    22ce:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    22d0:	0d b4       	in	r0, 0x2d	; 45
    22d2:	07 fe       	sbrs	r0, 7
    22d4:	fd cf       	rjmp	.-6      	; 0x22d0 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x1c>
    return SPDR;
    22d6:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    22d8:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    22da:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    22dc:	0d b4       	in	r0, 0x2d	; 45
    22de:	07 fe       	sbrs	r0, 7
    22e0:	fd cf       	rjmp	.-6      	; 0x22dc <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x28>
    return SPDR;
    22e2:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    22e4:	11 23       	and	r17, r17
    22e6:	91 f0       	breq	.+36     	; 0x230c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x58>
    22e8:	f7 01       	movw	r30, r14
    22ea:	11 50       	subi	r17, 0x01	; 1
    22ec:	41 2f       	mov	r20, r17
    22ee:	50 e0       	ldi	r21, 0x00	; 0
    22f0:	4f 5f       	subi	r20, 0xFF	; 255
    22f2:	5f 4f       	sbci	r21, 0xFF	; 255
    22f4:	4e 0d       	add	r20, r14
    22f6:	5f 1d       	adc	r21, r15
        SPI.transfer(values[i]);
    22f8:	81 91       	ld	r24, Z+
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    22fa:	8e bd       	out	0x2e, r24	; 46
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    22fc:	00 00       	nop
    22fe:	0d b4       	in	r0, 0x2d	; 45
    2300:	07 fe       	sbrs	r0, 7
    return SPDR;
    2302:	fd cf       	rjmp	.-6      	; 0x22fe <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x4a>
void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    startSPI();
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    2304:	8e b5       	in	r24, 0x2e	; 46
    2306:	e4 17       	cp	r30, r20
    2308:	f5 07       	cpc	r31, r21
        SPI.transfer(values[i]);
    }
    endSPI();
    230a:	b1 f7       	brne	.-20     	; 0x22f8 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x44>
    230c:	ce 01       	movw	r24, r28
    230e:	3d df       	rcall	.-390    	; 0x218a <_ZN7MCP25156endSPIEv>
}
    2310:	df 91       	pop	r29
    2312:	cf 91       	pop	r28
    2314:	1f 91       	pop	r17
    2316:	0f 91       	pop	r16
    2318:	ff 90       	pop	r15
    231a:	ef 90       	pop	r14

void MCP2515::modifyRegister(const REGISTER reg, const uint8_t mask, const uint8_t data)
{
    231c:	08 95       	ret

0000231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>:
    231e:	ff 92       	push	r15
    2320:	0f 93       	push	r16
    2322:	1f 93       	push	r17
    2324:	cf 93       	push	r28
    2326:	df 93       	push	r29
    2328:	ec 01       	movw	r28, r24
    232a:	f6 2e       	mov	r15, r22
    232c:	04 2f       	mov	r16, r20
    startSPI();
    232e:	12 2f       	mov	r17, r18
    2330:	0c df       	rcall	.-488    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2332:	85 e0       	ldi	r24, 0x05	; 5
    2334:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2336:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2338:	0d b4       	in	r0, 0x2d	; 45
    233a:	07 fe       	sbrs	r0, 7
    233c:	fd cf       	rjmp	.-6      	; 0x2338 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x1a>
    return SPDR;
    233e:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2340:	fe bc       	out	0x2e, r15	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2342:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2344:	0d b4       	in	r0, 0x2d	; 45
    2346:	07 fe       	sbrs	r0, 7
    2348:	fd cf       	rjmp	.-6      	; 0x2344 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x26>
    return SPDR;
    234a:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    234c:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    234e:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2350:	0d b4       	in	r0, 0x2d	; 45
    2352:	07 fe       	sbrs	r0, 7
    return SPDR;
    2354:	fd cf       	rjmp	.-6      	; 0x2350 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x32>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2356:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2358:	1e bd       	out	0x2e, r17	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    235a:	00 00       	nop
    235c:	0d b4       	in	r0, 0x2d	; 45
    235e:	07 fe       	sbrs	r0, 7
    return SPDR;
    2360:	fd cf       	rjmp	.-6      	; 0x235c <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x3e>
    SPI.transfer(INSTRUCTION_BITMOD);
    SPI.transfer(reg);
    SPI.transfer(mask);
    SPI.transfer(data);
    endSPI();
    2362:	8e b5       	in	r24, 0x2e	; 46
    2364:	ce 01       	movw	r24, r28
    2366:	11 df       	rcall	.-478    	; 0x218a <_ZN7MCP25156endSPIEv>
}
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	1f 91       	pop	r17
    236e:	0f 91       	pop	r16
    2370:	ff 90       	pop	r15
    2372:	08 95       	ret

00002374 <_ZN7MCP25155resetEv>:
     PORTB|=(1<<PB4);
    SPI.endTransaction();
}

MCP2515::ERROR MCP2515::reset(void)
{
    2374:	ef 92       	push	r14
    2376:	ff 92       	push	r15
    2378:	0f 93       	push	r16
    237a:	1f 93       	push	r17
    237c:	cf 93       	push	r28
    237e:	df 93       	push	r29
    2380:	cd b7       	in	r28, 0x3d	; 61
    2382:	de b7       	in	r29, 0x3e	; 62
    2384:	2e 97       	sbiw	r28, 0x0e	; 14
    2386:	0f b6       	in	r0, 0x3f	; 63
    2388:	f8 94       	cli
    238a:	de bf       	out	0x3e, r29	; 62
    238c:	0f be       	out	0x3f, r0	; 63
    startSPI();
    238e:	cd bf       	out	0x3d, r28	; 61
    2390:	8c 01       	movw	r16, r24
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2392:	db de       	rcall	.-586    	; 0x214a <_ZN7MCP25158startSPIEv>
    2394:	80 ec       	ldi	r24, 0xC0	; 192
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2396:	8e bd       	out	0x2e, r24	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2398:	00 00       	nop
    239a:	0d b4       	in	r0, 0x2d	; 45
    239c:	07 fe       	sbrs	r0, 7
    return SPDR;
    239e:	fd cf       	rjmp	.-6      	; 0x239a <_ZN7MCP25155resetEv+0x26>
    SPI.transfer(INSTRUCTION_RESET);
    endSPI();
    23a0:	8e b5       	in	r24, 0x2e	; 46
    23a2:	c8 01       	movw	r24, r16
    23a4:	f2 de       	rcall	.-540    	; 0x218a <_ZN7MCP25156endSPIEv>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    23a6:	8f e3       	ldi	r24, 0x3F	; 63
    23a8:	9c e9       	ldi	r25, 0x9C	; 156
    23aa:	01 97       	sbiw	r24, 0x01	; 1
    23ac:	f1 f7       	brne	.-4      	; 0x23aa <_ZN7MCP25155resetEv+0x36>
    23ae:	00 c0       	rjmp	.+0      	; 0x23b0 <_ZN7MCP25155resetEv+0x3c>

    _delay_ms(10);

    uint8_t zeros[14];
    memset(zeros, 0, sizeof(zeros));
    23b0:	00 00       	nop
    23b2:	fe 01       	movw	r30, r28
    23b4:	31 96       	adiw	r30, 0x01	; 1
    23b6:	7f 01       	movw	r14, r30
    23b8:	8e e0       	ldi	r24, 0x0E	; 14
    23ba:	11 92       	st	Z+, r1
    setRegisters(MCP_TXB0CTRL, zeros, 14);
    23bc:	8a 95       	dec	r24
    23be:	e9 f7       	brne	.-6      	; 0x23ba <_ZN7MCP25155resetEv+0x46>
    23c0:	2e e0       	ldi	r18, 0x0E	; 14
    23c2:	a7 01       	movw	r20, r14
    setRegisters(MCP_TXB1CTRL, zeros, 14);
    23c4:	60 e3       	ldi	r22, 0x30	; 48
    23c6:	c8 01       	movw	r24, r16
    23c8:	75 df       	rcall	.-278    	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    23ca:	2e e0       	ldi	r18, 0x0E	; 14
    23cc:	a7 01       	movw	r20, r14
    setRegisters(MCP_TXB2CTRL, zeros, 14);
    23ce:	60 e4       	ldi	r22, 0x40	; 64
    23d0:	c8 01       	movw	r24, r16
    23d2:	70 df       	rcall	.-288    	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    23d4:	2e e0       	ldi	r18, 0x0E	; 14
    23d6:	a7 01       	movw	r20, r14

    setRegister(MCP_RXB0CTRL, 0);
    23d8:	60 e5       	ldi	r22, 0x50	; 80
    23da:	c8 01       	movw	r24, r16
    23dc:	6b df       	rcall	.-298    	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    23de:	40 e0       	ldi	r20, 0x00	; 0
    setRegister(MCP_RXB1CTRL, 0);
    23e0:	60 e6       	ldi	r22, 0x60	; 96
    23e2:	c8 01       	movw	r24, r16
    23e4:	45 df       	rcall	.-374    	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    23e6:	40 e0       	ldi	r20, 0x00	; 0
    23e8:	60 e7       	ldi	r22, 0x70	; 112

    setRegister(MCP_CANINTE, CANINTF_RX0IF | CANINTF_RX1IF); // | CANINTF_ERRIF | CANINTF_MERRF
    23ea:	c8 01       	movw	r24, r16
    23ec:	41 df       	rcall	.-382    	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    23ee:	43 e0       	ldi	r20, 0x03	; 3
    23f0:	6b e2       	ldi	r22, 0x2B	; 43
    23f2:	c8 01       	movw	r24, r16

    modifyRegister(MCP_RXB0CTRL,
                   RXBnCTRL_RXM_MASK | RXB0CTRL_BUKT,
                   RXBnCTRL_RXM_STDEXT | RXB0CTRL_BUKT);
    23f4:	3d df       	rcall	.-390    	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    23f6:	24 e0       	ldi	r18, 0x04	; 4
    23f8:	44 e6       	ldi	r20, 0x64	; 100
    23fa:	60 e6       	ldi	r22, 0x60	; 96
    23fc:	c8 01       	movw	r24, r16
    23fe:	8f df       	rcall	.-226    	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    modifyRegister(MCP_RXB1CTRL, RXBnCTRL_RXM_MASK, RXBnCTRL_RXM_STDEXT);
    2400:	20 e0       	ldi	r18, 0x00	; 0
    2402:	40 e6       	ldi	r20, 0x60	; 96
    2404:	60 e7       	ldi	r22, 0x70	; 112
    2406:	c8 01       	movw	r24, r16
    2408:	8a df       	rcall	.-236    	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
            return result;
        }
    }*/

    return ERROR_OK;
}
    240a:	80 e0       	ldi	r24, 0x00	; 0
    240c:	2e 96       	adiw	r28, 0x0e	; 14
    240e:	0f b6       	in	r0, 0x3f	; 63
    2410:	f8 94       	cli
    2412:	de bf       	out	0x3e, r29	; 62
    2414:	0f be       	out	0x3f, r0	; 63
    2416:	cd bf       	out	0x3d, r28	; 61
    2418:	df 91       	pop	r29
    241a:	cf 91       	pop	r28
    241c:	1f 91       	pop	r17
    241e:	0f 91       	pop	r16
    2420:	ff 90       	pop	r15
    2422:	ef 90       	pop	r14
    SPI.transfer(data);
    endSPI();
}

uint8_t MCP2515::getStatus(void)
{
    2424:	08 95       	ret

00002426 <_ZN7MCP25159getStatusEv>:
    2426:	1f 93       	push	r17
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    startSPI();
    242c:	ec 01       	movw	r28, r24
    242e:	8d de       	rcall	.-742    	; 0x214a <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    2430:	80 ea       	ldi	r24, 0xA0	; 160
    2432:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    2434:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2436:	0d b4       	in	r0, 0x2d	; 45
    2438:	07 fe       	sbrs	r0, 7
    243a:	fd cf       	rjmp	.-6      	; 0x2436 <_ZN7MCP25159getStatusEv+0x10>
    return SPDR;
    243c:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    243e:	1e bc       	out	0x2e, r1	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    2440:	00 00       	nop
    2442:	0d b4       	in	r0, 0x2d	; 45
    SPI.transfer(INSTRUCTION_READ_STATUS);
    uint8_t i = SPI.transfer(0x00);
    endSPI();
    2444:	07 fe       	sbrs	r0, 7
    2446:	fd cf       	rjmp	.-6      	; 0x2442 <_ZN7MCP25159getStatusEv+0x1c>
    2448:	1e b5       	in	r17, 0x2e	; 46

    return i;
}
    244a:	ce 01       	movw	r24, r28
    244c:	9e de       	rcall	.-708    	; 0x218a <_ZN7MCP25156endSPIEv>
    244e:	81 2f       	mov	r24, r17
    2450:	df 91       	pop	r29
{
    return setMode(CANCTRL_REQOP_NORMAL);
}

MCP2515::ERROR MCP2515::setMode(const CANCTRL_REQOP_MODE mode)
{
    2452:	cf 91       	pop	r28
    2454:	1f 91       	pop	r17
    2456:	08 95       	ret

00002458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>:
    2458:	0f 93       	push	r16
    245a:	1f 93       	push	r17
    245c:	cf 93       	push	r28
	uint8_t sreg = SREG;
    245e:	df 93       	push	r29
    modifyRegister(MCP_CANCTRL, CANCTRL_REQOP, mode);
    2460:	ec 01       	movw	r28, r24
    2462:	16 2f       	mov	r17, r22
    2464:	0f b7       	in	r16, 0x3f	; 63
    2466:	26 2f       	mov	r18, r22
    2468:	40 ee       	ldi	r20, 0xE0	; 224
	sei();
    timeoutstart(624);
    246a:	6f e0       	ldi	r22, 0x0F	; 15
    246c:	58 df       	rcall	.-336    	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    246e:	78 94       	sei
    bool modeMatch = false;
    while (~timeoutcheck()) {
    2470:	80 e7       	ldi	r24, 0x70	; 112
    2472:	92 e0       	ldi	r25, 0x02	; 2
    2474:	e9 da       	rcall	.-2606   	; 0x1a48 <_Z12timeoutstarti>
        uint8_t newmode = readRegister(MCP_CANSTAT);
    2476:	0a db       	rcall	.-2540   	; 0x1a8c <_Z12timeoutcheckv>
    2478:	01 96       	adiw	r24, 0x01	; 1
    247a:	41 f0       	breq	.+16     	; 0x248c <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x34>
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;

        if (modeMatch) {
    247c:	6e e0       	ldi	r22, 0x0E	; 14
    247e:	ce 01       	movw	r24, r28
    2480:	a2 de       	rcall	.-700    	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    bool modeMatch = false;
    while (~timeoutcheck()) {
        uint8_t newmode = readRegister(MCP_CANSTAT);
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;
    2482:	80 7e       	andi	r24, 0xE0	; 224
    2484:	18 13       	cpse	r17, r24
    2486:	f7 cf       	rjmp	.-18     	; 0x2476 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x1e>

        if (modeMatch) {
            break;
        }
    }
	SREG = sreg;
    2488:	91 e0       	ldi	r25, 0x01	; 1

    return modeMatch ? ERROR_OK : ERROR_FAIL;

}
    248a:	01 c0       	rjmp	.+2      	; 0x248e <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x36>
    248c:	90 e0       	ldi	r25, 0x00	; 0
    248e:	0f bf       	out	0x3f, r16	; 63
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	89 27       	eor	r24, r25
    2494:	df 91       	pop	r29
    return i;
}

MCP2515::ERROR MCP2515::setConfigMode()
{
    return setMode(CANCTRL_REQOP_CONFIG);
    2496:	cf 91       	pop	r28
    2498:	1f 91       	pop	r17
    249a:	0f 91       	pop	r16
}
    249c:	08 95       	ret

0000249e <_ZN7MCP251513setConfigModeEv>:

MCP2515::ERROR MCP2515::setListenOnlyMode()
{
    return setMode(CANCTRL_REQOP_LISTENONLY);
    249e:	60 e8       	ldi	r22, 0x80	; 128
    24a0:	db cf       	rjmp	.-74     	; 0x2458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    24a2:	08 95       	ret

000024a4 <_ZN7MCP251517setListenOnlyModeEv>:
}
    24a4:	60 e6       	ldi	r22, 0x60	; 96

MCP2515::ERROR MCP2515::setSleepMode()
{
    return setMode(CANCTRL_REQOP_SLEEP);
    24a6:	d8 cf       	rjmp	.-80     	; 0x2458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    24a8:	08 95       	ret

000024aa <_ZN7MCP251512setSleepModeEv>:
    24aa:	60 e2       	ldi	r22, 0x20	; 32
}
    24ac:	d5 cf       	rjmp	.-86     	; 0x2458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>

MCP2515::ERROR MCP2515::setLoopbackMode()
{
    return setMode(CANCTRL_REQOP_LOOPBACK);
    24ae:	08 95       	ret

000024b0 <_ZN7MCP251515setLoopbackModeEv>:
    24b0:	60 e4       	ldi	r22, 0x40	; 64
    24b2:	d2 cf       	rjmp	.-92     	; 0x2458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
}
    24b4:	08 95       	ret

000024b6 <_ZN7MCP251513setNormalModeEv>:

MCP2515::ERROR MCP2515::setNormalMode()
{
    return setMode(CANCTRL_REQOP_NORMAL);
    24b6:	60 e0       	ldi	r22, 0x00	; 0
    24b8:	cf cf       	rjmp	.-98     	; 0x2458 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    24ba:	08 95       	ret

000024bc <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>:
}
    24bc:	ef 92       	push	r14
{
    return setBitrate(canSpeed, MCP_16MHZ);
}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed, CAN_CLOCK canClock)
{
    24be:	ff 92       	push	r15
    24c0:	0f 93       	push	r16
    24c2:	1f 93       	push	r17
    24c4:	cf 93       	push	r28
    24c6:	df 93       	push	r29
    24c8:	ec 01       	movw	r28, r24
    24ca:	16 2f       	mov	r17, r22
    24cc:	04 2f       	mov	r16, r20
    24ce:	e7 df       	rcall	.-50     	; 0x249e <_ZN7MCP251513setConfigModeEv>
    ERROR error = setConfigMode();
    24d0:	81 11       	cpse	r24, r1
    24d2:	98 c1       	rjmp	.+816    	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    if (error != ERROR_OK) {
    24d4:	01 30       	cpi	r16, 0x01	; 1
    24d6:	09 f4       	brne	.+2      	; 0x24da <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1e>
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    switch (canClock)
    24d8:	6d c0       	rjmp	.+218    	; 0x25b4 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0xf8>
    24da:	08 f4       	brcc	.+2      	; 0x24de <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x22>
    24dc:	e2 c0       	rjmp	.+452    	; 0x26a2 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1e6>
    24de:	02 30       	cpi	r16, 0x02	; 2
    24e0:	09 f0       	breq	.+2      	; 0x24e4 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x28>
    24e2:	38 c1       	rjmp	.+624    	; 0x2754 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x298>
    24e4:	81 2f       	mov	r24, r17
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    {
        case (MCP_8MHZ):
        switch (canSpeed)
    24e8:	80 31       	cpi	r24, 0x10	; 16
    24ea:	91 05       	cpc	r25, r1
    24ec:	08 f0       	brcs	.+2      	; 0x24f0 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x34>
    24ee:	5e c1       	rjmp	.+700    	; 0x27ac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f0>
    24f0:	fc 01       	movw	r30, r24
    24f2:	88 27       	eor	r24, r24
    24f4:	e7 57       	subi	r30, 0x77	; 119
    24f6:	ff 4f       	sbci	r31, 0xFF	; 255
    24f8:	8f 4f       	sbci	r24, 0xFF	; 255
    24fa:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
    24fe:	17 e8       	ldi	r17, 0x87	; 135
    2500:	0f 2e       	mov	r0, r31
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
    2502:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
    2504:	ef 2e       	mov	r14, r31
    2506:	f0 2d       	mov	r31, r0
    2508:	0f 2e       	mov	r0, r31
    250a:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
    250c:	ff 2e       	mov	r15, r31
    250e:	f0 2d       	mov	r31, r0
    2510:	3f c1       	rjmp	.+638    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2512:	15 e8       	ldi	r17, 0x85	; 133
    2514:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
    2516:	f2 ee       	ldi	r31, 0xE2	; 226
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
    2518:	ef 2e       	mov	r14, r31
    251a:	f0 2d       	mov	r31, r0
    251c:	0f 2e       	mov	r0, r31
    251e:	f7 e4       	ldi	r31, 0x47	; 71
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
    2520:	ff 2e       	mov	r15, r31
    2522:	f0 2d       	mov	r31, r0
    2524:	35 c1       	rjmp	.+618    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2526:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;
    2528:	0f 2e       	mov	r0, r31

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
    252a:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
    252c:	ef 2e       	mov	r14, r31
    252e:	f0 2d       	mov	r31, r0
    2530:	0f 2e       	mov	r0, r31
    2532:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
    2534:	ff 2e       	mov	r15, r31
    2536:	f0 2d       	mov	r31, r0
    2538:	2b c1       	rjmp	.+598    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    253a:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;
    253c:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
    253e:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
    2540:	ef 2e       	mov	r14, r31
    2542:	f0 2d       	mov	r31, r0
    2544:	0f 2e       	mov	r0, r31
    2546:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
    2548:	ff 2e       	mov	r15, r31
    254a:	f0 2d       	mov	r31, r0
    254c:	21 c1       	rjmp	.+578    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    254e:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;
    2550:	0f 2e       	mov	r0, r31

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
    2552:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
    2554:	ef 2e       	mov	r14, r31
    2556:	f0 2d       	mov	r31, r0
    2558:	ff 24       	eor	r15, r15
    255a:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
    255c:	19 c1       	rjmp	.+562    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    255e:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;
    2560:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
    2562:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
    2564:	ef 2e       	mov	r14, r31
    2566:	f0 2d       	mov	r31, r0
    2568:	ff 24       	eor	r15, r15
    256a:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
    256c:	11 c1       	rjmp	.+546    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    256e:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;
    2570:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
    2572:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
    2574:	ef 2e       	mov	r14, r31
    2576:	f0 2d       	mov	r31, r0
    2578:	ff 24       	eor	r15, r15
    257a:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
    257c:	09 c1       	rjmp	.+530    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    257e:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;
    2580:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
    2582:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
    2584:	ef 2e       	mov	r14, r31
    2586:	f0 2d       	mov	r31, r0
    2588:	f1 2c       	mov	r15, r1
    258a:	02 c1       	rjmp	.+516    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
    258c:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;
    258e:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
    2590:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
    2592:	ef 2e       	mov	r14, r31
    2594:	f0 2d       	mov	r31, r0
    2596:	f1 2c       	mov	r15, r1
    2598:	fb c0       	rjmp	.+502    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
    259a:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;
    259c:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
    259e:	f0 e9       	ldi	r31, 0x90	; 144
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
    25a0:	ef 2e       	mov	r14, r31
    25a2:	f0 2d       	mov	r31, r0
    25a4:	f1 2c       	mov	r15, r1
    25a6:	f4 c0       	rjmp	.+488    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
    25a8:	10 e8       	ldi	r17, 0x80	; 128
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;
    25aa:	68 94       	set

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
    25ac:	ee 24       	eor	r14, r14
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
    25ae:	e7 f8       	bld	r14, 7
    25b0:	f1 2c       	mov	r15, r1
    25b2:	ee c0       	rjmp	.+476    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
    25b4:	81 2f       	mov	r24, r17
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
            break;
    25b6:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_16MHZ):
        switch (canSpeed)
    25b8:	80 31       	cpi	r24, 0x10	; 16
    25ba:	91 05       	cpc	r25, r1
    25bc:	08 f0       	brcs	.+2      	; 0x25c0 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x104>
    25be:	f8 c0       	rjmp	.+496    	; 0x27b0 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f4>
    25c0:	fc 01       	movw	r30, r24
    25c2:	88 27       	eor	r24, r24
    25c4:	e7 56       	subi	r30, 0x67	; 103
    25c6:	ff 4f       	sbci	r31, 0xFF	; 255
    25c8:	8f 4f       	sbci	r24, 0xFF	; 255
    25ca:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
    25ce:	17 e8       	ldi	r17, 0x87	; 135
    25d0:	ee 24       	eor	r14, r14
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
    25d2:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
    25d4:	0f 2e       	mov	r0, r31
    25d6:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_16MHz_10kBPS_CFG2;
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
    25d8:	ff 2e       	mov	r15, r31
    25da:	f0 2d       	mov	r31, r0
    25dc:	d9 c0       	rjmp	.+434    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    25de:	15 e8       	ldi	r17, 0x85	; 133
    25e0:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
    25e2:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
    25e4:	ef 2e       	mov	r14, r31
    25e6:	f0 2d       	mov	r31, r0
    25e8:	0f 2e       	mov	r0, r31
    25ea:	fe e4       	ldi	r31, 0x4E	; 78
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
    25ec:	ff 2e       	mov	r15, r31
    25ee:	f0 2d       	mov	r31, r0
    25f0:	cf c0       	rjmp	.+414    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    25f2:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;
    25f4:	ee 24       	eor	r14, r14

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
    25f6:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
    25f8:	0f 2e       	mov	r0, r31
    25fa:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
    25fc:	ff 2e       	mov	r15, r31
    25fe:	f0 2d       	mov	r31, r0
    2600:	c7 c0       	rjmp	.+398    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2602:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;
    2604:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
    2606:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
    2608:	ef 2e       	mov	r14, r31
    260a:	f0 2d       	mov	r31, r0
    260c:	0f 2e       	mov	r0, r31
    260e:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
    2610:	ff 2e       	mov	r15, r31
    2612:	f0 2d       	mov	r31, r0
    2614:	bd c0       	rjmp	.+378    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2616:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;
    2618:	ee 24       	eor	r14, r14

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
    261a:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
    261c:	0f 2e       	mov	r0, r31
    261e:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
    2620:	ff 2e       	mov	r15, r31
    2622:	f0 2d       	mov	r31, r0
    2624:	b5 c0       	rjmp	.+362    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2626:	17 e0       	ldi	r17, 0x07	; 7
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;
    2628:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
    262a:	fe eb       	ldi	r31, 0xBE	; 190
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
    262c:	ef 2e       	mov	r14, r31
    262e:	f0 2d       	mov	r31, r0
    2630:	0f 2e       	mov	r0, r31
    2632:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
    2634:	ff 2e       	mov	r15, r31
    2636:	f0 2d       	mov	r31, r0
    2638:	ab c0       	rjmp	.+342    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    263a:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 
    263c:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
    263e:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
    2640:	ef 2e       	mov	r14, r31
    2642:	f0 2d       	mov	r31, r0
    2644:	0f 2e       	mov	r0, r31
    2646:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
    2648:	ff 2e       	mov	r15, r31
    264a:	f0 2d       	mov	r31, r0
    264c:	a1 c0       	rjmp	.+322    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    264e:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;
    2650:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
    2652:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
    2654:	ef 2e       	mov	r14, r31
    2656:	f0 2d       	mov	r31, r0
    2658:	0f 2e       	mov	r0, r31
    265a:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
    265c:	ff 2e       	mov	r15, r31
    265e:	f0 2d       	mov	r31, r0
    2660:	97 c0       	rjmp	.+302    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2662:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;
    2664:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
    2666:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
    2668:	ef 2e       	mov	r14, r31
    266a:	f0 2d       	mov	r31, r0
    266c:	ff 24       	eor	r15, r15
    266e:	f3 94       	inc	r15
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
    2670:	8f c0       	rjmp	.+286    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2672:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;
    2674:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
    2676:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
    2678:	ef 2e       	mov	r14, r31
    267a:	f0 2d       	mov	r31, r0
    267c:	0f 2e       	mov	r0, r31
    267e:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
    2680:	ff 2e       	mov	r15, r31
    2682:	f0 2d       	mov	r31, r0
    2684:	85 c0       	rjmp	.+266    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2686:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;
    2688:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
    268a:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
    268c:	ef 2e       	mov	r14, r31
    268e:	f0 2d       	mov	r31, r0
    2690:	f1 2c       	mov	r15, r1
    2692:	7e c0       	rjmp	.+252    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
    2694:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;
    2696:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
    2698:	f0 ed       	ldi	r31, 0xD0	; 208
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
    269a:	ef 2e       	mov	r14, r31
    269c:	f0 2d       	mov	r31, r0
    269e:	f1 2c       	mov	r15, r1
    26a0:	77 c0       	rjmp	.+238    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
    26a2:	81 2f       	mov	r24, r17
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
            break;
    26a4:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_20MHZ):
        switch (canSpeed)
    26a6:	fc 01       	movw	r30, r24
    26a8:	34 97       	sbiw	r30, 0x04	; 4
    26aa:	ec 30       	cpi	r30, 0x0C	; 12
    26ac:	f1 05       	cpc	r31, r1
    26ae:	08 f0       	brcs	.+2      	; 0x26b2 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1f6>
    26b0:	81 c0       	rjmp	.+258    	; 0x27b4 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f8>
    26b2:	88 27       	eor	r24, r24
    26b4:	e7 55       	subi	r30, 0x57	; 87
    26b6:	ff 4f       	sbci	r31, 0xFF	; 255
    26b8:	8f 4f       	sbci	r24, 0xFF	; 255
    26ba:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
    26be:	17 e8       	ldi	r17, 0x87	; 135
    26c0:	0f 2e       	mov	r0, r31
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
    26c2:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
    26c4:	ef 2e       	mov	r14, r31
    26c6:	f0 2d       	mov	r31, r0
    26c8:	0f 2e       	mov	r0, r31
    26ca:	f9 e0       	ldi	r31, 0x09	; 9
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
    26cc:	ff 2e       	mov	r15, r31
    26ce:	f0 2d       	mov	r31, r0
    26d0:	5f c0       	rjmp	.+190    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    26d2:	17 e8       	ldi	r17, 0x87	; 135
    26d4:	ee 24       	eor	r14, r14
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
    26d6:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
    26d8:	68 94       	set
    26da:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
    26dc:	f2 f8       	bld	r15, 2
    26de:	58 c0       	rjmp	.+176    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    26e0:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;
    26e2:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
    26e4:	fe ef       	ldi	r31, 0xFE	; 254
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
    26e6:	ef 2e       	mov	r14, r31
    26e8:	f0 2d       	mov	r31, r0
    26ea:	68 94       	set
    26ec:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
    26ee:	f2 f8       	bld	r15, 2
    26f0:	4f c0       	rjmp	.+158    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    26f2:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;
    26f4:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
    26f6:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
    26f8:	ef 2e       	mov	r14, r31
    26fa:	f0 2d       	mov	r31, r0
    26fc:	68 94       	set
    26fe:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
    2700:	f2 f8       	bld	r15, 2
    2702:	46 c0       	rjmp	.+140    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2704:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;
    2706:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
    2708:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
    270a:	ef 2e       	mov	r14, r31
    270c:	f0 2d       	mov	r31, r0
    270e:	0f 2e       	mov	r0, r31
    2710:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
    2712:	ff 2e       	mov	r15, r31
    2714:	f0 2d       	mov	r31, r0
    2716:	3c c0       	rjmp	.+120    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2718:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;
    271a:	ee 24       	eor	r14, r14

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
    271c:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
    271e:	ff 24       	eor	r15, r15
    2720:	f3 94       	inc	r15
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
    2722:	36 c0       	rjmp	.+108    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2724:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;
    2726:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
    2728:	fb ef       	ldi	r31, 0xFB	; 251
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
    272a:	ef 2e       	mov	r14, r31
    272c:	f0 2d       	mov	r31, r0
    272e:	0f 2e       	mov	r0, r31
    2730:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
    2732:	ff 2e       	mov	r15, r31
    2734:	f0 2d       	mov	r31, r0
    2736:	2c c0       	rjmp	.+88     	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2738:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;
    273a:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
    273c:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
    273e:	ef 2e       	mov	r14, r31
    2740:	f0 2d       	mov	r31, r0
    2742:	f1 2c       	mov	r15, r1
    2744:	25 c0       	rjmp	.+74     	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
    2746:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;
    2748:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
            cfg3 = MCP_20MHz_1000kBPS_CFG3;
    274a:	f9 ed       	ldi	r31, 0xD9	; 217
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
    274c:	ef 2e       	mov	r14, r31
    274e:	f0 2d       	mov	r31, r0
    2750:	f1 2c       	mov	r15, r1
    2752:	1e c0       	rjmp	.+60     	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
    2754:	80 e0       	ldi	r24, 0x00	; 0
            break;
        }
        break;

        default:
        set = 0;
    2756:	19 c0       	rjmp	.+50     	; 0x278a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
    2758:	0f 2e       	mov	r0, r31
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
            cfg2 = MCP_8MHz_5kBPS_CFG2;
    275a:	ff eb       	ldi	r31, 0xBF	; 191
    275c:	ef 2e       	mov	r14, r31
    275e:	f0 2d       	mov	r31, r0
    {
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
    2760:	0f 2e       	mov	r0, r31
    2762:	ff e1       	ldi	r31, 0x1F	; 31
    2764:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2766:	f0 2d       	mov	r31, r0
    2768:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
            cfg2 = MCP_16MHz_5kBPS_CFG2;
    276a:	0f c0       	rjmp	.+30     	; 0x278a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
    276c:	ee 24       	eor	r14, r14

        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
    276e:	ea 94       	dec	r14
    2770:	0f 2e       	mov	r0, r31
    2772:	ff e3       	ldi	r31, 0x3F	; 63
    2774:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2776:	f0 2d       	mov	r31, r0
    2778:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
    277a:	07 c0       	rjmp	.+14     	; 0x278a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
    277c:	ee 24       	eor	r14, r14

        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
    277e:	ea 94       	dec	r14
    2780:	0f 2e       	mov	r0, r31
    2782:	fb e0       	ldi	r31, 0x0B	; 11
    2784:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    2786:	f0 2d       	mov	r31, r0
        default:
        set = 0;
        break;
    }

    if (set) {
    2788:	81 e0       	ldi	r24, 0x01	; 1
    278a:	88 23       	and	r24, r24
    278c:	a9 f0       	breq	.+42     	; 0x27b8 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2fc>
        setRegister(MCP_CNF1, cfg1);
    278e:	17 e8       	ldi	r17, 0x87	; 135
    2790:	4f 2d       	mov	r20, r15
    2792:	6a e2       	ldi	r22, 0x2A	; 42
    2794:	ce 01       	movw	r24, r28
    2796:	6c dd       	rcall	.-1320   	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
        setRegister(MCP_CNF2, cfg2);
    2798:	4e 2d       	mov	r20, r14
    279a:	69 e2       	ldi	r22, 0x29	; 41
    279c:	ce 01       	movw	r24, r28
    279e:	68 dd       	rcall	.-1328   	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    27a0:	41 2f       	mov	r20, r17
        setRegister(MCP_CNF3, cfg3);
    27a2:	68 e2       	ldi	r22, 0x28	; 40
    27a4:	ce 01       	movw	r24, r28
    27a6:	64 dd       	rcall	.-1336   	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    27a8:	80 e0       	ldi	r24, 0x00	; 0
    27aa:	2c c0       	rjmp	.+88     	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
        return ERROR_OK;
    27ac:	81 e0       	ldi	r24, 0x01	; 1
    27ae:	2a c0       	rjmp	.+84     	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    }
    else {
        return ERROR_FAIL;
    27b0:	81 e0       	ldi	r24, 0x01	; 1
    27b2:	28 c0       	rjmp	.+80     	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    27b4:	81 e0       	ldi	r24, 0x01	; 1
    27b6:	26 c0       	rjmp	.+76     	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	24 c0       	rjmp	.+72     	; 0x2804 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    27bc:	17 e8       	ldi	r17, 0x87	; 135
    27be:	0f 2e       	mov	r0, r31
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
    27c0:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
    27c2:	ef 2e       	mov	r14, r31
    27c4:	f0 2d       	mov	r31, r0
    27c6:	0f 2e       	mov	r0, r31
    27c8:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_8MHz_5kBPS_CFG2;
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
    27ca:	ff 2e       	mov	r15, r31
    27cc:	f0 2d       	mov	r31, r0
    27ce:	e0 cf       	rjmp	.-64     	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    27d0:	14 e8       	ldi	r17, 0x84	; 132
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
    27d2:	0f 2e       	mov	r0, r31
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
    27d4:	f4 ea       	ldi	r31, 0xA4	; 164
    27d6:	ef 2e       	mov	r14, r31
    27d8:	f0 2d       	mov	r31, r0
    27da:	0f 2e       	mov	r0, r31
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
    27dc:	f7 e0       	ldi	r31, 0x07	; 7
    27de:	ff 2e       	mov	r15, r31
    27e0:	f0 2d       	mov	r31, r0
    27e2:	d6 cf       	rjmp	.-84     	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
            cfg2 = MCP_16MHz_10kBPS_CFG2;
            cfg3 = MCP_16MHz_10kBPS_CFG3;
    27e4:	17 e8       	ldi	r17, 0x87	; 135
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
            cfg2 = MCP_16MHz_10kBPS_CFG2;
    27e6:	ee 24       	eor	r14, r14
            cfg2 = MCP_16MHz_5kBPS_CFG2;
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
    27e8:	ea 94       	dec	r14
    27ea:	0f 2e       	mov	r0, r31
    27ec:	ff e1       	ldi	r31, 0x1F	; 31
    27ee:	ff 2e       	mov	r15, r31
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
    27f0:	f0 2d       	mov	r31, r0
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
    27f2:	ce cf       	rjmp	.-100    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    27f4:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
    27f6:	ee 24       	eor	r14, r14
    27f8:	ea 94       	dec	r14
    27fa:	0f 2e       	mov	r0, r31
    27fc:	f9 e0       	ldi	r31, 0x09	; 9
        return ERROR_OK;
    }
    else {
        return ERROR_FAIL;
    }
}
    27fe:	ff 2e       	mov	r15, r31
    2800:	f0 2d       	mov	r31, r0
    2802:	c6 cf       	rjmp	.-116    	; 0x2790 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	1f 91       	pop	r17

}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed)
{
    return setBitrate(canSpeed, MCP_16MHZ);
    280a:	0f 91       	pop	r16
    280c:	ff 90       	pop	r15
    280e:	ef 90       	pop	r14
}
    2810:	08 95       	ret

00002812 <_ZN7MCP251510setBitrateE9CAN_SPEED>:
        return ERROR_FAIL;
    }
}

MCP2515::ERROR MCP2515::setClkOut(const CAN_CLKOUT divisor)
{
    2812:	41 e0       	ldi	r20, 0x01	; 1
    2814:	53 ce       	rjmp	.-858    	; 0x24bc <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>
    2816:	08 95       	ret

00002818 <_ZN7MCP25159setClkOutE10CAN_CLKOUT>:
    ERROR res;
    uint8_t cfg3;

    if (divisor == CLKOUT_DISABLE) {
    2818:	cf 93       	push	r28
    281a:	df 93       	push	r29
	/* Turn off CLKEN */
	modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, 0x00);
    281c:	ec 01       	movw	r28, r24
    281e:	6f 3f       	cpi	r22, 0xFF	; 255
    2820:	51 f4       	brne	.+20     	; 0x2836 <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x1e>
    2822:	20 e0       	ldi	r18, 0x00	; 0
    2824:	44 e0       	ldi	r20, 0x04	; 4

	/* Turn on CLKOUT for SOF */
	modifyRegister(MCP_CNF3, CNF3_SOF, CNF3_SOF);
    2826:	6f e0       	ldi	r22, 0x0F	; 15
    2828:	7a dd       	rcall	.-1292   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    282a:	20 e8       	ldi	r18, 0x80	; 128
    282c:	40 e8       	ldi	r20, 0x80	; 128
    282e:	68 e2       	ldi	r22, 0x28	; 40
    2830:	ce 01       	movw	r24, r28
        return ERROR_OK;
    2832:	75 dd       	rcall	.-1302   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    }

    /* Set the prescaler (CLKPRE) */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKPRE, divisor);
    2834:	0e c0       	rjmp	.+28     	; 0x2852 <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x3a>
    2836:	26 2f       	mov	r18, r22
    2838:	43 e0       	ldi	r20, 0x03	; 3
    283a:	6f e0       	ldi	r22, 0x0F	; 15
    283c:	70 dd       	rcall	.-1312   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>

    /* Turn on CLKEN */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, CANCTRL_CLKEN);
    283e:	24 e0       	ldi	r18, 0x04	; 4
    2840:	44 e0       	ldi	r20, 0x04	; 4
    2842:	6f e0       	ldi	r22, 0x0F	; 15
    2844:	ce 01       	movw	r24, r28
    2846:	6b dd       	rcall	.-1322   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2848:	20 e0       	ldi	r18, 0x00	; 0

    /* Turn off CLKOUT for SOF */
    modifyRegister(MCP_CNF3, CNF3_SOF, 0x00);
    284a:	40 e8       	ldi	r20, 0x80	; 128
    284c:	68 e2       	ldi	r22, 0x28	; 40
    284e:	ce 01       	movw	r24, r28
    2850:	66 dd       	rcall	.-1332   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2852:	80 e0       	ldi	r24, 0x00	; 0
    2854:	df 91       	pop	r29
    return ERROR_OK;
}
    2856:	cf 91       	pop	r28
    2858:	08 95       	ret

0000285a <_ZN7MCP25159prepareIdEPhbm>:
    285a:	0f 93       	push	r16
    285c:	1f 93       	push	r17

void MCP2515::prepareId(uint8_t *buffer, const bool ext, const uint32_t id)
{
    285e:	fb 01       	movw	r30, r22
    2860:	44 23       	and	r20, r20
    2862:	c9 f0       	breq	.+50     	; 0x2896 <_ZN7MCP25159prepareIdEPhbm+0x3c>
    uint16_t canid = (uint16_t)(id & 0x0FFFF);

    if (ext) {
    2864:	03 83       	std	Z+3, r16	; 0x03
    2866:	12 83       	std	Z+2, r17	; 0x02
        buffer[MCP_EID0] = (uint8_t) (canid & 0xFF);
    2868:	89 01       	movw	r16, r18
        buffer[MCP_EID8] = (uint8_t) (canid >> 8);
    286a:	22 27       	eor	r18, r18
        canid = (uint16_t)(id >> 16);
    286c:	33 27       	eor	r19, r19
    286e:	80 2f       	mov	r24, r16
    2870:	8c 71       	andi	r24, 0x1C	; 28
        buffer[MCP_SIDL] = (uint8_t) (canid & 0x03);
        buffer[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
        buffer[MCP_SIDL] |= TXB_EXIDE_MASK;
    2872:	88 0f       	add	r24, r24
    2874:	88 0f       	add	r24, r24
    2876:	88 0f       	add	r24, r24
    2878:	90 2f       	mov	r25, r16
    287a:	93 70       	andi	r25, 0x03	; 3
    287c:	89 0f       	add	r24, r25
    287e:	88 60       	ori	r24, 0x08	; 8
    2880:	81 83       	std	Z+1, r24	; 0x01
    2882:	16 95       	lsr	r17
    2884:	07 95       	ror	r16
        buffer[MCP_SIDH] = (uint8_t) (canid >> 5);
    2886:	12 95       	swap	r17
    2888:	02 95       	swap	r16
    288a:	0f 70       	andi	r16, 0x0F	; 15
    288c:	01 27       	eor	r16, r17
    288e:	1f 70       	andi	r17, 0x0F	; 15
    2890:	01 27       	eor	r16, r17
    2892:	00 83       	st	Z, r16
    2894:	0e c0       	rjmp	.+28     	; 0x28b2 <_ZN7MCP25159prepareIdEPhbm+0x58>
    2896:	c8 01       	movw	r24, r16
    } else {
        buffer[MCP_SIDH] = (uint8_t) (canid >> 3);
    2898:	96 95       	lsr	r25
    289a:	87 95       	ror	r24
    289c:	96 95       	lsr	r25
    289e:	87 95       	ror	r24
    28a0:	96 95       	lsr	r25
    28a2:	87 95       	ror	r24
    28a4:	80 83       	st	Z, r24
        buffer[MCP_SIDL] = (uint8_t) ((canid & 0x07 ) << 5);
    28a6:	02 95       	swap	r16
    28a8:	00 0f       	add	r16, r16
    28aa:	00 7e       	andi	r16, 0xE0	; 224
    28ac:	01 83       	std	Z+1, r16	; 0x01
        buffer[MCP_EID0] = 0;
    28ae:	13 82       	std	Z+3, r1	; 0x03
        buffer[MCP_EID8] = 0;
    28b0:	12 82       	std	Z+2, r1	; 0x02
    }
}
    28b2:	1f 91       	pop	r17
    28b4:	0f 91       	pop	r16
    28b6:	08 95       	ret

000028b8 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>:

MCP2515::ERROR MCP2515::setFilterMask(const MASK mask, const bool ext, const uint32_t ulData)
{
    28b8:	8f 92       	push	r8
    28ba:	9f 92       	push	r9
    28bc:	af 92       	push	r10
    28be:	bf 92       	push	r11
    28c0:	cf 92       	push	r12
    28c2:	df 92       	push	r13
    28c4:	ef 92       	push	r14
    28c6:	ff 92       	push	r15
    28c8:	0f 93       	push	r16
    28ca:	1f 93       	push	r17
    28cc:	cf 93       	push	r28
    28ce:	df 93       	push	r29
    28d0:	00 d0       	rcall	.+0      	; 0x28d2 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x1a>
    28d2:	1f 92       	push	r1
    28d4:	cd b7       	in	r28, 0x3d	; 61
    28d6:	de b7       	in	r29, 0x3e	; 62
    28d8:	7c 01       	movw	r14, r24
    28da:	d6 2e       	mov	r13, r22
    28dc:	c4 2e       	mov	r12, r20
    28de:	48 01       	movw	r8, r16
    ERROR res = setConfigMode();
    28e0:	59 01       	movw	r10, r18
    28e2:	dd dd       	rcall	.-1094   	; 0x249e <_ZN7MCP251513setConfigModeEv>
    if (res != ERROR_OK) {
    28e4:	81 11       	cpse	r24, r1
    28e6:	19 c0       	rjmp	.+50     	; 0x291a <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
        return res;
    }
    
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    28e8:	95 01       	movw	r18, r10
    28ea:	84 01       	movw	r16, r8
    28ec:	4c 2d       	mov	r20, r12
    28ee:	be 01       	movw	r22, r28
    28f0:	6f 5f       	subi	r22, 0xFF	; 255
    28f2:	7f 4f       	sbci	r23, 0xFF	; 255
    28f4:	c7 01       	movw	r24, r14
    28f6:	b1 df       	rcall	.-158    	; 0x285a <_ZN7MCP25159prepareIdEPhbm>
    28f8:	dd 20       	and	r13, r13

    REGISTER reg;
    switch (mask) {
    28fa:	29 f0       	breq	.+10     	; 0x2906 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x4e>
    28fc:	81 e0       	ldi	r24, 0x01	; 1
    28fe:	d8 12       	cpse	r13, r24
    2900:	0b c0       	rjmp	.+22     	; 0x2918 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x60>
    2902:	64 e2       	ldi	r22, 0x24	; 36
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
    2904:	01 c0       	rjmp	.+2      	; 0x2908 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x50>
    2906:	60 e2       	ldi	r22, 0x20	; 32
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);

    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
    2908:	24 e0       	ldi	r18, 0x04	; 4
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    }

    setRegisters(reg, tbufdata, 4);
    290a:	ae 01       	movw	r20, r28
    290c:	4f 5f       	subi	r20, 0xFF	; 255
    290e:	5f 4f       	sbci	r21, 0xFF	; 255
    2910:	c7 01       	movw	r24, r14
    2912:	d0 dc       	rcall	.-1632   	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    2914:	80 e0       	ldi	r24, 0x00	; 0
    
    return ERROR_OK;
    2916:	01 c0       	rjmp	.+2      	; 0x291a <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
    2918:	81 e0       	ldi	r24, 0x01	; 1
    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    291a:	0f 90       	pop	r0
    }

    setRegisters(reg, tbufdata, 4);
    
    return ERROR_OK;
}
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	df 91       	pop	r29
    2924:	cf 91       	pop	r28
    2926:	1f 91       	pop	r17
    2928:	0f 91       	pop	r16
    292a:	ff 90       	pop	r15
    292c:	ef 90       	pop	r14
    292e:	df 90       	pop	r13
    2930:	cf 90       	pop	r12
    2932:	bf 90       	pop	r11
    2934:	af 90       	pop	r10
    2936:	9f 90       	pop	r9
    2938:	8f 90       	pop	r8
    293a:	08 95       	ret

0000293c <_ZN7MCP25159setFilterENS_3RXFEbm>:
    293c:	8f 92       	push	r8

MCP2515::ERROR MCP2515::setFilter(const RXF num, const bool ext, const uint32_t ulData)
{
    293e:	9f 92       	push	r9
    2940:	af 92       	push	r10
    2942:	bf 92       	push	r11
    2944:	cf 92       	push	r12
    2946:	df 92       	push	r13
    2948:	ef 92       	push	r14
    294a:	ff 92       	push	r15
    294c:	0f 93       	push	r16
    294e:	1f 93       	push	r17
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	00 d0       	rcall	.+0      	; 0x2956 <_ZN7MCP25159setFilterENS_3RXFEbm+0x1a>
    2956:	1f 92       	push	r1
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
    295c:	6c 01       	movw	r12, r24
    295e:	f6 2e       	mov	r15, r22
    2960:	e4 2e       	mov	r14, r20
    2962:	48 01       	movw	r8, r16
    2964:	59 01       	movw	r10, r18
    2966:	9b dd       	rcall	.-1226   	; 0x249e <_ZN7MCP251513setConfigModeEv>
    ERROR res = setConfigMode();
    2968:	81 11       	cpse	r24, r1
    296a:	3d c0       	rjmp	.+122    	; 0x29e6 <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>
    if (res != ERROR_OK) {
    296c:	82 e0       	ldi	r24, 0x02	; 2
    296e:	f8 16       	cp	r15, r24
        return res;
    }

    REGISTER reg;

    switch (num) {
    2970:	a9 f0       	breq	.+42     	; 0x299c <_ZN7MCP25159setFilterENS_3RXFEbm+0x60>
    2972:	8f 15       	cp	r24, r15
    2974:	30 f0       	brcs	.+12     	; 0x2982 <_ZN7MCP25159setFilterENS_3RXFEbm+0x46>
    2976:	ff 20       	and	r15, r15
    2978:	19 f1       	breq	.+70     	; 0x29c0 <_ZN7MCP25159setFilterENS_3RXFEbm+0x84>
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	f8 16       	cp	r15, r24
    297e:	51 f0       	breq	.+20     	; 0x2994 <_ZN7MCP25159setFilterENS_3RXFEbm+0x58>
    2980:	31 c0       	rjmp	.+98     	; 0x29e4 <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
    2982:	84 e0       	ldi	r24, 0x04	; 4
    2984:	f8 16       	cp	r15, r24
    2986:	91 f0       	breq	.+36     	; 0x29ac <_ZN7MCP25159setFilterENS_3RXFEbm+0x70>
    2988:	f8 16       	cp	r15, r24
    298a:	60 f0       	brcs	.+24     	; 0x29a4 <_ZN7MCP25159setFilterENS_3RXFEbm+0x68>
    298c:	85 e0       	ldi	r24, 0x05	; 5
    298e:	f8 16       	cp	r15, r24
    2990:	91 f0       	breq	.+36     	; 0x29b6 <_ZN7MCP25159setFilterENS_3RXFEbm+0x7a>
    2992:	28 c0       	rjmp	.+80     	; 0x29e4 <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
        case RXF0: reg = MCP_RXF0SIDH; break;
        case RXF1: reg = MCP_RXF1SIDH; break;
    2994:	68 94       	set
    2996:	ff 24       	eor	r15, r15
    2998:	f2 f8       	bld	r15, 2
    299a:	13 c0       	rjmp	.+38     	; 0x29c2 <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF2: reg = MCP_RXF2SIDH; break;
    299c:	68 94       	set
    299e:	ff 24       	eor	r15, r15
    29a0:	f3 f8       	bld	r15, 3
    29a2:	0f c0       	rjmp	.+30     	; 0x29c2 <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF3: reg = MCP_RXF3SIDH; break;
    29a4:	68 94       	set
    29a6:	ff 24       	eor	r15, r15
    29a8:	f4 f8       	bld	r15, 4
    29aa:	0b c0       	rjmp	.+22     	; 0x29c2 <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF4: reg = MCP_RXF4SIDH; break;
    29ac:	0f 2e       	mov	r0, r31
    29ae:	f4 e1       	ldi	r31, 0x14	; 20
    29b0:	ff 2e       	mov	r15, r31
    29b2:	f0 2d       	mov	r31, r0
    29b4:	06 c0       	rjmp	.+12     	; 0x29c2 <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF5: reg = MCP_RXF5SIDH; break;
    29b6:	0f 2e       	mov	r0, r31
    29b8:	f8 e1       	ldi	r31, 0x18	; 24
    29ba:	ff 2e       	mov	r15, r31
    29bc:	f0 2d       	mov	r31, r0
    29be:	01 c0       	rjmp	.+2      	; 0x29c2 <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
    }

    REGISTER reg;

    switch (num) {
        case RXF0: reg = MCP_RXF0SIDH; break;
    29c0:	f1 2c       	mov	r15, r1
        default:
            return ERROR_FAIL;
    }

    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    29c2:	95 01       	movw	r18, r10
    29c4:	84 01       	movw	r16, r8
    29c6:	4e 2d       	mov	r20, r14
    29c8:	be 01       	movw	r22, r28
    29ca:	6f 5f       	subi	r22, 0xFF	; 255
    29cc:	7f 4f       	sbci	r23, 0xFF	; 255
    29ce:	c6 01       	movw	r24, r12
    29d0:	44 df       	rcall	.-376    	; 0x285a <_ZN7MCP25159prepareIdEPhbm>
    29d2:	24 e0       	ldi	r18, 0x04	; 4
    setRegisters(reg, tbufdata, 4);
    29d4:	ae 01       	movw	r20, r28
    29d6:	4f 5f       	subi	r20, 0xFF	; 255
    29d8:	5f 4f       	sbci	r21, 0xFF	; 255
    29da:	6f 2d       	mov	r22, r15
    29dc:	c6 01       	movw	r24, r12
    29de:	6a dc       	rcall	.-1836   	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    29e0:	80 e0       	ldi	r24, 0x00	; 0
    29e2:	01 c0       	rjmp	.+2      	; 0x29e6 <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>

    return ERROR_OK;
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	0f 90       	pop	r0
        case RXF2: reg = MCP_RXF2SIDH; break;
        case RXF3: reg = MCP_RXF3SIDH; break;
        case RXF4: reg = MCP_RXF4SIDH; break;
        case RXF5: reg = MCP_RXF5SIDH; break;
        default:
            return ERROR_FAIL;
    29e8:	0f 90       	pop	r0
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    setRegisters(reg, tbufdata, 4);

    return ERROR_OK;
}
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	df 91       	pop	r29
    29f0:	cf 91       	pop	r28
    29f2:	1f 91       	pop	r17
    29f4:	0f 91       	pop	r16
    29f6:	ff 90       	pop	r15
    29f8:	ef 90       	pop	r14
    29fa:	df 90       	pop	r13
    29fc:	cf 90       	pop	r12
    29fe:	bf 90       	pop	r11
    2a00:	af 90       	pop	r10
    2a02:	9f 90       	pop	r9
    2a04:	8f 90       	pop	r8
    2a06:	08 95       	ret

00002a08 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>:
    2a08:	4f 92       	push	r4
    2a0a:	5f 92       	push	r5

MCP2515::ERROR MCP2515::sendMessage(const TXBn txbn, const struct can_frame *frame)
{
    2a0c:	6f 92       	push	r6
    2a0e:	7f 92       	push	r7
    2a10:	af 92       	push	r10
    2a12:	bf 92       	push	r11
    2a14:	cf 92       	push	r12
    2a16:	df 92       	push	r13
    2a18:	ef 92       	push	r14
    2a1a:	ff 92       	push	r15
    2a1c:	0f 93       	push	r16
    2a1e:	1f 93       	push	r17
    2a20:	cf 93       	push	r28
    2a22:	df 93       	push	r29
    2a24:	cd b7       	in	r28, 0x3d	; 61
    2a26:	de b7       	in	r29, 0x3e	; 62
    2a28:	2d 97       	sbiw	r28, 0x0d	; 13
    2a2a:	0f b6       	in	r0, 0x3f	; 63
    2a2c:	f8 94       	cli
    2a2e:	de bf       	out	0x3e, r29	; 62
    2a30:	0f be       	out	0x3f, r0	; 63
    2a32:	cd bf       	out	0x3d, r28	; 61
    2a34:	5c 01       	movw	r10, r24
    2a36:	6a 01       	movw	r12, r20
    2a38:	e6 2e       	mov	r14, r22
    const struct TXBn_REGS *txbuf = &TXB[txbn];
    2a3a:	f1 2c       	mov	r15, r1
    2a3c:	fa 01       	movw	r30, r20

    uint8_t data[13];

    bool ext = (frame->can_id & CAN_EFF_FLAG);
    2a3e:	00 81       	ld	r16, Z
    2a40:	11 81       	ldd	r17, Z+1	; 0x01
    2a42:	22 81       	ldd	r18, Z+2	; 0x02
    2a44:	33 81       	ldd	r19, Z+3	; 0x03
    2a46:	b9 01       	movw	r22, r18
    2a48:	a8 01       	movw	r20, r16
    2a4a:	44 27       	eor	r20, r20
    2a4c:	77 fd       	sbrc	r23, 7
    2a4e:	43 95       	inc	r20
    2a50:	55 27       	eor	r21, r21
    2a52:	66 27       	eor	r22, r22
    2a54:	77 27       	eor	r23, r23
    2a56:	28 01       	movw	r4, r16
    bool rtr = (frame->can_id & CAN_RTR_FLAG);
    2a58:	39 01       	movw	r6, r18
    2a5a:	44 24       	eor	r4, r4
    2a5c:	55 24       	eor	r5, r5
    2a5e:	66 24       	eor	r6, r6
    2a60:	f0 e4       	ldi	r31, 0x40	; 64
    2a62:	7f 22       	and	r7, r31
    2a64:	33 23       	and	r19, r19
    uint32_t id = (frame->can_id & (ext ? CAN_EFF_MASK : CAN_SFF_MASK));
    2a66:	2c f0       	brlt	.+10     	; 0x2a72 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x6a>
    2a68:	8f ef       	ldi	r24, 0xFF	; 255
    2a6a:	97 e0       	ldi	r25, 0x07	; 7
    2a6c:	a0 e0       	ldi	r26, 0x00	; 0
    2a6e:	b0 e0       	ldi	r27, 0x00	; 0
    2a70:	04 c0       	rjmp	.+8      	; 0x2a7a <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x72>
    2a72:	8f ef       	ldi	r24, 0xFF	; 255
    2a74:	9f ef       	ldi	r25, 0xFF	; 255
    2a76:	af ef       	ldi	r26, 0xFF	; 255
    2a78:	bf e1       	ldi	r27, 0x1F	; 31

    prepareId(data, ext, id);
    2a7a:	08 23       	and	r16, r24
    2a7c:	19 23       	and	r17, r25
    2a7e:	2a 23       	and	r18, r26
    2a80:	3b 23       	and	r19, r27
    2a82:	be 01       	movw	r22, r28
    2a84:	6f 5f       	subi	r22, 0xFF	; 255
    2a86:	7f 4f       	sbci	r23, 0xFF	; 255
    2a88:	c5 01       	movw	r24, r10
    2a8a:	e7 de       	rcall	.-562    	; 0x285a <_ZN7MCP25159prepareIdEPhbm>

    data[MCP_DLC] = rtr ? (frame->can_dlc | RTR_MASK) : frame->can_dlc;
    2a8c:	45 28       	or	r4, r5
    2a8e:	46 28       	or	r4, r6
    2a90:	47 28       	or	r4, r7
    2a92:	21 f0       	breq	.+8      	; 0x2a9c <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x94>
    2a94:	f6 01       	movw	r30, r12
    2a96:	84 81       	ldd	r24, Z+4	; 0x04
    2a98:	80 64       	ori	r24, 0x40	; 64
    2a9a:	02 c0       	rjmp	.+4      	; 0x2aa0 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x98>
    2a9c:	f6 01       	movw	r30, r12
    2a9e:	84 81       	ldd	r24, Z+4	; 0x04
    2aa0:	8d 83       	std	Y+5, r24	; 0x05

    memcpy(&data[MCP_DATA], frame->data, frame->can_dlc);
    2aa2:	f6 01       	movw	r30, r12
    2aa4:	14 81       	ldd	r17, Z+4	; 0x04
    2aa6:	41 2f       	mov	r20, r17
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	b6 01       	movw	r22, r12
    2aac:	68 5f       	subi	r22, 0xF8	; 248
    2aae:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab0:	ce 01       	movw	r24, r28
    2ab2:	06 96       	adiw	r24, 0x06	; 6
    2ab4:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>

    setRegisters(txbuf->SIDH, data, 5 + frame->can_dlc);
    2ab8:	25 e0       	ldi	r18, 0x05	; 5
    2aba:	21 0f       	add	r18, r17
    2abc:	87 01       	movw	r16, r14
    2abe:	00 0f       	add	r16, r16
    2ac0:	11 1f       	adc	r17, r17
    2ac2:	0e 0d       	add	r16, r14
    2ac4:	1f 1d       	adc	r17, r15
    2ac6:	0e 50       	subi	r16, 0x0E	; 14
    2ac8:	1d 4f       	sbci	r17, 0xFD	; 253
    2aca:	ae 01       	movw	r20, r28
    2acc:	4f 5f       	subi	r20, 0xFF	; 255
    2ace:	5f 4f       	sbci	r21, 0xFF	; 255
    2ad0:	f8 01       	movw	r30, r16
    2ad2:	61 81       	ldd	r22, Z+1	; 0x01
    2ad4:	c5 01       	movw	r24, r10
    2ad6:	ee db       	rcall	.-2084   	; 0x22b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    2ad8:	28 e0       	ldi	r18, 0x08	; 8

    modifyRegister(txbuf->CTRL, TXB_TXREQ, TXB_TXREQ);
    2ada:	48 e0       	ldi	r20, 0x08	; 8
    2adc:	f8 01       	movw	r30, r16
    2ade:	60 81       	ld	r22, Z
    2ae0:	c5 01       	movw	r24, r10
    2ae2:	1d dc       	rcall	.-1990   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2ae4:	80 e0       	ldi	r24, 0x00	; 0
    2ae6:	2d 96       	adiw	r28, 0x0d	; 13

    return ERROR_OK;
}
    2ae8:	0f b6       	in	r0, 0x3f	; 63
    2aea:	f8 94       	cli
    2aec:	de bf       	out	0x3e, r29	; 62
    2aee:	0f be       	out	0x3f, r0	; 63
    2af0:	cd bf       	out	0x3d, r28	; 61
    2af2:	df 91       	pop	r29
    2af4:	cf 91       	pop	r28
    2af6:	1f 91       	pop	r17
    2af8:	0f 91       	pop	r16
    2afa:	ff 90       	pop	r15
    2afc:	ef 90       	pop	r14
    2afe:	df 90       	pop	r13
    2b00:	cf 90       	pop	r12
    2b02:	bf 90       	pop	r11
    2b04:	af 90       	pop	r10
    2b06:	7f 90       	pop	r7
    2b08:	6f 90       	pop	r6
    2b0a:	5f 90       	pop	r5
    2b0c:	4f 90       	pop	r4
    2b0e:	08 95       	ret

00002b10 <_ZN7MCP251511sendMessageEPK9can_frame>:
    2b10:	9f 92       	push	r9

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    2b12:	af 92       	push	r10
    2b14:	bf 92       	push	r11
    2b16:	cf 92       	push	r12
    2b18:	df 92       	push	r13
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	cf 93       	push	r28
    2b24:	df 93       	push	r29
    2b26:	00 d0       	rcall	.+0      	; 0x2b28 <_ZN7MCP251511sendMessageEPK9can_frame+0x18>
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
    2b2c:	6c 01       	movw	r12, r24
    if (frame->can_dlc > CAN_MAX_DLEN) {
    2b2e:	fb 01       	movw	r30, r22
    2b30:	94 81       	ldd	r25, Z+4	; 0x04
    2b32:	99 30       	cpi	r25, 0x09	; 9
    2b34:	48 f5       	brcc	.+82     	; 0x2b88 <_ZN7MCP251511sendMessageEPK9can_frame+0x78>
    2b36:	7b 01       	movw	r14, r22
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};
    2b38:	19 82       	std	Y+1, r1	; 0x01
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	8a 83       	std	Y+2, r24	; 0x02
    2b3e:	82 e0       	ldi	r24, 0x02	; 2
    2b40:	8b 83       	std	Y+3, r24	; 0x03
    2b42:	8e 01       	movw	r16, r28
    2b44:	0f 5f       	subi	r16, 0xFF	; 255
    2b46:	1f 4f       	sbci	r17, 0xFF	; 255
    2b48:	5e 01       	movw	r10, r28
    2b4a:	f4 e0       	ldi	r31, 0x04	; 4
    2b4c:	af 0e       	add	r10, r31
    2b4e:	b1 1c       	adc	r11, r1

    for (int i=0; i<N_TXBUFFERS; i++) {
        const struct TXBn_REGS *txbuf = &TXB[txBuffers[i]];
    2b50:	f8 01       	movw	r30, r16
    2b52:	91 90       	ld	r9, Z+
    2b54:	8f 01       	movw	r16, r30
        uint8_t ctrlval = readRegister(txbuf->CTRL);
    2b56:	29 2d       	mov	r18, r9
    2b58:	30 e0       	ldi	r19, 0x00	; 0
    2b5a:	f9 01       	movw	r30, r18
    2b5c:	ee 0f       	add	r30, r30
    2b5e:	ff 1f       	adc	r31, r31
    2b60:	2e 0f       	add	r18, r30
    2b62:	3f 1f       	adc	r19, r31
    2b64:	f9 01       	movw	r30, r18
    2b66:	ee 50       	subi	r30, 0x0E	; 14
    2b68:	fd 4f       	sbci	r31, 0xFD	; 253
    2b6a:	60 81       	ld	r22, Z
    2b6c:	c6 01       	movw	r24, r12
    2b6e:	2b db       	rcall	.-2474   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2b70:	83 fd       	sbrc	r24, 3
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
    2b72:	05 c0       	rjmp	.+10     	; 0x2b7e <_ZN7MCP251511sendMessageEPK9can_frame+0x6e>
    2b74:	a7 01       	movw	r20, r14
            return sendMessage(txBuffers[i], frame);
    2b76:	69 2d       	mov	r22, r9
    2b78:	c6 01       	movw	r24, r12
    2b7a:	46 df       	rcall	.-372    	; 0x2a08 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    2b7c:	06 c0       	rjmp	.+12     	; 0x2b8a <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
    2b7e:	0a 15       	cp	r16, r10
    2b80:	1b 05       	cpc	r17, r11
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};

    for (int i=0; i<N_TXBUFFERS; i++) {
    2b82:	31 f7       	brne	.-52     	; 0x2b50 <_ZN7MCP251511sendMessageEPK9can_frame+0x40>
    2b84:	84 e0       	ldi	r24, 0x04	; 4
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
    2b86:	01 c0       	rjmp	.+2      	; 0x2b8a <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
    2b88:	84 e0       	ldi	r24, 0x04	; 4
}

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    if (frame->can_dlc > CAN_MAX_DLEN) {
        return ERROR_FAILTX;
    2b8a:	0f 90       	pop	r0
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
}
    2b8c:	0f 90       	pop	r0
    2b8e:	0f 90       	pop	r0
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	ff 90       	pop	r15
    2b9a:	ef 90       	pop	r14
    2b9c:	df 90       	pop	r13
    2b9e:	cf 90       	pop	r12
    2ba0:	bf 90       	pop	r11
    2ba2:	af 90       	pop	r10
    2ba4:	9f 90       	pop	r9
    2ba6:	08 95       	ret

00002ba8 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>:
    2ba8:	7f 92       	push	r7

MCP2515::ERROR MCP2515::readMessage(const RXBn rxbn, struct can_frame *frame)
{
    2baa:	8f 92       	push	r8
    2bac:	9f 92       	push	r9
    2bae:	af 92       	push	r10
    2bb0:	bf 92       	push	r11
    2bb2:	cf 92       	push	r12
    2bb4:	df 92       	push	r13
    2bb6:	ef 92       	push	r14
    2bb8:	ff 92       	push	r15
    2bba:	0f 93       	push	r16
    2bbc:	1f 93       	push	r17
    2bbe:	cf 93       	push	r28
    2bc0:	df 93       	push	r29
    2bc2:	00 d0       	rcall	.+0      	; 0x2bc4 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x1c>
    2bc4:	1f 92       	push	r1
    2bc6:	1f 92       	push	r1
    2bc8:	cd b7       	in	r28, 0x3d	; 61
    2bca:	de b7       	in	r29, 0x3e	; 62
    2bcc:	5c 01       	movw	r10, r24
    2bce:	4a 01       	movw	r8, r20
    2bd0:	06 2f       	mov	r16, r22
    const struct RXBn_REGS *rxb = &RXB[rxbn];
    2bd2:	10 e0       	ldi	r17, 0x00	; 0
    2bd4:	f8 01       	movw	r30, r16

    uint8_t tbufdata[5];

    readRegisters(rxb->SIDH, tbufdata, 5);
    2bd6:	ee 0f       	add	r30, r30
    2bd8:	ff 1f       	adc	r31, r31
    2bda:	ee 0f       	add	r30, r30
    2bdc:	ff 1f       	adc	r31, r31
    2bde:	e6 51       	subi	r30, 0x16	; 22
    2be0:	fd 4f       	sbci	r31, 0xFD	; 253
    2be2:	25 e0       	ldi	r18, 0x05	; 5
    2be4:	ae 01       	movw	r20, r28
    2be6:	4f 5f       	subi	r20, 0xFF	; 255
    2be8:	5f 4f       	sbci	r21, 0xFF	; 255
    2bea:	61 81       	ldd	r22, Z+1	; 0x01
    2bec:	0c db       	rcall	.-2536   	; 0x2206 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    2bee:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf0:	99 81       	ldd	r25, Y+1	; 0x01

    uint32_t id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    2bf2:	c8 2e       	mov	r12, r24
    2bf4:	d1 2c       	mov	r13, r1
    2bf6:	d5 94       	asr	r13
    2bf8:	c7 94       	ror	r12
    2bfa:	d5 94       	asr	r13
    2bfc:	c7 94       	ror	r12
    2bfe:	d5 94       	asr	r13
    2c00:	c7 94       	ror	r12
    2c02:	d5 94       	asr	r13
    2c04:	c7 94       	ror	r12
    2c06:	d5 94       	asr	r13
    2c08:	c7 94       	ror	r12
    2c0a:	28 e0       	ldi	r18, 0x08	; 8
    2c0c:	92 9f       	mul	r25, r18
    2c0e:	c0 0c       	add	r12, r0
    2c10:	d1 1c       	adc	r13, r1
    2c12:	11 24       	eor	r1, r1
    2c14:	0d 2c       	mov	r0, r13
    2c16:	00 0c       	add	r0, r0
    2c18:	ee 08       	sbc	r14, r14
    2c1a:	ff 08       	sbc	r15, r15
    2c1c:	83 ff       	sbrs	r24, 3
	//printf("%lx	",id);
    if ( (tbufdata[MCP_SIDL] & TXB_EXIDE_MASK) ==  TXB_EXIDE_MASK ) {
    2c1e:	21 c0       	rjmp	.+66     	; 0x2c62 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xba>
    2c20:	cc 0c       	add	r12, r12
        id = (id<<2) + (tbufdata[MCP_SIDL] & 0x03);
    2c22:	dd 1c       	adc	r13, r13
    2c24:	ee 1c       	adc	r14, r14
    2c26:	ff 1c       	adc	r15, r15
    2c28:	cc 0c       	add	r12, r12
    2c2a:	dd 1c       	adc	r13, r13
    2c2c:	ee 1c       	adc	r14, r14
    2c2e:	ff 1c       	adc	r15, r15
    2c30:	83 70       	andi	r24, 0x03	; 3
        id = (id<<8) + tbufdata[MCP_EID8];
    2c32:	c8 0e       	add	r12, r24
    2c34:	d1 1c       	adc	r13, r1
    2c36:	e1 1c       	adc	r14, r1
    2c38:	f1 1c       	adc	r15, r1
    2c3a:	fe 2c       	mov	r15, r14
    2c3c:	ed 2c       	mov	r14, r13
    2c3e:	dc 2c       	mov	r13, r12
    2c40:	cc 24       	eor	r12, r12
    2c42:	8b 81       	ldd	r24, Y+3	; 0x03
        id = (id<<8) + tbufdata[MCP_EID0];
    2c44:	c8 0e       	add	r12, r24
    2c46:	d1 1c       	adc	r13, r1
    2c48:	e1 1c       	adc	r14, r1
    2c4a:	f1 1c       	adc	r15, r1
    2c4c:	fe 2c       	mov	r15, r14
    2c4e:	ed 2c       	mov	r14, r13
    2c50:	dc 2c       	mov	r13, r12
    2c52:	cc 24       	eor	r12, r12
    2c54:	8c 81       	ldd	r24, Y+4	; 0x04
    2c56:	c8 0e       	add	r12, r24
    2c58:	d1 1c       	adc	r13, r1
    2c5a:	e1 1c       	adc	r14, r1
        id |= CAN_EFF_FLAG;
    2c5c:	f1 1c       	adc	r15, r1
    2c5e:	68 94       	set
    }

    uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
    2c60:	f7 f8       	bld	r15, 7
    2c62:	8d 81       	ldd	r24, Y+5	; 0x05
    2c64:	8f 70       	andi	r24, 0x0F	; 15
    if (dlc > CAN_MAX_DLEN) {
    2c66:	78 2e       	mov	r7, r24
    2c68:	88 e0       	ldi	r24, 0x08	; 8
    2c6a:	87 15       	cp	r24, r7
        return ERROR_FAIL;
    }

    uint8_t ctrl = readRegister(rxb->CTRL);
    2c6c:	50 f1       	brcs	.+84     	; 0x2cc2 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11a>
    2c6e:	f8 01       	movw	r30, r16
    2c70:	ee 0f       	add	r30, r30
    2c72:	ff 1f       	adc	r31, r31
    2c74:	ee 0f       	add	r30, r30
    2c76:	ff 1f       	adc	r31, r31
    2c78:	e6 51       	subi	r30, 0x16	; 22
    2c7a:	fd 4f       	sbci	r31, 0xFD	; 253
    2c7c:	60 81       	ld	r22, Z
    2c7e:	c5 01       	movw	r24, r10
    2c80:	a2 da       	rcall	.-2748   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    if (ctrl & RXBnCTRL_RTR) {
    2c82:	83 ff       	sbrs	r24, 3
    2c84:	02 c0       	rjmp	.+4      	; 0x2c8a <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xe2>
        id |= CAN_RTR_FLAG;
    2c86:	68 94       	set
    }

    frame->can_id = id;
    2c88:	f6 f8       	bld	r15, 6
    2c8a:	f4 01       	movw	r30, r8
    2c8c:	c0 82       	st	Z, r12
    2c8e:	d1 82       	std	Z+1, r13	; 0x01
    frame->can_dlc = dlc;
    2c90:	e2 82       	std	Z+2, r14	; 0x02


    readRegisters(rxb->DATA, frame->data, dlc);
    2c92:	f3 82       	std	Z+3, r15	; 0x03
    2c94:	74 82       	std	Z+4, r7	; 0x04
    2c96:	a4 01       	movw	r20, r8
    2c98:	48 5f       	subi	r20, 0xF8	; 248
    2c9a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c9c:	00 0f       	add	r16, r16
    2c9e:	11 1f       	adc	r17, r17
    2ca0:	00 0f       	add	r16, r16
    2ca2:	11 1f       	adc	r17, r17
    2ca4:	06 51       	subi	r16, 0x16	; 22
    2ca6:	1d 4f       	sbci	r17, 0xFD	; 253
    2ca8:	27 2d       	mov	r18, r7
    2caa:	f8 01       	movw	r30, r16

    modifyRegister(MCP_CANINTF, rxb->CANINTF_RXnIF, 0);
    2cac:	62 81       	ldd	r22, Z+2	; 0x02
    2cae:	c5 01       	movw	r24, r10
    2cb0:	aa da       	rcall	.-2732   	; 0x2206 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    2cb2:	20 e0       	ldi	r18, 0x00	; 0
    2cb4:	f8 01       	movw	r30, r16
    2cb6:	43 81       	ldd	r20, Z+3	; 0x03

    return ERROR_OK;
    2cb8:	6c e2       	ldi	r22, 0x2C	; 44
        id |= CAN_EFF_FLAG;
    }

    uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
    if (dlc > CAN_MAX_DLEN) {
        return ERROR_FAIL;
    2cba:	c5 01       	movw	r24, r10
    readRegisters(rxb->DATA, frame->data, dlc);

    modifyRegister(MCP_CANINTF, rxb->CANINTF_RXnIF, 0);

    return ERROR_OK;
}
    2cbc:	30 db       	rcall	.-2464   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2cbe:	80 e0       	ldi	r24, 0x00	; 0
    2cc0:	01 c0       	rjmp	.+2      	; 0x2cc4 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11c>
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	0f 90       	pop	r0
    2cc6:	0f 90       	pop	r0
    2cc8:	0f 90       	pop	r0
    2cca:	0f 90       	pop	r0
    2ccc:	0f 90       	pop	r0
    2cce:	df 91       	pop	r29
    2cd0:	cf 91       	pop	r28
    2cd2:	1f 91       	pop	r17
    2cd4:	0f 91       	pop	r16
    2cd6:	ff 90       	pop	r15
    2cd8:	ef 90       	pop	r14
    2cda:	df 90       	pop	r13

MCP2515::ERROR MCP2515::readMessage(struct can_frame *frame)
{
    2cdc:	cf 90       	pop	r12
    2cde:	bf 90       	pop	r11
    2ce0:	af 90       	pop	r10
    2ce2:	9f 90       	pop	r9
    2ce4:	8f 90       	pop	r8
    ERROR rc;
    uint8_t stat = getStatus();
    2ce6:	7f 90       	pop	r7
    2ce8:	08 95       	ret

00002cea <_ZN7MCP251511readMessageEP9can_frame>:

    if ( stat & STAT_RX0IF ) {
    2cea:	0f 93       	push	r16
        rc = readMessage(RXB0, frame);
    2cec:	1f 93       	push	r17
    2cee:	cf 93       	push	r28
    2cf0:	df 93       	push	r29
    2cf2:	ec 01       	movw	r28, r24
    2cf4:	8b 01       	movw	r16, r22
    } else if ( stat & STAT_RX1IF ) {
    2cf6:	97 db       	rcall	.-2258   	; 0x2426 <_ZN7MCP25159getStatusEv>
    2cf8:	80 ff       	sbrs	r24, 0
        rc = readMessage(RXB1, frame);
    2cfa:	05 c0       	rjmp	.+10     	; 0x2d06 <_ZN7MCP251511readMessageEP9can_frame+0x1c>
    2cfc:	a8 01       	movw	r20, r16
    2cfe:	60 e0       	ldi	r22, 0x00	; 0
    2d00:	ce 01       	movw	r24, r28
    2d02:	52 df       	rcall	.-348    	; 0x2ba8 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    } else {
        rc = ERROR_NOMSG;
    2d04:	08 c0       	rjmp	.+16     	; 0x2d16 <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    }

    return rc;
}
    2d06:	81 ff       	sbrs	r24, 1
    2d08:	05 c0       	rjmp	.+10     	; 0x2d14 <_ZN7MCP251511readMessageEP9can_frame+0x2a>
    2d0a:	a8 01       	movw	r20, r16
    2d0c:	61 e0       	ldi	r22, 0x01	; 1

bool MCP2515::checkReceive(void)
{
    uint8_t res = getStatus();
    2d0e:	ce 01       	movw	r24, r28
    2d10:	4b df       	rcall	.-362    	; 0x2ba8 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    2d12:	01 c0       	rjmp	.+2      	; 0x2d16 <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    2d14:	85 e0       	ldi	r24, 0x05	; 5
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    if ( res & STAT_RXIF_MASK ) {
        return true;
    } else {
        return false;
    }
}
    2d1a:	1f 91       	pop	r17
    }
}

uint8_t MCP2515::getErrorFlags(void)
{
    return readRegister(MCP_EFLG);
    2d1c:	0f 91       	pop	r16
    2d1e:	08 95       	ret

00002d20 <_ZN7MCP251512checkReceiveEv>:
    2d20:	82 db       	rcall	.-2300   	; 0x2426 <_ZN7MCP25159getStatusEv>
}
    2d22:	98 2f       	mov	r25, r24
    }
}

bool MCP2515::checkError(void)
{
    uint8_t eflg = getErrorFlags();
    2d24:	93 70       	andi	r25, 0x03	; 3
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	09 f4       	brne	.+2      	; 0x2d2c <_ZN7MCP251512checkReceiveEv+0xc>
    2d2a:	80 e0       	ldi	r24, 0x00	; 0
    2d2c:	08 95       	ret

00002d2e <_ZN7MCP251513getErrorFlagsEv>:
    2d2e:	6d e2       	ldi	r22, 0x2D	; 45
    2d30:	4a ca       	rjmp	.-2924   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    if ( eflg & EFLG_ERRORMASK ) {
        return true;
    } else {
        return false;
    }
}
    2d32:	08 95       	ret

00002d34 <_ZN7MCP251510checkErrorEv>:
    return readRegister(MCP_EFLG);
}

void MCP2515::clearRXnOVRFlags(void)
{
	modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    2d34:	fc df       	rcall	.-8      	; 0x2d2e <_ZN7MCP251513getErrorFlagsEv>
    2d36:	98 2f       	mov	r25, r24
    2d38:	98 7f       	andi	r25, 0xF8	; 248
    2d3a:	81 e0       	ldi	r24, 0x01	; 1
    2d3c:	09 f4       	brne	.+2      	; 0x2d40 <_ZN7MCP251510checkErrorEv+0xc>
    2d3e:	80 e0       	ldi	r24, 0x00	; 0
}

uint8_t MCP2515::getInterrupts(void)
{
    return readRegister(MCP_CANINTF);
    2d40:	08 95       	ret

00002d42 <_ZN7MCP251516clearRXnOVRFlagsEv>:
    2d42:	20 e0       	ldi	r18, 0x00	; 0
    2d44:	40 ec       	ldi	r20, 0xC0	; 192
}
    2d46:	6d e2       	ldi	r22, 0x2D	; 45

void MCP2515::clearInterrupts(void)
{
    setRegister(MCP_CANINTF, 0);
    2d48:	ea ca       	rjmp	.-2604   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2d4a:	08 95       	ret

00002d4c <_ZN7MCP251513getInterruptsEv>:
    2d4c:	6c e2       	ldi	r22, 0x2C	; 44
    2d4e:	3b ca       	rjmp	.-2954   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2d50:	08 95       	ret

00002d52 <_ZN7MCP251515clearInterruptsEv>:
}

uint8_t MCP2515::getInterruptMask(void)
{
    return readRegister(MCP_CANINTE);
    2d52:	40 e0       	ldi	r20, 0x00	; 0
    2d54:	6c e2       	ldi	r22, 0x2C	; 44
    2d56:	8c ca       	rjmp	.-2792   	; 0x2270 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
}
    2d58:	08 95       	ret

00002d5a <_ZN7MCP251516getInterruptMaskEv>:

void MCP2515::clearTXInterrupts(void)
{
    modifyRegister(MCP_CANINTF, (CANINTF_TX0IF | CANINTF_TX1IF | CANINTF_TX2IF), 0);
    2d5a:	6b e2       	ldi	r22, 0x2B	; 43
    2d5c:	34 ca       	rjmp	.-2968   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2d5e:	08 95       	ret

00002d60 <_ZN7MCP251517clearTXInterruptsEv>:
    2d60:	20 e0       	ldi	r18, 0x00	; 0
    2d62:	4c e1       	ldi	r20, 0x1C	; 28
    2d64:	6c e2       	ldi	r22, 0x2C	; 44
}

void MCP2515::clearRXnOVR(void)
{
    2d66:	db ca       	rjmp	.-2634   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2d68:	08 95       	ret

00002d6a <_ZN7MCP251511clearRXnOVREv>:
    2d6a:	cf 93       	push	r28
	uint8_t eflg = getErrorFlags();
    2d6c:	df 93       	push	r29
    2d6e:	ec 01       	movw	r28, r24
	if (eflg != 0) {
    2d70:	de df       	rcall	.-68     	; 0x2d2e <_ZN7MCP251513getErrorFlagsEv>
    2d72:	88 23       	and	r24, r24
		clearRXnOVRFlags();
    2d74:	21 f0       	breq	.+8      	; 0x2d7e <_ZN7MCP251511clearRXnOVREv+0x14>
    2d76:	ce 01       	movw	r24, r28
    2d78:	e4 df       	rcall	.-56     	; 0x2d42 <_ZN7MCP251516clearRXnOVRFlagsEv>
		clearInterrupts();
    2d7a:	ce 01       	movw	r24, r28
    2d7c:	ea df       	rcall	.-44     	; 0x2d52 <_ZN7MCP251515clearInterruptsEv>
    2d7e:	df 91       	pop	r29
		//modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
	}
	
}
    2d80:	cf 91       	pop	r28
    2d82:	08 95       	ret

00002d84 <_ZN7MCP25159clearMERREv>:
    2d84:	20 e0       	ldi	r18, 0x00	; 0

void MCP2515::clearMERR()
{
	//modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
	//clearInterrupts();
	modifyRegister(MCP_CANINTF, CANINTF_MERRF, 0);
    2d86:	40 e8       	ldi	r20, 0x80	; 128
    2d88:	6c e2       	ldi	r22, 0x2C	; 44
    2d8a:	c9 ca       	rjmp	.-2670   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2d8c:	08 95       	ret

00002d8e <_ZN7MCP251510clearERRIFEv>:
    2d8e:	20 e0       	ldi	r18, 0x00	; 0
    2d90:	40 e2       	ldi	r20, 0x20	; 32

void MCP2515::clearERRIF()
{
    //modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    //clearInterrupts();
    modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
    2d92:	6c e2       	ldi	r22, 0x2C	; 44
    2d94:	c4 ca       	rjmp	.-2680   	; 0x231e <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2d96:	08 95       	ret

00002d98 <_ZN7MCP251510checktxavaEv>:
    2d98:	60 e3       	ldi	r22, 0x30	; 48
    2d9a:	15 da       	rcall	.-3030   	; 0x21c6 <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2d9c:	80 e0       	ldi	r24, 0x00	; 0
}

MCP2515::ERROR MCP2515::checktxava(void) {
	if(((readRegister(MCP_TXB0CTRL)&TXB_TXREQ)>>TXB_TXREQ)==0) {
    2d9e:	08 95       	ret

00002da0 <_ZN8SPIClass5beginEv>:

//PB4 is CS pin for CAN controller

void SPIClass::begin()
{
  uint8_t sreg = SREG;
    2da0:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2da2:	f8 94       	cli
  if (!initialized) {
    2da4:	80 91 f2 1f 	lds	r24, 0x1FF2	; 0x801ff2 <_ZN8SPIClass11initializedE>
    2da8:	81 11       	cpse	r24, r1
    2daa:	0f c0       	rjmp	.+30     	; 0x2dca <_ZN8SPIClass5beginEv+0x2a>
    // Set SS to high so a connected chip will be "deselected" by default
   // uint8_t port = digitalPinToPort(SS);
    //uint8_t bit = digitalPinToBitMask(SS);
    //volatile uint8_t *reg = portModeRegister(port);
	
	DDRB|=(1<<PB4); // sets SS to output
    2dac:	24 9a       	sbi	0x04, 4	; 4
	DDRB|=(1<<PB0);
    2dae:	20 9a       	sbi	0x04, 0	; 4
	PORTB|=(1<<PB0);
    2db0:	28 9a       	sbi	0x05, 0	; 5

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
	
	PORTB|=(1<<PB4); // then set SS high
    2db2:	2c 9a       	sbi	0x05, 4	; 5
   // pinMode(SS, OUTPUT);

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
		DDRB|=(1<<PB1); //set SCK out
    2db4:	21 9a       	sbi	0x04, 1	; 4
		DDRB|=(1<<PB2); // set MOSI out
    2db6:	22 9a       	sbi	0x04, 2	; 4

	
	
    SPCR |= (1<<(MSTR));
    2db8:	8c b5       	in	r24, 0x2c	; 44
    2dba:	80 61       	ori	r24, 0x10	; 16
    2dbc:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<(SPE));
    2dbe:	8c b5       	in	r24, 0x2c	; 44
    2dc0:	80 64       	ori	r24, 0x40	; 64
    2dc2:	8c bd       	out	0x2c, r24	; 44
	SPCR |= (1<<(SPR0)) | (1<<SPR1);
    2dc4:	8c b5       	in	r24, 0x2c	; 44
    2dc6:	83 60       	ori	r24, 0x03	; 3
    2dc8:	8c bd       	out	0x2c, r24	; 44


    //pinMode(SCK, OUTPUT);
    //pinMode(MOSI, OUTPUT);
  }
  initialized++; // reference count
    2dca:	80 91 f2 1f 	lds	r24, 0x1FF2	; 0x801ff2 <_ZN8SPIClass11initializedE>
    2dce:	8f 5f       	subi	r24, 0xFF	; 255
    2dd0:	80 93 f2 1f 	sts	0x1FF2, r24	; 0x801ff2 <_ZN8SPIClass11initializedE>
  SREG = sreg;
    2dd4:	9f bf       	out	0x3f, r25	; 63
    2dd6:	08 95       	ret

00002dd8 <_ZN8SPIClass3endEv>:
}

void SPIClass::end() {
  uint8_t sreg = SREG;
    2dd8:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2dda:	f8 94       	cli
  // Decrease the reference counter
  if (initialized)
    2ddc:	80 91 f2 1f 	lds	r24, 0x1FF2	; 0x801ff2 <_ZN8SPIClass11initializedE>
    2de0:	88 23       	and	r24, r24
    2de2:	29 f0       	breq	.+10     	; 0x2dee <_ZN8SPIClass3endEv+0x16>
    initialized--;
    2de4:	81 50       	subi	r24, 0x01	; 1
    2de6:	80 93 f2 1f 	sts	0x1FF2, r24	; 0x801ff2 <_ZN8SPIClass11initializedE>
  // If there are no more references disable SPI
  if (!initialized) {
    2dea:	81 11       	cpse	r24, r1
    2dec:	05 c0       	rjmp	.+10     	; 0x2df8 <_ZN8SPIClass3endEv+0x20>
    SPCR &= ~(1<<(SPE));
    2dee:	8c b5       	in	r24, 0x2c	; 44
    2df0:	8f 7b       	andi	r24, 0xBF	; 191
    2df2:	8c bd       	out	0x2c, r24	; 44
    interruptMode = 0;
    2df4:	10 92 f1 1f 	sts	0x1FF1, r1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    #ifdef SPI_TRANSACTION_MISMATCH_LED
    inTransactionFlag = 0;
    #endif
  }
  SREG = sreg;
    2df8:	9f bf       	out	0x3f, r25	; 63
    2dfa:	08 95       	ret

00002dfc <_ZN8SPIClass14usingInterruptEh>:
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    2dfc:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2dfe:	f8 94       	cli
  switch (interruptNumber) {
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	88 30       	cpi	r24, 0x08	; 8
    2e04:	91 05       	cpc	r25, r1
    2e06:	a8 f4       	brcc	.+42     	; 0x2e32 <_ZN8SPIClass14usingInterruptEh+0x36>
    2e08:	fc 01       	movw	r30, r24
    2e0a:	88 27       	eor	r24, r24
    2e0c:	eb 54       	subi	r30, 0x4B	; 75
    2e0e:	ff 4f       	sbci	r31, 0xFF	; 255
    2e10:	8f 4f       	sbci	r24, 0xFF	; 255
    2e12:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    2e16:	80 e2       	ldi	r24, 0x20	; 32
    2e18:	12 c0       	rjmp	.+36     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    2e1a:	81 e0       	ldi	r24, 0x01	; 1
    2e1c:	10 c0       	rjmp	.+32     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    2e1e:	82 e0       	ldi	r24, 0x02	; 2
    2e20:	0e c0       	rjmp	.+28     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    2e22:	84 e0       	ldi	r24, 0x04	; 4
    2e24:	0c c0       	rjmp	.+24     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    2e26:	88 e0       	ldi	r24, 0x08	; 8
    2e28:	0a c0       	rjmp	.+20     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    2e2a:	80 e4       	ldi	r24, 0x40	; 64
    2e2c:	08 c0       	rjmp	.+16     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    2e2e:	80 e8       	ldi	r24, 0x80	; 128
    2e30:	06 c0       	rjmp	.+12     	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  default:
    interruptMode = 2;
    2e32:	82 e0       	ldi	r24, 0x02	; 2
    2e34:	80 93 f1 1f 	sts	0x1FF1, r24	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
  #endif
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
    2e38:	80 e0       	ldi	r24, 0x00	; 0
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
  #endif
  default:
    interruptMode = 2;
    break;
    2e3a:	01 c0       	rjmp	.+2      	; 0x2e3e <_ZN8SPIClass14usingInterruptEh+0x42>
  uint8_t mask = 0;
  uint8_t sreg = SREG;
  cli(); // Protect from a scheduler and prevent transactionBegin
  switch (interruptNumber) {
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    2e3c:	80 e1       	ldi	r24, 0x10	; 16
  #endif
  default:
    interruptMode = 2;
    break;
  }
  interruptMask |= mask;
    2e3e:	90 91 f0 1f 	lds	r25, 0x1FF0	; 0x801ff0 <_ZN8SPIClass13interruptMaskE>
    2e42:	89 2b       	or	r24, r25
    2e44:	80 93 f0 1f 	sts	0x1FF0, r24	; 0x801ff0 <_ZN8SPIClass13interruptMaskE>
  if (!interruptMode)
    2e48:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    2e4c:	81 11       	cpse	r24, r1
    2e4e:	03 c0       	rjmp	.+6      	; 0x2e56 <_ZN8SPIClass14usingInterruptEh+0x5a>
    interruptMode = 1;
    2e50:	81 e0       	ldi	r24, 0x01	; 1
    2e52:	80 93 f1 1f 	sts	0x1FF1, r24	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    2e56:	2f bf       	out	0x3f, r18	; 63
    2e58:	08 95       	ret

00002e5a <_ZN8SPIClass17notUsingInterruptEh>:
}

void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    2e5a:	90 91 f1 1f 	lds	r25, 0x1FF1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
    2e5e:	92 30       	cpi	r25, 0x02	; 2
    2e60:	49 f1       	breq	.+82     	; 0x2eb4 <_ZN8SPIClass17notUsingInterruptEh+0x5a>
    return;
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    2e62:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2e64:	f8 94       	cli
  switch (interruptNumber) {
    2e66:	90 e0       	ldi	r25, 0x00	; 0
    2e68:	88 30       	cpi	r24, 0x08	; 8
    2e6a:	91 05       	cpc	r25, r1
    2e6c:	b8 f4       	brcc	.+46     	; 0x2e9c <_ZN8SPIClass17notUsingInterruptEh+0x42>
    2e6e:	fc 01       	movw	r30, r24
    2e70:	88 27       	eor	r24, r24
    2e72:	e3 54       	subi	r30, 0x43	; 67
    2e74:	ff 4f       	sbci	r31, 0xFF	; 255
    2e76:	8f 4f       	sbci	r24, 0xFF	; 255
    2e78:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    2e7c:	80 e1       	ldi	r24, 0x10	; 16
    2e7e:	0f c0       	rjmp	.+30     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    2e80:	80 e2       	ldi	r24, 0x20	; 32
    2e82:	0d c0       	rjmp	.+26     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    2e84:	81 e0       	ldi	r24, 0x01	; 1
    2e86:	0b c0       	rjmp	.+22     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    2e88:	82 e0       	ldi	r24, 0x02	; 2
    2e8a:	09 c0       	rjmp	.+18     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    2e8c:	84 e0       	ldi	r24, 0x04	; 4
    2e8e:	07 c0       	rjmp	.+14     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    2e90:	88 e0       	ldi	r24, 0x08	; 8
    2e92:	05 c0       	rjmp	.+10     	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    2e94:	80 e4       	ldi	r24, 0x40	; 64
    2e96:	03 c0       	rjmp	.+6      	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    2e98:	80 e8       	ldi	r24, 0x80	; 128
    2e9a:	01 c0       	rjmp	.+2      	; 0x2e9e <_ZN8SPIClass17notUsingInterruptEh+0x44>
void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    return;
  uint8_t mask = 0;
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
  #endif
  default:
    break;
    // this case can't be reached
  }
  interruptMask &= ~mask;
    2e9e:	80 95       	com	r24
    2ea0:	90 91 f0 1f 	lds	r25, 0x1FF0	; 0x801ff0 <_ZN8SPIClass13interruptMaskE>
    2ea4:	89 23       	and	r24, r25
    2ea6:	80 93 f0 1f 	sts	0x1FF0, r24	; 0x801ff0 <_ZN8SPIClass13interruptMaskE>
  if (!interruptMask)
    2eaa:	81 11       	cpse	r24, r1
    2eac:	02 c0       	rjmp	.+4      	; 0x2eb2 <_ZN8SPIClass17notUsingInterruptEh+0x58>
    interruptMode = 0;
    2eae:	10 92 f1 1f 	sts	0x1FF1, r1	; 0x801ff1 <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    2eb2:	2f bf       	out	0x3f, r18	; 63
    2eb4:	08 95       	ret

00002eb6 <usart_init>:
	return b;
}

void usart_nl(void) {
			usart_putchar('\r');
			usart_putchar('\n');
    2eb6:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
    2eba:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
    2ebe:	e0 ec       	ldi	r30, 0xC0	; 192
    2ec0:	f0 e0       	ldi	r31, 0x00	; 0
    2ec2:	80 81       	ld	r24, Z
    2ec4:	82 60       	ori	r24, 0x02	; 2
    2ec6:	80 83       	st	Z, r24
    2ec8:	88 e0       	ldi	r24, 0x08	; 8
    2eca:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
    2ece:	86 e0       	ldi	r24, 0x06	; 6
    2ed0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
    2ed4:	08 95       	ret

00002ed6 <usart_putchar>:
    2ed6:	e0 ec       	ldi	r30, 0xC0	; 192
    2ed8:	f0 e0       	ldi	r31, 0x00	; 0
    2eda:	90 81       	ld	r25, Z
    2edc:	95 ff       	sbrs	r25, 5
    2ede:	fd cf       	rjmp	.-6      	; 0x2eda <usart_putchar+0x4>
    2ee0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    2ee4:	08 95       	ret

00002ee6 <usart_putchar_printf>:
}

int usart_putchar_printf(char var, FILE *stream) {
    2ee6:	cf 93       	push	r28
    2ee8:	c8 2f       	mov	r28, r24
	if (var == '\n') usart_putchar('\r');
    2eea:	8a 30       	cpi	r24, 0x0A	; 10
    2eec:	11 f4       	brne	.+4      	; 0x2ef2 <usart_putchar_printf+0xc>
    2eee:	8d e0       	ldi	r24, 0x0D	; 13
    2ef0:	f2 df       	rcall	.-28     	; 0x2ed6 <usart_putchar>
	usart_putchar(var);
    2ef2:	8c 2f       	mov	r24, r28
    2ef4:	f0 df       	rcall	.-32     	; 0x2ed6 <usart_putchar>
	return 0;
}
    2ef6:	80 e0       	ldi	r24, 0x00	; 0
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	cf 91       	pop	r28
    2efc:	08 95       	ret

00002efe <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    2efe:	cf 92       	push	r12
    2f00:	df 92       	push	r13
    2f02:	ef 92       	push	r14
    2f04:	ff 92       	push	r15
    2f06:	0f 93       	push	r16
    2f08:	1f 93       	push	r17
    2f0a:	cf 93       	push	r28
    2f0c:	df 93       	push	r29
    2f0e:	1f 92       	push	r1
    2f10:	1f 92       	push	r1
    2f12:	cd b7       	in	r28, 0x3d	; 61
    2f14:	de b7       	in	r29, 0x3e	; 62
    2f16:	90 93 f4 03 	sts	0x03F4, r25	; 0x8003f4 <count+0x1>
    2f1a:	80 93 f3 03 	sts	0x03F3, r24	; 0x8003f3 <count>
    2f1e:	9b 01       	movw	r18, r22
    2f20:	22 5f       	subi	r18, 0xF2	; 242
    2f22:	3f 4f       	sbci	r19, 0xFF	; 255
    2f24:	30 93 f2 03 	sts	0x03F2, r19	; 0x8003f2 <size+0x1>
    2f28:	20 93 f1 03 	sts	0x03F1, r18	; 0x8003f1 <size>
    2f2c:	6b 01       	movw	r12, r22
    2f2e:	22 e1       	ldi	r18, 0x12	; 18
    2f30:	c2 0e       	add	r12, r18
    2f32:	d1 1c       	adc	r13, r1
    2f34:	8c 9d       	mul	r24, r12
    2f36:	80 01       	movw	r16, r0
    2f38:	8d 9d       	mul	r24, r13
    2f3a:	10 0d       	add	r17, r0
    2f3c:	9c 9d       	mul	r25, r12
    2f3e:	10 0d       	add	r17, r0
    2f40:	11 24       	eor	r1, r1
    2f42:	c8 01       	movw	r24, r16
    2f44:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <csp_malloc>
    2f48:	90 93 f6 03 	sts	0x03F6, r25	; 0x8003f6 <csp_buffer_pool+0x1>
    2f4c:	80 93 f5 03 	sts	0x03F5, r24	; 0x8003f5 <csp_buffer_pool>
    2f50:	89 2b       	or	r24, r25
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <csp_buffer_init+0x58>
    2f54:	52 c0       	rjmp	.+164    	; 0x2ffa <csp_buffer_init+0xfc>
    2f56:	62 e0       	ldi	r22, 0x02	; 2
    2f58:	70 e0       	ldi	r23, 0x00	; 0
    2f5a:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2f5e:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2f62:	0e 94 80 28 	call	0x5100	; 0x5100 <csp_queue_create>
    2f66:	90 93 f8 03 	sts	0x03F8, r25	; 0x8003f8 <csp_buffers+0x1>
    2f6a:	80 93 f7 03 	sts	0x03F7, r24	; 0x8003f7 <csp_buffers>
    2f6e:	89 2b       	or	r24, r25
    2f70:	d9 f1       	breq	.+118    	; 0x2fe8 <csp_buffer_init+0xea>
    2f72:	a8 01       	movw	r20, r16
    2f74:	60 e0       	ldi	r22, 0x00	; 0
    2f76:	70 e0       	ldi	r23, 0x00	; 0
    2f78:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2f7c:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2f80:	0e 94 97 45 	call	0x8b2e	; 0x8b2e <memset>
    2f84:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2f88:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2f8c:	89 2b       	or	r24, r25
    2f8e:	c1 f1       	breq	.+112    	; 0x3000 <csp_buffer_init+0x102>
    2f90:	e1 2c       	mov	r14, r1
    2f92:	f1 2c       	mov	r15, r1
    2f94:	00 e0       	ldi	r16, 0x00	; 0
    2f96:	10 e0       	ldi	r17, 0x00	; 0
    2f98:	e0 91 f5 03 	lds	r30, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2f9c:	f0 91 f6 03 	lds	r31, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2fa0:	ee 0d       	add	r30, r14
    2fa2:	ff 1d       	adc	r31, r15
    2fa4:	fa 83       	std	Y+2, r31	; 0x02
    2fa6:	e9 83       	std	Y+1, r30	; 0x01
    2fa8:	11 82       	std	Z+1, r1	; 0x01
    2faa:	10 82       	st	Z, r1
    2fac:	e9 81       	ldd	r30, Y+1	; 0x01
    2fae:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb0:	f3 83       	std	Z+3, r31	; 0x03
    2fb2:	e2 83       	std	Z+2, r30	; 0x02
    2fb4:	20 e0       	ldi	r18, 0x00	; 0
    2fb6:	30 e0       	ldi	r19, 0x00	; 0
    2fb8:	a9 01       	movw	r20, r18
    2fba:	be 01       	movw	r22, r28
    2fbc:	6f 5f       	subi	r22, 0xFF	; 255
    2fbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2fc0:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    2fc4:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    2fc8:	0e 94 84 28 	call	0x5108	; 0x5108 <csp_queue_enqueue>
    2fcc:	0f 5f       	subi	r16, 0xFF	; 255
    2fce:	1f 4f       	sbci	r17, 0xFF	; 255
    2fd0:	ec 0c       	add	r14, r12
    2fd2:	fd 1c       	adc	r15, r13
    2fd4:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    2fd8:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    2fdc:	08 17       	cp	r16, r24
    2fde:	19 07       	cpc	r17, r25
    2fe0:	d8 f2       	brcs	.-74     	; 0x2f98 <csp_buffer_init+0x9a>
    2fe2:	80 e0       	ldi	r24, 0x00	; 0
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	0e c0       	rjmp	.+28     	; 0x3004 <csp_buffer_init+0x106>
    2fe8:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    2fec:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    2ff0:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <csp_free>
    2ff4:	8f ef       	ldi	r24, 0xFF	; 255
    2ff6:	9f ef       	ldi	r25, 0xFF	; 255
    2ff8:	05 c0       	rjmp	.+10     	; 0x3004 <csp_buffer_init+0x106>
    2ffa:	8f ef       	ldi	r24, 0xFF	; 255
    2ffc:	9f ef       	ldi	r25, 0xFF	; 255
    2ffe:	02 c0       	rjmp	.+4      	; 0x3004 <csp_buffer_init+0x106>
    3000:	80 e0       	ldi	r24, 0x00	; 0
    3002:	90 e0       	ldi	r25, 0x00	; 0
    3004:	0f 90       	pop	r0
    3006:	0f 90       	pop	r0
    3008:	df 91       	pop	r29
    300a:	cf 91       	pop	r28
    300c:	1f 91       	pop	r17
    300e:	0f 91       	pop	r16
    3010:	ff 90       	pop	r15
    3012:	ef 90       	pop	r14
    3014:	df 90       	pop	r13
    3016:	cf 90       	pop	r12
    3018:	08 95       	ret

0000301a <csp_buffer_get>:
    301a:	cf 93       	push	r28
    301c:	df 93       	push	r29
    301e:	1f 92       	push	r1
    3020:	1f 92       	push	r1
    3022:	cd b7       	in	r28, 0x3d	; 61
    3024:	de b7       	in	r29, 0x3e	; 62
    3026:	1a 82       	std	Y+2, r1	; 0x02
    3028:	19 82       	std	Y+1, r1	; 0x01
    302a:	ac 01       	movw	r20, r24
    302c:	42 5f       	subi	r20, 0xF2	; 242
    302e:	5f 4f       	sbci	r21, 0xFF	; 255
    3030:	20 91 f1 03 	lds	r18, 0x03F1	; 0x8003f1 <size>
    3034:	30 91 f2 03 	lds	r19, 0x03F2	; 0x8003f2 <size+0x1>
    3038:	24 17       	cp	r18, r20
    303a:	35 07       	cpc	r19, r21
    303c:	80 f4       	brcc	.+32     	; 0x305e <csp_buffer_get+0x44>
    303e:	9f 93       	push	r25
    3040:	8f 93       	push	r24
    3042:	8e ee       	ldi	r24, 0xEE	; 238
    3044:	92 e0       	ldi	r25, 0x02	; 2
    3046:	9f 93       	push	r25
    3048:	8f 93       	push	r24
    304a:	1f 92       	push	r1
    304c:	49 d5       	rcall	.+2706   	; 0x3ae0 <do_csp_debug>
    304e:	0f 90       	pop	r0
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	0f 90       	pop	r0
    3058:	80 e0       	ldi	r24, 0x00	; 0
    305a:	90 e0       	ldi	r25, 0x00	; 0
    305c:	58 c0       	rjmp	.+176    	; 0x310e <csp_buffer_get+0xf4>
    305e:	20 e0       	ldi	r18, 0x00	; 0
    3060:	30 e0       	ldi	r19, 0x00	; 0
    3062:	a9 01       	movw	r20, r18
    3064:	be 01       	movw	r22, r28
    3066:	6f 5f       	subi	r22, 0xFF	; 255
    3068:	7f 4f       	sbci	r23, 0xFF	; 255
    306a:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    306e:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    3072:	0e 94 af 28 	call	0x515e	; 0x515e <csp_queue_dequeue>
    3076:	e9 81       	ldd	r30, Y+1	; 0x01
    3078:	fa 81       	ldd	r31, Y+2	; 0x02
    307a:	30 97       	sbiw	r30, 0x00	; 0
    307c:	61 f4       	brne	.+24     	; 0x3096 <csp_buffer_get+0x7c>
    307e:	8f ed       	ldi	r24, 0xDF	; 223
    3080:	92 e0       	ldi	r25, 0x02	; 2
    3082:	9f 93       	push	r25
    3084:	8f 93       	push	r24
    3086:	1f 92       	push	r1
    3088:	2b d5       	rcall	.+2646   	; 0x3ae0 <do_csp_debug>
    308a:	0f 90       	pop	r0
    308c:	0f 90       	pop	r0
    308e:	0f 90       	pop	r0
    3090:	80 e0       	ldi	r24, 0x00	; 0
    3092:	90 e0       	ldi	r25, 0x00	; 0
    3094:	3c c0       	rjmp	.+120    	; 0x310e <csp_buffer_get+0xf4>
    3096:	83 81       	ldd	r24, Z+3	; 0x03
    3098:	8f 93       	push	r24
    309a:	82 81       	ldd	r24, Z+2	; 0x02
    309c:	8f 93       	push	r24
    309e:	ff 93       	push	r31
    30a0:	ef 93       	push	r30
    30a2:	84 ed       	ldi	r24, 0xD4	; 212
    30a4:	92 e0       	ldi	r25, 0x02	; 2
    30a6:	9f 93       	push	r25
    30a8:	8f 93       	push	r24
    30aa:	83 e0       	ldi	r24, 0x03	; 3
    30ac:	8f 93       	push	r24
    30ae:	18 d5       	rcall	.+2608   	; 0x3ae0 <do_csp_debug>
    30b0:	e9 81       	ldd	r30, Y+1	; 0x01
    30b2:	fa 81       	ldd	r31, Y+2	; 0x02
    30b4:	0f b6       	in	r0, 0x3f	; 63
    30b6:	f8 94       	cli
    30b8:	de bf       	out	0x3e, r29	; 62
    30ba:	0f be       	out	0x3f, r0	; 63
    30bc:	cd bf       	out	0x3d, r28	; 61
    30be:	82 81       	ldd	r24, Z+2	; 0x02
    30c0:	93 81       	ldd	r25, Z+3	; 0x03
    30c2:	e8 17       	cp	r30, r24
    30c4:	f9 07       	cpc	r31, r25
    30c6:	d9 f0       	breq	.+54     	; 0x30fe <csp_buffer_get+0xe4>
    30c8:	81 ec       	ldi	r24, 0xC1	; 193
    30ca:	92 e0       	ldi	r25, 0x02	; 2
    30cc:	9f 93       	push	r25
    30ce:	8f 93       	push	r24
    30d0:	1f 92       	push	r1
    30d2:	06 d5       	rcall	.+2572   	; 0x3ae0 <do_csp_debug>
    30d4:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <csp_buffer_pool>
    30d8:	90 91 f6 03 	lds	r25, 0x03F6	; 0x8003f6 <csp_buffer_pool+0x1>
    30dc:	0e 94 b5 31 	call	0x636a	; 0x636a <vPortFree>
    30e0:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <size>
    30e4:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <size+0x1>
    30e8:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <count>
    30ec:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <count+0x1>
    30f0:	06 df       	rcall	.-500    	; 0x2efe <csp_buffer_init>
    30f2:	0f 90       	pop	r0
    30f4:	0f 90       	pop	r0
    30f6:	0f 90       	pop	r0
    30f8:	80 e0       	ldi	r24, 0x00	; 0
    30fa:	90 e0       	ldi	r25, 0x00	; 0
    30fc:	08 c0       	rjmp	.+16     	; 0x310e <csp_buffer_get+0xf4>
    30fe:	80 81       	ld	r24, Z
    3100:	91 81       	ldd	r25, Z+1	; 0x01
    3102:	01 96       	adiw	r24, 0x01	; 1
    3104:	91 83       	std	Z+1, r25	; 0x01
    3106:	80 83       	st	Z, r24
    3108:	89 81       	ldd	r24, Y+1	; 0x01
    310a:	9a 81       	ldd	r25, Y+2	; 0x02
    310c:	04 96       	adiw	r24, 0x04	; 4
    310e:	0f 90       	pop	r0
    3110:	0f 90       	pop	r0
    3112:	df 91       	pop	r29
    3114:	cf 91       	pop	r28
    3116:	08 95       	ret

00003118 <csp_buffer_free_isr>:
    3118:	cf 93       	push	r28
    311a:	df 93       	push	r29
    311c:	00 d0       	rcall	.+0      	; 0x311e <csp_buffer_free_isr+0x6>
    311e:	cd b7       	in	r28, 0x3d	; 61
    3120:	de b7       	in	r29, 0x3e	; 62
    3122:	19 82       	std	Y+1, r1	; 0x01
    3124:	00 97       	sbiw	r24, 0x00	; 0
    3126:	31 f1       	breq	.+76     	; 0x3174 <csp_buffer_free_isr+0x5c>
    3128:	fc 01       	movw	r30, r24
    312a:	34 97       	sbiw	r30, 0x04	; 4
    312c:	fb 83       	std	Y+3, r31	; 0x03
    312e:	ea 83       	std	Y+2, r30	; 0x02
    3130:	22 81       	ldd	r18, Z+2	; 0x02
    3132:	33 81       	ldd	r19, Z+3	; 0x03
    3134:	e2 17       	cp	r30, r18
    3136:	f3 07       	cpc	r31, r19
    3138:	e9 f4       	brne	.+58     	; 0x3174 <csp_buffer_free_isr+0x5c>
    313a:	20 81       	ld	r18, Z
    313c:	31 81       	ldd	r19, Z+1	; 0x01
    313e:	21 15       	cp	r18, r1
    3140:	31 05       	cpc	r19, r1
    3142:	c1 f0       	breq	.+48     	; 0x3174 <csp_buffer_free_isr+0x5c>
    3144:	22 30       	cpi	r18, 0x02	; 2
    3146:	31 05       	cpc	r19, r1
    3148:	28 f0       	brcs	.+10     	; 0x3154 <csp_buffer_free_isr+0x3c>
    314a:	21 50       	subi	r18, 0x01	; 1
    314c:	31 09       	sbc	r19, r1
    314e:	31 83       	std	Z+1, r19	; 0x01
    3150:	20 83       	st	Z, r18
    3152:	10 c0       	rjmp	.+32     	; 0x3174 <csp_buffer_free_isr+0x5c>
    3154:	fc 01       	movw	r30, r24
    3156:	34 97       	sbiw	r30, 0x04	; 4
    3158:	11 82       	std	Z+1, r1	; 0x01
    315a:	10 82       	st	Z, r1
    315c:	ae 01       	movw	r20, r28
    315e:	4f 5f       	subi	r20, 0xFF	; 255
    3160:	5f 4f       	sbci	r21, 0xFF	; 255
    3162:	be 01       	movw	r22, r28
    3164:	6e 5f       	subi	r22, 0xFE	; 254
    3166:	7f 4f       	sbci	r23, 0xFF	; 255
    3168:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    316c:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    3170:	0e 94 a8 28 	call	0x5150	; 0x5150 <csp_queue_enqueue_isr>
    3174:	0f 90       	pop	r0
    3176:	0f 90       	pop	r0
    3178:	0f 90       	pop	r0
    317a:	df 91       	pop	r29
    317c:	cf 91       	pop	r28
    317e:	08 95       	ret

00003180 <csp_buffer_free>:
    3180:	cf 93       	push	r28
    3182:	df 93       	push	r29
    3184:	1f 92       	push	r1
    3186:	1f 92       	push	r1
    3188:	cd b7       	in	r28, 0x3d	; 61
    318a:	de b7       	in	r29, 0x3e	; 62
    318c:	00 97       	sbiw	r24, 0x00	; 0
    318e:	51 f4       	brne	.+20     	; 0x31a4 <csp_buffer_free+0x24>
    3190:	84 ea       	ldi	r24, 0xA4	; 164
    3192:	92 e0       	ldi	r25, 0x02	; 2
    3194:	9f 93       	push	r25
    3196:	8f 93       	push	r24
    3198:	1f 92       	push	r1
    319a:	a2 d4       	rcall	.+2372   	; 0x3ae0 <do_csp_debug>
    319c:	0f 90       	pop	r0
    319e:	0f 90       	pop	r0
    31a0:	0f 90       	pop	r0
    31a2:	63 c0       	rjmp	.+198    	; 0x326a <csp_buffer_free+0xea>
    31a4:	fc 01       	movw	r30, r24
    31a6:	34 97       	sbiw	r30, 0x04	; 4
    31a8:	fa 83       	std	Y+2, r31	; 0x02
    31aa:	e9 83       	std	Y+1, r30	; 0x01
    31ac:	22 81       	ldd	r18, Z+2	; 0x02
    31ae:	33 81       	ldd	r19, Z+3	; 0x03
    31b0:	e2 17       	cp	r30, r18
    31b2:	f3 07       	cpc	r31, r19
    31b4:	71 f0       	breq	.+28     	; 0x31d2 <csp_buffer_free+0x52>
    31b6:	9f 93       	push	r25
    31b8:	8f 93       	push	r24
    31ba:	80 e8       	ldi	r24, 0x80	; 128
    31bc:	92 e0       	ldi	r25, 0x02	; 2
    31be:	9f 93       	push	r25
    31c0:	8f 93       	push	r24
    31c2:	1f 92       	push	r1
    31c4:	8d d4       	rcall	.+2330   	; 0x3ae0 <do_csp_debug>
    31c6:	0f 90       	pop	r0
    31c8:	0f 90       	pop	r0
    31ca:	0f 90       	pop	r0
    31cc:	0f 90       	pop	r0
    31ce:	0f 90       	pop	r0
    31d0:	4c c0       	rjmp	.+152    	; 0x326a <csp_buffer_free+0xea>
    31d2:	dc 01       	movw	r26, r24
    31d4:	14 97       	sbiw	r26, 0x04	; 4
    31d6:	2d 91       	ld	r18, X+
    31d8:	3c 91       	ld	r19, X
    31da:	21 15       	cp	r18, r1
    31dc:	31 05       	cpc	r19, r1
    31de:	71 f4       	brne	.+28     	; 0x31fc <csp_buffer_free+0x7c>
    31e0:	ff 93       	push	r31
    31e2:	ef 93       	push	r30
    31e4:	83 e6       	ldi	r24, 0x63	; 99
    31e6:	92 e0       	ldi	r25, 0x02	; 2
    31e8:	9f 93       	push	r25
    31ea:	8f 93       	push	r24
    31ec:	1f 92       	push	r1
    31ee:	78 d4       	rcall	.+2288   	; 0x3ae0 <do_csp_debug>
    31f0:	0f 90       	pop	r0
    31f2:	0f 90       	pop	r0
    31f4:	0f 90       	pop	r0
    31f6:	0f 90       	pop	r0
    31f8:	0f 90       	pop	r0
    31fa:	37 c0       	rjmp	.+110    	; 0x326a <csp_buffer_free+0xea>
    31fc:	22 30       	cpi	r18, 0x02	; 2
    31fe:	31 05       	cpc	r19, r1
    3200:	b0 f0       	brcs	.+44     	; 0x322e <csp_buffer_free+0xae>
    3202:	21 50       	subi	r18, 0x01	; 1
    3204:	31 09       	sbc	r19, r1
    3206:	dc 01       	movw	r26, r24
    3208:	14 97       	sbiw	r26, 0x04	; 4
    320a:	2d 93       	st	X+, r18
    320c:	3c 93       	st	X, r19
    320e:	3f 93       	push	r19
    3210:	2f 93       	push	r18
    3212:	ff 93       	push	r31
    3214:	ef 93       	push	r30
    3216:	80 e4       	ldi	r24, 0x40	; 64
    3218:	92 e0       	ldi	r25, 0x02	; 2
    321a:	9f 93       	push	r25
    321c:	8f 93       	push	r24
    321e:	1f 92       	push	r1
    3220:	5f d4       	rcall	.+2238   	; 0x3ae0 <do_csp_debug>
    3222:	0f b6       	in	r0, 0x3f	; 63
    3224:	f8 94       	cli
    3226:	de bf       	out	0x3e, r29	; 62
    3228:	0f be       	out	0x3f, r0	; 63
    322a:	cd bf       	out	0x3d, r28	; 61
    322c:	1e c0       	rjmp	.+60     	; 0x326a <csp_buffer_free+0xea>
    322e:	dc 01       	movw	r26, r24
    3230:	14 97       	sbiw	r26, 0x04	; 4
    3232:	1d 92       	st	X+, r1
    3234:	1c 92       	st	X, r1
    3236:	ff 93       	push	r31
    3238:	ef 93       	push	r30
    323a:	87 e3       	ldi	r24, 0x37	; 55
    323c:	92 e0       	ldi	r25, 0x02	; 2
    323e:	9f 93       	push	r25
    3240:	8f 93       	push	r24
    3242:	83 e0       	ldi	r24, 0x03	; 3
    3244:	8f 93       	push	r24
    3246:	4c d4       	rcall	.+2200   	; 0x3ae0 <do_csp_debug>
    3248:	20 e0       	ldi	r18, 0x00	; 0
    324a:	30 e0       	ldi	r19, 0x00	; 0
    324c:	a9 01       	movw	r20, r18
    324e:	be 01       	movw	r22, r28
    3250:	6f 5f       	subi	r22, 0xFF	; 255
    3252:	7f 4f       	sbci	r23, 0xFF	; 255
    3254:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    3258:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    325c:	0e 94 84 28 	call	0x5108	; 0x5108 <csp_queue_enqueue>
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	0f 90       	pop	r0
    3268:	0f 90       	pop	r0
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	df 91       	pop	r29
    3270:	cf 91       	pop	r28
    3272:	08 95       	ret

00003274 <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    3274:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <csp_buffers>
    3278:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <csp_buffers+0x1>
    327c:	0c 94 d0 28 	jmp	0x51a0	; 0x51a0 <csp_queue_size>
}
    3280:	08 95       	ret

00003282 <csp_conn_flush_rx_queue>:

inline int csp_conn_flags(csp_conn_t * conn) {

	return conn->idin.flags;

}
    3282:	0f 93       	push	r16
    3284:	1f 93       	push	r17
    3286:	cf 93       	push	r28
    3288:	df 93       	push	r29
    328a:	1f 92       	push	r1
    328c:	1f 92       	push	r1
    328e:	cd b7       	in	r28, 0x3d	; 61
    3290:	de b7       	in	r29, 0x3e	; 62
    3292:	8c 01       	movw	r16, r24
    3294:	05 c0       	rjmp	.+10     	; 0x32a0 <csp_conn_flush_rx_queue+0x1e>
    3296:	89 81       	ldd	r24, Y+1	; 0x01
    3298:	9a 81       	ldd	r25, Y+2	; 0x02
    329a:	00 97       	sbiw	r24, 0x00	; 0
    329c:	09 f0       	breq	.+2      	; 0x32a0 <csp_conn_flush_rx_queue+0x1e>
    329e:	70 df       	rcall	.-288    	; 0x3180 <csp_buffer_free>
    32a0:	20 e0       	ldi	r18, 0x00	; 0
    32a2:	30 e0       	ldi	r19, 0x00	; 0
    32a4:	a9 01       	movw	r20, r18
    32a6:	be 01       	movw	r22, r28
    32a8:	6f 5f       	subi	r22, 0xFF	; 255
    32aa:	7f 4f       	sbci	r23, 0xFF	; 255
    32ac:	f8 01       	movw	r30, r16
    32ae:	84 85       	ldd	r24, Z+12	; 0x0c
    32b0:	95 85       	ldd	r25, Z+13	; 0x0d
    32b2:	0e 94 af 28 	call	0x515e	; 0x515e <csp_queue_dequeue>
    32b6:	01 97       	sbiw	r24, 0x01	; 1
    32b8:	71 f3       	breq	.-36     	; 0x3296 <csp_conn_flush_rx_queue+0x14>
    32ba:	80 e0       	ldi	r24, 0x00	; 0
    32bc:	90 e0       	ldi	r25, 0x00	; 0
    32be:	0f 90       	pop	r0
    32c0:	0f 90       	pop	r0
    32c2:	df 91       	pop	r29
    32c4:	cf 91       	pop	r28
    32c6:	1f 91       	pop	r17
    32c8:	0f 91       	pop	r16
    32ca:	08 95       	ret

000032cc <csp_conn_enqueue_packet>:
    32cc:	0f 93       	push	r16
    32ce:	1f 93       	push	r17
    32d0:	cf 93       	push	r28
    32d2:	df 93       	push	r29
    32d4:	1f 92       	push	r1
    32d6:	1f 92       	push	r1
    32d8:	cd b7       	in	r28, 0x3d	; 61
    32da:	de b7       	in	r29, 0x3e	; 62
    32dc:	7a 83       	std	Y+2, r23	; 0x02
    32de:	69 83       	std	Y+1, r22	; 0x01
    32e0:	00 97       	sbiw	r24, 0x00	; 0
    32e2:	41 f1       	breq	.+80     	; 0x3334 <csp_conn_enqueue_packet+0x68>
    32e4:	8c 01       	movw	r16, r24
    32e6:	20 e0       	ldi	r18, 0x00	; 0
    32e8:	30 e0       	ldi	r19, 0x00	; 0
    32ea:	a9 01       	movw	r20, r18
    32ec:	be 01       	movw	r22, r28
    32ee:	6f 5f       	subi	r22, 0xFF	; 255
    32f0:	7f 4f       	sbci	r23, 0xFF	; 255
    32f2:	fc 01       	movw	r30, r24
    32f4:	84 85       	ldd	r24, Z+12	; 0x0c
    32f6:	95 85       	ldd	r25, Z+13	; 0x0d
    32f8:	0e 94 84 28 	call	0x5108	; 0x5108 <csp_queue_enqueue>
    32fc:	01 97       	sbiw	r24, 0x01	; 1
    32fe:	e9 f0       	breq	.+58     	; 0x333a <csp_conn_enqueue_packet+0x6e>
    3300:	f8 01       	movw	r30, r16
    3302:	84 85       	ldd	r24, Z+12	; 0x0c
    3304:	95 85       	ldd	r25, Z+13	; 0x0d
    3306:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <csp_queue_size>
    330a:	9f 93       	push	r25
    330c:	8f 93       	push	r24
    330e:	f8 01       	movw	r30, r16
    3310:	85 85       	ldd	r24, Z+13	; 0x0d
    3312:	8f 93       	push	r24
    3314:	84 85       	ldd	r24, Z+12	; 0x0c
    3316:	8f 93       	push	r24
    3318:	87 e2       	ldi	r24, 0x27	; 39
    331a:	95 e0       	ldi	r25, 0x05	; 5
    331c:	9f 93       	push	r25
    331e:	8f 93       	push	r24
    3320:	1f 92       	push	r1
    3322:	de d3       	rcall	.+1980   	; 0x3ae0 <do_csp_debug>
    3324:	0f b6       	in	r0, 0x3f	; 63
    3326:	f8 94       	cli
    3328:	de bf       	out	0x3e, r29	; 62
    332a:	0f be       	out	0x3f, r0	; 63
    332c:	cd bf       	out	0x3d, r28	; 61
    332e:	8f ef       	ldi	r24, 0xFF	; 255
    3330:	9f ef       	ldi	r25, 0xFF	; 255
    3332:	05 c0       	rjmp	.+10     	; 0x333e <csp_conn_enqueue_packet+0x72>
    3334:	8e ef       	ldi	r24, 0xFE	; 254
    3336:	9f ef       	ldi	r25, 0xFF	; 255
    3338:	02 c0       	rjmp	.+4      	; 0x333e <csp_conn_enqueue_packet+0x72>
    333a:	80 e0       	ldi	r24, 0x00	; 0
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	0f 90       	pop	r0
    3340:	0f 90       	pop	r0
    3342:	df 91       	pop	r29
    3344:	cf 91       	pop	r28
    3346:	1f 91       	pop	r17
    3348:	0f 91       	pop	r16
    334a:	08 95       	ret

0000334c <csp_conn_init>:
    334c:	0f 93       	push	r16
    334e:	1f 93       	push	r17
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
    3358:	cb 01       	movw	r24, r22
    335a:	0e 94 76 45 	call	0x8aec	; 0x8aec <srand>
    335e:	0e 94 73 45 	call	0x8ae6	; 0x8ae6 <rand>
    3362:	8f 71       	andi	r24, 0x1F	; 31
    3364:	90 78       	andi	r25, 0x80	; 128
    3366:	99 23       	and	r25, r25
    3368:	24 f4       	brge	.+8      	; 0x3372 <csp_conn_init+0x26>
    336a:	01 97       	sbiw	r24, 0x01	; 1
    336c:	80 6e       	ori	r24, 0xE0	; 224
    336e:	9f 6f       	ori	r25, 0xFF	; 255
    3370:	01 96       	adiw	r24, 0x01	; 1
    3372:	80 5e       	subi	r24, 0xE0	; 224
    3374:	80 93 fc 03 	sts	0x03FC, r24	; 0x8003fc <sport>
    3378:	8a ef       	ldi	r24, 0xFA	; 250
    337a:	93 e0       	ldi	r25, 0x03	; 3
    337c:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <csp_bin_sem_create>
    3380:	01 97       	sbiw	r24, 0x01	; 1
    3382:	29 f4       	brne	.+10     	; 0x338e <csp_conn_init+0x42>
    3384:	c1 e0       	ldi	r28, 0x01	; 1
    3386:	d4 e0       	ldi	r29, 0x04	; 4
    3388:	01 ef       	ldi	r16, 0xF1	; 241
    338a:	14 e0       	ldi	r17, 0x04	; 4
    338c:	1c c0       	rjmp	.+56     	; 0x33c6 <csp_conn_init+0x7a>
    338e:	84 e0       	ldi	r24, 0x04	; 4
    3390:	95 e0       	ldi	r25, 0x05	; 5
    3392:	9f 93       	push	r25
    3394:	8f 93       	push	r24
    3396:	1f 92       	push	r1
    3398:	a3 d3       	rcall	.+1862   	; 0x3ae0 <do_csp_debug>
    339a:	0f 90       	pop	r0
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	8f ef       	ldi	r24, 0xFF	; 255
    33a2:	9f ef       	ldi	r25, 0xFF	; 255
    33a4:	35 c0       	rjmp	.+106    	; 0x3410 <csp_conn_init+0xc4>
    33a6:	83 ee       	ldi	r24, 0xE3	; 227
    33a8:	94 e0       	ldi	r25, 0x04	; 4
    33aa:	9f 93       	push	r25
    33ac:	8f 93       	push	r24
    33ae:	1f 92       	push	r1
    33b0:	97 d3       	rcall	.+1838   	; 0x3ae0 <do_csp_debug>
    33b2:	0f 90       	pop	r0
    33b4:	0f 90       	pop	r0
    33b6:	0f 90       	pop	r0
    33b8:	8f ef       	ldi	r24, 0xFF	; 255
    33ba:	9f ef       	ldi	r25, 0xFF	; 255
    33bc:	29 c0       	rjmp	.+82     	; 0x3410 <csp_conn_init+0xc4>
    33be:	68 96       	adiw	r28, 0x18	; 24
    33c0:	0c 17       	cp	r16, r28
    33c2:	1d 07       	cpc	r17, r29
    33c4:	89 f0       	breq	.+34     	; 0x33e8 <csp_conn_init+0x9c>
    33c6:	62 e0       	ldi	r22, 0x02	; 2
    33c8:	70 e0       	ldi	r23, 0x00	; 0
    33ca:	84 e6       	ldi	r24, 0x64	; 100
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	0e 94 80 28 	call	0x5100	; 0x5100 <csp_queue_create>
    33d2:	9b 87       	std	Y+11, r25	; 0x0b
    33d4:	8a 87       	std	Y+10, r24	; 0x0a
    33d6:	fe 01       	movw	r30, r28
    33d8:	31 97       	sbiw	r30, 0x01	; 1
    33da:	10 82       	st	Z, r1
    33dc:	ce 01       	movw	r24, r28
    33de:	0e 94 4c 2c 	call	0x5898	; 0x5898 <csp_mutex_create>
    33e2:	01 97       	sbiw	r24, 0x01	; 1
    33e4:	61 f3       	breq	.-40     	; 0x33be <csp_conn_init+0x72>
    33e6:	df cf       	rjmp	.-66     	; 0x33a6 <csp_conn_init+0x5a>
    33e8:	8d ef       	ldi	r24, 0xFD	; 253
    33ea:	93 e0       	ldi	r25, 0x03	; 3
    33ec:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <csp_bin_sem_create>
    33f0:	01 97       	sbiw	r24, 0x01	; 1
    33f2:	61 f0       	breq	.+24     	; 0x340c <csp_conn_init+0xc0>
    33f4:	81 ec       	ldi	r24, 0xC1	; 193
    33f6:	94 e0       	ldi	r25, 0x04	; 4
    33f8:	9f 93       	push	r25
    33fa:	8f 93       	push	r24
    33fc:	1f 92       	push	r1
    33fe:	70 d3       	rcall	.+1760   	; 0x3ae0 <do_csp_debug>
    3400:	0f 90       	pop	r0
    3402:	0f 90       	pop	r0
    3404:	0f 90       	pop	r0
    3406:	8f ef       	ldi	r24, 0xFF	; 255
    3408:	9f ef       	ldi	r25, 0xFF	; 255
    340a:	02 c0       	rjmp	.+4      	; 0x3410 <csp_conn_init+0xc4>
    340c:	80 e0       	ldi	r24, 0x00	; 0
    340e:	90 e0       	ldi	r25, 0x00	; 0
    3410:	df 91       	pop	r29
    3412:	cf 91       	pop	r28
    3414:	1f 91       	pop	r17
    3416:	0f 91       	pop	r16
    3418:	08 95       	ret

0000341a <csp_conn_find>:
    341a:	8f 92       	push	r8
    341c:	9f 92       	push	r9
    341e:	af 92       	push	r10
    3420:	bf 92       	push	r11
    3422:	cf 92       	push	r12
    3424:	df 92       	push	r13
    3426:	ef 92       	push	r14
    3428:	ff 92       	push	r15
    342a:	6b 01       	movw	r12, r22
    342c:	7c 01       	movw	r14, r24
    342e:	49 01       	movw	r8, r18
    3430:	5a 01       	movw	r10, r20
    3432:	ef ef       	ldi	r30, 0xFF	; 255
    3434:	f3 e0       	ldi	r31, 0x03	; 3
    3436:	80 e0       	ldi	r24, 0x00	; 0
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	31 81       	ldd	r19, Z+1	; 0x01
    343c:	33 23       	and	r19, r19
    343e:	09 f1       	breq	.+66     	; 0x3482 <csp_conn_find+0x68>
    3440:	20 81       	ld	r18, Z
    3442:	21 11       	cpse	r18, r1
    3444:	1e c0       	rjmp	.+60     	; 0x3482 <csp_conn_find+0x68>
    3446:	44 81       	ldd	r20, Z+4	; 0x04
    3448:	55 81       	ldd	r21, Z+5	; 0x05
    344a:	66 81       	ldd	r22, Z+6	; 0x06
    344c:	77 81       	ldd	r23, Z+7	; 0x07
    344e:	4c 25       	eor	r20, r12
    3450:	5d 25       	eor	r21, r13
    3452:	6e 25       	eor	r22, r14
    3454:	7f 25       	eor	r23, r15
    3456:	48 21       	and	r20, r8
    3458:	59 21       	and	r21, r9
    345a:	6a 21       	and	r22, r10
    345c:	7b 21       	and	r23, r11
    345e:	45 2b       	or	r20, r21
    3460:	46 2b       	or	r20, r22
    3462:	47 2b       	or	r20, r23
    3464:	71 f4       	brne	.+28     	; 0x3482 <csp_conn_find+0x68>
    3466:	9c 01       	movw	r18, r24
    3468:	22 0f       	add	r18, r18
    346a:	33 1f       	adc	r19, r19
    346c:	82 0f       	add	r24, r18
    346e:	93 1f       	adc	r25, r19
    3470:	88 0f       	add	r24, r24
    3472:	99 1f       	adc	r25, r25
    3474:	88 0f       	add	r24, r24
    3476:	99 1f       	adc	r25, r25
    3478:	88 0f       	add	r24, r24
    347a:	99 1f       	adc	r25, r25
    347c:	81 50       	subi	r24, 0x01	; 1
    347e:	9c 4f       	sbci	r25, 0xFC	; 252
    3480:	07 c0       	rjmp	.+14     	; 0x3490 <csp_conn_find+0x76>
    3482:	01 96       	adiw	r24, 0x01	; 1
    3484:	78 96       	adiw	r30, 0x18	; 24
    3486:	8a 30       	cpi	r24, 0x0A	; 10
    3488:	91 05       	cpc	r25, r1
    348a:	b9 f6       	brne	.-82     	; 0x343a <csp_conn_find+0x20>
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	ff 90       	pop	r15
    3492:	ef 90       	pop	r14
    3494:	df 90       	pop	r13
    3496:	cf 90       	pop	r12
    3498:	bf 90       	pop	r11
    349a:	af 90       	pop	r10
    349c:	9f 90       	pop	r9
    349e:	8f 90       	pop	r8
    34a0:	08 95       	ret

000034a2 <csp_conn_allocate>:
    34a2:	1f 93       	push	r17
    34a4:	cf 93       	push	r28
    34a6:	df 93       	push	r29
    34a8:	18 2f       	mov	r17, r24
    34aa:	44 e6       	ldi	r20, 0x64	; 100
    34ac:	50 e0       	ldi	r21, 0x00	; 0
    34ae:	60 e0       	ldi	r22, 0x00	; 0
    34b0:	70 e0       	ldi	r23, 0x00	; 0
    34b2:	8d ef       	ldi	r24, 0xFD	; 253
    34b4:	93 e0       	ldi	r25, 0x03	; 3
    34b6:	0e 94 76 2c 	call	0x58ec	; 0x58ec <csp_bin_sem_wait>
    34ba:	01 97       	sbiw	r24, 0x01	; 1
    34bc:	61 f0       	breq	.+24     	; 0x34d6 <csp_conn_allocate+0x34>
    34be:	87 ea       	ldi	r24, 0xA7	; 167
    34c0:	94 e0       	ldi	r25, 0x04	; 4
    34c2:	9f 93       	push	r25
    34c4:	8f 93       	push	r24
    34c6:	1f 92       	push	r1
    34c8:	0b d3       	rcall	.+1558   	; 0x3ae0 <do_csp_debug>
    34ca:	0f 90       	pop	r0
    34cc:	0f 90       	pop	r0
    34ce:	0f 90       	pop	r0
    34d0:	80 e0       	ldi	r24, 0x00	; 0
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	5c c0       	rjmp	.+184    	; 0x358e <csp_conn_allocate+0xec>
    34d6:	80 91 f9 03 	lds	r24, 0x03F9	; 0x8003f9 <csp_conn_last_given.3263>
    34da:	90 e0       	ldi	r25, 0x00	; 0
    34dc:	01 96       	adiw	r24, 0x01	; 1
    34de:	6a e0       	ldi	r22, 0x0A	; 10
    34e0:	70 e0       	ldi	r23, 0x00	; 0
    34e2:	0e 94 b0 44 	call	0x8960	; 0x8960 <__divmodhi4>
    34e6:	fc 01       	movw	r30, r24
    34e8:	ee 0f       	add	r30, r30
    34ea:	ff 1f       	adc	r31, r31
    34ec:	e8 0f       	add	r30, r24
    34ee:	f9 1f       	adc	r31, r25
    34f0:	ee 0f       	add	r30, r30
    34f2:	ff 1f       	adc	r31, r31
    34f4:	ee 0f       	add	r30, r30
    34f6:	ff 1f       	adc	r31, r31
    34f8:	ee 0f       	add	r30, r30
    34fa:	ff 1f       	adc	r31, r31
    34fc:	e1 50       	subi	r30, 0x01	; 1
    34fe:	fc 4f       	sbci	r31, 0xFC	; 252
    3500:	41 81       	ldd	r20, Z+1	; 0x01
    3502:	41 11       	cpse	r20, r1
    3504:	3a c0       	rjmp	.+116    	; 0x357a <csp_conn_allocate+0xd8>
    3506:	ef 01       	movw	r28, r30
    3508:	17 c0       	rjmp	.+46     	; 0x3538 <csp_conn_allocate+0x96>
    350a:	ec 01       	movw	r28, r24
    350c:	cc 0f       	add	r28, r28
    350e:	dd 1f       	adc	r29, r29
    3510:	c8 0f       	add	r28, r24
    3512:	d9 1f       	adc	r29, r25
    3514:	cc 0f       	add	r28, r28
    3516:	dd 1f       	adc	r29, r29
    3518:	cc 0f       	add	r28, r28
    351a:	dd 1f       	adc	r29, r29
    351c:	cc 0f       	add	r28, r28
    351e:	dd 1f       	adc	r29, r29
    3520:	c1 50       	subi	r28, 0x01	; 1
    3522:	dc 4f       	sbci	r29, 0xFC	; 252
    3524:	49 81       	ldd	r20, Y+1	; 0x01
    3526:	44 23       	and	r20, r20
    3528:	39 f0       	breq	.+14     	; 0x3538 <csp_conn_allocate+0x96>
    352a:	01 96       	adiw	r24, 0x01	; 1
    352c:	bf 01       	movw	r22, r30
    352e:	0e 94 b0 44 	call	0x8960	; 0x8960 <__divmodhi4>
    3532:	21 50       	subi	r18, 0x01	; 1
    3534:	31 09       	sbc	r19, r1
    3536:	49 f7       	brne	.-46     	; 0x350a <csp_conn_allocate+0x68>
    3538:	29 81       	ldd	r18, Y+1	; 0x01
    353a:	21 30       	cpi	r18, 0x01	; 1
    353c:	81 f4       	brne	.+32     	; 0x355e <csp_conn_allocate+0xbc>
    353e:	8e e8       	ldi	r24, 0x8E	; 142
    3540:	94 e0       	ldi	r25, 0x04	; 4
    3542:	9f 93       	push	r25
    3544:	8f 93       	push	r24
    3546:	1f 92       	push	r1
    3548:	cb d2       	rcall	.+1430   	; 0x3ae0 <do_csp_debug>
    354a:	8d ef       	ldi	r24, 0xFD	; 253
    354c:	93 e0       	ldi	r25, 0x03	; 3
    354e:	0e 94 b1 2c 	call	0x5962	; 0x5962 <csp_bin_sem_post>
    3552:	0f 90       	pop	r0
    3554:	0f 90       	pop	r0
    3556:	0f 90       	pop	r0
    3558:	80 e0       	ldi	r24, 0x00	; 0
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	18 c0       	rjmp	.+48     	; 0x358e <csp_conn_allocate+0xec>
    355e:	91 e0       	ldi	r25, 0x01	; 1
    3560:	99 83       	std	Y+1, r25	; 0x01
    3562:	1f 86       	std	Y+15, r1	; 0x0f
    3564:	1e 86       	std	Y+14, r1	; 0x0e
    3566:	18 83       	st	Y, r17
    3568:	80 93 f9 03 	sts	0x03F9, r24	; 0x8003f9 <csp_conn_last_given.3263>
    356c:	8d ef       	ldi	r24, 0xFD	; 253
    356e:	93 e0       	ldi	r25, 0x03	; 3
    3570:	0e 94 b1 2c 	call	0x5962	; 0x5962 <csp_bin_sem_post>
    3574:	8c 2f       	mov	r24, r28
    3576:	9d 2f       	mov	r25, r29
    3578:	0a c0       	rjmp	.+20     	; 0x358e <csp_conn_allocate+0xec>
    357a:	01 96       	adiw	r24, 0x01	; 1
    357c:	6a e0       	ldi	r22, 0x0A	; 10
    357e:	70 e0       	ldi	r23, 0x00	; 0
    3580:	0e 94 b0 44 	call	0x8960	; 0x8960 <__divmodhi4>
    3584:	29 e0       	ldi	r18, 0x09	; 9
    3586:	30 e0       	ldi	r19, 0x00	; 0
    3588:	ea e0       	ldi	r30, 0x0A	; 10
    358a:	f0 e0       	ldi	r31, 0x00	; 0
    358c:	be cf       	rjmp	.-132    	; 0x350a <csp_conn_allocate+0x68>
    358e:	df 91       	pop	r29
    3590:	cf 91       	pop	r28
    3592:	1f 91       	pop	r17
    3594:	08 95       	ret

00003596 <csp_conn_new>:
    3596:	8f 92       	push	r8
    3598:	9f 92       	push	r9
    359a:	af 92       	push	r10
    359c:	bf 92       	push	r11
    359e:	cf 92       	push	r12
    35a0:	df 92       	push	r13
    35a2:	ef 92       	push	r14
    35a4:	ff 92       	push	r15
    35a6:	cf 93       	push	r28
    35a8:	df 93       	push	r29
    35aa:	4b 01       	movw	r8, r22
    35ac:	5c 01       	movw	r10, r24
    35ae:	69 01       	movw	r12, r18
    35b0:	7a 01       	movw	r14, r20
    35b2:	80 e0       	ldi	r24, 0x00	; 0
    35b4:	76 df       	rcall	.-276    	; 0x34a2 <csp_conn_allocate>
    35b6:	ec 01       	movw	r28, r24
    35b8:	89 2b       	or	r24, r25
    35ba:	81 f0       	breq	.+32     	; 0x35dc <csp_conn_new+0x46>
    35bc:	8c 82       	std	Y+4, r8	; 0x04
    35be:	9d 82       	std	Y+5, r9	; 0x05
    35c0:	ae 82       	std	Y+6, r10	; 0x06
    35c2:	bf 82       	std	Y+7, r11	; 0x07
    35c4:	c8 86       	std	Y+8, r12	; 0x08
    35c6:	d9 86       	std	Y+9, r13	; 0x09
    35c8:	ea 86       	std	Y+10, r14	; 0x0a
    35ca:	fb 86       	std	Y+11, r15	; 0x0b
    35cc:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
    35d0:	68 8b       	std	Y+16, r22	; 0x10
    35d2:	79 8b       	std	Y+17, r23	; 0x11
    35d4:	8a 8b       	std	Y+18, r24	; 0x12
    35d6:	9b 8b       	std	Y+19, r25	; 0x13
    35d8:	ce 01       	movw	r24, r28
    35da:	53 de       	rcall	.-858    	; 0x3282 <csp_conn_flush_rx_queue>
    35dc:	ce 01       	movw	r24, r28
    35de:	df 91       	pop	r29
    35e0:	cf 91       	pop	r28
    35e2:	ff 90       	pop	r15
    35e4:	ef 90       	pop	r14
    35e6:	df 90       	pop	r13
    35e8:	cf 90       	pop	r12
    35ea:	bf 90       	pop	r11
    35ec:	af 90       	pop	r10
    35ee:	9f 90       	pop	r9
    35f0:	8f 90       	pop	r8
    35f2:	08 95       	ret

000035f4 <csp_close>:
    35f4:	cf 93       	push	r28
    35f6:	df 93       	push	r29
    35f8:	ec 01       	movw	r28, r24
    35fa:	89 2b       	or	r24, r25
    35fc:	61 f4       	brne	.+24     	; 0x3616 <csp_close+0x22>
    35fe:	8e e6       	ldi	r24, 0x6E	; 110
    3600:	94 e0       	ldi	r25, 0x04	; 4
    3602:	9f 93       	push	r25
    3604:	8f 93       	push	r24
    3606:	1f 92       	push	r1
    3608:	6b d2       	rcall	.+1238   	; 0x3ae0 <do_csp_debug>
    360a:	0f 90       	pop	r0
    360c:	0f 90       	pop	r0
    360e:	0f 90       	pop	r0
    3610:	8e ef       	ldi	r24, 0xFE	; 254
    3612:	9f ef       	ldi	r25, 0xFF	; 255
    3614:	2f c0       	rjmp	.+94     	; 0x3674 <csp_close+0x80>
    3616:	89 81       	ldd	r24, Y+1	; 0x01
    3618:	81 11       	cpse	r24, r1
    361a:	0d c0       	rjmp	.+26     	; 0x3636 <csp_close+0x42>
    361c:	8a e5       	ldi	r24, 0x5A	; 90
    361e:	94 e0       	ldi	r25, 0x04	; 4
    3620:	9f 93       	push	r25
    3622:	8f 93       	push	r24
    3624:	85 e0       	ldi	r24, 0x05	; 5
    3626:	8f 93       	push	r24
    3628:	5b d2       	rcall	.+1206   	; 0x3ae0 <do_csp_debug>
    362a:	0f 90       	pop	r0
    362c:	0f 90       	pop	r0
    362e:	0f 90       	pop	r0
    3630:	80 e0       	ldi	r24, 0x00	; 0
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	1f c0       	rjmp	.+62     	; 0x3674 <csp_close+0x80>
    3636:	44 e6       	ldi	r20, 0x64	; 100
    3638:	50 e0       	ldi	r21, 0x00	; 0
    363a:	60 e0       	ldi	r22, 0x00	; 0
    363c:	70 e0       	ldi	r23, 0x00	; 0
    363e:	8d ef       	ldi	r24, 0xFD	; 253
    3640:	93 e0       	ldi	r25, 0x03	; 3
    3642:	0e 94 76 2c 	call	0x58ec	; 0x58ec <csp_bin_sem_wait>
    3646:	01 97       	sbiw	r24, 0x01	; 1
    3648:	61 f0       	breq	.+24     	; 0x3662 <csp_close+0x6e>
    364a:	80 e4       	ldi	r24, 0x40	; 64
    364c:	94 e0       	ldi	r25, 0x04	; 4
    364e:	9f 93       	push	r25
    3650:	8f 93       	push	r24
    3652:	1f 92       	push	r1
    3654:	45 d2       	rcall	.+1162   	; 0x3ae0 <do_csp_debug>
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	0f 90       	pop	r0
    365c:	8d ef       	ldi	r24, 0xFD	; 253
    365e:	9f ef       	ldi	r25, 0xFF	; 255
    3660:	09 c0       	rjmp	.+18     	; 0x3674 <csp_close+0x80>
    3662:	19 82       	std	Y+1, r1	; 0x01
    3664:	ce 01       	movw	r24, r28
    3666:	0d de       	rcall	.-998    	; 0x3282 <csp_conn_flush_rx_queue>
    3668:	8d ef       	ldi	r24, 0xFD	; 253
    366a:	93 e0       	ldi	r25, 0x03	; 3
    366c:	0e 94 b1 2c 	call	0x5962	; 0x5962 <csp_bin_sem_post>
    3670:	80 e0       	ldi	r24, 0x00	; 0
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	08 95       	ret

0000367a <csp_connect>:
    367a:	6f 92       	push	r6
    367c:	7f 92       	push	r7
    367e:	8f 92       	push	r8
    3680:	9f 92       	push	r9
    3682:	af 92       	push	r10
    3684:	bf 92       	push	r11
    3686:	cf 92       	push	r12
    3688:	df 92       	push	r13
    368a:	ef 92       	push	r14
    368c:	ff 92       	push	r15
    368e:	0f 93       	push	r16
    3690:	1f 93       	push	r17
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	86 2e       	mov	r8, r22
    3698:	14 2f       	mov	r17, r20
    369a:	98 2e       	mov	r9, r24
    369c:	99 0c       	add	r9, r9
    369e:	99 0c       	add	r9, r9
    36a0:	99 0c       	add	r9, r9
    36a2:	99 0c       	add	r9, r9
    36a4:	99 0c       	add	r9, r9
    36a6:	99 0c       	add	r9, r9
    36a8:	09 2d       	mov	r16, r9
    36aa:	0e 94 a4 24 	call	0x4948	; 0x4948 <csp_get_address>
    36ae:	c8 2f       	mov	r28, r24
    36b0:	c2 95       	swap	r28
    36b2:	c0 7f       	andi	r28, 0xF0	; 240
    36b4:	82 95       	swap	r24
    36b6:	81 70       	andi	r24, 0x01	; 1
    36b8:	08 2b       	or	r16, r24
    36ba:	88 2d       	mov	r24, r8
    36bc:	8f 71       	andi	r24, 0x1F	; 31
    36be:	98 2f       	mov	r25, r24
    36c0:	99 0f       	add	r25, r25
    36c2:	09 2b       	or	r16, r25
    36c4:	91 2f       	mov	r25, r17
    36c6:	9f 73       	andi	r25, 0x3F	; 63
    36c8:	a9 2e       	mov	r10, r25
    36ca:	d9 2f       	mov	r29, r25
    36cc:	b1 2c       	mov	r11, r1
    36ce:	88 0c       	add	r8, r8
    36d0:	88 0c       	add	r8, r8
    36d2:	88 0c       	add	r8, r8
    36d4:	88 0c       	add	r8, r8
    36d6:	82 95       	swap	r24
    36d8:	8f 70       	andi	r24, 0x0F	; 15
    36da:	98 2a       	or	r9, r24
    36dc:	0e 94 a4 24 	call	0x4948	; 0x4948 <csp_get_address>
    36e0:	8f 71       	andi	r24, 0x1F	; 31
    36e2:	88 0f       	add	r24, r24
    36e4:	98 2a       	or	r9, r24
    36e6:	12 95       	swap	r17
    36e8:	11 0f       	add	r17, r17
    36ea:	11 0f       	add	r17, r17
    36ec:	10 7c       	andi	r17, 0xC0	; 192
    36ee:	a6 94       	lsr	r10
    36f0:	a6 94       	lsr	r10
    36f2:	8a 28       	or	r8, r10
    36f4:	c0 fe       	sbrs	r12, 0
    36f6:	0c c0       	rjmp	.+24     	; 0x3710 <csp_connect+0x96>
    36f8:	85 ef       	ldi	r24, 0xF5	; 245
    36fa:	93 e0       	ldi	r25, 0x03	; 3
    36fc:	9f 93       	push	r25
    36fe:	8f 93       	push	r24
    3700:	1f 92       	push	r1
    3702:	ee d1       	rcall	.+988    	; 0x3ae0 <do_csp_debug>
    3704:	0f 90       	pop	r0
    3706:	0f 90       	pop	r0
    3708:	0f 90       	pop	r0
    370a:	80 e0       	ldi	r24, 0x00	; 0
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	7c c0       	rjmp	.+248    	; 0x3808 <csp_connect+0x18e>
    3710:	c2 fe       	sbrs	r12, 2
    3712:	0c c0       	rjmp	.+24     	; 0x372c <csp_connect+0xb2>
    3714:	8a e9       	ldi	r24, 0x9A	; 154
    3716:	93 e0       	ldi	r25, 0x03	; 3
    3718:	9f 93       	push	r25
    371a:	8f 93       	push	r24
    371c:	1f 92       	push	r1
    371e:	e0 d1       	rcall	.+960    	; 0x3ae0 <do_csp_debug>
    3720:	0f 90       	pop	r0
    3722:	0f 90       	pop	r0
    3724:	0f 90       	pop	r0
    3726:	80 e0       	ldi	r24, 0x00	; 0
    3728:	90 e0       	ldi	r25, 0x00	; 0
    372a:	6e c0       	rjmp	.+220    	; 0x3808 <csp_connect+0x18e>
    372c:	c4 fe       	sbrs	r12, 4
    372e:	0c c0       	rjmp	.+24     	; 0x3748 <csp_connect+0xce>
    3730:	83 e4       	ldi	r24, 0x43	; 67
    3732:	93 e0       	ldi	r25, 0x03	; 3
    3734:	9f 93       	push	r25
    3736:	8f 93       	push	r24
    3738:	1f 92       	push	r1
    373a:	d2 d1       	rcall	.+932    	; 0x3ae0 <do_csp_debug>
    373c:	0f 90       	pop	r0
    373e:	0f 90       	pop	r0
    3740:	0f 90       	pop	r0
    3742:	80 e0       	ldi	r24, 0x00	; 0
    3744:	90 e0       	ldi	r25, 0x00	; 0
    3746:	60 c0       	rjmp	.+192    	; 0x3808 <csp_connect+0x18e>
    3748:	c6 fe       	sbrs	r12, 6
    374a:	05 c0       	rjmp	.+10     	; 0x3756 <csp_connect+0xdc>
    374c:	bb 24       	eor	r11, r11
    374e:	b3 94       	inc	r11
    3750:	66 24       	eor	r6, r6
    3752:	63 94       	inc	r6
    3754:	01 c0       	rjmp	.+2      	; 0x3758 <csp_connect+0xde>
    3756:	61 2c       	mov	r6, r1
    3758:	48 ee       	ldi	r20, 0xE8	; 232
    375a:	53 e0       	ldi	r21, 0x03	; 3
    375c:	60 e0       	ldi	r22, 0x00	; 0
    375e:	70 e0       	ldi	r23, 0x00	; 0
    3760:	8a ef       	ldi	r24, 0xFA	; 250
    3762:	93 e0       	ldi	r25, 0x03	; 3
    3764:	0e 94 76 2c 	call	0x58ec	; 0x58ec <csp_bin_sem_wait>
    3768:	01 97       	sbiw	r24, 0x01	; 1
    376a:	09 f0       	breq	.+2      	; 0x376e <csp_connect+0xf4>
    376c:	46 c0       	rjmp	.+140    	; 0x37fa <csp_connect+0x180>
    376e:	a0 90 fc 03 	lds	r10, 0x03FC	; 0x8003fc <sport>
    3772:	68 94       	set
    3774:	77 24       	eor	r7, r7
    3776:	75 f8       	bld	r7, 5
    3778:	1f c0       	rjmp	.+62     	; 0x37b8 <csp_connect+0x13e>
    377a:	90 34       	cpi	r25, 0x40	; 64
    377c:	10 f0       	brcs	.+4      	; 0x3782 <csp_connect+0x108>
    377e:	70 92 fc 03 	sts	0x03FC, r7	; 0x8003fc <sport>
    3782:	80 91 fc 03 	lds	r24, 0x03FC	; 0x8003fc <sport>
    3786:	98 2f       	mov	r25, r24
    3788:	9f 73       	andi	r25, 0x3F	; 63
    378a:	10 7c       	andi	r17, 0xC0	; 192
    378c:	19 2b       	or	r17, r25
    378e:	82 95       	swap	r24
    3790:	88 0f       	add	r24, r24
    3792:	88 0f       	add	r24, r24
    3794:	80 7c       	andi	r24, 0xC0	; 192
    3796:	df 73       	andi	r29, 0x3F	; 63
    3798:	d8 2b       	or	r29, r24
    379a:	96 95       	lsr	r25
    379c:	96 95       	lsr	r25
    379e:	c0 7f       	andi	r28, 0xF0	; 240
    37a0:	c9 2b       	or	r28, r25
    37a2:	20 e0       	ldi	r18, 0x00	; 0
    37a4:	30 ec       	ldi	r19, 0xC0	; 192
    37a6:	4f e0       	ldi	r20, 0x0F	; 15
    37a8:	50 e0       	ldi	r21, 0x00	; 0
    37aa:	6b 2d       	mov	r22, r11
    37ac:	7d 2f       	mov	r23, r29
    37ae:	8c 2f       	mov	r24, r28
    37b0:	90 2f       	mov	r25, r16
    37b2:	33 de       	rcall	.-922    	; 0x341a <csp_conn_find>
    37b4:	89 2b       	or	r24, r25
    37b6:	39 f0       	breq	.+14     	; 0x37c6 <csp_connect+0x14c>
    37b8:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <sport>
    37bc:	9f 5f       	subi	r25, 0xFF	; 255
    37be:	90 93 fc 03 	sts	0x03FC, r25	; 0x8003fc <sport>
    37c2:	a9 12       	cpse	r10, r25
    37c4:	da cf       	rjmp	.-76     	; 0x377a <csp_connect+0x100>
    37c6:	8a ef       	ldi	r24, 0xFA	; 250
    37c8:	93 e0       	ldi	r25, 0x03	; 3
    37ca:	0e 94 b1 2c 	call	0x5962	; 0x5962 <csp_bin_sem_post>
    37ce:	80 91 fc 03 	lds	r24, 0x03FC	; 0x8003fc <sport>
    37d2:	a8 16       	cp	r10, r24
    37d4:	a9 f0       	breq	.+42     	; 0x3800 <csp_connect+0x186>
    37d6:	26 2d       	mov	r18, r6
    37d8:	31 2f       	mov	r19, r17
    37da:	48 2d       	mov	r20, r8
    37dc:	59 2d       	mov	r21, r9
    37de:	6b 2d       	mov	r22, r11
    37e0:	7d 2f       	mov	r23, r29
    37e2:	8c 2f       	mov	r24, r28
    37e4:	90 2f       	mov	r25, r16
    37e6:	d7 de       	rcall	.-594    	; 0x3596 <csp_conn_new>
    37e8:	fc 01       	movw	r30, r24
    37ea:	00 97       	sbiw	r24, 0x00	; 0
    37ec:	61 f0       	breq	.+24     	; 0x3806 <csp_connect+0x18c>
    37ee:	c4 8a       	std	Z+20, r12	; 0x14
    37f0:	d5 8a       	std	Z+21, r13	; 0x15
    37f2:	e6 8a       	std	Z+22, r14	; 0x16
    37f4:	f7 8a       	std	Z+23, r15	; 0x17
    37f6:	9f 2f       	mov	r25, r31
    37f8:	07 c0       	rjmp	.+14     	; 0x3808 <csp_connect+0x18e>
    37fa:	80 e0       	ldi	r24, 0x00	; 0
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	04 c0       	rjmp	.+8      	; 0x3808 <csp_connect+0x18e>
    3800:	80 e0       	ldi	r24, 0x00	; 0
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	01 c0       	rjmp	.+2      	; 0x3808 <csp_connect+0x18e>
    3806:	9f 2f       	mov	r25, r31
    3808:	df 91       	pop	r29
    380a:	cf 91       	pop	r28
    380c:	1f 91       	pop	r17
    380e:	0f 91       	pop	r16
    3810:	ff 90       	pop	r15
    3812:	ef 90       	pop	r14
    3814:	df 90       	pop	r13
    3816:	cf 90       	pop	r12
    3818:	bf 90       	pop	r11
    381a:	af 90       	pop	r10
    381c:	9f 90       	pop	r9
    381e:	8f 90       	pop	r8
    3820:	7f 90       	pop	r7
    3822:	6f 90       	pop	r6
    3824:	08 95       	ret

00003826 <csp_conn_dport>:
    3826:	fc 01       	movw	r30, r24
    3828:	95 81       	ldd	r25, Z+5	; 0x05
    382a:	92 95       	swap	r25
    382c:	96 95       	lsr	r25
    382e:	96 95       	lsr	r25
    3830:	93 70       	andi	r25, 0x03	; 3
    3832:	86 81       	ldd	r24, Z+6	; 0x06
    3834:	8f 70       	andi	r24, 0x0F	; 15
    3836:	88 0f       	add	r24, r24
    3838:	88 0f       	add	r24, r24
    383a:	89 2b       	or	r24, r25
    383c:	90 e0       	ldi	r25, 0x00	; 0
    383e:	08 95       	ret

00003840 <csp_conn_print_table>:

#ifdef CSP_DEBUG
void csp_conn_print_table(void) {
    3840:	ef 92       	push	r14
    3842:	ff 92       	push	r15
    3844:	0f 93       	push	r16
    3846:	1f 93       	push	r17
    3848:	cf 93       	push	r28
    384a:	df 93       	push	r29
    384c:	0f 2e       	mov	r0, r31
    384e:	ff ef       	ldi	r31, 0xFF	; 255
    3850:	ef 2e       	mov	r14, r31
    3852:	f3 e0       	ldi	r31, 0x03	; 3
    3854:	ff 2e       	mov	r15, r31
    3856:	f0 2d       	mov	r31, r0

	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    3858:	c0 e0       	ldi	r28, 0x00	; 0
    385a:	d0 e0       	ldi	r29, 0x00	; 0
		conn = &arr_conn[i];
		printf("[%02u %p] S:%u, %u -> %u, %u -> %u, sock: %p\n",
    385c:	05 e1       	ldi	r16, 0x15	; 21
    385e:	13 e0       	ldi	r17, 0x03	; 3
    3860:	f7 01       	movw	r30, r14
    3862:	87 85       	ldd	r24, Z+15	; 0x0f
    3864:	8f 93       	push	r24
    3866:	86 85       	ldd	r24, Z+14	; 0x0e
    3868:	8f 93       	push	r24
    386a:	ce 01       	movw	r24, r28
    386c:	88 0f       	add	r24, r24
    386e:	99 1f       	adc	r25, r25
    3870:	fc 01       	movw	r30, r24
    3872:	ec 0f       	add	r30, r28
    3874:	fd 1f       	adc	r31, r29
    3876:	ee 0f       	add	r30, r30
    3878:	ff 1f       	adc	r31, r31
    387a:	ee 0f       	add	r30, r30
    387c:	ff 1f       	adc	r31, r31
    387e:	ee 0f       	add	r30, r30
    3880:	ff 1f       	adc	r31, r31
    3882:	ec 5f       	subi	r30, 0xFC	; 252
    3884:	fb 4f       	sbci	r31, 0xFB	; 251
    3886:	20 81       	ld	r18, Z
    3888:	2f 73       	andi	r18, 0x3F	; 63
    388a:	1f 92       	push	r1
    388c:	2f 93       	push	r18
    388e:	20 81       	ld	r18, Z
    3890:	32 2f       	mov	r19, r18
    3892:	32 95       	swap	r19
    3894:	36 95       	lsr	r19
    3896:	36 95       	lsr	r19
    3898:	33 70       	andi	r19, 0x03	; 3
    389a:	21 81       	ldd	r18, Z+1	; 0x01
    389c:	2f 70       	andi	r18, 0x0F	; 15
    389e:	22 0f       	add	r18, r18
    38a0:	22 0f       	add	r18, r18
    38a2:	23 2b       	or	r18, r19
    38a4:	1f 92       	push	r1
    38a6:	2f 93       	push	r18
    38a8:	fc 01       	movw	r30, r24
    38aa:	ec 0f       	add	r30, r28
    38ac:	fd 1f       	adc	r31, r29
    38ae:	ee 0f       	add	r30, r30
    38b0:	ff 1f       	adc	r31, r31
    38b2:	ee 0f       	add	r30, r30
    38b4:	ff 1f       	adc	r31, r31
    38b6:	ee 0f       	add	r30, r30
    38b8:	ff 1f       	adc	r31, r31
    38ba:	eb 5f       	subi	r30, 0xFB	; 251
    38bc:	fb 4f       	sbci	r31, 0xFB	; 251
    38be:	20 81       	ld	r18, Z
    38c0:	32 2f       	mov	r19, r18
    38c2:	32 95       	swap	r19
    38c4:	3f 70       	andi	r19, 0x0F	; 15
    38c6:	21 81       	ldd	r18, Z+1	; 0x01
    38c8:	21 70       	andi	r18, 0x01	; 1
    38ca:	22 95       	swap	r18
    38cc:	20 7f       	andi	r18, 0xF0	; 240
    38ce:	23 2b       	or	r18, r19
    38d0:	1f 92       	push	r1
    38d2:	2f 93       	push	r18
    38d4:	fc 01       	movw	r30, r24
    38d6:	ec 0f       	add	r30, r28
    38d8:	fd 1f       	adc	r31, r29
    38da:	ee 0f       	add	r30, r30
    38dc:	ff 1f       	adc	r31, r31
    38de:	ee 0f       	add	r30, r30
    38e0:	ff 1f       	adc	r31, r31
    38e2:	ee 0f       	add	r30, r30
    38e4:	ff 1f       	adc	r31, r31
    38e6:	ea 5f       	subi	r30, 0xFA	; 250
    38e8:	fb 4f       	sbci	r31, 0xFB	; 251
    38ea:	80 81       	ld	r24, Z
    38ec:	86 95       	lsr	r24
    38ee:	8f 71       	andi	r24, 0x1F	; 31
    38f0:	1f 92       	push	r1
    38f2:	8f 93       	push	r24
    38f4:	f7 01       	movw	r30, r14
    38f6:	81 81       	ldd	r24, Z+1	; 0x01
    38f8:	1f 92       	push	r1
    38fa:	8f 93       	push	r24
    38fc:	ff 92       	push	r15
    38fe:	ef 92       	push	r14
    3900:	df 93       	push	r29
    3902:	cf 93       	push	r28
    3904:	1f 93       	push	r17
    3906:	0f 93       	push	r16
    3908:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
void csp_conn_print_table(void) {

	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    390c:	21 96       	adiw	r28, 0x01	; 1
    390e:	98 e1       	ldi	r25, 0x18	; 24
    3910:	e9 0e       	add	r14, r25
    3912:	f1 1c       	adc	r15, r1
    3914:	ed b7       	in	r30, 0x3d	; 61
    3916:	fe b7       	in	r31, 0x3e	; 62
    3918:	72 96       	adiw	r30, 0x12	; 18
    391a:	0f b6       	in	r0, 0x3f	; 63
    391c:	f8 94       	cli
    391e:	fe bf       	out	0x3e, r31	; 62
    3920:	0f be       	out	0x3f, r0	; 63
    3922:	ed bf       	out	0x3d, r30	; 61
    3924:	ca 30       	cpi	r28, 0x0A	; 10
    3926:	d1 05       	cpc	r29, r1
    3928:	09 f0       	breq	.+2      	; 0x392c <csp_conn_print_table+0xec>
    392a:	9a cf       	rjmp	.-204    	; 0x3860 <csp_conn_print_table+0x20>
#ifdef CSP_USE_RDP
		if (conn->idin.flags & CSP_FRDP)
			csp_rdp_conn_print(conn);
#endif
	}
}
    392c:	df 91       	pop	r29
    392e:	cf 91       	pop	r28
    3930:	1f 91       	pop	r17
    3932:	0f 91       	pop	r16
    3934:	ff 90       	pop	r15
    3936:	ef 90       	pop	r14
    3938:	08 95       	ret

0000393a <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    393a:	cf 92       	push	r12
    393c:	df 92       	push	r13
    393e:	ef 92       	push	r14
    3940:	ff 92       	push	r15
    3942:	0f 93       	push	r16
    3944:	1f 93       	push	r17
    3946:	cf 93       	push	r28
    3948:	df 93       	push	r29
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    394a:	8a 01       	movw	r16, r20
    394c:	9b 01       	movw	r18, r22
    394e:	01 50       	subi	r16, 0x01	; 1
    3950:	11 09       	sbc	r17, r1
    3952:	21 09       	sbc	r18, r1
    3954:	31 09       	sbc	r19, r1
    3956:	45 2b       	or	r20, r21
    3958:	46 2b       	or	r20, r22
    395a:	47 2b       	or	r20, r23
    395c:	39 f1       	breq	.+78     	; 0x39ac <csp_crc32_memory+0x72>
    395e:	c8 2f       	mov	r28, r24
    3960:	d9 2f       	mov	r29, r25
    3962:	4f ef       	ldi	r20, 0xFF	; 255
    3964:	5f ef       	ldi	r21, 0xFF	; 255
    3966:	ba 01       	movw	r22, r20
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    3968:	89 91       	ld	r24, Y+
    396a:	6a 01       	movw	r12, r20
    396c:	7b 01       	movw	r14, r22
    396e:	c8 26       	eor	r12, r24
    3970:	d7 01       	movw	r26, r14
    3972:	c6 01       	movw	r24, r12
    3974:	99 27       	eor	r25, r25
    3976:	aa 27       	eor	r26, r26
    3978:	bb 27       	eor	r27, r27
    397a:	fc 01       	movw	r30, r24
    397c:	ee 0f       	add	r30, r30
    397e:	ff 1f       	adc	r31, r31
    3980:	ee 0f       	add	r30, r30
    3982:	ff 1f       	adc	r31, r31
    3984:	ea 5b       	subi	r30, 0xBA	; 186
    3986:	fa 4f       	sbci	r31, 0xFA	; 250
    3988:	85 91       	lpm	r24, Z+
    398a:	95 91       	lpm	r25, Z+
    398c:	a5 91       	lpm	r26, Z+
    398e:	b4 91       	lpm	r27, Z
    3990:	45 2f       	mov	r20, r21
    3992:	56 2f       	mov	r21, r22
    3994:	67 2f       	mov	r22, r23
    3996:	77 27       	eor	r23, r23
    3998:	48 27       	eor	r20, r24
    399a:	59 27       	eor	r21, r25
    399c:	6a 27       	eor	r22, r26
    399e:	7b 27       	eor	r23, r27

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    39a0:	01 50       	subi	r16, 0x01	; 1
    39a2:	11 09       	sbc	r17, r1
    39a4:	21 09       	sbc	r18, r1
    39a6:	31 09       	sbc	r19, r1
    39a8:	f8 f6       	brcc	.-66     	; 0x3968 <csp_crc32_memory+0x2e>
    39aa:	03 c0       	rjmp	.+6      	; 0x39b2 <csp_crc32_memory+0x78>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    39ac:	4f ef       	ldi	r20, 0xFF	; 255
    39ae:	5f ef       	ldi	r21, 0xFF	; 255
    39b0:	ba 01       	movw	r22, r20
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    39b2:	cb 01       	movw	r24, r22
    39b4:	ba 01       	movw	r22, r20
    39b6:	60 95       	com	r22
    39b8:	70 95       	com	r23
    39ba:	80 95       	com	r24
    39bc:	90 95       	com	r25
}
    39be:	df 91       	pop	r29
    39c0:	cf 91       	pop	r28
    39c2:	1f 91       	pop	r17
    39c4:	0f 91       	pop	r16
    39c6:	ff 90       	pop	r15
    39c8:	ef 90       	pop	r14
    39ca:	df 90       	pop	r13
    39cc:	cf 90       	pop	r12
    39ce:	08 95       	ret

000039d0 <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet, bool include_header) {
    39d0:	cf 93       	push	r28
    39d2:	df 93       	push	r29

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    39d4:	00 97       	sbiw	r24, 0x00	; 0
    39d6:	19 f1       	breq	.+70     	; 0x3a1e <csp_crc32_append+0x4e>
    39d8:	ec 01       	movw	r28, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    39da:	66 23       	and	r22, r22
    39dc:	49 f0       	breq	.+18     	; 0x39f0 <csp_crc32_append+0x20>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id));
    39de:	48 85       	ldd	r20, Y+8	; 0x08
    39e0:	59 85       	ldd	r21, Y+9	; 0x09
    39e2:	4c 5f       	subi	r20, 0xFC	; 252
    39e4:	5f 4f       	sbci	r21, 0xFF	; 255
    39e6:	60 e0       	ldi	r22, 0x00	; 0
    39e8:	70 e0       	ldi	r23, 0x00	; 0
    39ea:	0a 96       	adiw	r24, 0x0a	; 10
    39ec:	a6 df       	rcall	.-180    	; 0x393a <csp_crc32_memory>
    39ee:	06 c0       	rjmp	.+12     	; 0x39fc <csp_crc32_append+0x2c>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length);
    39f0:	48 85       	ldd	r20, Y+8	; 0x08
    39f2:	59 85       	ldd	r21, Y+9	; 0x09
    39f4:	60 e0       	ldi	r22, 0x00	; 0
    39f6:	70 e0       	ldi	r23, 0x00	; 0
    39f8:	0e 96       	adiw	r24, 0x0e	; 14
	}
	crc = csp_hton32(crc);
    39fa:	9f df       	rcall	.-194    	; 0x393a <csp_crc32_memory>
    39fc:	f0 d0       	rcall	.+480    	; 0x3bde <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    39fe:	e8 85       	ldd	r30, Y+8	; 0x08
    3a00:	f9 85       	ldd	r31, Y+9	; 0x09
    3a02:	ec 0f       	add	r30, r28
    3a04:	fd 1f       	adc	r31, r29
    3a06:	66 87       	std	Z+14, r22	; 0x0e
    3a08:	77 87       	std	Z+15, r23	; 0x0f
    3a0a:	80 8b       	std	Z+16, r24	; 0x10
    3a0c:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    3a0e:	88 85       	ldd	r24, Y+8	; 0x08
    3a10:	99 85       	ldd	r25, Y+9	; 0x09
    3a12:	04 96       	adiw	r24, 0x04	; 4
    3a14:	99 87       	std	Y+9, r25	; 0x09
    3a16:	88 87       	std	Y+8, r24	; 0x08

	return CSP_ERR_NONE;
    3a18:	80 e0       	ldi	r24, 0x00	; 0
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
    3a1c:	02 c0       	rjmp	.+4      	; 0x3a22 <csp_crc32_append+0x52>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    3a1e:	8e ef       	ldi	r24, 0xFE	; 254
    3a20:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    3a22:	df 91       	pop	r29
    3a24:	cf 91       	pop	r28
    3a26:	08 95       	ret

00003a28 <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet, bool include_header) {
    3a28:	ef 92       	push	r14
    3a2a:	ff 92       	push	r15
    3a2c:	0f 93       	push	r16
    3a2e:	1f 93       	push	r17
    3a30:	cf 93       	push	r28
    3a32:	df 93       	push	r29
    3a34:	00 d0       	rcall	.+0      	; 0x3a36 <csp_crc32_verify+0xe>
    3a36:	1f 92       	push	r1
    3a38:	cd b7       	in	r28, 0x3d	; 61
    3a3a:	de b7       	in	r29, 0x3e	; 62

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    3a3c:	00 97       	sbiw	r24, 0x00	; 0
    3a3e:	09 f4       	brne	.+2      	; 0x3a42 <csp_crc32_verify+0x1a>
    3a40:	3c c0       	rjmp	.+120    	; 0x3aba <csp_crc32_verify+0x92>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    3a42:	fc 01       	movw	r30, r24
    3a44:	40 85       	ldd	r20, Z+8	; 0x08
    3a46:	51 85       	ldd	r21, Z+9	; 0x09
    3a48:	44 30       	cpi	r20, 0x04	; 4
    3a4a:	51 05       	cpc	r21, r1
    3a4c:	c8 f1       	brcs	.+114    	; 0x3ac0 <csp_crc32_verify+0x98>
    3a4e:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    3a50:	66 23       	and	r22, r22
    3a52:	49 f0       	breq	.+18     	; 0x3a66 <csp_crc32_verify+0x3e>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id) - sizeof(uint32_t));
    3a54:	60 e0       	ldi	r22, 0x00	; 0
    3a56:	70 e0       	ldi	r23, 0x00	; 0
    3a58:	0a 96       	adiw	r24, 0x0a	; 10
    3a5a:	6f df       	rcall	.-290    	; 0x393a <csp_crc32_memory>
    3a5c:	69 83       	std	Y+1, r22	; 0x01
    3a5e:	7a 83       	std	Y+2, r23	; 0x02
    3a60:	8b 83       	std	Y+3, r24	; 0x03
    3a62:	9c 83       	std	Y+4, r25	; 0x04
    3a64:	0a c0       	rjmp	.+20     	; 0x3a7a <csp_crc32_verify+0x52>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    3a66:	44 50       	subi	r20, 0x04	; 4
    3a68:	51 09       	sbc	r21, r1
    3a6a:	60 e0       	ldi	r22, 0x00	; 0
    3a6c:	70 e0       	ldi	r23, 0x00	; 0
    3a6e:	0e 96       	adiw	r24, 0x0e	; 14
    3a70:	64 df       	rcall	.-312    	; 0x393a <csp_crc32_memory>
    3a72:	69 83       	std	Y+1, r22	; 0x01
    3a74:	7a 83       	std	Y+2, r23	; 0x02
    3a76:	8b 83       	std	Y+3, r24	; 0x03
    3a78:	9c 83       	std	Y+4, r25	; 0x04
	}
	crc = csp_hton32(crc);
    3a7a:	69 81       	ldd	r22, Y+1	; 0x01
    3a7c:	7a 81       	ldd	r23, Y+2	; 0x02
    3a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a80:	9c 81       	ldd	r25, Y+4	; 0x04
    3a82:	ad d0       	rcall	.+346    	; 0x3bde <csp_hton32>
    3a84:	69 83       	std	Y+1, r22	; 0x01
    3a86:	7a 83       	std	Y+2, r23	; 0x02
    3a88:	8b 83       	std	Y+3, r24	; 0x03
    3a8a:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    3a8c:	f8 01       	movw	r30, r16
    3a8e:	e0 84       	ldd	r14, Z+8	; 0x08
    3a90:	f1 84       	ldd	r15, Z+9	; 0x09
    3a92:	c8 01       	movw	r24, r16
    3a94:	8e 0d       	add	r24, r14
    3a96:	9f 1d       	adc	r25, r15
    3a98:	44 e0       	ldi	r20, 0x04	; 4
    3a9a:	50 e0       	ldi	r21, 0x00	; 0
    3a9c:	be 01       	movw	r22, r28
    3a9e:	6f 5f       	subi	r22, 0xFF	; 255
    3aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    3aa2:	0a 96       	adiw	r24, 0x0a	; 10
    3aa4:	0e 94 81 45 	call	0x8b02	; 0x8b02 <memcmp>
    3aa8:	00 97       	sbiw	r24, 0x00	; 0
    3aaa:	69 f4       	brne	.+26     	; 0x3ac6 <csp_crc32_verify+0x9e>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    3aac:	f4 e0       	ldi	r31, 0x04	; 4
    3aae:	ef 1a       	sub	r14, r31
    3ab0:	f1 08       	sbc	r15, r1
    3ab2:	f8 01       	movw	r30, r16
    3ab4:	f1 86       	std	Z+9, r15	; 0x09
    3ab6:	e0 86       	std	Z+8, r14	; 0x08
		return CSP_ERR_NONE;
    3ab8:	08 c0       	rjmp	.+16     	; 0x3aca <csp_crc32_verify+0xa2>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    3aba:	8e ef       	ldi	r24, 0xFE	; 254
    3abc:	9f ef       	ldi	r25, 0xFF	; 255
    3abe:	05 c0       	rjmp	.+10     	; 0x3aca <csp_crc32_verify+0xa2>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    3ac0:	8e ef       	ldi	r24, 0xFE	; 254
    3ac2:	9f ef       	ldi	r25, 0xFF	; 255
    3ac4:	02 c0       	rjmp	.+4      	; 0x3aca <csp_crc32_verify+0xa2>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    3ac6:	8e ef       	ldi	r24, 0xFE	; 254
    3ac8:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    3aca:	0f 90       	pop	r0
    3acc:	0f 90       	pop	r0
    3ace:	0f 90       	pop	r0
    3ad0:	0f 90       	pop	r0
    3ad2:	df 91       	pop	r29
    3ad4:	cf 91       	pop	r28
    3ad6:	1f 91       	pop	r17
    3ad8:	0f 91       	pop	r16
    3ada:	ff 90       	pop	r15
    3adc:	ef 90       	pop	r14
    3ade:	08 95       	ret

00003ae0 <do_csp_debug>:
{
	csp_debug_hook_func = f;
}

void do_csp_debug(csp_debug_level_t level, const char *format, ...)
{
    3ae0:	ff 92       	push	r15
    3ae2:	0f 93       	push	r16
    3ae4:	1f 93       	push	r17
    3ae6:	cf 93       	push	r28
    3ae8:	df 93       	push	r29
    3aea:	cd b7       	in	r28, 0x3d	; 61
    3aec:	de b7       	in	r29, 0x3e	; 62
    3aee:	19 85       	ldd	r17, Y+9	; 0x09
	int color = COLOR_RESET;
	va_list args;

	/* Don't print anything if log level is disabled */
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
    3af0:	18 30       	cpi	r17, 0x08	; 8
    3af2:	08 f0       	brcs	.+2      	; 0x3af6 <do_csp_debug+0x16>
    3af4:	66 c0       	rjmp	.+204    	; 0x3bc2 <do_csp_debug+0xe2>
    3af6:	e1 2f       	mov	r30, r17
    3af8:	f0 e0       	ldi	r31, 0x00	; 0
    3afa:	e6 5f       	subi	r30, 0xF6	; 246
    3afc:	fd 4f       	sbci	r31, 0xFD	; 253
    3afe:	80 81       	ld	r24, Z
    3b00:	88 23       	and	r24, r24
    3b02:	09 f4       	brne	.+2      	; 0x3b06 <do_csp_debug+0x26>
    3b04:	5e c0       	rjmp	.+188    	; 0x3bc2 <do_csp_debug+0xe2>
		return;

	switch(level) {
    3b06:	81 2f       	mov	r24, r17
    3b08:	90 e0       	ldi	r25, 0x00	; 0
    3b0a:	88 30       	cpi	r24, 0x08	; 8
    3b0c:	91 05       	cpc	r25, r1
    3b0e:	08 f0       	brcs	.+2      	; 0x3b12 <do_csp_debug+0x32>
    3b10:	58 c0       	rjmp	.+176    	; 0x3bc2 <do_csp_debug+0xe2>
    3b12:	fc 01       	movw	r30, r24
    3b14:	88 27       	eor	r24, r24
    3b16:	ee 58       	subi	r30, 0x8E	; 142
    3b18:	ff 4f       	sbci	r31, 0xFF	; 255
    3b1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3b1c:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
		break;
	case CSP_ERROR:
		color = COLOR_RED | COLOR_BOLD;
    3b20:	82 e1       	ldi	r24, 0x12	; 18
    3b22:	0b c0       	rjmp	.+22     	; 0x3b3a <do_csp_debug+0x5a>
		break;
	case CSP_WARN:
		color = COLOR_YELLOW | COLOR_BOLD;
    3b24:	84 e1       	ldi	r24, 0x14	; 20
		break;
    3b26:	09 c0       	rjmp	.+18     	; 0x3b3a <do_csp_debug+0x5a>
	case CSP_RESET:
		color = COLOR_RED | COLOR_BOLD;
		break;
	case CSP_BUFFER:
		color = COLOR_MAGENTA;
    3b28:	86 e0       	ldi	r24, 0x06	; 6
		break;
    3b2a:	07 c0       	rjmp	.+14     	; 0x3b3a <do_csp_debug+0x5a>
	case CSP_PACKET:
		color = COLOR_GREEN;
    3b2c:	83 e0       	ldi	r24, 0x03	; 3
		break;
    3b2e:	05 c0       	rjmp	.+10     	; 0x3b3a <do_csp_debug+0x5a>
	case CSP_PROTOCOL:
		color = COLOR_BLUE;
    3b30:	85 e0       	ldi	r24, 0x05	; 5
		break;
    3b32:	03 c0       	rjmp	.+6      	; 0x3b3a <do_csp_debug+0x5a>
	case CSP_LOCK:
		color = COLOR_CYAN;
    3b34:	87 e0       	ldi	r24, 0x07	; 7
		break;
    3b36:	01 c0       	rjmp	.+2      	; 0x3b3a <do_csp_debug+0x5a>
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
		return;

	switch(level) {
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
    3b38:	83 e1       	ldi	r24, 0x13	; 19
		break;
	default:
		return;
	}

	va_start(args, format);
    3b3a:	ae 01       	movw	r20, r28
    3b3c:	44 5f       	subi	r20, 0xF4	; 244
    3b3e:	5f 4f       	sbci	r21, 0xFF	; 255
    3b40:	f4 2e       	mov	r15, r20
    3b42:	05 2f       	mov	r16, r21

	/* If csp_debug_hook symbol is defined, pass on the message.
	 * Otherwise, just print with pretty colors ... */
	if (csp_debug_hook_func) {
    3b44:	e0 91 ef 04 	lds	r30, 0x04EF	; 0x8004ef <csp_debug_hook_func>
    3b48:	f0 91 f0 04 	lds	r31, 0x04F0	; 0x8004f0 <csp_debug_hook_func+0x1>
    3b4c:	30 97       	sbiw	r30, 0x00	; 0
    3b4e:	29 f0       	breq	.+10     	; 0x3b5a <do_csp_debug+0x7a>
		csp_debug_hook_func(level, format, args);
    3b50:	6a 85       	ldd	r22, Y+10	; 0x0a
    3b52:	7b 85       	ldd	r23, Y+11	; 0x0b
    3b54:	81 2f       	mov	r24, r17
    3b56:	19 95       	eicall
    3b58:	17 c0       	rjmp	.+46     	; 0x3b88 <do_csp_debug+0xa8>
	} else {
		csp_sys_set_color(color);
    3b5a:	0e 94 96 30 	call	0x612c	; 0x612c <csp_sys_set_color>
#ifdef __AVR__
		vfprintf_P(stdout, format, args);
    3b5e:	4f 2d       	mov	r20, r15
    3b60:	50 2f       	mov	r21, r16
    3b62:	6a 85       	ldd	r22, Y+10	; 0x0a
    3b64:	7b 85       	ldd	r23, Y+11	; 0x0b
    3b66:	80 91 77 20 	lds	r24, 0x2077	; 0x802077 <__iob+0x2>
    3b6a:	90 91 78 20 	lds	r25, 0x2078	; 0x802078 <__iob+0x3>
    3b6e:	0e 94 eb 46 	call	0x8dd6	; 0x8dd6 <vfprintf_P>
#else
		vprintf(format, args);
#endif
		printf("\r\n");
    3b72:	80 e6       	ldi	r24, 0x60	; 96
    3b74:	99 e0       	ldi	r25, 0x09	; 9
    3b76:	9f 93       	push	r25
    3b78:	8f 93       	push	r24
    3b7a:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
		csp_sys_set_color(COLOR_RESET);
    3b7e:	80 ef       	ldi	r24, 0xF0	; 240
    3b80:	0e 94 96 30 	call	0x612c	; 0x612c <csp_sys_set_color>
    3b84:	0f 90       	pop	r0
    3b86:	0f 90       	pop	r0
	}

	va_end(args);
	if(level==CSP_RESET){
    3b88:	16 30       	cpi	r17, 0x06	; 6
    3b8a:	d9 f4       	brne	.+54     	; 0x3bc2 <do_csp_debug+0xe2>
		printf("CSP RESET %s",pcTaskGetName(NULL));
    3b8c:	80 e0       	ldi	r24, 0x00	; 0
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	0e 94 87 3b 	call	0x770e	; 0x770e <pcTaskGetName>
    3b94:	9f 93       	push	r25
    3b96:	8f 93       	push	r24
    3b98:	83 e5       	ldi	r24, 0x53	; 83
    3b9a:	99 e0       	ldi	r25, 0x09	; 9
    3b9c:	9f 93       	push	r25
    3b9e:	8f 93       	push	r24
    3ba0:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
	FORCERESET
    3ba4:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
    3ba8:	86 e4       	ldi	r24, 0x46	; 70
    3baa:	99 e0       	ldi	r25, 0x09	; 9
    3bac:	9f 93       	push	r25
    3bae:	8f 93       	push	r24
    3bb0:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
    3bb4:	0f 90       	pop	r0
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	0f 90       	pop	r0
    3bbc:	0f 90       	pop	r0
    3bbe:	0f 90       	pop	r0
    3bc0:	ff cf       	rjmp	.-2      	; 0x3bc0 <do_csp_debug+0xe0>
	}
}
    3bc2:	df 91       	pop	r29
    3bc4:	cf 91       	pop	r28
    3bc6:	1f 91       	pop	r17
    3bc8:	0f 91       	pop	r16
    3bca:	ff 90       	pop	r15
    3bcc:	08 95       	ret

00003bce <csp_hton16>:
	return h16;
#else
	return (((h16 & 0xff00) >> 8) |
			((h16 & 0x00ff) << 8));
#endif
}
    3bce:	98 27       	eor	r25, r24
    3bd0:	89 27       	eor	r24, r25
    3bd2:	98 27       	eor	r25, r24
    3bd4:	08 95       	ret

00003bd6 <csp_ntoh16>:

/* Convert 16-bit number from network byte order to host byte order */
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}
    3bd6:	98 27       	eor	r25, r24
    3bd8:	89 27       	eor	r24, r25
    3bda:	98 27       	eor	r25, r24
    3bdc:	08 95       	ret

00003bde <csp_hton32>:

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    3bde:	cf 92       	push	r12
    3be0:	df 92       	push	r13
    3be2:	ef 92       	push	r14
    3be4:	ff 92       	push	r15
    3be6:	0f 93       	push	r16
    3be8:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    3bea:	c9 2e       	mov	r12, r25
    3bec:	dd 24       	eor	r13, r13
    3bee:	ee 24       	eor	r14, r14
    3bf0:	ff 24       	eor	r15, r15
    3bf2:	36 2f       	mov	r19, r22
    3bf4:	22 27       	eor	r18, r18
    3bf6:	11 27       	eor	r17, r17
    3bf8:	00 27       	eor	r16, r16
    3bfa:	0c 29       	or	r16, r12
    3bfc:	1d 29       	or	r17, r13
    3bfe:	2e 29       	or	r18, r14
    3c00:	3f 29       	or	r19, r15
    3c02:	6b 01       	movw	r12, r22
    3c04:	7c 01       	movw	r14, r24
    3c06:	cc 24       	eor	r12, r12
    3c08:	ee 24       	eor	r14, r14
    3c0a:	ff 24       	eor	r15, r15
    3c0c:	fe 2c       	mov	r15, r14
    3c0e:	ed 2c       	mov	r14, r13
    3c10:	dc 2c       	mov	r13, r12
    3c12:	cc 24       	eor	r12, r12
    3c14:	0c 29       	or	r16, r12
    3c16:	1d 29       	or	r17, r13
    3c18:	2e 29       	or	r18, r14
    3c1a:	3f 29       	or	r19, r15
    3c1c:	dc 01       	movw	r26, r24
    3c1e:	cb 01       	movw	r24, r22
    3c20:	88 27       	eor	r24, r24
    3c22:	99 27       	eor	r25, r25
    3c24:	bb 27       	eor	r27, r27
    3c26:	89 2f       	mov	r24, r25
    3c28:	9a 2f       	mov	r25, r26
    3c2a:	ab 2f       	mov	r26, r27
    3c2c:	bb 27       	eor	r27, r27
    3c2e:	bc 01       	movw	r22, r24
    3c30:	cd 01       	movw	r24, r26
    3c32:	60 2b       	or	r22, r16
    3c34:	71 2b       	or	r23, r17
    3c36:	82 2b       	or	r24, r18
    3c38:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    3c3a:	1f 91       	pop	r17
    3c3c:	0f 91       	pop	r16
    3c3e:	ff 90       	pop	r15
    3c40:	ef 90       	pop	r14
    3c42:	df 90       	pop	r13
    3c44:	cf 90       	pop	r12
    3c46:	08 95       	ret

00003c48 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    3c48:	cf 92       	push	r12
    3c4a:	df 92       	push	r13
    3c4c:	ef 92       	push	r14
    3c4e:	ff 92       	push	r15
    3c50:	0f 93       	push	r16
    3c52:	1f 93       	push	r17
	return csp_hton32(n32);
    3c54:	c9 2e       	mov	r12, r25
    3c56:	dd 24       	eor	r13, r13
    3c58:	ee 24       	eor	r14, r14
    3c5a:	ff 24       	eor	r15, r15
    3c5c:	36 2f       	mov	r19, r22
    3c5e:	22 27       	eor	r18, r18
    3c60:	11 27       	eor	r17, r17
    3c62:	00 27       	eor	r16, r16
    3c64:	0c 29       	or	r16, r12
    3c66:	1d 29       	or	r17, r13
    3c68:	2e 29       	or	r18, r14
    3c6a:	3f 29       	or	r19, r15
    3c6c:	6b 01       	movw	r12, r22
    3c6e:	7c 01       	movw	r14, r24
    3c70:	cc 24       	eor	r12, r12
    3c72:	ee 24       	eor	r14, r14
    3c74:	ff 24       	eor	r15, r15
    3c76:	fe 2c       	mov	r15, r14
    3c78:	ed 2c       	mov	r14, r13
    3c7a:	dc 2c       	mov	r13, r12
    3c7c:	cc 24       	eor	r12, r12
    3c7e:	0c 29       	or	r16, r12
    3c80:	1d 29       	or	r17, r13
    3c82:	2e 29       	or	r18, r14
    3c84:	3f 29       	or	r19, r15
    3c86:	dc 01       	movw	r26, r24
    3c88:	cb 01       	movw	r24, r22
    3c8a:	88 27       	eor	r24, r24
    3c8c:	99 27       	eor	r25, r25
    3c8e:	bb 27       	eor	r27, r27
    3c90:	89 2f       	mov	r24, r25
    3c92:	9a 2f       	mov	r25, r26
    3c94:	ab 2f       	mov	r26, r27
    3c96:	bb 27       	eor	r27, r27
    3c98:	bc 01       	movw	r22, r24
    3c9a:	cd 01       	movw	r24, r26
    3c9c:	60 2b       	or	r22, r16
    3c9e:	71 2b       	or	r23, r17
    3ca0:	82 2b       	or	r24, r18
    3ca2:	93 2b       	or	r25, r19
}
    3ca4:	1f 91       	pop	r17
    3ca6:	0f 91       	pop	r16
    3ca8:	ff 90       	pop	r15
    3caa:	ef 90       	pop	r14
    3cac:	df 90       	pop	r13
    3cae:	cf 90       	pop	r12
    3cb0:	08 95       	ret

00003cb2 <csp_bytesize>:
	}

}

#ifdef CSP_DEBUG
static int csp_bytesize(char *buf, int len, unsigned long int n) {
    3cb2:	0f 93       	push	r16
    3cb4:	1f 93       	push	r17
    3cb6:	cf 93       	push	r28
    3cb8:	df 93       	push	r29
    3cba:	c8 2f       	mov	r28, r24
    3cbc:	d9 2f       	mov	r29, r25
    3cbe:	16 2f       	mov	r17, r22
    3cc0:	07 2f       	mov	r16, r23
	char postfix;
	double size;

	if (n >= 1048576) {
    3cc2:	21 15       	cp	r18, r1
    3cc4:	31 05       	cpc	r19, r1
    3cc6:	80 e1       	ldi	r24, 0x10	; 16
    3cc8:	48 07       	cpc	r20, r24
    3cca:	51 05       	cpc	r21, r1
    3ccc:	60 f0       	brcs	.+24     	; 0x3ce6 <csp_bytesize+0x34>
		size = n/1048576.0;
    3cce:	ca 01       	movw	r24, r20
    3cd0:	b9 01       	movw	r22, r18
    3cd2:	0e 94 bf 43 	call	0x877e	; 0x877e <__floatunsisf>
    3cd6:	20 e0       	ldi	r18, 0x00	; 0
    3cd8:	30 e0       	ldi	r19, 0x00	; 0
    3cda:	40 e8       	ldi	r20, 0x80	; 128
    3cdc:	55 e3       	ldi	r21, 0x35	; 53
    3cde:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__mulsf3>
		postfix = 'M';
    3ce2:	2d e4       	ldi	r18, 0x4D	; 77
    3ce4:	17 c0       	rjmp	.+46     	; 0x3d14 <csp_bytesize+0x62>
	} else if (n >= 1024) {
    3ce6:	21 15       	cp	r18, r1
    3ce8:	84 e0       	ldi	r24, 0x04	; 4
    3cea:	38 07       	cpc	r19, r24
    3cec:	41 05       	cpc	r20, r1
    3cee:	51 05       	cpc	r21, r1
    3cf0:	60 f0       	brcs	.+24     	; 0x3d0a <csp_bytesize+0x58>
		size = n/1024.;
    3cf2:	ca 01       	movw	r24, r20
    3cf4:	b9 01       	movw	r22, r18
    3cf6:	0e 94 bf 43 	call	0x877e	; 0x877e <__floatunsisf>
    3cfa:	20 e0       	ldi	r18, 0x00	; 0
    3cfc:	30 e0       	ldi	r19, 0x00	; 0
    3cfe:	40 e8       	ldi	r20, 0x80	; 128
    3d00:	5a e3       	ldi	r21, 0x3A	; 58
    3d02:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__mulsf3>
		postfix = 'K';
    3d06:	2b e4       	ldi	r18, 0x4B	; 75
    3d08:	05 c0       	rjmp	.+10     	; 0x3d14 <csp_bytesize+0x62>
	} else {
		size = n;
    3d0a:	ca 01       	movw	r24, r20
    3d0c:	b9 01       	movw	r22, r18
    3d0e:	0e 94 bf 43 	call	0x877e	; 0x877e <__floatunsisf>
		postfix = 'B';
    3d12:	22 e4       	ldi	r18, 0x42	; 66
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
    3d14:	1f 92       	push	r1
    3d16:	2f 93       	push	r18
    3d18:	9f 93       	push	r25
    3d1a:	8f 93       	push	r24
    3d1c:	7f 93       	push	r23
    3d1e:	6f 93       	push	r22
    3d20:	83 e6       	ldi	r24, 0x63	; 99
    3d22:	99 e0       	ldi	r25, 0x09	; 9
    3d24:	9f 93       	push	r25
    3d26:	8f 93       	push	r24
    3d28:	0f 93       	push	r16
    3d2a:	1f 93       	push	r17
    3d2c:	df 93       	push	r29
    3d2e:	cf 93       	push	r28
    3d30:	0e 94 81 46 	call	0x8d02	; 0x8d02 <snprintf_P>
    3d34:	2d b7       	in	r18, 0x3d	; 61
    3d36:	3e b7       	in	r19, 0x3e	; 62
    3d38:	24 5f       	subi	r18, 0xF4	; 244
    3d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d3c:	0f b6       	in	r0, 0x3f	; 63
    3d3e:	f8 94       	cli
    3d40:	3e bf       	out	0x3e, r19	; 62
    3d42:	0f be       	out	0x3f, r0	; 63
    3d44:	2d bf       	out	0x3d, r18	; 61
}
    3d46:	df 91       	pop	r29
    3d48:	cf 91       	pop	r28
    3d4a:	1f 91       	pop	r17
    3d4c:	0f 91       	pop	r16
    3d4e:	08 95       	ret

00003d50 <csp_iflist_get_by_name>:
#include "csp.h"

/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
    3d50:	0f 93       	push	r16
    3d52:	1f 93       	push	r17
    3d54:	cf 93       	push	r28
    3d56:	df 93       	push	r29
    3d58:	8c 01       	movw	r16, r24
	csp_iface_t *ifc = interfaces;
    3d5a:	c0 91 f1 04 	lds	r28, 0x04F1	; 0x8004f1 <interfaces>
    3d5e:	d0 91 f2 04 	lds	r29, 0x04F2	; 0x8004f2 <interfaces+0x1>
	while(ifc) {
    3d62:	20 97       	sbiw	r28, 0x00	; 0
    3d64:	71 f0       	breq	.+28     	; 0x3d82 <csp_iflist_get_by_name+0x32>
		if (strncmp(ifc->name, name, 10) == 0)
    3d66:	4a e0       	ldi	r20, 0x0A	; 10
    3d68:	50 e0       	ldi	r21, 0x00	; 0
    3d6a:	b8 01       	movw	r22, r16
    3d6c:	88 81       	ld	r24, Y
    3d6e:	99 81       	ldd	r25, Y+1	; 0x01
    3d70:	0e 94 a5 45 	call	0x8b4a	; 0x8b4a <strncmp>
    3d74:	89 2b       	or	r24, r25
    3d76:	29 f0       	breq	.+10     	; 0x3d82 <csp_iflist_get_by_name+0x32>
			break;
		ifc = ifc->next;
    3d78:	09 a8       	ldd	r0, Y+49	; 0x31
    3d7a:	da a9       	ldd	r29, Y+50	; 0x32
    3d7c:	c0 2d       	mov	r28, r0
/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
	csp_iface_t *ifc = interfaces;
	while(ifc) {
    3d7e:	20 97       	sbiw	r28, 0x00	; 0
    3d80:	91 f7       	brne	.-28     	; 0x3d66 <csp_iflist_get_by_name+0x16>
		if (strncmp(ifc->name, name, 10) == 0)
			break;
		ifc = ifc->next;
	}
	return ifc;
}
    3d82:	ce 01       	movw	r24, r28
    3d84:	df 91       	pop	r29
    3d86:	cf 91       	pop	r28
    3d88:	1f 91       	pop	r17
    3d8a:	0f 91       	pop	r16
    3d8c:	08 95       	ret

00003d8e <csp_iflist_add>:

void csp_iflist_add(csp_iface_t *ifc) {

	/* Add interface to pool */
	if (interfaces == NULL) {
    3d8e:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <interfaces>
    3d92:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <interfaces+0x1>
    3d96:	10 97       	sbiw	r26, 0x00	; 0
    3d98:	41 f4       	brne	.+16     	; 0x3daa <csp_iflist_add+0x1c>
		/* This is the first interface to be added */
		interfaces = ifc;
    3d9a:	90 93 f2 04 	sts	0x04F2, r25	; 0x8004f2 <interfaces+0x1>
    3d9e:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <interfaces>
		ifc->next = NULL;
    3da2:	fc 01       	movw	r30, r24
    3da4:	12 aa       	std	Z+50, r1	; 0x32
    3da6:	11 aa       	std	Z+49, r1	; 0x31
    3da8:	08 95       	ret
	} else {
		/* One or more interfaces were already added */
		csp_iface_t * i = interfaces;
		while (i != ifc && i->next)
    3daa:	a8 17       	cp	r26, r24
    3dac:	b9 07       	cpc	r27, r25
    3dae:	b9 f0       	breq	.+46     	; 0x3dde <csp_iflist_add+0x50>
    3db0:	d1 96       	adiw	r26, 0x31	; 49
    3db2:	ed 91       	ld	r30, X+
    3db4:	fc 91       	ld	r31, X
    3db6:	d2 97       	sbiw	r26, 0x32	; 50
    3db8:	30 97       	sbiw	r30, 0x00	; 0
    3dba:	41 f4       	brne	.+16     	; 0x3dcc <csp_iflist_add+0x3e>
    3dbc:	fd 01       	movw	r30, r26
    3dbe:	0a c0       	rjmp	.+20     	; 0x3dd4 <csp_iflist_add+0x46>
    3dc0:	21 a9       	ldd	r18, Z+49	; 0x31
    3dc2:	32 a9       	ldd	r19, Z+50	; 0x32
    3dc4:	21 15       	cp	r18, r1
    3dc6:	31 05       	cpc	r19, r1
    3dc8:	29 f0       	breq	.+10     	; 0x3dd4 <csp_iflist_add+0x46>
    3dca:	f9 01       	movw	r30, r18
    3dcc:	8e 17       	cp	r24, r30
    3dce:	9f 07       	cpc	r25, r31
    3dd0:	b9 f7       	brne	.-18     	; 0x3dc0 <csp_iflist_add+0x32>
    3dd2:	08 95       	ret
			i = i->next;

		/* Insert interface last if not already in pool */
		if (i != ifc && i->next == NULL) {
			i->next = ifc;
    3dd4:	92 ab       	std	Z+50, r25	; 0x32
    3dd6:	81 ab       	std	Z+49, r24	; 0x31
			ifc->next = NULL;
    3dd8:	fc 01       	movw	r30, r24
    3dda:	12 aa       	std	Z+50, r1	; 0x32
    3ddc:	11 aa       	std	Z+49, r1	; 0x31
    3dde:	08 95       	ret

00003de0 <csp_iflist_print>:
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
}

void csp_iflist_print(void) {
    3de0:	af 92       	push	r10
    3de2:	bf 92       	push	r11
    3de4:	cf 92       	push	r12
    3de6:	df 92       	push	r13
    3de8:	ef 92       	push	r14
    3dea:	ff 92       	push	r15
    3dec:	0f 93       	push	r16
    3dee:	1f 93       	push	r17
    3df0:	cf 93       	push	r28
    3df2:	df 93       	push	r29
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62
    3df8:	e2 97       	sbiw	r28, 0x32	; 50
    3dfa:	0f b6       	in	r0, 0x3f	; 63
    3dfc:	f8 94       	cli
    3dfe:	de bf       	out	0x3e, r29	; 62
    3e00:	0f be       	out	0x3f, r0	; 63
    3e02:	cd bf       	out	0x3d, r28	; 61
	csp_iface_t * i = interfaces;
    3e04:	00 91 f1 04 	lds	r16, 0x04F1	; 0x8004f1 <interfaces>
    3e08:	10 91 f2 04 	lds	r17, 0x04F2	; 0x8004f2 <interfaces+0x1>
	char txbuf[25], rxbuf[25];

	while (i) {
    3e0c:	01 15       	cp	r16, r1
    3e0e:	11 05       	cpc	r17, r1
    3e10:	09 f4       	brne	.+2      	; 0x3e14 <csp_iflist_print+0x34>
    3e12:	80 c0       	rjmp	.+256    	; 0x3f14 <csp_iflist_print+0x134>
		csp_bytesize(txbuf, 25, i->txbytes);
    3e14:	ce 01       	movw	r24, r28
    3e16:	01 96       	adiw	r24, 0x01	; 1
    3e18:	5c 01       	movw	r10, r24
		csp_bytesize(rxbuf, 25, i->rxbytes);
    3e1a:	7e 01       	movw	r14, r28
    3e1c:	9a e1       	ldi	r25, 0x1A	; 26
    3e1e:	e9 0e       	add	r14, r25
    3e20:	f1 1c       	adc	r15, r1
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    3e22:	0f 2e       	mov	r0, r31
    3e24:	fa e6       	ldi	r31, 0x6A	; 106
    3e26:	cf 2e       	mov	r12, r31
    3e28:	f9 e0       	ldi	r31, 0x09	; 9
    3e2a:	df 2e       	mov	r13, r31
    3e2c:	f0 2d       	mov	r31, r0
void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
		csp_bytesize(txbuf, 25, i->txbytes);
    3e2e:	f8 01       	movw	r30, r16
    3e30:	25 a1       	ldd	r18, Z+37	; 0x25
    3e32:	36 a1       	ldd	r19, Z+38	; 0x26
    3e34:	47 a1       	ldd	r20, Z+39	; 0x27
    3e36:	50 a5       	ldd	r21, Z+40	; 0x28
    3e38:	69 e1       	ldi	r22, 0x19	; 25
    3e3a:	70 e0       	ldi	r23, 0x00	; 0
    3e3c:	c5 01       	movw	r24, r10
    3e3e:	39 df       	rcall	.-398    	; 0x3cb2 <csp_bytesize>
		csp_bytesize(rxbuf, 25, i->rxbytes);
    3e40:	f8 01       	movw	r30, r16
    3e42:	21 a5       	ldd	r18, Z+41	; 0x29
    3e44:	32 a5       	ldd	r19, Z+42	; 0x2a
    3e46:	43 a5       	ldd	r20, Z+43	; 0x2b
    3e48:	54 a5       	ldd	r21, Z+44	; 0x2c
    3e4a:	69 e1       	ldi	r22, 0x19	; 25
    3e4c:	70 e0       	ldi	r23, 0x00	; 0
    3e4e:	c7 01       	movw	r24, r14
    3e50:	30 df       	rcall	.-416    	; 0x3cb2 <csp_bytesize>
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    3e52:	ff 92       	push	r15
    3e54:	ef 92       	push	r14
    3e56:	f8 01       	movw	r30, r16
    3e58:	84 a5       	ldd	r24, Z+44	; 0x2c
    3e5a:	8f 93       	push	r24
    3e5c:	83 a5       	ldd	r24, Z+43	; 0x2b
    3e5e:	8f 93       	push	r24
    3e60:	82 a5       	ldd	r24, Z+42	; 0x2a
    3e62:	8f 93       	push	r24
    3e64:	81 a5       	ldd	r24, Z+41	; 0x29
    3e66:	8f 93       	push	r24
    3e68:	bf 92       	push	r11
    3e6a:	af 92       	push	r10
    3e6c:	80 a5       	ldd	r24, Z+40	; 0x28
    3e6e:	8f 93       	push	r24
    3e70:	87 a1       	ldd	r24, Z+39	; 0x27
    3e72:	8f 93       	push	r24
    3e74:	86 a1       	ldd	r24, Z+38	; 0x26
    3e76:	8f 93       	push	r24
    3e78:	85 a1       	ldd	r24, Z+37	; 0x25
    3e7a:	8f 93       	push	r24
    3e7c:	84 a1       	ldd	r24, Z+36	; 0x24
    3e7e:	8f 93       	push	r24
    3e80:	83 a1       	ldd	r24, Z+35	; 0x23
    3e82:	8f 93       	push	r24
    3e84:	82 a1       	ldd	r24, Z+34	; 0x22
    3e86:	8f 93       	push	r24
    3e88:	81 a1       	ldd	r24, Z+33	; 0x21
    3e8a:	8f 93       	push	r24
    3e8c:	80 a1       	ldd	r24, Z+32	; 0x20
    3e8e:	8f 93       	push	r24
    3e90:	87 8d       	ldd	r24, Z+31	; 0x1f
    3e92:	8f 93       	push	r24
    3e94:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e96:	8f 93       	push	r24
    3e98:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e9a:	8f 93       	push	r24
    3e9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e9e:	8f 93       	push	r24
    3ea0:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ea2:	8f 93       	push	r24
    3ea4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ea6:	8f 93       	push	r24
    3ea8:	81 8d       	ldd	r24, Z+25	; 0x19
    3eaa:	8f 93       	push	r24
    3eac:	80 8d       	ldd	r24, Z+24	; 0x18
    3eae:	8f 93       	push	r24
    3eb0:	87 89       	ldd	r24, Z+23	; 0x17
    3eb2:	8f 93       	push	r24
    3eb4:	86 89       	ldd	r24, Z+22	; 0x16
    3eb6:	8f 93       	push	r24
    3eb8:	85 89       	ldd	r24, Z+21	; 0x15
    3eba:	8f 93       	push	r24
    3ebc:	84 89       	ldd	r24, Z+20	; 0x14
    3ebe:	8f 93       	push	r24
    3ec0:	83 89       	ldd	r24, Z+19	; 0x13
    3ec2:	8f 93       	push	r24
    3ec4:	82 89       	ldd	r24, Z+18	; 0x12
    3ec6:	8f 93       	push	r24
    3ec8:	81 89       	ldd	r24, Z+17	; 0x11
    3eca:	8f 93       	push	r24
    3ecc:	80 89       	ldd	r24, Z+16	; 0x10
    3ece:	8f 93       	push	r24
    3ed0:	87 85       	ldd	r24, Z+15	; 0x0f
    3ed2:	8f 93       	push	r24
    3ed4:	86 85       	ldd	r24, Z+14	; 0x0e
    3ed6:	8f 93       	push	r24
    3ed8:	85 85       	ldd	r24, Z+13	; 0x0d
    3eda:	8f 93       	push	r24
    3edc:	84 85       	ldd	r24, Z+12	; 0x0c
    3ede:	8f 93       	push	r24
    3ee0:	83 85       	ldd	r24, Z+11	; 0x0b
    3ee2:	8f 93       	push	r24
    3ee4:	82 85       	ldd	r24, Z+10	; 0x0a
    3ee6:	8f 93       	push	r24
    3ee8:	81 85       	ldd	r24, Z+9	; 0x09
    3eea:	8f 93       	push	r24
    3eec:	81 81       	ldd	r24, Z+1	; 0x01
    3eee:	8f 93       	push	r24
    3ef0:	80 81       	ld	r24, Z
    3ef2:	8f 93       	push	r24
    3ef4:	df 92       	push	r13
    3ef6:	cf 92       	push	r12
    3ef8:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
		       "        drop: %05"PRIu32" autherr: %05"PRIu32 " frame: %05"PRIu32"\r\n"
		       "        txb: %"PRIu32" (%s) rxb: %"PRIu32" (%s)\r\n\r\n",
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
    3efc:	f8 01       	movw	r30, r16
    3efe:	01 a9       	ldd	r16, Z+49	; 0x31
    3f00:	12 a9       	ldd	r17, Z+50	; 0x32

void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
    3f02:	0f b6       	in	r0, 0x3f	; 63
    3f04:	f8 94       	cli
    3f06:	de bf       	out	0x3e, r29	; 62
    3f08:	0f be       	out	0x3f, r0	; 63
    3f0a:	cd bf       	out	0x3d, r28	; 61
    3f0c:	01 15       	cp	r16, r1
    3f0e:	11 05       	cpc	r17, r1
    3f10:	09 f0       	breq	.+2      	; 0x3f14 <csp_iflist_print+0x134>
    3f12:	8d cf       	rjmp	.-230    	; 0x3e2e <csp_iflist_print+0x4e>
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
	}

}
    3f14:	e2 96       	adiw	r28, 0x32	; 50
    3f16:	0f b6       	in	r0, 0x3f	; 63
    3f18:	f8 94       	cli
    3f1a:	de bf       	out	0x3e, r29	; 62
    3f1c:	0f be       	out	0x3f, r0	; 63
    3f1e:	cd bf       	out	0x3d, r28	; 61
    3f20:	df 91       	pop	r29
    3f22:	cf 91       	pop	r28
    3f24:	1f 91       	pop	r17
    3f26:	0f 91       	pop	r16
    3f28:	ff 90       	pop	r15
    3f2a:	ef 90       	pop	r14
    3f2c:	df 90       	pop	r13
    3f2e:	cf 90       	pop	r12
    3f30:	bf 90       	pop	r11
    3f32:	af 90       	pop	r10
    3f34:	08 95       	ret

00003f36 <csp_can_pbuf_free>:
{
	buf->last_used = csp_get_ms();
}

static int csp_can_pbuf_free(csp_can_pbuf_element_t *buf)
{
    3f36:	cf 93       	push	r28
    3f38:	df 93       	push	r29
    3f3a:	ec 01       	movw	r28, r24
	/* Free CSP packet */
	if (buf->packet != NULL)
    3f3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f40:	00 97       	sbiw	r24, 0x00	; 0
    3f42:	09 f0       	breq	.+2      	; 0x3f46 <csp_can_pbuf_free+0x10>
		csp_buffer_free(buf->packet);
    3f44:	1d d9       	rcall	.-3526   	; 0x3180 <csp_buffer_free>

	/* Mark buffer element free */
	buf->packet = NULL;
    3f46:	1b 86       	std	Y+11, r1	; 0x0b
    3f48:	1a 86       	std	Y+10, r1	; 0x0a
	buf->state = BUF_FREE;
    3f4a:	1c 86       	std	Y+12, r1	; 0x0c
	buf->rx_count = 0;
    3f4c:	19 82       	std	Y+1, r1	; 0x01
    3f4e:	18 82       	st	Y, r1
	buf->cfpid = 0;
    3f50:	1e 82       	std	Y+6, r1	; 0x06
    3f52:	1f 82       	std	Y+7, r1	; 0x07
    3f54:	18 86       	std	Y+8, r1	; 0x08
    3f56:	19 86       	std	Y+9, r1	; 0x09
	buf->last_used = 0;
    3f58:	1d 86       	std	Y+13, r1	; 0x0d
    3f5a:	1e 86       	std	Y+14, r1	; 0x0e
    3f5c:	1f 86       	std	Y+15, r1	; 0x0f
    3f5e:	18 8a       	std	Y+16, r1	; 0x10
	buf->remain = 0;
    3f60:	1a 82       	std	Y+2, r1	; 0x02
    3f62:	1b 82       	std	Y+3, r1	; 0x03
    3f64:	1c 82       	std	Y+4, r1	; 0x04
    3f66:	1d 82       	std	Y+5, r1	; 0x05

	return CSP_ERR_NONE;
}
    3f68:	80 e0       	ldi	r24, 0x00	; 0
    3f6a:	90 e0       	ldi	r25, 0x00	; 0
    3f6c:	df 91       	pop	r29
    3f6e:	cf 91       	pop	r28
    3f70:	08 95       	ret

00003f72 <csp_can_tx>:

	return CSP_ERR_NONE;
}

static int csp_can_tx(csp_iface_t *interface, csp_packet_t *packet, uint32_t timeout)
{
    3f72:	2f 92       	push	r2
    3f74:	3f 92       	push	r3
    3f76:	4f 92       	push	r4
    3f78:	5f 92       	push	r5
    3f7a:	6f 92       	push	r6
    3f7c:	7f 92       	push	r7
    3f7e:	8f 92       	push	r8
    3f80:	9f 92       	push	r9
    3f82:	af 92       	push	r10
    3f84:	bf 92       	push	r11
    3f86:	cf 92       	push	r12
    3f88:	df 92       	push	r13
    3f8a:	ef 92       	push	r14
    3f8c:	ff 92       	push	r15
    3f8e:	0f 93       	push	r16
    3f90:	1f 93       	push	r17
    3f92:	cf 93       	push	r28
    3f94:	df 93       	push	r29
    3f96:	cd b7       	in	r28, 0x3d	; 61
    3f98:	de b7       	in	r29, 0x3e	; 62
    3f9a:	60 97       	sbiw	r28, 0x10	; 16
    3f9c:	0f b6       	in	r0, 0x3f	; 63
    3f9e:	f8 94       	cli
    3fa0:	de bf       	out	0x3e, r29	; 62
    3fa2:	0f be       	out	0x3f, r0	; 63
    3fa4:	cd bf       	out	0x3d, r28	; 61
    3fa6:	7a 87       	std	Y+10, r23	; 0x0a
    3fa8:	69 87       	std	Y+9, r22	; 0x09
}

static int csp_can_id_get(void)
{
	int id;
	if (csp_bin_sem_wait(&csp_can_id_sem, 1000) != CSP_SEMAPHORE_OK)
    3faa:	48 ee       	ldi	r20, 0xE8	; 232
    3fac:	53 e0       	ldi	r21, 0x03	; 3
    3fae:	60 e0       	ldi	r22, 0x00	; 0
    3fb0:	70 e0       	ldi	r23, 0x00	; 0
    3fb2:	81 ea       	ldi	r24, 0xA1	; 161
    3fb4:	95 e0       	ldi	r25, 0x05	; 5
    3fb6:	0e 94 76 2c 	call	0x58ec	; 0x58ec <csp_bin_sem_wait>
    3fba:	01 97       	sbiw	r24, 0x01	; 1
    3fbc:	89 f4       	brne	.+34     	; 0x3fe0 <csp_can_tx+0x6e>
		return CSP_ERR_TIMEDOUT;
	id = csp_can_id++;
    3fbe:	80 90 a3 05 	lds	r8, 0x05A3	; 0x8005a3 <csp_can_id>
    3fc2:	90 90 a4 05 	lds	r9, 0x05A4	; 0x8005a4 <csp_can_id+0x1>
	csp_can_id = csp_can_id & ((1 << CFP_ID_SIZE) - 1);
    3fc6:	c4 01       	movw	r24, r8
    3fc8:	01 96       	adiw	r24, 0x01	; 1
    3fca:	93 70       	andi	r25, 0x03	; 3
    3fcc:	90 93 a4 05 	sts	0x05A4, r25	; 0x8005a4 <csp_can_id+0x1>
    3fd0:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <csp_can_id>
	csp_bin_sem_post(&csp_can_id_sem);
    3fd4:	81 ea       	ldi	r24, 0xA1	; 161
    3fd6:	95 e0       	ldi	r25, 0x05	; 5
    3fd8:	0e 94 b1 2c 	call	0x5962	; 0x5962 <csp_bin_sem_post>
	uint8_t bytes, overhead, avail, dest;
	uint8_t frame_buf[8];

	/* Get CFP identification number */
	int ident = csp_can_id_get();
	if (ident < 0) {
    3fdc:	99 20       	and	r9, r9
    3fde:	7c f4       	brge	.+30     	; 0x3ffe <csp_can_tx+0x8c>
		csp_log_warn("Failed to get CFP identification number");
    3fe0:	84 e4       	ldi	r24, 0x44	; 68
    3fe2:	9a e0       	ldi	r25, 0x0A	; 10
    3fe4:	9f 93       	push	r25
    3fe6:	8f 93       	push	r24
    3fe8:	81 e0       	ldi	r24, 0x01	; 1
    3fea:	8f 93       	push	r24
    3fec:	79 dd       	rcall	.-1294   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_INVAL;
    3fee:	0f 90       	pop	r0
    3ff0:	0f 90       	pop	r0
    3ff2:	0f 90       	pop	r0
    3ff4:	4e ef       	ldi	r20, 0xFE	; 254
    3ff6:	5f ef       	ldi	r21, 0xFF	; 255
    3ff8:	58 8b       	std	Y+16, r21	; 0x10
    3ffa:	4f 87       	std	Y+15, r20	; 0x0f
    3ffc:	16 c1       	rjmp	.+556    	; 0x422a <csp_can_tx+0x2b8>

	/* Calculate overhead */
	overhead = sizeof(csp_id_t) + sizeof(uint16_t);

	/* Insert destination node mac address into the CFP destination field */
	dest = csp_rtable_find_mac(packet->id.dst);
    3ffe:	a9 85       	ldd	r26, Y+9	; 0x09
    4000:	ba 85       	ldd	r27, Y+10	; 0x0a
    4002:	1c 96       	adiw	r26, 0x0c	; 12
    4004:	9c 91       	ld	r25, X
    4006:	1c 97       	sbiw	r26, 0x0c	; 12
    4008:	92 95       	swap	r25
    400a:	9f 70       	andi	r25, 0x0F	; 15
    400c:	1d 96       	adiw	r26, 0x0d	; 13
    400e:	8c 91       	ld	r24, X
    4010:	81 70       	andi	r24, 0x01	; 1
    4012:	82 95       	swap	r24
    4014:	80 7f       	andi	r24, 0xF0	; 240
    4016:	89 2b       	or	r24, r25
    4018:	0e 94 97 2b 	call	0x572e	; 0x572e <csp_rtable_find_mac>
	if (dest == CSP_NODE_MAC)
    401c:	8f 3f       	cpi	r24, 0xFF	; 255
    401e:	59 f4       	brne	.+22     	; 0x4036 <csp_can_tx+0xc4>
		dest = packet->id.dst;
    4020:	e9 85       	ldd	r30, Y+9	; 0x09
    4022:	fa 85       	ldd	r31, Y+10	; 0x0a
    4024:	84 85       	ldd	r24, Z+12	; 0x0c
    4026:	98 2f       	mov	r25, r24
    4028:	92 95       	swap	r25
    402a:	9f 70       	andi	r25, 0x0F	; 15
    402c:	85 85       	ldd	r24, Z+13	; 0x0d
    402e:	81 70       	andi	r24, 0x01	; 1
    4030:	82 95       	swap	r24
    4032:	80 7f       	andi	r24, 0xF0	; 240
    4034:	89 2b       	or	r24, r25

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
	id |= CFP_MAKE_DST(dest);
    4036:	8f 71       	andi	r24, 0x1F	; 31
    4038:	c8 2e       	mov	r12, r24
    403a:	d1 2c       	mov	r13, r1
    403c:	e1 2c       	mov	r14, r1
    403e:	f1 2c       	mov	r15, r1
    4040:	0b 2e       	mov	r0, r27
    4042:	b3 e1       	ldi	r27, 0x13	; 19
    4044:	cc 0c       	add	r12, r12
    4046:	dd 1c       	adc	r13, r13
    4048:	ee 1c       	adc	r14, r14
    404a:	ff 1c       	adc	r15, r15
    404c:	ba 95       	dec	r27
    404e:	d1 f7       	brne	.-12     	; 0x4044 <csp_can_tx+0xd2>
    4050:	b0 2d       	mov	r27, r0
	id |= CFP_MAKE_ID(ident);
    4052:	f3 e0       	ldi	r31, 0x03	; 3
    4054:	9f 22       	and	r9, r31
    4056:	09 2c       	mov	r0, r9
    4058:	00 0c       	add	r0, r0
    405a:	aa 08       	sbc	r10, r10
    405c:	bb 08       	sbc	r11, r11
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    405e:	a9 85       	ldd	r26, Y+9	; 0x09
    4060:	ba 85       	ldd	r27, Y+10	; 0x0a
    4062:	18 96       	adiw	r26, 0x08	; 8
    4064:	2d 91       	ld	r18, X+
    4066:	3c 91       	ld	r19, X
    4068:	19 97       	sbiw	r26, 0x09	; 9
    406a:	c9 01       	movw	r24, r18
    406c:	05 96       	adiw	r24, 0x05	; 5
    406e:	96 95       	lsr	r25
    4070:	87 95       	ror	r24
    4072:	96 95       	lsr	r25
    4074:	87 95       	ror	r24
    4076:	96 95       	lsr	r25
    4078:	87 95       	ror	r24
    407a:	90 e0       	ldi	r25, 0x00	; 0
    407c:	a0 e0       	ldi	r26, 0x00	; 0
    407e:	b0 e0       	ldi	r27, 0x00	; 0
    4080:	07 2e       	mov	r0, r23
    4082:	7a e0       	ldi	r23, 0x0A	; 10
    4084:	88 0f       	add	r24, r24
    4086:	99 1f       	adc	r25, r25
    4088:	aa 1f       	adc	r26, r26
    408a:	bb 1f       	adc	r27, r27
    408c:	7a 95       	dec	r23
    408e:	d1 f7       	brne	.-12     	; 0x4084 <csp_can_tx+0x112>
    4090:	70 2d       	mov	r23, r0
	if (dest == CSP_NODE_MAC)
		dest = packet->id.dst;

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
    4092:	e9 85       	ldd	r30, Y+9	; 0x09
    4094:	fa 85       	ldd	r31, Y+10	; 0x0a
    4096:	45 85       	ldd	r20, Z+13	; 0x0d
    4098:	46 95       	lsr	r20
    409a:	4f 71       	andi	r20, 0x1F	; 31
	id |= CFP_MAKE_DST(dest);
	id |= CFP_MAKE_ID(ident);
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    409c:	24 01       	movw	r4, r8
    409e:	35 01       	movw	r6, r10
    40a0:	74 2a       	or	r7, r20
    40a2:	84 29       	or	r24, r4
    40a4:	95 29       	or	r25, r5
    40a6:	a6 29       	or	r26, r6
    40a8:	b7 29       	or	r27, r7
    40aa:	2c 01       	movw	r4, r24
    40ac:	3d 01       	movw	r6, r26
    40ae:	4c 28       	or	r4, r12
    40b0:	5d 28       	or	r5, r13
    40b2:	6e 28       	or	r6, r14
    40b4:	7f 28       	or	r7, r15
    40b6:	4b 86       	std	Y+11, r4	; 0x0b
    40b8:	5c 86       	std	Y+12, r5	; 0x0c
    40ba:	6d 86       	std	Y+13, r6	; 0x0d
    40bc:	7e 86       	std	Y+14, r7	; 0x0e

	/* Calculate first frame data bytes */
	avail = 8 - overhead;
	bytes = (packet->length <= avail) ? packet->length : avail;
    40be:	39 01       	movw	r6, r18
    40c0:	23 30       	cpi	r18, 0x03	; 3
    40c2:	31 05       	cpc	r19, r1
    40c4:	20 f0       	brcs	.+8      	; 0x40ce <csp_can_tx+0x15c>
    40c6:	68 94       	set
    40c8:	66 24       	eor	r6, r6
    40ca:	61 f8       	bld	r6, 1
    40cc:	71 2c       	mov	r7, r1

	/* Copy CSP headers and data */
	uint32_t csp_id_be = csp_hton32(packet->id.ext);
    40ce:	a9 85       	ldd	r26, Y+9	; 0x09
    40d0:	ba 85       	ldd	r27, Y+10	; 0x0a
    40d2:	1a 96       	adiw	r26, 0x0a	; 10
    40d4:	6d 91       	ld	r22, X+
    40d6:	7d 91       	ld	r23, X+
    40d8:	8d 91       	ld	r24, X+
    40da:	9c 91       	ld	r25, X
    40dc:	1d 97       	sbiw	r26, 0x0d	; 13
    40de:	7f dd       	rcall	.-1282   	; 0x3bde <csp_hton32>
    40e0:	1b 01       	movw	r2, r22
    40e2:	2c 01       	movw	r4, r24
	uint16_t csp_length_be = csp_hton16(packet->length);
    40e4:	e9 85       	ldd	r30, Y+9	; 0x09
    40e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    40e8:	80 85       	ldd	r24, Z+8	; 0x08
    40ea:	91 85       	ldd	r25, Z+9	; 0x09
    40ec:	70 dd       	rcall	.-1312   	; 0x3bce <csp_hton16>

	memcpy(frame_buf, &csp_id_be, sizeof(csp_id_be));
    40ee:	29 82       	std	Y+1, r2	; 0x01
    40f0:	3a 82       	std	Y+2, r3	; 0x02
    40f2:	4b 82       	std	Y+3, r4	; 0x03
    40f4:	5c 82       	std	Y+4, r5	; 0x04
	memcpy(frame_buf + sizeof(csp_id_be), &csp_length_be, sizeof(csp_length_be));
    40f6:	9e 83       	std	Y+6, r25	; 0x06
    40f8:	8d 83       	std	Y+5, r24	; 0x05
    40fa:	83 01       	movw	r16, r6
    40fc:	11 27       	eor	r17, r17
	memcpy(frame_buf + overhead, packet->data, bytes);
    40fe:	29 84       	ldd	r2, Y+9	; 0x09
    4100:	3a 84       	ldd	r3, Y+10	; 0x0a
    4102:	fe e0       	ldi	r31, 0x0E	; 14
    4104:	2f 0e       	add	r2, r31
    4106:	31 1c       	adc	r3, r1
    4108:	a8 01       	movw	r20, r16
    410a:	b1 01       	movw	r22, r2
    410c:	ce 01       	movw	r24, r28
    410e:	07 96       	adiw	r24, 0x07	; 7
    4110:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>

	/* Increment tx counter */
	tx_count = bytes;

	/* Send first frame */
	if (can_send(id, frame_buf, overhead + bytes)) {
    4114:	26 e0       	ldi	r18, 0x06	; 6
    4116:	26 0d       	add	r18, r6
    4118:	ae 01       	movw	r20, r28
    411a:	4f 5f       	subi	r20, 0xFF	; 255
    411c:	5f 4f       	sbci	r21, 0xFF	; 255
    411e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4120:	7c 85       	ldd	r23, Y+12	; 0x0c
    4122:	8d 85       	ldd	r24, Y+13	; 0x0d
    4124:	9e 85       	ldd	r25, Y+14	; 0x0e
    4126:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <can_send>
    412a:	98 8b       	std	Y+16, r25	; 0x10
    412c:	8f 87       	std	Y+15, r24	; 0x0f
    412e:	89 2b       	or	r24, r25
    4130:	09 f4       	brne	.+2      	; 0x4134 <csp_can_tx+0x1c2>
    4132:	6e c0       	rjmp	.+220    	; 0x4210 <csp_can_tx+0x29e>
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
    4134:	8d e1       	ldi	r24, 0x1D	; 29
    4136:	9a e0       	ldi	r25, 0x0A	; 10
    4138:	9f 93       	push	r25
    413a:	8f 93       	push	r24
    413c:	81 e0       	ldi	r24, 0x01	; 1
    413e:	8f 93       	push	r24
    4140:	cf dc       	rcall	.-1634   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_DRIVER;
    4142:	0f 90       	pop	r0
    4144:	0f 90       	pop	r0
    4146:	0f 90       	pop	r0
    4148:	45 ef       	ldi	r20, 0xF5	; 245
    414a:	5f ef       	ldi	r21, 0xFF	; 255
    414c:	58 8b       	std	Y+16, r21	; 0x10
    414e:	4f 87       	std	Y+15, r20	; 0x0f
    4150:	6c c0       	rjmp	.+216    	; 0x422a <csp_can_tx+0x2b8>
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
		/* Calculate frame data bytes */
		bytes = (packet->length - tx_count >= 8) ? 8 : packet->length - tx_count;
    4152:	80 1b       	sub	r24, r16
    4154:	91 0b       	sbc	r25, r17
    4156:	fc 01       	movw	r30, r24
    4158:	89 30       	cpi	r24, 0x09	; 9
    415a:	91 05       	cpc	r25, r1
    415c:	10 f0       	brcs	.+4      	; 0x4162 <csp_can_tx+0x1f0>
    415e:	e8 e0       	ldi	r30, 0x08	; 8
    4160:	f0 e0       	ldi	r31, 0x00	; 0

		/* Prepare identifier */
		can_id_t id = 0;
		id |= CFP_MAKE_SRC(packet->id.src);
    4162:	a9 85       	ldd	r26, Y+9	; 0x09
    4164:	ba 85       	ldd	r27, Y+10	; 0x0a
    4166:	1d 96       	adiw	r26, 0x0d	; 13
    4168:	2c 91       	ld	r18, X
    416a:	26 95       	lsr	r18
    416c:	2f 71       	andi	r18, 0x1F	; 31
		id |= CFP_MAKE_DST(dest);
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
    416e:	24 01       	movw	r4, r8
    4170:	35 01       	movw	r6, r10
    4172:	72 2a       	or	r7, r18
    4174:	68 94       	set
    4176:	62 f8       	bld	r6, 2
    4178:	4c 28       	or	r4, r12
    417a:	5d 28       	or	r5, r13
    417c:	6e 28       	or	r6, r14
    417e:	7f 28       	or	r7, r15
    4180:	9f 01       	movw	r18, r30
    4182:	33 27       	eor	r19, r19
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    4184:	a8 01       	movw	r20, r16
    4186:	42 0f       	add	r20, r18
    4188:	53 1f       	adc	r21, r19
    418a:	5c 87       	std	Y+12, r21	; 0x0c
    418c:	4b 87       	std	Y+11, r20	; 0x0b

		/* Send frame */
		if (can_send(id, packet->data + tx_count - bytes, bytes)) {
    418e:	a1 01       	movw	r20, r2
    4190:	40 0f       	add	r20, r16
    4192:	51 1f       	adc	r21, r17
    4194:	07 96       	adiw	r24, 0x07	; 7
    4196:	82 1b       	sub	r24, r18
    4198:	93 0b       	sbc	r25, r19
    419a:	96 95       	lsr	r25
    419c:	87 95       	ror	r24
    419e:	96 95       	lsr	r25
    41a0:	87 95       	ror	r24
    41a2:	96 95       	lsr	r25
    41a4:	87 95       	ror	r24
    41a6:	90 e0       	ldi	r25, 0x00	; 0
    41a8:	a0 e0       	ldi	r26, 0x00	; 0
    41aa:	b0 e0       	ldi	r27, 0x00	; 0
    41ac:	07 2e       	mov	r0, r23
    41ae:	7a e0       	ldi	r23, 0x0A	; 10
    41b0:	88 0f       	add	r24, r24
    41b2:	99 1f       	adc	r25, r25
    41b4:	aa 1f       	adc	r26, r26
    41b6:	bb 1f       	adc	r27, r27
    41b8:	7a 95       	dec	r23
    41ba:	d1 f7       	brne	.-12     	; 0x41b0 <csp_can_tx+0x23e>
    41bc:	70 2d       	mov	r23, r0
    41be:	bc 01       	movw	r22, r24
    41c0:	cd 01       	movw	r24, r26
    41c2:	64 29       	or	r22, r4
    41c4:	75 29       	or	r23, r5
    41c6:	86 29       	or	r24, r6
    41c8:	97 29       	or	r25, r7
    41ca:	2e 2f       	mov	r18, r30
    41cc:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <can_send>
    41d0:	89 2b       	or	r24, r25
    41d2:	e1 f0       	breq	.+56     	; 0x420c <csp_can_tx+0x29a>
			csp_log_warn("Failed to send CAN frame in Tx callback");
    41d4:	85 ef       	ldi	r24, 0xF5	; 245
    41d6:	99 e0       	ldi	r25, 0x09	; 9
    41d8:	9f 93       	push	r25
    41da:	8f 93       	push	r24
    41dc:	81 e0       	ldi	r24, 0x01	; 1
    41de:	8f 93       	push	r24
    41e0:	7f dc       	rcall	.-1794   	; 0x3ae0 <do_csp_debug>
			csp_if_can.tx_error++;
    41e2:	e2 e1       	ldi	r30, 0x12	; 18
    41e4:	f2 e0       	ldi	r31, 0x02	; 2
    41e6:	81 89       	ldd	r24, Z+17	; 0x11
    41e8:	92 89       	ldd	r25, Z+18	; 0x12
    41ea:	a3 89       	ldd	r26, Z+19	; 0x13
    41ec:	b4 89       	ldd	r27, Z+20	; 0x14
    41ee:	01 96       	adiw	r24, 0x01	; 1
    41f0:	a1 1d       	adc	r26, r1
    41f2:	b1 1d       	adc	r27, r1
    41f4:	81 8b       	std	Z+17, r24	; 0x11
    41f6:	92 8b       	std	Z+18, r25	; 0x12
    41f8:	a3 8b       	std	Z+19, r26	; 0x13
    41fa:	b4 8b       	std	Z+20, r27	; 0x14
			return CSP_ERR_DRIVER;
    41fc:	0f 90       	pop	r0
    41fe:	0f 90       	pop	r0
    4200:	0f 90       	pop	r0
    4202:	65 ef       	ldi	r22, 0xF5	; 245
    4204:	7f ef       	ldi	r23, 0xFF	; 255
    4206:	78 8b       	std	Y+16, r23	; 0x10
    4208:	6f 87       	std	Y+15, r22	; 0x0f
    420a:	0f c0       	rjmp	.+30     	; 0x422a <csp_can_tx+0x2b8>
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    420c:	0b 85       	ldd	r16, Y+11	; 0x0b
    420e:	1c 85       	ldd	r17, Y+12	; 0x0c
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
		return CSP_ERR_DRIVER;
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
    4210:	a9 85       	ldd	r26, Y+9	; 0x09
    4212:	ba 85       	ldd	r27, Y+10	; 0x0a
    4214:	18 96       	adiw	r26, 0x08	; 8
    4216:	8d 91       	ld	r24, X+
    4218:	9c 91       	ld	r25, X
    421a:	19 97       	sbiw	r26, 0x09	; 9
    421c:	08 17       	cp	r16, r24
    421e:	19 07       	cpc	r17, r25
    4220:	08 f4       	brcc	.+2      	; 0x4224 <csp_can_tx+0x2b2>
    4222:	97 cf       	rjmp	.-210    	; 0x4152 <csp_can_tx+0x1e0>
			csp_if_can.tx_error++;
			return CSP_ERR_DRIVER;
		}
	}

	csp_buffer_free(packet);
    4224:	cd 01       	movw	r24, r26
    4226:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>

	return CSP_ERR_NONE;
}
    422a:	8f 85       	ldd	r24, Y+15	; 0x0f
    422c:	98 89       	ldd	r25, Y+16	; 0x10
    422e:	60 96       	adiw	r28, 0x10	; 16
    4230:	0f b6       	in	r0, 0x3f	; 63
    4232:	f8 94       	cli
    4234:	de bf       	out	0x3e, r29	; 62
    4236:	0f be       	out	0x3f, r0	; 63
    4238:	cd bf       	out	0x3d, r28	; 61
    423a:	df 91       	pop	r29
    423c:	cf 91       	pop	r28
    423e:	1f 91       	pop	r17
    4240:	0f 91       	pop	r16
    4242:	ff 90       	pop	r15
    4244:	ef 90       	pop	r14
    4246:	df 90       	pop	r13
    4248:	cf 90       	pop	r12
    424a:	bf 90       	pop	r11
    424c:	af 90       	pop	r10
    424e:	9f 90       	pop	r9
    4250:	8f 90       	pop	r8
    4252:	7f 90       	pop	r7
    4254:	6f 90       	pop	r6
    4256:	5f 90       	pop	r5
    4258:	4f 90       	pop	r4
    425a:	3f 90       	pop	r3
    425c:	2f 90       	pop	r2
    425e:	08 95       	ret

00004260 <csp_can_rx_task>:

	return CSP_ERR_NONE;
}

static CSP_DEFINE_TASK(csp_can_rx_task)
{
    4260:	cf 93       	push	r28
    4262:	df 93       	push	r29
    4264:	cd b7       	in	r28, 0x3d	; 61
    4266:	de b7       	in	r29, 0x3e	; 62
    4268:	2d 97       	sbiw	r28, 0x0d	; 13
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	f8 94       	cli
    426e:	de bf       	out	0x3e, r29	; 62
    4270:	0f be       	out	0x3f, r0	; 63
    4272:	cd bf       	out	0x3d, r28	; 61
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    4274:	0f 2e       	mov	r0, r31
    4276:	f3 ef       	ldi	r31, 0xF3	; 243
    4278:	2f 2e       	mov	r2, r31
    427a:	f4 e0       	ldi	r31, 0x04	; 4
    427c:	3f 2e       	mov	r3, r31
    427e:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    4280:	0f 2e       	mov	r0, r31
    4282:	fe e7       	ldi	r31, 0x7E	; 126
    4284:	ef 2e       	mov	r14, r31
    4286:	fb e0       	ldi	r31, 0x0B	; 11
    4288:	ff 2e       	mov	r15, r31
    428a:	f0 2d       	mov	r31, r0
	can_frame_t frame;

	while (1) {
		//csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		
		ret = csp_queue_dequeue(csp_can_rx_queue, &frame, 1000);
    428c:	28 ee       	ldi	r18, 0xE8	; 232
    428e:	33 e0       	ldi	r19, 0x03	; 3
    4290:	40 e0       	ldi	r20, 0x00	; 0
    4292:	50 e0       	ldi	r21, 0x00	; 0
    4294:	be 01       	movw	r22, r28
    4296:	6f 5f       	subi	r22, 0xFF	; 255
    4298:	7f 4f       	sbci	r23, 0xFF	; 255
    429a:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <csp_can_rx_queue>
    429e:	90 91 9e 05 	lds	r25, 0x059E	; 0x80059e <csp_can_rx_queue+0x1>
    42a2:	5d d7       	rcall	.+3770   	; 0x515e <csp_queue_dequeue>
		if (ret != CSP_QUEUE_OK) {
    42a4:	01 97       	sbiw	r24, 0x01	; 1
    42a6:	89 f1       	breq	.+98     	; 0x430a <csp_can_rx_task+0xaa>
    42a8:	03 ef       	ldi	r16, 0xF3	; 243
    42aa:	14 e0       	ldi	r17, 0x04	; 4
    42ac:	0f 2e       	mov	r0, r31
    42ae:	fd e9       	ldi	r31, 0x9D	; 157
    42b0:	cf 2e       	mov	r12, r31
    42b2:	f5 e0       	ldi	r31, 0x05	; 5
    42b4:	df 2e       	mov	r13, r31
    42b6:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    42b8:	99 24       	eor	r9, r9
    42ba:	93 94       	inc	r9

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];

		/* Skip if not used */
		if (buf->state != BUF_USED)
    42bc:	d8 01       	movw	r26, r16
    42be:	1c 96       	adiw	r26, 0x0c	; 12
    42c0:	8c 91       	ld	r24, X
    42c2:	81 30       	cpi	r24, 0x01	; 1
    42c4:	e1 f4       	brne	.+56     	; 0x42fe <csp_can_rx_task+0x9e>
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
    42c6:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
    42ca:	f8 01       	movw	r30, r16
    42cc:	45 84       	ldd	r4, Z+13	; 0x0d
    42ce:	56 84       	ldd	r5, Z+14	; 0x0e
    42d0:	67 84       	ldd	r6, Z+15	; 0x0f
    42d2:	70 88       	ldd	r7, Z+16	; 0x10
    42d4:	dc 01       	movw	r26, r24
    42d6:	cb 01       	movw	r24, r22
    42d8:	84 19       	sub	r24, r4
    42da:	95 09       	sbc	r25, r5
    42dc:	a6 09       	sbc	r26, r6
    42de:	b7 09       	sbc	r27, r7
    42e0:	81 3d       	cpi	r24, 0xD1	; 209
    42e2:	97 40       	sbci	r25, 0x07	; 7
    42e4:	a1 05       	cpc	r26, r1
    42e6:	b1 05       	cpc	r27, r1
    42e8:	50 f0       	brcs	.+20     	; 0x42fe <csp_can_rx_task+0x9e>
			csp_log_warn("CAN Buffer element timed out");
    42ea:	ff 92       	push	r15
    42ec:	ef 92       	push	r14
    42ee:	9f 92       	push	r9
    42f0:	f7 db       	rcall	.-2066   	; 0x3ae0 <do_csp_debug>
			/* Recycle packet buffer */
			csp_can_pbuf_free(buf);
    42f2:	80 2f       	mov	r24, r16
    42f4:	91 2f       	mov	r25, r17
    42f6:	1f de       	rcall	.-962    	; 0x3f36 <csp_can_pbuf_free>
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	0f 5e       	subi	r16, 0xEF	; 239
    4300:	1f 4f       	sbci	r17, 0xFF	; 255
static void csp_can_pbuf_cleanup(void)
{
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    4302:	c0 16       	cp	r12, r16
    4304:	d1 06       	cpc	r13, r17
    4306:	d1 f6       	brne	.-76     	; 0x42bc <csp_can_rx_task+0x5c>
    4308:	c1 cf       	rjmp	.-126    	; 0x428c <csp_can_rx_task+0x2c>
static int csp_can_process_frame(can_frame_t *frame)
{
	csp_can_pbuf_element_t *buf;
	uint8_t offset;

	can_id_t id = frame->id;
    430a:	89 80       	ldd	r8, Y+1	; 0x01
    430c:	9a 80       	ldd	r9, Y+2	; 0x02
    430e:	ab 80       	ldd	r10, Y+3	; 0x03
    4310:	bc 80       	ldd	r11, Y+4	; 0x04
    4312:	e9 ef       	ldi	r30, 0xF9	; 249
    4314:	f4 e0       	ldi	r31, 0x04	; 4
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    4316:	80 e0       	ldi	r24, 0x00	; 0
    4318:	90 e0       	ldi	r25, 0x00	; 0
		buf = &csp_can_pbuf[i];

		if ((buf->state == BUF_USED) && ((buf->cfpid & mask) == (id & mask))) {
    431a:	26 81       	ldd	r18, Z+6	; 0x06
    431c:	21 30       	cpi	r18, 0x01	; 1
    431e:	d1 f5       	brne	.+116    	; 0x4394 <csp_can_rx_task+0x134>
    4320:	40 81       	ld	r20, Z
    4322:	51 81       	ldd	r21, Z+1	; 0x01
    4324:	62 81       	ldd	r22, Z+2	; 0x02
    4326:	73 81       	ldd	r23, Z+3	; 0x03
    4328:	48 25       	eor	r20, r8
    432a:	59 25       	eor	r21, r9
    432c:	6a 25       	eor	r22, r10
    432e:	7b 25       	eor	r23, r11
    4330:	53 70       	andi	r21, 0x03	; 3
    4332:	68 7f       	andi	r22, 0xF8	; 248
    4334:	7f 71       	andi	r23, 0x1F	; 31
    4336:	45 2b       	or	r20, r21
    4338:	46 2b       	or	r20, r22
    433a:	47 2b       	or	r20, r23
    433c:	59 f5       	brne	.+86     	; 0x4394 <csp_can_rx_task+0x134>
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    433e:	21 e1       	ldi	r18, 0x11	; 17
    4340:	28 9f       	mul	r18, r24
    4342:	80 01       	movw	r16, r0
    4344:	29 9f       	mul	r18, r25
    4346:	10 0d       	add	r17, r0
    4348:	11 24       	eor	r1, r1
    434a:	0d 50       	subi	r16, 0x0D	; 13
    434c:	1b 4f       	sbci	r17, 0xFB	; 251
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    434e:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
    4352:	d8 01       	movw	r26, r16
    4354:	1d 96       	adiw	r26, 0x0d	; 13
    4356:	6d 93       	st	X+, r22
    4358:	7d 93       	st	X+, r23
    435a:	8d 93       	st	X+, r24
    435c:	9c 93       	st	X, r25
    435e:	50 97       	sbiw	r26, 0x10	; 16
	}

	/* Reset frame data offset */
	offset = 0;

	switch (CFP_TYPE(id)) {
    4360:	d5 01       	movw	r26, r10
    4362:	c4 01       	movw	r24, r8
    4364:	07 2e       	mov	r0, r23
    4366:	72 e1       	ldi	r23, 0x12	; 18
    4368:	b6 95       	lsr	r27
    436a:	a7 95       	ror	r26
    436c:	97 95       	ror	r25
    436e:	87 95       	ror	r24
    4370:	7a 95       	dec	r23
    4372:	d1 f7       	brne	.-12     	; 0x4368 <csp_can_rx_task+0x108>
    4374:	70 2d       	mov	r23, r0
    4376:	ac 01       	movw	r20, r24
    4378:	bd 01       	movw	r22, r26
    437a:	41 70       	andi	r20, 0x01	; 1
    437c:	55 27       	eor	r21, r21
    437e:	66 27       	eor	r22, r22
    4380:	77 27       	eor	r23, r23
    4382:	80 ff       	sbrs	r24, 0
    4384:	70 c0       	rjmp	.+224    	; 0x4466 <csp_can_rx_task+0x206>
    4386:	41 30       	cpi	r20, 0x01	; 1
    4388:	51 05       	cpc	r21, r1
    438a:	61 05       	cpc	r22, r1
    438c:	71 05       	cpc	r23, r1
    438e:	09 f4       	brne	.+2      	; 0x4392 <csp_can_rx_task+0x132>
    4390:	18 c1       	rjmp	.+560    	; 0x45c2 <csp_can_rx_task+0x362>
    4392:	ab c1       	rjmp	.+854    	; 0x46ea <csp_can_rx_task+0x48a>
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    4394:	01 96       	adiw	r24, 0x01	; 1
    4396:	71 96       	adiw	r30, 0x11	; 17
    4398:	8a 30       	cpi	r24, 0x0A	; 10
    439a:	91 05       	cpc	r25, r1
    439c:	09 f0       	breq	.+2      	; 0x43a0 <csp_can_rx_task+0x140>
    439e:	bd cf       	rjmp	.-134    	; 0x431a <csp_can_rx_task+0xba>
	/* Bind incoming frame to a packet buffer */
	buf = csp_can_pbuf_find(id, CFP_ID_CONN_MASK);

	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
    43a0:	a2 fc       	sbrc	r10, 2
    43a2:	49 c0       	rjmp	.+146    	; 0x4436 <csp_can_rx_task+0x1d6>
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    43a4:	f1 01       	movw	r30, r2
    43a6:	84 85       	ldd	r24, Z+12	; 0x0c
    43a8:	88 23       	and	r24, r24
    43aa:	09 f4       	brne	.+2      	; 0x43ae <csp_can_rx_task+0x14e>
    43ac:	ab c1       	rjmp	.+854    	; 0x4704 <csp_can_rx_task+0x4a4>
    43ae:	e3 ef       	ldi	r30, 0xF3	; 243
    43b0:	f4 e0       	ldi	r31, 0x04	; 4
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    43b2:	81 e0       	ldi	r24, 0x01	; 1
    43b4:	90 e0       	ldi	r25, 0x00	; 0
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    43b6:	25 8d       	ldd	r18, Z+29	; 0x1d
    43b8:	21 11       	cpse	r18, r1
    43ba:	20 c0       	rjmp	.+64     	; 0x43fc <csp_can_rx_task+0x19c>
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    43bc:	21 e1       	ldi	r18, 0x11	; 17
    43be:	28 9f       	mul	r18, r24
    43c0:	80 01       	movw	r16, r0
    43c2:	29 9f       	mul	r18, r25
    43c4:	10 0d       	add	r17, r0
    43c6:	11 24       	eor	r1, r1
    43c8:	0d 50       	subi	r16, 0x0D	; 13
    43ca:	1b 4f       	sbci	r17, 0xFB	; 251
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    43cc:	81 e0       	ldi	r24, 0x01	; 1
    43ce:	d8 01       	movw	r26, r16
    43d0:	1c 96       	adiw	r26, 0x0c	; 12
    43d2:	8c 93       	st	X, r24
    43d4:	1c 97       	sbiw	r26, 0x0c	; 12
			buf->cfpid = id;
    43d6:	f8 01       	movw	r30, r16
    43d8:	86 82       	std	Z+6, r8	; 0x06
    43da:	97 82       	std	Z+7, r9	; 0x07
    43dc:	a0 86       	std	Z+8, r10	; 0x08
    43de:	b1 86       	std	Z+9, r11	; 0x09
			buf->remain = 0;
    43e0:	12 96       	adiw	r26, 0x02	; 2
    43e2:	1d 92       	st	X+, r1
    43e4:	1d 92       	st	X+, r1
    43e6:	1d 92       	st	X+, r1
    43e8:	1c 92       	st	X, r1
    43ea:	15 97       	sbiw	r26, 0x05	; 5
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    43ec:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
    43f0:	f8 01       	movw	r30, r16
    43f2:	65 87       	std	Z+13, r22	; 0x0d
    43f4:	76 87       	std	Z+14, r23	; 0x0e
    43f6:	87 87       	std	Z+15, r24	; 0x0f
    43f8:	90 8b       	std	Z+16, r25	; 0x10
    43fa:	35 c0       	rjmp	.+106    	; 0x4466 <csp_can_rx_task+0x206>
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    43fc:	01 96       	adiw	r24, 0x01	; 1
    43fe:	71 96       	adiw	r30, 0x11	; 17
    4400:	8a 30       	cpi	r24, 0x0A	; 10
    4402:	91 05       	cpc	r25, r1
    4404:	c1 f6       	brne	.-80     	; 0x43b6 <csp_can_rx_task+0x156>
	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
			buf = csp_can_pbuf_new(id);
			if (buf == NULL) {
				csp_log_warn("No available packet buffer for CAN");
    4406:	2b e5       	ldi	r18, 0x5B	; 91
    4408:	3b e0       	ldi	r19, 0x0B	; 11
    440a:	3f 93       	push	r19
    440c:	2f 93       	push	r18
    440e:	81 e0       	ldi	r24, 0x01	; 1
    4410:	8f 93       	push	r24
    4412:	66 db       	rcall	.-2356   	; 0x3ae0 <do_csp_debug>
				csp_if_can.rx_error++;
    4414:	e2 e1       	ldi	r30, 0x12	; 18
    4416:	f2 e0       	ldi	r31, 0x02	; 2
    4418:	85 89       	ldd	r24, Z+21	; 0x15
    441a:	96 89       	ldd	r25, Z+22	; 0x16
    441c:	a7 89       	ldd	r26, Z+23	; 0x17
    441e:	b0 8d       	ldd	r27, Z+24	; 0x18
    4420:	01 96       	adiw	r24, 0x01	; 1
    4422:	a1 1d       	adc	r26, r1
    4424:	b1 1d       	adc	r27, r1
    4426:	85 8b       	std	Z+21, r24	; 0x15
    4428:	96 8b       	std	Z+22, r25	; 0x16
    442a:	a7 8b       	std	Z+23, r26	; 0x17
    442c:	b0 8f       	std	Z+24, r27	; 0x18
    442e:	0f 90       	pop	r0
    4430:	0f 90       	pop	r0
    4432:	0f 90       	pop	r0
    4434:	2b cf       	rjmp	.-426    	; 0x428c <csp_can_rx_task+0x2c>
				return CSP_ERR_NOMEM;
			}
		} else {
			csp_log_warn("Out of order MORE frame received");
    4436:	aa e3       	ldi	r26, 0x3A	; 58
    4438:	bb e0       	ldi	r27, 0x0B	; 11
    443a:	bf 93       	push	r27
    443c:	af 93       	push	r26
    443e:	81 e0       	ldi	r24, 0x01	; 1
    4440:	8f 93       	push	r24
    4442:	4e db       	rcall	.-2404   	; 0x3ae0 <do_csp_debug>
			csp_if_can.frame++;
    4444:	e2 e1       	ldi	r30, 0x12	; 18
    4446:	f2 e0       	ldi	r31, 0x02	; 2
    4448:	81 a1       	ldd	r24, Z+33	; 0x21
    444a:	92 a1       	ldd	r25, Z+34	; 0x22
    444c:	a3 a1       	ldd	r26, Z+35	; 0x23
    444e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4450:	01 96       	adiw	r24, 0x01	; 1
    4452:	a1 1d       	adc	r26, r1
    4454:	b1 1d       	adc	r27, r1
    4456:	81 a3       	std	Z+33, r24	; 0x21
    4458:	92 a3       	std	Z+34, r25	; 0x22
    445a:	a3 a3       	std	Z+35, r26	; 0x23
    445c:	b4 a3       	std	Z+36, r27	; 0x24
    445e:	0f 90       	pop	r0
    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
    4464:	13 cf       	rjmp	.-474    	; 0x428c <csp_can_rx_task+0x2c>
	switch (CFP_TYPE(id)) {

	case CFP_BEGIN:

		/* Discard packet if DLC is less than CSP id + CSP length fields */
		if (frame->dlc < sizeof(csp_id_t) + sizeof(uint16_t)) {
    4466:	8d 81       	ldd	r24, Y+5	; 0x05
    4468:	86 30       	cpi	r24, 0x06	; 6
    446a:	d0 f4       	brcc	.+52     	; 0x44a0 <csp_can_rx_task+0x240>
			csp_log_warn("Short BEGIN frame received");
    446c:	2f e1       	ldi	r18, 0x1F	; 31
    446e:	3b e0       	ldi	r19, 0x0B	; 11
    4470:	3f 93       	push	r19
    4472:	2f 93       	push	r18
    4474:	81 e0       	ldi	r24, 0x01	; 1
    4476:	8f 93       	push	r24
    4478:	33 db       	rcall	.-2458   	; 0x3ae0 <do_csp_debug>
			csp_if_can.frame++;
    447a:	e2 e1       	ldi	r30, 0x12	; 18
    447c:	f2 e0       	ldi	r31, 0x02	; 2
    447e:	81 a1       	ldd	r24, Z+33	; 0x21
    4480:	92 a1       	ldd	r25, Z+34	; 0x22
    4482:	a3 a1       	ldd	r26, Z+35	; 0x23
    4484:	b4 a1       	ldd	r27, Z+36	; 0x24
    4486:	01 96       	adiw	r24, 0x01	; 1
    4488:	a1 1d       	adc	r26, r1
    448a:	b1 1d       	adc	r27, r1
    448c:	81 a3       	std	Z+33, r24	; 0x21
    448e:	92 a3       	std	Z+34, r25	; 0x22
    4490:	a3 a3       	std	Z+35, r26	; 0x23
			csp_can_pbuf_free(buf);
    4492:	b4 a3       	std	Z+36, r27	; 0x24
    4494:	c8 01       	movw	r24, r16
    4496:	4f dd       	rcall	.-1378   	; 0x3f36 <csp_can_pbuf_free>
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	0f 90       	pop	r0
    449e:	f6 ce       	rjmp	.-532    	; 0x428c <csp_can_rx_task+0x2c>
			break;
		}

		/* Check for incomplete frame */
		if (buf->packet != NULL) {
    44a0:	d8 01       	movw	r26, r16
    44a2:	1a 96       	adiw	r26, 0x0a	; 10
    44a4:	8d 91       	ld	r24, X+
    44a6:	9c 91       	ld	r25, X
    44a8:	1b 97       	sbiw	r26, 0x0b	; 11
    44aa:	89 2b       	or	r24, r25
			/* Reuse the buffer */
			csp_log_warn("Incomplete frame");
    44ac:	c1 f0       	breq	.+48     	; 0x44de <csp_can_rx_task+0x27e>
    44ae:	ee e0       	ldi	r30, 0x0E	; 14
    44b0:	fb e0       	ldi	r31, 0x0B	; 11
    44b2:	ff 93       	push	r31
    44b4:	ef 93       	push	r30
    44b6:	81 e0       	ldi	r24, 0x01	; 1
    44b8:	8f 93       	push	r24
    44ba:	12 db       	rcall	.-2524   	; 0x3ae0 <do_csp_debug>
			csp_if_can.frame++;
    44bc:	e2 e1       	ldi	r30, 0x12	; 18
    44be:	f2 e0       	ldi	r31, 0x02	; 2
    44c0:	81 a1       	ldd	r24, Z+33	; 0x21
    44c2:	92 a1       	ldd	r25, Z+34	; 0x22
    44c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    44c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    44c8:	01 96       	adiw	r24, 0x01	; 1
    44ca:	a1 1d       	adc	r26, r1
    44cc:	b1 1d       	adc	r27, r1
    44ce:	81 a3       	std	Z+33, r24	; 0x21
    44d0:	92 a3       	std	Z+34, r25	; 0x22
    44d2:	a3 a3       	std	Z+35, r26	; 0x23
    44d4:	b4 a3       	std	Z+36, r27	; 0x24
    44d6:	0f 90       	pop	r0
    44d8:	0f 90       	pop	r0
    44da:	0f 90       	pop	r0
    44dc:	24 c0       	rjmp	.+72     	; 0x4526 <csp_can_rx_task+0x2c6>
		} else {
			/* Allocate memory for frame */
			buf->packet = csp_buffer_get(CSP_CAN_MTU);
    44de:	82 e3       	ldi	r24, 0x32	; 50
    44e0:	90 e0       	ldi	r25, 0x00	; 0
    44e2:	0e 94 0d 18 	call	0x301a	; 0x301a <csp_buffer_get>
    44e6:	d8 01       	movw	r26, r16
    44e8:	1b 96       	adiw	r26, 0x0b	; 11
    44ea:	9c 93       	st	X, r25
    44ec:	8e 93       	st	-X, r24
			if (buf->packet == NULL) {
    44ee:	1a 97       	sbiw	r26, 0x0a	; 10
    44f0:	89 2b       	or	r24, r25
				csp_log_error("Failed to get buffer for CSP_BEGIN packet");
    44f2:	c9 f4       	brne	.+50     	; 0x4526 <csp_can_rx_task+0x2c6>
    44f4:	e4 ee       	ldi	r30, 0xE4	; 228
    44f6:	fa e0       	ldi	r31, 0x0A	; 10
    44f8:	ff 93       	push	r31
    44fa:	ef 93       	push	r30
    44fc:	1f 92       	push	r1
    44fe:	f0 da       	rcall	.-2592   	; 0x3ae0 <do_csp_debug>
				csp_if_can.frame++;
    4500:	e2 e1       	ldi	r30, 0x12	; 18
    4502:	f2 e0       	ldi	r31, 0x02	; 2
    4504:	81 a1       	ldd	r24, Z+33	; 0x21
    4506:	92 a1       	ldd	r25, Z+34	; 0x22
    4508:	a3 a1       	ldd	r26, Z+35	; 0x23
    450a:	b4 a1       	ldd	r27, Z+36	; 0x24
    450c:	01 96       	adiw	r24, 0x01	; 1
    450e:	a1 1d       	adc	r26, r1
    4510:	b1 1d       	adc	r27, r1
    4512:	81 a3       	std	Z+33, r24	; 0x21
    4514:	92 a3       	std	Z+34, r25	; 0x22
    4516:	a3 a3       	std	Z+35, r26	; 0x23
				csp_can_pbuf_free(buf);
    4518:	b4 a3       	std	Z+36, r27	; 0x24
    451a:	c8 01       	movw	r24, r16
    451c:	0c dd       	rcall	.-1512   	; 0x3f36 <csp_can_pbuf_free>
    451e:	0f 90       	pop	r0
    4520:	0f 90       	pop	r0
    4522:	0f 90       	pop	r0
    4524:	b3 ce       	rjmp	.-666    	; 0x428c <csp_can_rx_task+0x2c>
				break;
			}
		}

		/* Copy CSP identifier and length*/
		memcpy(&(buf->packet->id), frame->data, sizeof(csp_id_t));
    4526:	d8 01       	movw	r26, r16
    4528:	1a 96       	adiw	r26, 0x0a	; 10
    452a:	ed 91       	ld	r30, X+
    452c:	fc 91       	ld	r31, X
    452e:	1b 97       	sbiw	r26, 0x0b	; 11
    4530:	8e 81       	ldd	r24, Y+6	; 0x06
    4532:	9f 81       	ldd	r25, Y+7	; 0x07
    4534:	93 87       	std	Z+11, r25	; 0x0b
    4536:	82 87       	std	Z+10, r24	; 0x0a
    4538:	88 85       	ldd	r24, Y+8	; 0x08
    453a:	99 85       	ldd	r25, Y+9	; 0x09
    453c:	95 87       	std	Z+13, r25	; 0x0d
		buf->packet->id.ext = csp_ntoh32(buf->packet->id.ext);
    453e:	84 87       	std	Z+12, r24	; 0x0c
    4540:	1a 96       	adiw	r26, 0x0a	; 10
    4542:	cd 90       	ld	r12, X+
    4544:	dc 90       	ld	r13, X
    4546:	1b 97       	sbiw	r26, 0x0b	; 11
    4548:	f6 01       	movw	r30, r12
    454a:	62 85       	ldd	r22, Z+10	; 0x0a
    454c:	73 85       	ldd	r23, Z+11	; 0x0b
    454e:	84 85       	ldd	r24, Z+12	; 0x0c
    4550:	95 85       	ldd	r25, Z+13	; 0x0d
    4552:	7a db       	rcall	.-2316   	; 0x3c48 <csp_ntoh32>
    4554:	d6 01       	movw	r26, r12
    4556:	1a 96       	adiw	r26, 0x0a	; 10
    4558:	6d 93       	st	X+, r22
    455a:	7d 93       	st	X+, r23
    455c:	8d 93       	st	X+, r24
    455e:	9c 93       	st	X, r25
    4560:	1d 97       	sbiw	r26, 0x0d	; 13
		memcpy(&(buf->packet->length), frame->data + sizeof(csp_id_t), sizeof(uint16_t));
    4562:	d8 01       	movw	r26, r16
    4564:	1a 96       	adiw	r26, 0x0a	; 10
    4566:	ed 91       	ld	r30, X+
    4568:	fc 91       	ld	r31, X
    456a:	1b 97       	sbiw	r26, 0x0b	; 11
    456c:	8a 85       	ldd	r24, Y+10	; 0x0a
    456e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4570:	91 87       	std	Z+9, r25	; 0x09
		buf->packet->length = csp_ntoh16(buf->packet->length);
    4572:	80 87       	std	Z+8, r24	; 0x08
    4574:	1a 96       	adiw	r26, 0x0a	; 10
    4576:	cd 90       	ld	r12, X+
    4578:	dc 90       	ld	r13, X
    457a:	1b 97       	sbiw	r26, 0x0b	; 11
    457c:	f6 01       	movw	r30, r12
    457e:	80 85       	ldd	r24, Z+8	; 0x08
    4580:	91 85       	ldd	r25, Z+9	; 0x09
    4582:	29 db       	rcall	.-2478   	; 0x3bd6 <csp_ntoh16>
    4584:	d6 01       	movw	r26, r12
    4586:	19 96       	adiw	r26, 0x09	; 9
    4588:	9c 93       	st	X, r25
    458a:	8e 93       	st	-X, r24
    458c:	18 97       	sbiw	r26, 0x08	; 8

		/* Reset RX count */
		buf->rx_count = 0;
    458e:	f8 01       	movw	r30, r16
    4590:	11 82       	std	Z+1, r1	; 0x01
    4592:	10 82       	st	Z, r1

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);

		/* Set remain field - increment to include begin packet */
		buf->remain = CFP_REMAIN(id) + 1;
    4594:	d5 01       	movw	r26, r10
    4596:	c4 01       	movw	r24, r8
    4598:	07 2e       	mov	r0, r23
    459a:	7a e0       	ldi	r23, 0x0A	; 10
    459c:	b6 95       	lsr	r27
    459e:	a7 95       	ror	r26
    45a0:	97 95       	ror	r25
    45a2:	87 95       	ror	r24
    45a4:	7a 95       	dec	r23
    45a6:	d1 f7       	brne	.-12     	; 0x459c <csp_can_rx_task+0x33c>
    45a8:	70 2d       	mov	r23, r0
    45aa:	99 27       	eor	r25, r25
    45ac:	aa 27       	eor	r26, r26
    45ae:	bb 27       	eor	r27, r27
    45b0:	01 96       	adiw	r24, 0x01	; 1
    45b2:	a1 1d       	adc	r26, r1
    45b4:	b1 1d       	adc	r27, r1
    45b6:	82 83       	std	Z+2, r24	; 0x02
    45b8:	93 83       	std	Z+3, r25	; 0x03
    45ba:	a4 83       	std	Z+4, r26	; 0x04
    45bc:	b5 83       	std	Z+5, r27	; 0x05

		/* Reset RX count */
		buf->rx_count = 0;

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);
    45be:	26 e0       	ldi	r18, 0x06	; 6
    45c0:	01 c0       	rjmp	.+2      	; 0x45c4 <csp_can_rx_task+0x364>
			return CSP_ERR_INVAL;
		}
	}

	/* Reset frame data offset */
	offset = 0;
    45c2:	20 e0       	ldi	r18, 0x00	; 0
		/* FALLTHROUGH */

	case CFP_MORE:

		/* Check 'remain' field match */
		if (CFP_REMAIN(id) != buf->remain - 1) {
    45c4:	07 2e       	mov	r0, r23
    45c6:	7a e0       	ldi	r23, 0x0A	; 10
    45c8:	b6 94       	lsr	r11
    45ca:	a7 94       	ror	r10
    45cc:	97 94       	ror	r9
    45ce:	87 94       	ror	r8
    45d0:	7a 95       	dec	r23
    45d2:	d1 f7       	brne	.-12     	; 0x45c8 <csp_can_rx_task+0x368>
    45d4:	70 2d       	mov	r23, r0
    45d6:	99 24       	eor	r9, r9
    45d8:	aa 24       	eor	r10, r10
    45da:	bb 24       	eor	r11, r11
    45dc:	f8 01       	movw	r30, r16
    45de:	82 81       	ldd	r24, Z+2	; 0x02
    45e0:	93 81       	ldd	r25, Z+3	; 0x03
    45e2:	a4 81       	ldd	r26, Z+4	; 0x04
    45e4:	b5 81       	ldd	r27, Z+5	; 0x05
    45e6:	01 97       	sbiw	r24, 0x01	; 1
    45e8:	a1 09       	sbc	r26, r1
    45ea:	b1 09       	sbc	r27, r1
    45ec:	88 16       	cp	r8, r24
    45ee:	99 06       	cpc	r9, r25
    45f0:	aa 06       	cpc	r10, r26
			csp_log_error("CAN frame lost in CSP packet");
    45f2:	bb 06       	cpc	r11, r27
    45f4:	c9 f0       	breq	.+50     	; 0x4628 <csp_can_rx_task+0x3c8>
    45f6:	27 ec       	ldi	r18, 0xC7	; 199
    45f8:	3a e0       	ldi	r19, 0x0A	; 10
    45fa:	3f 93       	push	r19
    45fc:	2f 93       	push	r18
    45fe:	1f 92       	push	r1
			csp_can_pbuf_free(buf);
    4600:	6f da       	rcall	.-2850   	; 0x3ae0 <do_csp_debug>
    4602:	c8 01       	movw	r24, r16
    4604:	98 dc       	rcall	.-1744   	; 0x3f36 <csp_can_pbuf_free>
			csp_if_can.frame++;
    4606:	e2 e1       	ldi	r30, 0x12	; 18
    4608:	f2 e0       	ldi	r31, 0x02	; 2
    460a:	81 a1       	ldd	r24, Z+33	; 0x21
    460c:	92 a1       	ldd	r25, Z+34	; 0x22
    460e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4610:	b4 a1       	ldd	r27, Z+36	; 0x24
    4612:	01 96       	adiw	r24, 0x01	; 1
    4614:	a1 1d       	adc	r26, r1
    4616:	b1 1d       	adc	r27, r1
    4618:	81 a3       	std	Z+33, r24	; 0x21
    461a:	92 a3       	std	Z+34, r25	; 0x22
    461c:	a3 a3       	std	Z+35, r26	; 0x23
    461e:	b4 a3       	std	Z+36, r27	; 0x24
    4620:	0f 90       	pop	r0
    4622:	0f 90       	pop	r0
    4624:	0f 90       	pop	r0
    4626:	32 ce       	rjmp	.-924    	; 0x428c <csp_can_rx_task+0x2c>
			break;
		}

		/* Decrement remaining frames */
		buf->remain--;
    4628:	82 82       	std	Z+2, r8	; 0x02
    462a:	93 82       	std	Z+3, r9	; 0x03
    462c:	a4 82       	std	Z+4, r10	; 0x04
    462e:	b5 82       	std	Z+5, r11	; 0x05

		/* Check for overflow */
		if ((buf->rx_count + frame->dlc - offset) > buf->packet->length) {
    4630:	80 81       	ld	r24, Z
    4632:	91 81       	ldd	r25, Z+1	; 0x01
    4634:	4d 81       	ldd	r20, Y+5	; 0x05
    4636:	62 2f       	mov	r22, r18
    4638:	70 e0       	ldi	r23, 0x00	; 0
    463a:	02 84       	ldd	r0, Z+10	; 0x0a
    463c:	f3 85       	ldd	r31, Z+11	; 0x0b
    463e:	e0 2d       	mov	r30, r0
    4640:	dc 01       	movw	r26, r24
    4642:	a4 0f       	add	r26, r20
    4644:	b1 1d       	adc	r27, r1
    4646:	a6 1b       	sub	r26, r22
    4648:	b7 0b       	sbc	r27, r23
    464a:	c0 84       	ldd	r12, Z+8	; 0x08
    464c:	d1 84       	ldd	r13, Z+9	; 0x09
    464e:	ca 16       	cp	r12, r26
    4650:	db 06       	cpc	r13, r27
			csp_log_error("RX buffer overflow");
    4652:	c8 f4       	brcc	.+50     	; 0x4686 <csp_can_rx_task+0x426>
    4654:	e4 eb       	ldi	r30, 0xB4	; 180
    4656:	fa e0       	ldi	r31, 0x0A	; 10
    4658:	ff 93       	push	r31
    465a:	ef 93       	push	r30
    465c:	1f 92       	push	r1
			csp_if_can.frame++;
    465e:	40 da       	rcall	.-2944   	; 0x3ae0 <do_csp_debug>
    4660:	e2 e1       	ldi	r30, 0x12	; 18
    4662:	f2 e0       	ldi	r31, 0x02	; 2
    4664:	81 a1       	ldd	r24, Z+33	; 0x21
    4666:	92 a1       	ldd	r25, Z+34	; 0x22
    4668:	a3 a1       	ldd	r26, Z+35	; 0x23
    466a:	b4 a1       	ldd	r27, Z+36	; 0x24
    466c:	01 96       	adiw	r24, 0x01	; 1
    466e:	a1 1d       	adc	r26, r1
    4670:	b1 1d       	adc	r27, r1
    4672:	81 a3       	std	Z+33, r24	; 0x21
    4674:	92 a3       	std	Z+34, r25	; 0x22
    4676:	a3 a3       	std	Z+35, r26	; 0x23
			csp_can_pbuf_free(buf);
    4678:	b4 a3       	std	Z+36, r27	; 0x24
    467a:	c8 01       	movw	r24, r16
    467c:	5c dc       	rcall	.-1864   	; 0x3f36 <csp_can_pbuf_free>
    467e:	0f 90       	pop	r0
    4680:	0f 90       	pop	r0
    4682:	0f 90       	pop	r0
    4684:	03 ce       	rjmp	.-1018   	; 0x428c <csp_can_rx_task+0x2c>
			break;
		}

		/* Copy dlc bytes into buffer */
		memcpy(&buf->packet->data[buf->rx_count], frame->data + offset, frame->dlc - offset);
    4686:	c2 2e       	mov	r12, r18
    4688:	d1 2c       	mov	r13, r1
    468a:	0e 96       	adiw	r24, 0x0e	; 14
    468c:	50 e0       	ldi	r21, 0x00	; 0
    468e:	4c 19       	sub	r20, r12
    4690:	5d 09       	sbc	r21, r13
    4692:	a6 e0       	ldi	r26, 0x06	; 6
    4694:	b0 e0       	ldi	r27, 0x00	; 0
    4696:	ac 0f       	add	r26, r28
    4698:	bd 1f       	adc	r27, r29
    469a:	6a 0f       	add	r22, r26
    469c:	7b 1f       	adc	r23, r27
    469e:	8e 0f       	add	r24, r30
    46a0:	9f 1f       	adc	r25, r31
    46a2:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>
		buf->rx_count += frame->dlc - offset;
    46a6:	8d 81       	ldd	r24, Y+5	; 0x05
    46a8:	90 e0       	ldi	r25, 0x00	; 0
    46aa:	8c 19       	sub	r24, r12
    46ac:	9d 09       	sbc	r25, r13
    46ae:	f8 01       	movw	r30, r16
    46b0:	20 81       	ld	r18, Z
    46b2:	31 81       	ldd	r19, Z+1	; 0x01
    46b4:	82 0f       	add	r24, r18
    46b6:	93 1f       	adc	r25, r19
    46b8:	91 83       	std	Z+1, r25	; 0x01

		/* Check if more data is expected */
		if (buf->rx_count != buf->packet->length)
    46ba:	80 83       	st	Z, r24
    46bc:	02 84       	ldd	r0, Z+10	; 0x0a
    46be:	f3 85       	ldd	r31, Z+11	; 0x0b
    46c0:	e0 2d       	mov	r30, r0
    46c2:	20 85       	ldd	r18, Z+8	; 0x08
    46c4:	31 85       	ldd	r19, Z+9	; 0x09
    46c6:	82 17       	cp	r24, r18
    46c8:	93 07       	cpc	r25, r19
			break;

		/* Data is available */
		csp_new_packet(buf->packet, &csp_if_can, NULL);
    46ca:	09 f0       	breq	.+2      	; 0x46ce <csp_can_rx_task+0x46e>
    46cc:	df cd       	rjmp	.-1090   	; 0x428c <csp_can_rx_task+0x2c>
    46ce:	40 e0       	ldi	r20, 0x00	; 0
    46d0:	50 e0       	ldi	r21, 0x00	; 0
    46d2:	62 e1       	ldi	r22, 0x12	; 18
    46d4:	72 e0       	ldi	r23, 0x02	; 2

		/* Drop packet buffer reference */
		buf->packet = NULL;
    46d6:	cf 01       	movw	r24, r30
    46d8:	5f d4       	rcall	.+2238   	; 0x4f98 <csp_qfifo_write>
    46da:	d8 01       	movw	r26, r16
    46dc:	1b 96       	adiw	r26, 0x0b	; 11
    46de:	1c 92       	st	X, r1

		/* Free packet buffer */
		csp_can_pbuf_free(buf);
    46e0:	1e 92       	st	-X, r1
    46e2:	1a 97       	sbiw	r26, 0x0a	; 10
    46e4:	c8 01       	movw	r24, r16
    46e6:	27 dc       	rcall	.-1970   	; 0x3f36 <csp_can_pbuf_free>

		break;

	default:
		csp_log_warn("Received unknown CFP message type");
    46e8:	d1 cd       	rjmp	.-1118   	; 0x428c <csp_can_rx_task+0x2c>
    46ea:	82 e9       	ldi	r24, 0x92	; 146
    46ec:	9a e0       	ldi	r25, 0x0A	; 10
    46ee:	9f 93       	push	r25
    46f0:	8f 93       	push	r24
    46f2:	81 e0       	ldi	r24, 0x01	; 1
    46f4:	8f 93       	push	r24
    46f6:	f4 d9       	rcall	.-3096   	; 0x3ae0 <do_csp_debug>
		csp_can_pbuf_free(buf);
    46f8:	c8 01       	movw	r24, r16
    46fa:	1d dc       	rcall	.-1990   	; 0x3f36 <csp_can_pbuf_free>
    46fc:	0f 90       	pop	r0
    46fe:	0f 90       	pop	r0
    4700:	0f 90       	pop	r0
    4702:	c4 cd       	rjmp	.-1144   	; 0x428c <csp_can_rx_task+0x2c>
    4704:	81 e0       	ldi	r24, 0x01	; 1
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    4706:	f1 01       	movw	r30, r2
    4708:	84 87       	std	Z+12, r24	; 0x0c
    470a:	86 82       	std	Z+6, r8	; 0x06
			buf->cfpid = id;
    470c:	97 82       	std	Z+7, r9	; 0x07
    470e:	a0 86       	std	Z+8, r10	; 0x08
    4710:	b1 86       	std	Z+9, r11	; 0x09
    4712:	12 82       	std	Z+2, r1	; 0x02
			buf->remain = 0;
    4714:	13 82       	std	Z+3, r1	; 0x03
    4716:	14 82       	std	Z+4, r1	; 0x04
    4718:	15 82       	std	Z+5, r1	; 0x05
    471a:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    471e:	d1 01       	movw	r26, r2
    4720:	1d 96       	adiw	r26, 0x0d	; 13
    4722:	6d 93       	st	X+, r22
    4724:	7d 93       	st	X+, r23
    4726:	8d 93       	st	X+, r24
    4728:	9c 93       	st	X, r25
    472a:	50 97       	sbiw	r26, 0x10	; 16
    472c:	81 01       	movw	r16, r2
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    472e:	9b ce       	rjmp	.-714    	; 0x4466 <csp_can_rx_task+0x206>

00004730 <csp_can_rx_frame>:
    4730:	ab 01       	movw	r20, r22
	csp_thread_exit();
}

int csp_can_rx_frame(can_frame_t *frame, CSP_BASE_TYPE *task_woken)
{
	if (csp_queue_enqueue_isr(csp_can_rx_queue, frame, task_woken) != CSP_QUEUE_OK)
    4732:	bc 01       	movw	r22, r24
    4734:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <csp_can_rx_queue>
    4738:	90 91 9e 05 	lds	r25, 0x059E	; 0x80059e <csp_can_rx_queue+0x1>
    473c:	09 d5       	rcall	.+2578   	; 0x5150 <csp_queue_enqueue_isr>
    473e:	21 e0       	ldi	r18, 0x01	; 1
    4740:	30 e0       	ldi	r19, 0x00	; 0
    4742:	01 97       	sbiw	r24, 0x01	; 1
    4744:	11 f4       	brne	.+4      	; 0x474a <csp_can_rx_frame+0x1a>
    4746:	20 e0       	ldi	r18, 0x00	; 0
    4748:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;
}
    474a:	88 27       	eor	r24, r24
    474c:	99 27       	eor	r25, r25
    474e:	82 1b       	sub	r24, r18
    4750:	93 0b       	sbc	r25, r19
    4752:	08 95       	ret

00004754 <csp_can_init>:

	return CSP_ERR_NONE;
}

int csp_can_init(uint8_t mode, struct csp_can_config *conf)
{
    4754:	8f 92       	push	r8
    4756:	9f 92       	push	r9
    4758:	af 92       	push	r10
    475a:	bf 92       	push	r11
    475c:	ef 92       	push	r14
    475e:	ff 92       	push	r15
    4760:	0f 93       	push	r16
    4762:	1f 93       	push	r17
    4764:	cf 93       	push	r28
    4766:	df 93       	push	r29
    4768:	18 2f       	mov	r17, r24
    476a:	eb 01       	movw	r28, r22
    476c:	e3 ef       	ldi	r30, 0xF3	; 243
    476e:	f4 e0       	ldi	r31, 0x04	; 4
    4770:	8d e9       	ldi	r24, 0x9D	; 157
    4772:	95 e0       	ldi	r25, 0x05	; 5
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		buf->rx_count = 0;
    4774:	11 82       	std	Z+1, r1	; 0x01
    4776:	10 82       	st	Z, r1
		buf->cfpid = 0;
    4778:	16 82       	std	Z+6, r1	; 0x06
    477a:	17 82       	std	Z+7, r1	; 0x07
    477c:	10 86       	std	Z+8, r1	; 0x08
    477e:	11 86       	std	Z+9, r1	; 0x09
		buf->packet = NULL;
    4780:	13 86       	std	Z+11, r1	; 0x0b
    4782:	12 86       	std	Z+10, r1	; 0x0a
		buf->state = BUF_FREE;
    4784:	14 86       	std	Z+12, r1	; 0x0c
		buf->last_used = 0;
    4786:	15 86       	std	Z+13, r1	; 0x0d
    4788:	16 86       	std	Z+14, r1	; 0x0e
    478a:	17 86       	std	Z+15, r1	; 0x0f
    478c:	10 8a       	std	Z+16, r1	; 0x10
		buf->remain = 0;
    478e:	12 82       	std	Z+2, r1	; 0x02
    4790:	13 82       	std	Z+3, r1	; 0x03
    4792:	14 82       	std	Z+4, r1	; 0x04
    4794:	15 82       	std	Z+5, r1	; 0x05
    4796:	71 96       	adiw	r30, 0x11	; 17
{
	/* Initialize packet buffers */
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    4798:	e8 17       	cp	r30, r24
    479a:	f9 07       	cpc	r31, r25
    479c:	59 f7       	brne	.-42     	; 0x4774 <csp_can_init+0x20>

/* Identification number */
static int csp_can_id_init(void)
{
	/* Init ID field to random number */
	srand((int)csp_get_ms());
    479e:	0e 94 ff 30 	call	0x61fe	; 0x61fe <csp_get_ms>
    47a2:	cb 01       	movw	r24, r22
    47a4:	0e 94 76 45 	call	0x8aec	; 0x8aec <srand>
	csp_can_id = rand() & ((1 << CFP_ID_SIZE) - 1);
    47a8:	0e 94 73 45 	call	0x8ae6	; 0x8ae6 <rand>
    47ac:	93 70       	andi	r25, 0x03	; 3
    47ae:	90 93 a4 05 	sts	0x05A4, r25	; 0x8005a4 <csp_can_id+0x1>
    47b2:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <csp_can_id>

	if (csp_bin_sem_create(&csp_can_id_sem) == CSP_SEMAPHORE_OK) {
    47b6:	81 ea       	ldi	r24, 0xA1	; 161
    47b8:	95 e0       	ldi	r25, 0x05	; 5
    47ba:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <csp_bin_sem_create>
    47be:	01 97       	sbiw	r24, 0x01	; 1
    47c0:	09 f4       	brne	.+2      	; 0x47c4 <csp_can_init+0x70>
    47c2:	8e c0       	rjmp	.+284    	; 0x48e0 <csp_can_init+0x18c>
		return CSP_ERR_NONE;
	} else {
		csp_log_error("Could not initialize CFP id semaphore");
    47c4:	8c e6       	ldi	r24, 0x6C	; 108
    47c6:	9a e0       	ldi	r25, 0x0A	; 10
    47c8:	9f 93       	push	r25
    47ca:	8f 93       	push	r24
    47cc:	1f 92       	push	r1
    47ce:	88 d9       	rcall	.-3312   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_NOMEM;
	}

	/* Initialize CFP identifier */
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
    47d0:	85 e0       	ldi	r24, 0x05	; 5
    47d2:	9c e0       	ldi	r25, 0x0C	; 12
    47d4:	9f 93       	push	r25
    47d6:	8f 93       	push	r24
    47d8:	1f 92       	push	r1
    47da:	82 d9       	rcall	.-3324   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_NOMEM;
    47dc:	0f 90       	pop	r0
    47de:	0f 90       	pop	r0
    47e0:	0f 90       	pop	r0
    47e2:	0f 90       	pop	r0
    47e4:	0f 90       	pop	r0
    47e6:	0f 90       	pop	r0
    47e8:	8f ef       	ldi	r24, 0xFF	; 255
    47ea:	9f ef       	ldi	r25, 0xFF	; 255
    47ec:	7c c0       	rjmp	.+248    	; 0x48e6 <csp_can_init+0x192>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
    47ee:	11 30       	cpi	r17, 0x01	; 1
    47f0:	61 f0       	breq	.+24     	; 0x480a <csp_can_init+0xb6>
		mask = 0;
	} else {
		csp_log_error("Unknown CAN mode");
    47f2:	84 ef       	ldi	r24, 0xF4	; 244
    47f4:	9b e0       	ldi	r25, 0x0B	; 11
    47f6:	9f 93       	push	r25
    47f8:	8f 93       	push	r24
    47fa:	1f 92       	push	r1
    47fc:	71 d9       	rcall	.-3358   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_INVAL;
    47fe:	0f 90       	pop	r0
    4800:	0f 90       	pop	r0
    4802:	0f 90       	pop	r0
    4804:	8e ef       	ldi	r24, 0xFE	; 254
    4806:	9f ef       	ldi	r25, 0xFF	; 255
    4808:	6e c0       	rjmp	.+220    	; 0x48e6 <csp_can_init+0x192>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
		mask = 0;
    480a:	81 2c       	mov	r8, r1
    480c:	91 2c       	mov	r9, r1
    480e:	54 01       	movw	r10, r8
    4810:	07 c0       	rjmp	.+14     	; 0x4820 <csp_can_init+0xcc>
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
    4812:	0f 2e       	mov	r0, r31
    4814:	81 2c       	mov	r8, r1
    4816:	91 2c       	mov	r9, r1
    4818:	f8 ef       	ldi	r31, 0xF8	; 248
    481a:	af 2e       	mov	r10, r31
    481c:	b1 2c       	mov	r11, r1
    481e:	f0 2d       	mov	r31, r0
	} else {
		csp_log_error("Unknown CAN mode");
		return CSP_ERR_INVAL;
	}

	csp_can_rx_queue = csp_queue_create(CSP_CAN_RX_QUEUE_SIZE, sizeof(can_frame_t));
    4820:	6d e0       	ldi	r22, 0x0D	; 13
    4822:	70 e0       	ldi	r23, 0x00	; 0
    4824:	80 e2       	ldi	r24, 0x20	; 32
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	6b d4       	rcall	.+2262   	; 0x5100 <csp_queue_create>
    482a:	90 93 9e 05 	sts	0x059E, r25	; 0x80059e <csp_can_rx_queue+0x1>
    482e:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <csp_can_rx_queue>
	if (!csp_can_rx_queue) {
    4832:	89 2b       	or	r24, r25
    4834:	61 f4       	brne	.+24     	; 0x484e <csp_can_init+0xfa>
		csp_log_error("Failed to create CAN RX queue");
    4836:	86 ed       	ldi	r24, 0xD6	; 214
    4838:	9b e0       	ldi	r25, 0x0B	; 11
    483a:	9f 93       	push	r25
    483c:	8f 93       	push	r24
    483e:	1f 92       	push	r1
    4840:	4f d9       	rcall	.-3426   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_NOMEM;
    4842:	0f 90       	pop	r0
    4844:	0f 90       	pop	r0
    4846:	0f 90       	pop	r0
    4848:	8f ef       	ldi	r24, 0xFF	; 255
    484a:	9f ef       	ldi	r25, 0xFF	; 255
    484c:	4c c0       	rjmp	.+152    	; 0x48e6 <csp_can_init+0x192>
	}

	ret = csp_thread_create(csp_can_rx_task, "CAN", 200 , NULL, 3, &csp_can_rx_task_h); //6000/sizeof(int)
    484e:	0f 2e       	mov	r0, r31
    4850:	ff e9       	ldi	r31, 0x9F	; 159
    4852:	ef 2e       	mov	r14, r31
    4854:	f5 e0       	ldi	r31, 0x05	; 5
    4856:	ff 2e       	mov	r15, r31
    4858:	f0 2d       	mov	r31, r0
    485a:	03 e0       	ldi	r16, 0x03	; 3
    485c:	10 e0       	ldi	r17, 0x00	; 0
    485e:	20 e0       	ldi	r18, 0x00	; 0
    4860:	30 e0       	ldi	r19, 0x00	; 0
    4862:	48 ec       	ldi	r20, 0xC8	; 200
    4864:	50 e0       	ldi	r21, 0x00	; 0
    4866:	66 e8       	ldi	r22, 0x86	; 134
    4868:	72 e0       	ldi	r23, 0x02	; 2
    486a:	80 e3       	ldi	r24, 0x30	; 48
    486c:	91 e2       	ldi	r25, 0x21	; 33
    486e:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <csp_thread_create>
	if (ret != 0) {
    4872:	89 2b       	or	r24, r25
    4874:	61 f0       	breq	.+24     	; 0x488e <csp_can_init+0x13a>
		csp_log_error("Failed to init CAN RX task");
    4876:	8b eb       	ldi	r24, 0xBB	; 187
    4878:	9b e0       	ldi	r25, 0x0B	; 11
    487a:	9f 93       	push	r25
    487c:	8f 93       	push	r24
    487e:	1f 92       	push	r1
    4880:	2f d9       	rcall	.-3490   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_NOMEM;
    4882:	0f 90       	pop	r0
    4884:	0f 90       	pop	r0
    4886:	0f 90       	pop	r0
    4888:	8f ef       	ldi	r24, 0xFF	; 255
    488a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Initialize CAN driver */

	int driverror=can_init(CFP_MAKE_DST(csp_get_address()), mask, conf);
    488c:	2c c0       	rjmp	.+88     	; 0x48e6 <csp_can_init+0x192>
    488e:	5c d0       	rcall	.+184    	; 0x4948 <csp_get_address>
    4890:	8f 71       	andi	r24, 0x1F	; 31
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	a0 e0       	ldi	r26, 0x00	; 0
    4896:	b0 e0       	ldi	r27, 0x00	; 0
    4898:	bc 01       	movw	r22, r24
    489a:	cd 01       	movw	r24, r26
    489c:	05 2e       	mov	r0, r21
    489e:	53 e1       	ldi	r21, 0x13	; 19
    48a0:	66 0f       	add	r22, r22
    48a2:	77 1f       	adc	r23, r23
    48a4:	88 1f       	adc	r24, r24
    48a6:	99 1f       	adc	r25, r25
    48a8:	5a 95       	dec	r21
    48aa:	d1 f7       	brne	.-12     	; 0x48a0 <csp_can_init+0x14c>
    48ac:	50 2d       	mov	r21, r0
    48ae:	8e 01       	movw	r16, r28
    48b0:	a5 01       	movw	r20, r10
    48b2:	94 01       	movw	r18, r8
    48b4:	0e 94 f6 09 	call	0x13ec	; 0x13ec <can_init>
	//printf("test = %d",driverror);
	if (driverror!=0){
    48b8:	89 2b       	or	r24, r25
		csp_log_error("Failed to initialize CAN driver");
    48ba:	61 f0       	breq	.+24     	; 0x48d4 <csp_can_init+0x180>
    48bc:	8b e9       	ldi	r24, 0x9B	; 155
    48be:	9b e0       	ldi	r25, 0x0B	; 11
    48c0:	9f 93       	push	r25
    48c2:	8f 93       	push	r24
    48c4:	1f 92       	push	r1
    48c6:	0c d9       	rcall	.-3560   	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_DRIVER;
    48c8:	0f 90       	pop	r0
    48ca:	0f 90       	pop	r0
    48cc:	0f 90       	pop	r0
    48ce:	85 ef       	ldi	r24, 0xF5	; 245
    48d0:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Register interface */
	csp_iflist_add(&csp_if_can);
    48d2:	09 c0       	rjmp	.+18     	; 0x48e6 <csp_can_init+0x192>
    48d4:	82 e1       	ldi	r24, 0x12	; 18
    48d6:	92 e0       	ldi	r25, 0x02	; 2
    48d8:	5a da       	rcall	.-2892   	; 0x3d8e <csp_iflist_add>

	return CSP_ERR_NONE;
    48da:	80 e0       	ldi	r24, 0x00	; 0
    48dc:	90 e0       	ldi	r25, 0x00	; 0
    48de:	03 c0       	rjmp	.+6      	; 0x48e6 <csp_can_init+0x192>
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
    48e0:	11 11       	cpse	r17, r1
    48e2:	85 cf       	rjmp	.-246    	; 0x47ee <csp_can_init+0x9a>
    48e4:	96 cf       	rjmp	.-212    	; 0x4812 <csp_can_init+0xbe>

	/* Register interface */
	csp_iflist_add(&csp_if_can);

	return CSP_ERR_NONE;
}
    48e6:	df 91       	pop	r29
    48e8:	cf 91       	pop	r28
    48ea:	1f 91       	pop	r17
    48ec:	0f 91       	pop	r16
    48ee:	ff 90       	pop	r15
    48f0:	ef 90       	pop	r14
    48f2:	bf 90       	pop	r11
    48f4:	af 90       	pop	r10
    48f6:	9f 90       	pop	r9
    48f8:	8f 90       	pop	r8
    48fa:	08 95       	ret

000048fc <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
static int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    48fc:	0f 93       	push	r16
    48fe:	1f 93       	push	r17
    4900:	cf 93       	push	r28
    4902:	df 93       	push	r29
    4904:	8b 01       	movw	r16, r22

	/* Drop packet silently if not destined for us. This allows
	 * blackhole routing addresses by setting their nexthop to
	 * the loopback interface.
	 */
	if (packet->id.dst != csp_get_address()) {
    4906:	fb 01       	movw	r30, r22
    4908:	c4 85       	ldd	r28, Z+12	; 0x0c
    490a:	8c 2f       	mov	r24, r28
    490c:	82 95       	swap	r24
    490e:	8f 70       	andi	r24, 0x0F	; 15
    4910:	c5 85       	ldd	r28, Z+13	; 0x0d
    4912:	c1 70       	andi	r28, 0x01	; 1
    4914:	c2 95       	swap	r28
    4916:	c0 7f       	andi	r28, 0xF0	; 240
    4918:	c8 2b       	or	r28, r24
    491a:	d0 e0       	ldi	r29, 0x00	; 0
    491c:	15 d0       	rcall	.+42     	; 0x4948 <csp_get_address>
    491e:	90 e0       	ldi	r25, 0x00	; 0
    4920:	c8 17       	cp	r28, r24
    4922:	d9 07       	cpc	r29, r25
    4924:	21 f0       	breq	.+8      	; 0x492e <csp_lo_tx+0x32>
		/* Consume and drop packet */
		csp_buffer_free(packet);
    4926:	c8 01       	movw	r24, r16
    4928:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
		return CSP_ERR_NONE;
    492c:	06 c0       	rjmp	.+12     	; 0x493a <csp_lo_tx+0x3e>
	}

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_qfifo_write(packet, &csp_if_lo, NULL);
    492e:	40 e0       	ldi	r20, 0x00	; 0
    4930:	50 e0       	ldi	r21, 0x00	; 0
    4932:	65 e4       	ldi	r22, 0x45	; 69
    4934:	72 e0       	ldi	r23, 0x02	; 2
    4936:	c8 01       	movw	r24, r16
    4938:	2f d3       	rcall	.+1630   	; 0x4f98 <csp_qfifo_write>

	return CSP_ERR_NONE;

}
    493a:	80 e0       	ldi	r24, 0x00	; 0
    493c:	90 e0       	ldi	r25, 0x00	; 0
    493e:	df 91       	pop	r29
    4940:	cf 91       	pop	r28
    4942:	1f 91       	pop	r17
    4944:	0f 91       	pop	r16
    4946:	08 95       	ret

00004948 <csp_get_address>:
	return csp_model;
}

void csp_set_revision(const char *revision)
{
	csp_revision = revision;
    4948:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    494c:	08 95       	ret

0000494e <csp_get_hostname>:
    494e:	80 91 a7 05 	lds	r24, 0x05A7	; 0x8005a7 <csp_hostname>
    4952:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <csp_hostname+0x1>
    4956:	08 95       	ret

00004958 <csp_get_model>:
    4958:	80 91 a5 05 	lds	r24, 0x05A5	; 0x8005a5 <csp_model>
    495c:	90 91 a6 05 	lds	r25, 0x05A6	; 0x8005a6 <csp_model+0x1>
    4960:	08 95       	ret

00004962 <csp_get_revision>:
}

const char *csp_get_revision(void)
{
	return csp_revision;
}
    4962:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <csp_revision>
    4966:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <csp_revision+0x1>
    496a:	08 95       	ret

0000496c <csp_init>:

int csp_init(unsigned char address) {
    496c:	cf 93       	push	r28
    496e:	df 93       	push	r29
extern csp_queue_handle_t csp_promisc_queue;
#endif

void csp_set_address(uint8_t addr)
{
	csp_my_address = addr;
    4970:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <csp_my_address>
	int ret;

	/* Initialize CSP */
	csp_set_address(address);

	ret = csp_conn_init();
    4974:	0e 94 a6 19 	call	0x334c	; 0x334c <csp_conn_init>
	if (ret != CSP_ERR_NONE)
    4978:	00 97       	sbiw	r24, 0x00	; 0
    497a:	d9 f4       	brne	.+54     	; 0x49b2 <csp_init+0x46>
		return ret;

	ret = csp_port_init();
    497c:	5c d2       	rcall	.+1208   	; 0x4e36 <csp_port_init>
	if (ret != CSP_ERR_NONE)
    497e:	00 97       	sbiw	r24, 0x00	; 0
		return ret;

	ret = csp_qfifo_init();
    4980:	c1 f4       	brne	.+48     	; 0x49b2 <csp_init+0x46>
    4982:	e1 d2       	rcall	.+1474   	; 0x4f46 <csp_qfifo_init>
    4984:	ec 01       	movw	r28, r24
	if (ret != CSP_ERR_NONE)
    4986:	00 97       	sbiw	r24, 0x00	; 0
    4988:	99 f4       	brne	.+38     	; 0x49b0 <csp_init+0x44>
		return ret;

	/* Loopback */
	csp_iflist_add(&csp_if_lo);
    498a:	85 e4       	ldi	r24, 0x45	; 69
    498c:	92 e0       	ldi	r25, 0x02	; 2
    498e:	ff d9       	rcall	.-3074   	; 0x3d8e <csp_iflist_add>

	/* Register loopback route */
	csp_route_set(csp_get_address(), &csp_if_lo, CSP_NODE_MAC);
    4990:	2f ef       	ldi	r18, 0xFF	; 255
    4992:	45 e4       	ldi	r20, 0x45	; 69
    4994:	52 e0       	ldi	r21, 0x02	; 2
    4996:	65 e0       	ldi	r22, 0x05	; 5
    4998:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    499c:	e9 d6       	rcall	.+3538   	; 0x5770 <csp_rtable_set>

	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);
    499e:	2f ef       	ldi	r18, 0xFF	; 255
    49a0:	45 e4       	ldi	r20, 0x45	; 69
    49a2:	52 e0       	ldi	r21, 0x02	; 2
    49a4:	65 e0       	ldi	r22, 0x05	; 5
    49a6:	80 e2       	ldi	r24, 0x20	; 32
    49a8:	e3 d6       	rcall	.+3526   	; 0x5770 <csp_rtable_set>

	return CSP_ERR_NONE;
    49aa:	8c 2f       	mov	r24, r28
    49ac:	9d 2f       	mov	r25, r29
    49ae:	01 c0       	rjmp	.+2      	; 0x49b2 <csp_init+0x46>
	if (ret != CSP_ERR_NONE)
		return ret;

	ret = csp_qfifo_init();
	if (ret != CSP_ERR_NONE)
		return ret;
    49b0:	9d 2f       	mov	r25, r29
	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);

	return CSP_ERR_NONE;

}
    49b2:	df 91       	pop	r29
    49b4:	cf 91       	pop	r28
    49b6:	08 95       	ret

000049b8 <csp_socket>:

csp_socket_t * csp_socket(uint32_t opts) {
    49b8:	cf 92       	push	r12
    49ba:	df 92       	push	r13
    49bc:	ef 92       	push	r14
    49be:	ff 92       	push	r15
    49c0:	cf 93       	push	r28
    49c2:	df 93       	push	r29
    49c4:	6b 01       	movw	r12, r22
    49c6:	7c 01       	movw	r14, r24
	
	/* Validate socket options */
#ifndef CSP_USE_RDP
	if (opts & CSP_SO_RDPREQ) {
    49c8:	60 ff       	sbrs	r22, 0
    49ca:	0c c0       	rjmp	.+24     	; 0x49e4 <csp_socket+0x2c>
		csp_log_error("Attempt to create socket that requires RDP, but CSP was compiled without RDP support");
    49cc:	88 e6       	ldi	r24, 0x68	; 104
    49ce:	9e e0       	ldi	r25, 0x0E	; 14
    49d0:	9f 93       	push	r25
    49d2:	8f 93       	push	r24
    49d4:	1f 92       	push	r1
    49d6:	84 d8       	rcall	.-3832   	; 0x3ae0 <do_csp_debug>
		return NULL;
    49d8:	0f 90       	pop	r0
    49da:	0f 90       	pop	r0
    49dc:	0f 90       	pop	r0
    49de:	80 e0       	ldi	r24, 0x00	; 0
    49e0:	90 e0       	ldi	r25, 0x00	; 0
    49e2:	50 c0       	rjmp	.+160    	; 0x4a84 <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_XTEA
	if (opts & CSP_SO_XTEAREQ) {
    49e4:	64 ff       	sbrs	r22, 4
    49e6:	0c c0       	rjmp	.+24     	; 0x4a00 <csp_socket+0x48>
		csp_log_error("Attempt to create socket that requires XTEA, but CSP was compiled without XTEA support");
    49e8:	81 e1       	ldi	r24, 0x11	; 17
    49ea:	9e e0       	ldi	r25, 0x0E	; 14
    49ec:	9f 93       	push	r25
    49ee:	8f 93       	push	r24
    49f0:	1f 92       	push	r1
    49f2:	76 d8       	rcall	.-3860   	; 0x3ae0 <do_csp_debug>
		return NULL;
    49f4:	0f 90       	pop	r0
    49f6:	0f 90       	pop	r0
    49f8:	0f 90       	pop	r0
    49fa:	80 e0       	ldi	r24, 0x00	; 0
    49fc:	90 e0       	ldi	r25, 0x00	; 0
    49fe:	42 c0       	rjmp	.+132    	; 0x4a84 <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_HMAC
	if (opts & CSP_SO_HMACREQ) {
    4a00:	62 ff       	sbrs	r22, 2
    4a02:	0c c0       	rjmp	.+24     	; 0x4a1c <csp_socket+0x64>
		csp_log_error("Attempt to create socket that requires HMAC, but CSP was compiled without HMAC support");
    4a04:	8a eb       	ldi	r24, 0xBA	; 186
    4a06:	9d e0       	ldi	r25, 0x0D	; 13
    4a08:	9f 93       	push	r25
    4a0a:	8f 93       	push	r24
    4a0c:	1f 92       	push	r1
    4a0e:	68 d8       	rcall	.-3888   	; 0x3ae0 <do_csp_debug>
		return NULL;
    4a10:	0f 90       	pop	r0
    4a12:	0f 90       	pop	r0
    4a14:	0f 90       	pop	r0
    4a16:	80 e0       	ldi	r24, 0x00	; 0
    4a18:	90 e0       	ldi	r25, 0x00	; 0
    4a1a:	34 c0       	rjmp	.+104    	; 0x4a84 <csp_socket+0xcc>
		return NULL;
	} 
#endif
	
	/* Drop packet if reserved flags are set */
	if (opts & ~(CSP_SO_RDPREQ | CSP_SO_XTEAREQ | CSP_SO_HMACREQ | CSP_SO_CRC32REQ | CSP_SO_CONN_LESS)) {
    4a1c:	dc 01       	movw	r26, r24
    4a1e:	cb 01       	movw	r24, r22
    4a20:	8a 7a       	andi	r24, 0xAA	; 170
    4a22:	9e 7f       	andi	r25, 0xFE	; 254
    4a24:	89 2b       	or	r24, r25
    4a26:	8a 2b       	or	r24, r26
    4a28:	8b 2b       	or	r24, r27
    4a2a:	61 f0       	breq	.+24     	; 0x4a44 <csp_socket+0x8c>
		csp_log_error("Invalid socket option");
    4a2c:	84 ea       	ldi	r24, 0xA4	; 164
    4a2e:	9d e0       	ldi	r25, 0x0D	; 13
    4a30:	9f 93       	push	r25
    4a32:	8f 93       	push	r24
    4a34:	1f 92       	push	r1
    4a36:	54 d8       	rcall	.-3928   	; 0x3ae0 <do_csp_debug>
		return NULL;
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
    4a3c:	0f 90       	pop	r0
    4a3e:	80 e0       	ldi	r24, 0x00	; 0
    4a40:	90 e0       	ldi	r25, 0x00	; 0
    4a42:	20 c0       	rjmp	.+64     	; 0x4a84 <csp_socket+0xcc>
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
    4a44:	81 e0       	ldi	r24, 0x01	; 1
    4a46:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <csp_conn_allocate>
    4a4a:	ec 01       	movw	r28, r24
	if (sock == NULL)
    4a4c:	89 2b       	or	r24, r25
    4a4e:	a9 f0       	breq	.+42     	; 0x4a7a <csp_socket+0xc2>
		return NULL;

	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
    4a50:	d0 fe       	sbrs	r13, 0
    4a52:	0a c0       	rjmp	.+20     	; 0x4a68 <csp_socket+0xb0>
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
    4a54:	62 e0       	ldi	r22, 0x02	; 2
    4a56:	70 e0       	ldi	r23, 0x00	; 0
    4a58:	84 e6       	ldi	r24, 0x64	; 100
    4a5a:	90 e0       	ldi	r25, 0x00	; 0
    4a5c:	51 d3       	rcall	.+1698   	; 0x5100 <csp_queue_create>
    4a5e:	9f 87       	std	Y+15, r25	; 0x0f
    4a60:	8e 87       	std	Y+14, r24	; 0x0e
		if (sock->socket == NULL)
    4a62:	89 2b       	or	r24, r25
    4a64:	19 f4       	brne	.+6      	; 0x4a6c <csp_socket+0xb4>
    4a66:	0c c0       	rjmp	.+24     	; 0x4a80 <csp_socket+0xc8>
			return NULL;
	} else {
		sock->socket = NULL;
    4a68:	1f 86       	std	Y+15, r1	; 0x0f
    4a6a:	1e 86       	std	Y+14, r1	; 0x0e
	}
	sock->opts = opts;
    4a6c:	cc 8a       	std	Y+20, r12	; 0x14
    4a6e:	dd 8a       	std	Y+21, r13	; 0x15
    4a70:	ee 8a       	std	Y+22, r14	; 0x16
    4a72:	ff 8a       	std	Y+23, r15	; 0x17

	return sock;
    4a74:	8c 2f       	mov	r24, r28
    4a76:	9d 2f       	mov	r25, r29
    4a78:	05 c0       	rjmp	.+10     	; 0x4a84 <csp_socket+0xcc>
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
	if (sock == NULL)
		return NULL;
    4a7a:	80 e0       	ldi	r24, 0x00	; 0
    4a7c:	90 e0       	ldi	r25, 0x00	; 0
    4a7e:	02 c0       	rjmp	.+4      	; 0x4a84 <csp_socket+0xcc>
	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
		if (sock->socket == NULL)
			return NULL;
    4a80:	80 e0       	ldi	r24, 0x00	; 0
    4a82:	90 e0       	ldi	r25, 0x00	; 0
	}
	sock->opts = opts;

	return sock;

}
    4a84:	df 91       	pop	r29
    4a86:	cf 91       	pop	r28
    4a88:	ff 90       	pop	r15
    4a8a:	ef 90       	pop	r14
    4a8c:	df 90       	pop	r13
    4a8e:	cf 90       	pop	r12
    4a90:	08 95       	ret

00004a92 <csp_accept>:

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {
    4a92:	cf 93       	push	r28
    4a94:	df 93       	push	r29
    4a96:	1f 92       	push	r1
    4a98:	1f 92       	push	r1
    4a9a:	cd b7       	in	r28, 0x3d	; 61
    4a9c:	de b7       	in	r29, 0x3e	; 62

	if (sock == NULL)
    4a9e:	00 97       	sbiw	r24, 0x00	; 0
    4aa0:	81 f0       	breq	.+32     	; 0x4ac2 <csp_accept+0x30>
		return NULL;

	if (sock->socket == NULL)
    4aa2:	fc 01       	movw	r30, r24
    4aa4:	86 85       	ldd	r24, Z+14	; 0x0e
    4aa6:	97 85       	ldd	r25, Z+15	; 0x0f
    4aa8:	00 97       	sbiw	r24, 0x00	; 0
    4aaa:	71 f0       	breq	.+28     	; 0x4ac8 <csp_accept+0x36>
    4aac:	9a 01       	movw	r18, r20
    4aae:	ab 01       	movw	r20, r22
		return NULL;

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
    4ab0:	be 01       	movw	r22, r28
    4ab2:	6f 5f       	subi	r22, 0xFF	; 255
    4ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    4ab6:	53 d3       	rcall	.+1702   	; 0x515e <csp_queue_dequeue>
    4ab8:	01 97       	sbiw	r24, 0x01	; 1
    4aba:	49 f4       	brne	.+18     	; 0x4ace <csp_accept+0x3c>
		return conn;
    4abc:	89 81       	ldd	r24, Y+1	; 0x01
    4abe:	9a 81       	ldd	r25, Y+2	; 0x02
    4ac0:	08 c0       	rjmp	.+16     	; 0x4ad2 <csp_accept+0x40>
}

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {

	if (sock == NULL)
		return NULL;
    4ac2:	80 e0       	ldi	r24, 0x00	; 0
    4ac4:	90 e0       	ldi	r25, 0x00	; 0
    4ac6:	05 c0       	rjmp	.+10     	; 0x4ad2 <csp_accept+0x40>

	if (sock->socket == NULL)
		return NULL;
    4ac8:	80 e0       	ldi	r24, 0x00	; 0
    4aca:	90 e0       	ldi	r25, 0x00	; 0
    4acc:	02 c0       	rjmp	.+4      	; 0x4ad2 <csp_accept+0x40>

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
		return conn;

	return NULL;
    4ace:	80 e0       	ldi	r24, 0x00	; 0
    4ad0:	90 e0       	ldi	r25, 0x00	; 0

}
    4ad2:	0f 90       	pop	r0
    4ad4:	0f 90       	pop	r0
    4ad6:	df 91       	pop	r29
    4ad8:	cf 91       	pop	r28
    4ada:	08 95       	ret

00004adc <csp_read>:

csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {
    4adc:	cf 93       	push	r28
    4ade:	df 93       	push	r29
    4ae0:	1f 92       	push	r1
    4ae2:	1f 92       	push	r1
    4ae4:	cd b7       	in	r28, 0x3d	; 61
    4ae6:	de b7       	in	r29, 0x3e	; 62

	csp_packet_t * packet = NULL;
    4ae8:	1a 82       	std	Y+2, r1	; 0x02
    4aea:	19 82       	std	Y+1, r1	; 0x01

	if (conn == NULL || conn->state != CONN_OPEN)
    4aec:	00 97       	sbiw	r24, 0x00	; 0
    4aee:	89 f0       	breq	.+34     	; 0x4b12 <csp_read+0x36>
    4af0:	fc 01       	movw	r30, r24
    4af2:	21 81       	ldd	r18, Z+1	; 0x01
    4af4:	21 30       	cpi	r18, 0x01	; 1
    4af6:	81 f4       	brne	.+32     	; 0x4b18 <csp_read+0x3c>
    4af8:	9a 01       	movw	r18, r20
    4afa:	ab 01       	movw	r20, r22

	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
    4afc:	be 01       	movw	r22, r28
    4afe:	6f 5f       	subi	r22, 0xFF	; 255
    4b00:	7f 4f       	sbci	r23, 0xFF	; 255
    4b02:	84 85       	ldd	r24, Z+12	; 0x0c
    4b04:	95 85       	ldd	r25, Z+13	; 0x0d
    4b06:	2b d3       	rcall	.+1622   	; 0x515e <csp_queue_dequeue>
    4b08:	01 97       	sbiw	r24, 0x01	; 1
    4b0a:	49 f4       	brne	.+18     	; 0x4b1e <csp_read+0x42>
	/* Packet read could trigger ACK transmission */
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_check_ack(conn);
#endif

	return packet;
    4b0c:	89 81       	ldd	r24, Y+1	; 0x01
    4b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b10:	08 c0       	rjmp	.+16     	; 0x4b22 <csp_read+0x46>
csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {

	csp_packet_t * packet = NULL;

	if (conn == NULL || conn->state != CONN_OPEN)
		return NULL;
    4b12:	80 e0       	ldi	r24, 0x00	; 0
    4b14:	90 e0       	ldi	r25, 0x00	; 0
    4b16:	05 c0       	rjmp	.+10     	; 0x4b22 <csp_read+0x46>
    4b18:	80 e0       	ldi	r24, 0x00	; 0
    4b1a:	90 e0       	ldi	r25, 0x00	; 0
    4b1c:	02 c0       	rjmp	.+4      	; 0x4b22 <csp_read+0x46>
	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
		return NULL;
    4b1e:	80 e0       	ldi	r24, 0x00	; 0
    4b20:	90 e0       	ldi	r25, 0x00	; 0
		csp_rdp_check_ack(conn);
#endif

	return packet;

}
    4b22:	0f 90       	pop	r0
    4b24:	0f 90       	pop	r0
    4b26:	df 91       	pop	r29
    4b28:	cf 91       	pop	r28
    4b2a:	08 95       	ret

00004b2c <csp_send_direct>:

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {
    4b2c:	4f 92       	push	r4
    4b2e:	5f 92       	push	r5
    4b30:	6f 92       	push	r6
    4b32:	7f 92       	push	r7
    4b34:	8f 92       	push	r8
    4b36:	9f 92       	push	r9
    4b38:	af 92       	push	r10
    4b3a:	bf 92       	push	r11
    4b3c:	cf 92       	push	r12
    4b3e:	df 92       	push	r13
    4b40:	ef 92       	push	r14
    4b42:	ff 92       	push	r15
    4b44:	0f 93       	push	r16
    4b46:	1f 93       	push	r17
    4b48:	cf 93       	push	r28
    4b4a:	df 93       	push	r29
    4b4c:	86 2e       	mov	r8, r22
    4b4e:	97 2e       	mov	r9, r23
    4b50:	a8 2e       	mov	r10, r24
    4b52:	b9 2e       	mov	r11, r25
    4b54:	6a 01       	movw	r12, r20
    4b56:	e9 01       	movw	r28, r18
    4b58:	27 01       	movw	r4, r14
    4b5a:	38 01       	movw	r6, r16

	if (packet == NULL) {
    4b5c:	41 15       	cp	r20, r1
    4b5e:	51 05       	cpc	r21, r1
    4b60:	69 f4       	brne	.+26     	; 0x4b7c <csp_send_direct+0x50>
		csp_log_error("csp_send_direct called with NULL packet");
    4b62:	8c e7       	ldi	r24, 0x7C	; 124
    4b64:	9d e0       	ldi	r25, 0x0D	; 13
    4b66:	9f 93       	push	r25
    4b68:	8f 93       	push	r24
    4b6a:	1f 92       	push	r1
    4b6c:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		goto err;
    4b70:	0f 90       	pop	r0
    4b72:	0f 90       	pop	r0
    4b74:	0f 90       	pop	r0
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    4b76:	86 ef       	ldi	r24, 0xF6	; 246
    4b78:	9f ef       	ldi	r25, 0xFF	; 255

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {

	if (packet == NULL) {
		csp_log_error("csp_send_direct called with NULL packet");
		goto err;
    4b7a:	d5 c0       	rjmp	.+426    	; 0x4d26 <csp_send_direct+0x1fa>
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
    4b7c:	20 97       	sbiw	r28, 0x00	; 0
    4b7e:	21 f0       	breq	.+8      	; 0x4b88 <csp_send_direct+0x5c>
    4b80:	8c 81       	ldd	r24, Y+4	; 0x04
    4b82:	9d 81       	ldd	r25, Y+5	; 0x05
    4b84:	89 2b       	or	r24, r25
    4b86:	b9 f4       	brne	.+46     	; 0x4bb6 <csp_send_direct+0x8a>
		csp_log_error("No route to host: %#08x", idout.ext);
    4b88:	bf 92       	push	r11
    4b8a:	af 92       	push	r10
    4b8c:	9f 92       	push	r9
    4b8e:	8f 92       	push	r8
    4b90:	84 e6       	ldi	r24, 0x64	; 100
    4b92:	9d e0       	ldi	r25, 0x0D	; 13
    4b94:	9f 93       	push	r25
    4b96:	8f 93       	push	r24
    4b98:	1f 92       	push	r1
    4b9a:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		goto err;
    4b9e:	2d b7       	in	r18, 0x3d	; 61
    4ba0:	3e b7       	in	r19, 0x3e	; 62
    4ba2:	29 5f       	subi	r18, 0xF9	; 249
    4ba4:	3f 4f       	sbci	r19, 0xFF	; 255
    4ba6:	0f b6       	in	r0, 0x3f	; 63
    4ba8:	f8 94       	cli
    4baa:	3e bf       	out	0x3e, r19	; 62
    4bac:	0f be       	out	0x3f, r0	; 63
    4bae:	2d bf       	out	0x3d, r18	; 61
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    4bb0:	86 ef       	ldi	r24, 0xF6	; 246
    4bb2:	9f ef       	ldi	r25, 0xFF	; 255
		goto err;
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
		csp_log_error("No route to host: %#08x", idout.ext);
		goto err;
    4bb4:	b8 c0       	rjmp	.+368    	; 0x4d26 <csp_send_direct+0x1fa>
	}

	csp_log_packet("OUT: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %u VIA: %s",
    4bb6:	8b 2d       	mov	r24, r11
    4bb8:	86 95       	lsr	r24
    4bba:	8f 71       	andi	r24, 0x1F	; 31
    4bbc:	08 2f       	mov	r16, r24
    4bbe:	10 e0       	ldi	r17, 0x00	; 0
    4bc0:	99 81       	ldd	r25, Y+1	; 0x01
    4bc2:	9f 93       	push	r25
    4bc4:	98 81       	ld	r25, Y
    4bc6:	9f 93       	push	r25
    4bc8:	fa 01       	movw	r30, r20
    4bca:	91 85       	ldd	r25, Z+9	; 0x09
    4bcc:	9f 93       	push	r25
    4bce:	90 85       	ldd	r25, Z+8	; 0x08
    4bd0:	9f 93       	push	r25
    4bd2:	1f 92       	push	r1
    4bd4:	6f 93       	push	r22
    4bd6:	9b 2d       	mov	r25, r11
    4bd8:	92 95       	swap	r25
    4bda:	96 95       	lsr	r25
    4bdc:	96 95       	lsr	r25
    4bde:	93 70       	andi	r25, 0x03	; 3
    4be0:	1f 92       	push	r1
    4be2:	9f 93       	push	r25
    4be4:	97 2f       	mov	r25, r23
    4be6:	9f 73       	andi	r25, 0x3F	; 63
    4be8:	1f 92       	push	r1
    4bea:	9f 93       	push	r25
    4bec:	27 2f       	mov	r18, r23
    4bee:	22 95       	swap	r18
    4bf0:	26 95       	lsr	r18
    4bf2:	26 95       	lsr	r18
    4bf4:	23 70       	andi	r18, 0x03	; 3
    4bf6:	9a 2d       	mov	r25, r10
    4bf8:	9f 70       	andi	r25, 0x0F	; 15
    4bfa:	99 0f       	add	r25, r25
    4bfc:	99 0f       	add	r25, r25
    4bfe:	92 2b       	or	r25, r18
    4c00:	1f 92       	push	r1
    4c02:	9f 93       	push	r25
    4c04:	2a 2d       	mov	r18, r10
    4c06:	22 95       	swap	r18
    4c08:	2f 70       	andi	r18, 0x0F	; 15
    4c0a:	9b 2d       	mov	r25, r11
    4c0c:	91 70       	andi	r25, 0x01	; 1
    4c0e:	92 95       	swap	r25
    4c10:	90 7f       	andi	r25, 0xF0	; 240
    4c12:	92 2b       	or	r25, r18
    4c14:	1f 92       	push	r1
    4c16:	9f 93       	push	r25
    4c18:	1f 92       	push	r1
    4c1a:	8f 93       	push	r24
    4c1c:	85 e2       	ldi	r24, 0x25	; 37
    4c1e:	9d e0       	ldi	r25, 0x0D	; 13
    4c20:	9f 93       	push	r25
    4c22:	8f 93       	push	r24
    4c24:	84 e0       	ldi	r24, 0x04	; 4
    4c26:	8f 93       	push	r24
    4c28:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		idout.src, idout.dst, idout.dport, idout.sport, idout.pri, idout.flags, packet->length, ifout->name);

	/* Copy identifier to packet (before crc, xtea and hmac) */
	packet->id.ext = idout.ext;
    4c2c:	f6 01       	movw	r30, r12
    4c2e:	82 86       	std	Z+10, r8	; 0x0a
    4c30:	93 86       	std	Z+11, r9	; 0x0b
    4c32:	a4 86       	std	Z+12, r10	; 0x0c
    4c34:	b5 86       	std	Z+13, r11	; 0x0d
		csp_promisc_add(packet);
	}
#endif

	/* Only encrypt packets from the current node */
	if (idout.src == csp_get_address()) {
    4c36:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <csp_my_address>
    4c3a:	90 e0       	ldi	r25, 0x00	; 0
    4c3c:	2d b7       	in	r18, 0x3d	; 61
    4c3e:	3e b7       	in	r19, 0x3e	; 62
    4c40:	2d 5e       	subi	r18, 0xED	; 237
    4c42:	3f 4f       	sbci	r19, 0xFF	; 255
    4c44:	0f b6       	in	r0, 0x3f	; 63
    4c46:	f8 94       	cli
    4c48:	3e bf       	out	0x3e, r19	; 62
    4c4a:	0f be       	out	0x3f, r0	; 63
    4c4c:	2d bf       	out	0x3d, r18	; 61
    4c4e:	08 17       	cp	r16, r24
    4c50:	19 07       	cpc	r17, r25
    4c52:	81 f5       	brne	.+96     	; 0x4cb4 <csp_send_direct+0x188>
		/* Append HMAC */
		if (idout.flags & CSP_FHMAC) {
    4c54:	83 fe       	sbrs	r8, 3
    4c56:	0c c0       	rjmp	.+24     	; 0x4c70 <csp_send_direct+0x144>
				/* HMAC append failed */
				csp_log_warn("HMAC append failed!");
				goto tx_err;
			}
#else
			csp_log_warn("Attempt to send packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    4c58:	86 ec       	ldi	r24, 0xC6	; 198
    4c5a:	9c e0       	ldi	r25, 0x0C	; 12
    4c5c:	9f 93       	push	r25
    4c5e:	8f 93       	push	r24
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	8f 93       	push	r24
    4c64:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			goto tx_err;
    4c68:	0f 90       	pop	r0
    4c6a:	0f 90       	pop	r0
    4c6c:	0f 90       	pop	r0
    4c6e:	4e c0       	rjmp	.+156    	; 0x4d0c <csp_send_direct+0x1e0>
#endif
		}

		/* Append CRC32 */
		if (idout.flags & CSP_FCRC32) {
    4c70:	80 fe       	sbrs	r8, 0
    4c72:	12 c0       	rjmp	.+36     	; 0x4c98 <csp_send_direct+0x16c>
#ifdef CSP_USE_CRC32
			/* Calculate and add CRC32 (does not include header for backwards compatability with csp1.x) */
			if (csp_crc32_append(packet, false) != 0) {
    4c74:	60 e0       	ldi	r22, 0x00	; 0
    4c76:	c6 01       	movw	r24, r12
    4c78:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <csp_crc32_append>
    4c7c:	89 2b       	or	r24, r25
    4c7e:	61 f0       	breq	.+24     	; 0x4c98 <csp_send_direct+0x16c>
				/* CRC32 append failed */
				csp_log_warn("CRC32 append failed!");
    4c80:	81 eb       	ldi	r24, 0xB1	; 177
    4c82:	9c e0       	ldi	r25, 0x0C	; 12
    4c84:	9f 93       	push	r25
    4c86:	8f 93       	push	r24
    4c88:	81 e0       	ldi	r24, 0x01	; 1
    4c8a:	8f 93       	push	r24
    4c8c:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
				goto tx_err;
    4c90:	0f 90       	pop	r0
    4c92:	0f 90       	pop	r0
    4c94:	0f 90       	pop	r0
    4c96:	3a c0       	rjmp	.+116    	; 0x4d0c <csp_send_direct+0x1e0>
			csp_log_warn("Attempt to send packet with CRC32, but CSP was compiled without CRC32 support. Sending without CRC32r");
			idout.flags &= ~(CSP_FCRC32);
#endif
		}

		if (idout.flags & CSP_FXTEA) {
    4c98:	82 fe       	sbrs	r8, 2
    4c9a:	0c c0       	rjmp	.+24     	; 0x4cb4 <csp_send_direct+0x188>
				goto tx_err;
			}

			packet->length += sizeof(nonce_n);
#else
			csp_log_warn("Attempt to send XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4c9c:	8d e4       	ldi	r24, 0x4D	; 77
    4c9e:	9c e0       	ldi	r25, 0x0C	; 12
    4ca0:	9f 93       	push	r25
    4ca2:	8f 93       	push	r24
    4ca4:	81 e0       	ldi	r24, 0x01	; 1
    4ca6:	8f 93       	push	r24
    4ca8:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			goto tx_err;
    4cac:	0f 90       	pop	r0
    4cae:	0f 90       	pop	r0
    4cb0:	0f 90       	pop	r0
    4cb2:	2c c0       	rjmp	.+88     	; 0x4d0c <csp_send_direct+0x1e0>
#endif
		}
	}

	/* Store length before passing to interface */
	uint16_t bytes = packet->length;
    4cb4:	f6 01       	movw	r30, r12
    4cb6:	00 85       	ldd	r16, Z+8	; 0x08
    4cb8:	11 85       	ldd	r17, Z+9	; 0x09
	uint16_t mtu = ifout->mtu;
    4cba:	8e 81       	ldd	r24, Y+6	; 0x06
    4cbc:	9f 81       	ldd	r25, Y+7	; 0x07

	if (mtu > 0 && bytes > mtu)
    4cbe:	00 97       	sbiw	r24, 0x00	; 0
    4cc0:	19 f0       	breq	.+6      	; 0x4cc8 <csp_send_direct+0x19c>
    4cc2:	80 17       	cp	r24, r16
    4cc4:	91 07       	cpc	r25, r17
    4cc6:	10 f1       	brcs	.+68     	; 0x4d0c <csp_send_direct+0x1e0>
		goto tx_err;

	if ((*ifout->nexthop)(ifout, packet, timeout) != CSP_ERR_NONE)
    4cc8:	ec 81       	ldd	r30, Y+4	; 0x04
    4cca:	fd 81       	ldd	r31, Y+5	; 0x05
    4ccc:	a3 01       	movw	r20, r6
    4cce:	92 01       	movw	r18, r4
    4cd0:	b6 01       	movw	r22, r12
    4cd2:	ce 01       	movw	r24, r28
    4cd4:	19 95       	eicall
    4cd6:	00 97       	sbiw	r24, 0x00	; 0
    4cd8:	c9 f4       	brne	.+50     	; 0x4d0c <csp_send_direct+0x1e0>
		goto tx_err;

	ifout->tx++;
    4cda:	49 85       	ldd	r20, Y+9	; 0x09
    4cdc:	5a 85       	ldd	r21, Y+10	; 0x0a
    4cde:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ce0:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ce2:	4f 5f       	subi	r20, 0xFF	; 255
    4ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    4ce6:	6f 4f       	sbci	r22, 0xFF	; 255
    4ce8:	7f 4f       	sbci	r23, 0xFF	; 255
    4cea:	49 87       	std	Y+9, r20	; 0x09
    4cec:	5a 87       	std	Y+10, r21	; 0x0a
    4cee:	6b 87       	std	Y+11, r22	; 0x0b
    4cf0:	7c 87       	std	Y+12, r23	; 0x0c
	ifout->txbytes += bytes;
    4cf2:	4d a1       	ldd	r20, Y+37	; 0x25
    4cf4:	5e a1       	ldd	r21, Y+38	; 0x26
    4cf6:	6f a1       	ldd	r22, Y+39	; 0x27
    4cf8:	78 a5       	ldd	r23, Y+40	; 0x28
    4cfa:	40 0f       	add	r20, r16
    4cfc:	51 1f       	adc	r21, r17
    4cfe:	61 1d       	adc	r22, r1
    4d00:	71 1d       	adc	r23, r1
    4d02:	4d a3       	std	Y+37, r20	; 0x25
    4d04:	5e a3       	std	Y+38, r21	; 0x26
    4d06:	6f a3       	std	Y+39, r22	; 0x27
    4d08:	78 a7       	std	Y+40, r23	; 0x28
	return CSP_ERR_NONE;
    4d0a:	0d c0       	rjmp	.+26     	; 0x4d26 <csp_send_direct+0x1fa>

tx_err:
	ifout->tx_error++;
    4d0c:	89 89       	ldd	r24, Y+17	; 0x11
    4d0e:	9a 89       	ldd	r25, Y+18	; 0x12
    4d10:	ab 89       	ldd	r26, Y+19	; 0x13
    4d12:	bc 89       	ldd	r27, Y+20	; 0x14
    4d14:	01 96       	adiw	r24, 0x01	; 1
    4d16:	a1 1d       	adc	r26, r1
    4d18:	b1 1d       	adc	r27, r1
    4d1a:	89 8b       	std	Y+17, r24	; 0x11
    4d1c:	9a 8b       	std	Y+18, r25	; 0x12
    4d1e:	ab 8b       	std	Y+19, r26	; 0x13
    4d20:	bc 8b       	std	Y+20, r27	; 0x14
err:
	return CSP_ERR_TX;
    4d22:	86 ef       	ldi	r24, 0xF6	; 246
    4d24:	9f ef       	ldi	r25, 0xFF	; 255

}
    4d26:	df 91       	pop	r29
    4d28:	cf 91       	pop	r28
    4d2a:	1f 91       	pop	r17
    4d2c:	0f 91       	pop	r16
    4d2e:	ff 90       	pop	r15
    4d30:	ef 90       	pop	r14
    4d32:	df 90       	pop	r13
    4d34:	cf 90       	pop	r12
    4d36:	bf 90       	pop	r11
    4d38:	af 90       	pop	r10
    4d3a:	9f 90       	pop	r9
    4d3c:	8f 90       	pop	r8
    4d3e:	7f 90       	pop	r7
    4d40:	6f 90       	pop	r6
    4d42:	5f 90       	pop	r5
    4d44:	4f 90       	pop	r4
    4d46:	08 95       	ret

00004d48 <csp_send>:

int csp_send(csp_conn_t * conn, csp_packet_t * packet, uint32_t timeout) {
    4d48:	8f 92       	push	r8
    4d4a:	9f 92       	push	r9
    4d4c:	af 92       	push	r10
    4d4e:	bf 92       	push	r11
    4d50:	cf 92       	push	r12
    4d52:	df 92       	push	r13
    4d54:	ef 92       	push	r14
    4d56:	ff 92       	push	r15
    4d58:	0f 93       	push	r16
    4d5a:	1f 93       	push	r17
    4d5c:	cf 93       	push	r28
    4d5e:	df 93       	push	r29
    4d60:	ec 01       	movw	r28, r24
    4d62:	6b 01       	movw	r12, r22
    4d64:	49 01       	movw	r8, r18
    4d66:	5a 01       	movw	r10, r20

	int ret;

	if ((conn == NULL) || (packet == NULL) || (conn->state != CONN_OPEN)) {
    4d68:	89 2b       	or	r24, r25
    4d6a:	29 f0       	breq	.+10     	; 0x4d76 <csp_send+0x2e>
    4d6c:	67 2b       	or	r22, r23
    4d6e:	19 f0       	breq	.+6      	; 0x4d76 <csp_send+0x2e>
    4d70:	89 81       	ldd	r24, Y+1	; 0x01
    4d72:	81 30       	cpi	r24, 0x01	; 1
    4d74:	69 f0       	breq	.+26     	; 0x4d90 <csp_send+0x48>
		csp_log_error("Invalid call to csp_send");
    4d76:	84 e3       	ldi	r24, 0x34	; 52
    4d78:	9c e0       	ldi	r25, 0x0C	; 12
    4d7a:	9f 93       	push	r25
    4d7c:	8f 93       	push	r24
    4d7e:	1f 92       	push	r1
    4d80:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return 0;
    4d84:	0f 90       	pop	r0
    4d86:	0f 90       	pop	r0
    4d88:	0f 90       	pop	r0
    4d8a:	80 e0       	ldi	r24, 0x00	; 0
    4d8c:	90 e0       	ldi	r25, 0x00	; 0
    4d8e:	19 c0       	rjmp	.+50     	; 0x4dc2 <csp_send+0x7a>
			return 0;
		}
	}
#endif

	csp_iface_t * ifout = csp_rtable_find_iface(conn->idout.dst);
    4d90:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d92:	92 95       	swap	r25
    4d94:	9f 70       	andi	r25, 0x0F	; 15
    4d96:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d98:	81 70       	andi	r24, 0x01	; 1
    4d9a:	82 95       	swap	r24
    4d9c:	80 7f       	andi	r24, 0xF0	; 240
    4d9e:	89 2b       	or	r24, r25
    4da0:	a6 d4       	rcall	.+2380   	; 0x56ee <csp_rtable_find_iface>
    4da2:	9c 01       	movw	r18, r24
	ret = csp_send_direct(conn->idout, packet, ifout, timeout);
    4da4:	68 85       	ldd	r22, Y+8	; 0x08
    4da6:	79 85       	ldd	r23, Y+9	; 0x09
    4da8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4daa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dac:	85 01       	movw	r16, r10
    4dae:	74 01       	movw	r14, r8
    4db0:	a6 01       	movw	r20, r12
    4db2:	bc de       	rcall	.-648    	; 0x4b2c <csp_send_direct>

	return (ret == CSP_ERR_NONE) ? 1 : 0;
    4db4:	31 e0       	ldi	r19, 0x01	; 1
    4db6:	20 e0       	ldi	r18, 0x00	; 0
    4db8:	89 2b       	or	r24, r25
    4dba:	09 f0       	breq	.+2      	; 0x4dbe <csp_send+0x76>
    4dbc:	30 e0       	ldi	r19, 0x00	; 0
    4dbe:	83 2f       	mov	r24, r19
    4dc0:	92 2f       	mov	r25, r18

}
    4dc2:	df 91       	pop	r29
    4dc4:	cf 91       	pop	r28
    4dc6:	1f 91       	pop	r17
    4dc8:	0f 91       	pop	r16
    4dca:	ff 90       	pop	r15
    4dcc:	ef 90       	pop	r14
    4dce:	df 90       	pop	r13
    4dd0:	cf 90       	pop	r12
    4dd2:	bf 90       	pop	r11
    4dd4:	af 90       	pop	r10
    4dd6:	9f 90       	pop	r9
    4dd8:	8f 90       	pop	r8
    4dda:	08 95       	ret

00004ddc <csp_malloc>:

/* FreeRTOS includes */
#include "FreeRTOS.h"

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    4ddc:	0c 94 f5 31 	jmp	0x63ea	; 0x63ea <pvPortMalloc>
}
    4de0:	08 95       	ret

00004de2 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    4de2:	0c 94 b5 31 	jmp	0x636a	; 0x636a <vPortFree>
    4de6:	08 95       	ret

00004de8 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
    4de8:	80 32       	cpi	r24, 0x20	; 32
    4dea:	91 05       	cpc	r25, r1
    4dec:	f0 f4       	brcc	.+60     	; 0x4e2a <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    4dee:	fc 01       	movw	r30, r24
    4df0:	ee 0f       	add	r30, r30
    4df2:	ff 1f       	adc	r31, r31
    4df4:	e8 0f       	add	r30, r24
    4df6:	f9 1f       	adc	r31, r25
    4df8:	e6 55       	subi	r30, 0x56	; 86
    4dfa:	fa 4f       	sbci	r31, 0xFA	; 250
    4dfc:	20 81       	ld	r18, Z
    4dfe:	21 30       	cpi	r18, 0x01	; 1
    4e00:	59 f4       	brne	.+22     	; 0x4e18 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    4e02:	fc 01       	movw	r30, r24
    4e04:	ee 0f       	add	r30, r30
    4e06:	ff 1f       	adc	r31, r31
    4e08:	8e 0f       	add	r24, r30
    4e0a:	9f 1f       	adc	r25, r31
    4e0c:	fc 01       	movw	r30, r24
    4e0e:	e6 55       	subi	r30, 0x56	; 86
    4e10:	fa 4f       	sbci	r31, 0xFA	; 250
    4e12:	81 81       	ldd	r24, Z+1	; 0x01
    4e14:	92 81       	ldd	r25, Z+2	; 0x02
    4e16:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    4e18:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <ports+0x60>
    4e1c:	81 30       	cpi	r24, 0x01	; 1
    4e1e:	41 f4       	brne	.+16     	; 0x4e30 <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    4e20:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ports+0x61>
    4e24:	90 91 0c 06 	lds	r25, 0x060C	; 0x80060c <ports+0x62>
    4e28:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
		return NULL;
    4e2a:	80 e0       	ldi	r24, 0x00	; 0
    4e2c:	90 e0       	ldi	r25, 0x00	; 0
    4e2e:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    4e30:	80 e0       	ldi	r24, 0x00	; 0
    4e32:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    4e34:	08 95       	ret

00004e36 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    4e36:	83 e6       	ldi	r24, 0x63	; 99
    4e38:	ea ea       	ldi	r30, 0xAA	; 170
    4e3a:	f5 e0       	ldi	r31, 0x05	; 5
    4e3c:	df 01       	movw	r26, r30
    4e3e:	1d 92       	st	X+, r1
    4e40:	8a 95       	dec	r24
    4e42:	e9 f7       	brne	.-6      	; 0x4e3e <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    4e44:	80 e0       	ldi	r24, 0x00	; 0
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	08 95       	ret

00004e4a <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    4e4a:	cf 93       	push	r28
    4e4c:	df 93       	push	r29
    4e4e:	9c 01       	movw	r18, r24
	
	if (socket == NULL)
    4e50:	89 2b       	or	r24, r25
    4e52:	91 f0       	breq	.+36     	; 0x4e78 <csp_listen+0x2e>
    4e54:	cb 01       	movw	r24, r22
    4e56:	e9 01       	movw	r28, r18
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    4e58:	62 e0       	ldi	r22, 0x02	; 2
    4e5a:	70 e0       	ldi	r23, 0x00	; 0
    4e5c:	51 d1       	rcall	.+674    	; 0x5100 <csp_queue_create>
    4e5e:	9f 87       	std	Y+15, r25	; 0x0f
    4e60:	8e 87       	std	Y+14, r24	; 0x0e
	if (socket->socket == NULL)
    4e62:	21 e0       	ldi	r18, 0x01	; 1
    4e64:	30 e0       	ldi	r19, 0x00	; 0
    4e66:	89 2b       	or	r24, r25
    4e68:	11 f0       	breq	.+4      	; 0x4e6e <csp_listen+0x24>
    4e6a:	20 e0       	ldi	r18, 0x00	; 0
    4e6c:	30 e0       	ldi	r19, 0x00	; 0
    4e6e:	88 27       	eor	r24, r24
    4e70:	99 27       	eor	r25, r25
    4e72:	82 1b       	sub	r24, r18
    4e74:	93 0b       	sbc	r25, r19
    4e76:	02 c0       	rjmp	.+4      	; 0x4e7c <csp_listen+0x32>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    4e78:	8e ef       	ldi	r24, 0xFE	; 254
    4e7a:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    4e7c:	df 91       	pop	r29
    4e7e:	cf 91       	pop	r28
    4e80:	08 95       	ret

00004e82 <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
    4e82:	0f 93       	push	r16
    4e84:	1f 93       	push	r17
    4e86:	cf 93       	push	r28
    4e88:	df 93       	push	r29
	
	if (socket == NULL)
    4e8a:	00 97       	sbiw	r24, 0x00	; 0
    4e8c:	09 f4       	brne	.+2      	; 0x4e90 <csp_bind+0xe>
    4e8e:	54 c0       	rjmp	.+168    	; 0x4f38 <csp_bind+0xb6>
    4e90:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    4e92:	61 32       	cpi	r22, 0x21	; 33
    4e94:	90 f0       	brcs	.+36     	; 0x4eba <csp_bind+0x38>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports", CSP_ANY);
    4e96:	1f 92       	push	r1
    4e98:	80 e2       	ldi	r24, 0x20	; 32
    4e9a:	8f 93       	push	r24
    4e9c:	84 ef       	ldi	r24, 0xF4	; 244
    4e9e:	9e e0       	ldi	r25, 0x0E	; 14
    4ea0:	9f 93       	push	r25
    4ea2:	8f 93       	push	r24
    4ea4:	1f 92       	push	r1
    4ea6:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_INVAL;
    4eaa:	0f 90       	pop	r0
    4eac:	0f 90       	pop	r0
    4eae:	0f 90       	pop	r0
    4eb0:	0f 90       	pop	r0
    4eb2:	0f 90       	pop	r0
    4eb4:	8e ef       	ldi	r24, 0xFE	; 254
    4eb6:	9f ef       	ldi	r25, 0xFF	; 255
    4eb8:	41 c0       	rjmp	.+130    	; 0x4f3c <csp_bind+0xba>
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    4eba:	c6 2f       	mov	r28, r22
    4ebc:	d0 e0       	ldi	r29, 0x00	; 0
    4ebe:	fe 01       	movw	r30, r28
    4ec0:	ee 0f       	add	r30, r30
    4ec2:	ff 1f       	adc	r31, r31
    4ec4:	ec 0f       	add	r30, r28
    4ec6:	fd 1f       	adc	r31, r29
    4ec8:	e6 55       	subi	r30, 0x56	; 86
    4eca:	fa 4f       	sbci	r31, 0xFA	; 250
    4ecc:	80 81       	ld	r24, Z
    4ece:	88 23       	and	r24, r24
    4ed0:	89 f0       	breq	.+34     	; 0x4ef4 <csp_bind+0x72>
		csp_log_error("Port %d is already in use", port);
    4ed2:	1f 92       	push	r1
    4ed4:	6f 93       	push	r22
    4ed6:	8a ed       	ldi	r24, 0xDA	; 218
    4ed8:	9e e0       	ldi	r25, 0x0E	; 14
    4eda:	9f 93       	push	r25
    4edc:	8f 93       	push	r24
    4ede:	1f 92       	push	r1
    4ee0:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_USED;
    4ee4:	0f 90       	pop	r0
    4ee6:	0f 90       	pop	r0
    4ee8:	0f 90       	pop	r0
    4eea:	0f 90       	pop	r0
    4eec:	0f 90       	pop	r0
    4eee:	8c ef       	ldi	r24, 0xFC	; 252
    4ef0:	9f ef       	ldi	r25, 0xFF	; 255
    4ef2:	24 c0       	rjmp	.+72     	; 0x4f3c <csp_bind+0xba>
	}

	csp_log_info("Binding socket %p to port %u", socket, port);
    4ef4:	1f 92       	push	r1
    4ef6:	6f 93       	push	r22
    4ef8:	1f 93       	push	r17
    4efa:	0f 93       	push	r16
    4efc:	8d eb       	ldi	r24, 0xBD	; 189
    4efe:	9e e0       	ldi	r25, 0x0E	; 14
    4f00:	9f 93       	push	r25
    4f02:	8f 93       	push	r24
    4f04:	82 e0       	ldi	r24, 0x02	; 2
    4f06:	8f 93       	push	r24
    4f08:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>

	/* Save listener */
	ports[port].socket = socket;
    4f0c:	ce 01       	movw	r24, r28
    4f0e:	88 0f       	add	r24, r24
    4f10:	99 1f       	adc	r25, r25
    4f12:	c8 0f       	add	r28, r24
    4f14:	d9 1f       	adc	r29, r25
    4f16:	c6 55       	subi	r28, 0x56	; 86
    4f18:	da 4f       	sbci	r29, 0xFA	; 250
    4f1a:	1a 83       	std	Y+2, r17	; 0x02
    4f1c:	09 83       	std	Y+1, r16	; 0x01
	ports[port].state = PORT_OPEN;
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	88 83       	st	Y, r24

	return CSP_ERR_NONE;
    4f22:	8d b7       	in	r24, 0x3d	; 61
    4f24:	9e b7       	in	r25, 0x3e	; 62
    4f26:	07 96       	adiw	r24, 0x07	; 7
    4f28:	0f b6       	in	r0, 0x3f	; 63
    4f2a:	f8 94       	cli
    4f2c:	9e bf       	out	0x3e, r25	; 62
    4f2e:	0f be       	out	0x3f, r0	; 63
    4f30:	8d bf       	out	0x3d, r24	; 61
    4f32:	80 e0       	ldi	r24, 0x00	; 0
    4f34:	90 e0       	ldi	r25, 0x00	; 0
    4f36:	02 c0       	rjmp	.+4      	; 0x4f3c <csp_bind+0xba>
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    4f38:	8e ef       	ldi	r24, 0xFE	; 254
    4f3a:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    4f3c:	df 91       	pop	r29
    4f3e:	cf 91       	pop	r28
    4f40:	1f 91       	pop	r17
    4f42:	0f 91       	pop	r16
    4f44:	08 95       	ret

00004f46 <csp_qfifo_init>:
int csp_qfifo_init(void) {
	int prio;

	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
    4f46:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4f4a:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4f4e:	89 2b       	or	r24, r25
    4f50:	59 f4       	brne	.+22     	; 0x4f68 <csp_qfifo_init+0x22>
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
    4f52:	64 e0       	ldi	r22, 0x04	; 4
    4f54:	70 e0       	ldi	r23, 0x00	; 0
    4f56:	8a e0       	ldi	r24, 0x0A	; 10
    4f58:	90 e0       	ldi	r25, 0x00	; 0
    4f5a:	d2 d0       	rcall	.+420    	; 0x5100 <csp_queue_create>
    4f5c:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <qfifo+0x1>
    4f60:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <qfifo>
			if (!qfifo[prio])
    4f64:	89 2b       	or	r24, r25
    4f66:	19 f0       	breq	.+6      	; 0x4f6e <csp_qfifo_init+0x28>
	qfifo_events = csp_queue_create(CSP_FIFO_INPUT, sizeof(int));
	if (!qfifo_events)
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;
    4f68:	80 e0       	ldi	r24, 0x00	; 0
    4f6a:	90 e0       	ldi	r25, 0x00	; 0
    4f6c:	08 95       	ret
	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
			if (!qfifo[prio])
				return CSP_ERR_NOMEM;
    4f6e:	8f ef       	ldi	r24, 0xFF	; 255
    4f70:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;

}
    4f72:	08 95       	ret

00004f74 <csp_qfifo_read>:
	if (!found) {
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
    4f74:	2f ef       	ldi	r18, 0xFF	; 255
    4f76:	3f ef       	ldi	r19, 0xFF	; 255
    4f78:	40 e0       	ldi	r20, 0x00	; 0
    4f7a:	50 e0       	ldi	r21, 0x00	; 0
    4f7c:	bc 01       	movw	r22, r24
    4f7e:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    4f82:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    4f86:	eb d0       	rcall	.+470    	; 0x515e <csp_queue_dequeue>
    4f88:	01 97       	sbiw	r24, 0x01	; 1
    4f8a:	19 f4       	brne	.+6      	; 0x4f92 <csp_qfifo_read+0x1e>
		return CSP_ERR_TIMEDOUT;
#endif

	return CSP_ERR_NONE;
    4f8c:	80 e0       	ldi	r24, 0x00	; 0
    4f8e:	90 e0       	ldi	r25, 0x00	; 0
    4f90:	08 95       	ret
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
		return CSP_ERR_TIMEDOUT;
    4f92:	8d ef       	ldi	r24, 0xFD	; 253
    4f94:	9f ef       	ldi	r25, 0xFF	; 255
#endif

	return CSP_ERR_NONE;

}
    4f96:	08 95       	ret

00004f98 <csp_qfifo_write>:

void csp_qfifo_write(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    4f98:	cf 92       	push	r12
    4f9a:	df 92       	push	r13
    4f9c:	ef 92       	push	r14
    4f9e:	ff 92       	push	r15
    4fa0:	0f 93       	push	r16
    4fa2:	1f 93       	push	r17
    4fa4:	cf 93       	push	r28
    4fa6:	df 93       	push	r29
    4fa8:	00 d0       	rcall	.+0      	; 0x4faa <csp_qfifo_write+0x12>
    4faa:	1f 92       	push	r1
    4fac:	cd b7       	in	r28, 0x3d	; 61
    4fae:	de b7       	in	r29, 0x3e	; 62
    4fb0:	7c 01       	movw	r14, r24
    4fb2:	8b 01       	movw	r16, r22
    4fb4:	6a 01       	movw	r12, r20

	int result;

	if (packet == NULL) {
    4fb6:	00 97       	sbiw	r24, 0x00	; 0
    4fb8:	61 f4       	brne	.+24     	; 0x4fd2 <csp_qfifo_write+0x3a>
		csp_log_warn("csp_new packet called with NULL packet");
    4fba:	82 ea       	ldi	r24, 0xA2	; 162
    4fbc:	9f e0       	ldi	r25, 0x0F	; 15
    4fbe:	9f 93       	push	r25
    4fc0:	8f 93       	push	r24
    4fc2:	81 e0       	ldi	r24, 0x01	; 1
    4fc4:	8f 93       	push	r24
    4fc6:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return;
    4fca:	0f 90       	pop	r0
    4fcc:	0f 90       	pop	r0
    4fce:	0f 90       	pop	r0
    4fd0:	8a c0       	rjmp	.+276    	; 0x50e6 <csp_qfifo_write+0x14e>
	} else if (interface == NULL) {
    4fd2:	61 15       	cp	r22, r1
    4fd4:	71 05       	cpc	r23, r1
    4fd6:	a9 f4       	brne	.+42     	; 0x5002 <csp_qfifo_write+0x6a>
		csp_log_warn("csp_new packet called with NULL interface");
    4fd8:	88 e7       	ldi	r24, 0x78	; 120
    4fda:	9f e0       	ldi	r25, 0x0F	; 15
    4fdc:	9f 93       	push	r25
    4fde:	8f 93       	push	r24
    4fe0:	81 e0       	ldi	r24, 0x01	; 1
    4fe2:	8f 93       	push	r24
    4fe4:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		if (pxTaskWoken == NULL)
    4fe8:	0f 90       	pop	r0
    4fea:	0f 90       	pop	r0
    4fec:	0f 90       	pop	r0
    4fee:	cd 28       	or	r12, r13
    4ff0:	21 f4       	brne	.+8      	; 0x4ffa <csp_qfifo_write+0x62>
			csp_buffer_free(packet);
    4ff2:	c7 01       	movw	r24, r14
    4ff4:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    4ff8:	76 c0       	rjmp	.+236    	; 0x50e6 <csp_qfifo_write+0x14e>
		else
			csp_buffer_free_isr(packet);
    4ffa:	c7 01       	movw	r24, r14
    4ffc:	0e 94 8c 18 	call	0x3118	; 0x3118 <csp_buffer_free_isr>
    5000:	72 c0       	rjmp	.+228    	; 0x50e6 <csp_qfifo_write+0x14e>
		return;
	}

	csp_qfifo_t queue_element;
	queue_element.interface = interface;
    5002:	7a 83       	std	Y+2, r23	; 0x02
    5004:	69 83       	std	Y+1, r22	; 0x01
	queue_element.packet = packet;
    5006:	9c 83       	std	Y+4, r25	; 0x04
    5008:	8b 83       	std	Y+3, r24	; 0x03
	int fifo = packet->id.pri;
#else
	int fifo = 0;
#endif

	if (pxTaskWoken == NULL)
    500a:	41 15       	cp	r20, r1
    500c:	51 05       	cpc	r21, r1
    500e:	79 f4       	brne	.+30     	; 0x502e <csp_qfifo_write+0x96>
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
    5010:	20 e0       	ldi	r18, 0x00	; 0
    5012:	30 e0       	ldi	r19, 0x00	; 0
    5014:	a9 01       	movw	r20, r18
    5016:	be 01       	movw	r22, r28
    5018:	6f 5f       	subi	r22, 0xFF	; 255
    501a:	7f 4f       	sbci	r23, 0xFF	; 255
    501c:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    5020:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    5024:	71 d0       	rcall	.+226    	; 0x5108 <csp_queue_enqueue>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    5026:	01 97       	sbiw	r24, 0x01	; 1
    5028:	09 f0       	breq	.+2      	; 0x502c <csp_qfifo_write+0x94>
    502a:	43 c0       	rjmp	.+134    	; 0x50b2 <csp_qfifo_write+0x11a>
    502c:	0a c0       	rjmp	.+20     	; 0x5042 <csp_qfifo_write+0xaa>
#endif

	if (pxTaskWoken == NULL)
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
	else
		result = csp_queue_enqueue_isr(qfifo[fifo], &queue_element, pxTaskWoken);
    502e:	be 01       	movw	r22, r28
    5030:	6f 5f       	subi	r22, 0xFF	; 255
    5032:	7f 4f       	sbci	r23, 0xFF	; 255
    5034:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <qfifo>
    5038:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <qfifo+0x1>
    503c:	89 d0       	rcall	.+274    	; 0x5150 <csp_queue_enqueue_isr>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    503e:	01 97       	sbiw	r24, 0x01	; 1
    5040:	e9 f4       	brne	.+58     	; 0x507c <csp_qfifo_write+0xe4>
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
	} else {
		interface->rx++;
    5042:	f8 01       	movw	r30, r16
    5044:	85 85       	ldd	r24, Z+13	; 0x0d
    5046:	96 85       	ldd	r25, Z+14	; 0x0e
    5048:	a7 85       	ldd	r26, Z+15	; 0x0f
    504a:	b0 89       	ldd	r27, Z+16	; 0x10
    504c:	01 96       	adiw	r24, 0x01	; 1
    504e:	a1 1d       	adc	r26, r1
    5050:	b1 1d       	adc	r27, r1
    5052:	85 87       	std	Z+13, r24	; 0x0d
    5054:	96 87       	std	Z+14, r25	; 0x0e
    5056:	a7 87       	std	Z+15, r26	; 0x0f
    5058:	b0 8b       	std	Z+16, r27	; 0x10
		interface->rxbytes += packet->length;
    505a:	f7 01       	movw	r30, r14
    505c:	20 85       	ldd	r18, Z+8	; 0x08
    505e:	31 85       	ldd	r19, Z+9	; 0x09
    5060:	f8 01       	movw	r30, r16
    5062:	81 a5       	ldd	r24, Z+41	; 0x29
    5064:	92 a5       	ldd	r25, Z+42	; 0x2a
    5066:	a3 a5       	ldd	r26, Z+43	; 0x2b
    5068:	b4 a5       	ldd	r27, Z+44	; 0x2c
    506a:	82 0f       	add	r24, r18
    506c:	93 1f       	adc	r25, r19
    506e:	a1 1d       	adc	r26, r1
    5070:	b1 1d       	adc	r27, r1
    5072:	81 a7       	std	Z+41, r24	; 0x29
    5074:	92 a7       	std	Z+42, r25	; 0x2a
    5076:	a3 a7       	std	Z+43, r26	; 0x2b
    5078:	b4 a7       	std	Z+44, r27	; 0x2c
    507a:	35 c0       	rjmp	.+106    	; 0x50e6 <csp_qfifo_write+0x14e>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    507c:	84 e4       	ldi	r24, 0x44	; 68
    507e:	9f e0       	ldi	r25, 0x0F	; 15
    5080:	9f 93       	push	r25
    5082:	8f 93       	push	r24
    5084:	81 e0       	ldi	r24, 0x01	; 1
    5086:	8f 93       	push	r24
    5088:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		interface->drop++;
    508c:	f8 01       	movw	r30, r16
    508e:	81 8d       	ldd	r24, Z+25	; 0x19
    5090:	92 8d       	ldd	r25, Z+26	; 0x1a
    5092:	a3 8d       	ldd	r26, Z+27	; 0x1b
    5094:	b4 8d       	ldd	r27, Z+28	; 0x1c
    5096:	01 96       	adiw	r24, 0x01	; 1
    5098:	a1 1d       	adc	r26, r1
    509a:	b1 1d       	adc	r27, r1
    509c:	81 8f       	std	Z+25, r24	; 0x19
    509e:	92 8f       	std	Z+26, r25	; 0x1a
    50a0:	a3 8f       	std	Z+27, r26	; 0x1b
    50a2:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
    50a4:	c7 01       	movw	r24, r14
    50a6:	0e 94 8c 18 	call	0x3118	; 0x3118 <csp_buffer_free_isr>
    50aa:	0f 90       	pop	r0
    50ac:	0f 90       	pop	r0
    50ae:	0f 90       	pop	r0
    50b0:	1a c0       	rjmp	.+52     	; 0x50e6 <csp_qfifo_write+0x14e>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    50b2:	84 e4       	ldi	r24, 0x44	; 68
    50b4:	9f e0       	ldi	r25, 0x0F	; 15
    50b6:	9f 93       	push	r25
    50b8:	8f 93       	push	r24
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	8f 93       	push	r24
    50be:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		interface->drop++;
    50c2:	f8 01       	movw	r30, r16
    50c4:	81 8d       	ldd	r24, Z+25	; 0x19
    50c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    50c8:	a3 8d       	ldd	r26, Z+27	; 0x1b
    50ca:	b4 8d       	ldd	r27, Z+28	; 0x1c
    50cc:	01 96       	adiw	r24, 0x01	; 1
    50ce:	a1 1d       	adc	r26, r1
    50d0:	b1 1d       	adc	r27, r1
    50d2:	81 8f       	std	Z+25, r24	; 0x19
    50d4:	92 8f       	std	Z+26, r25	; 0x1a
    50d6:	a3 8f       	std	Z+27, r26	; 0x1b
    50d8:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
    50da:	c7 01       	movw	r24, r14
    50dc:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    50e0:	0f 90       	pop	r0
    50e2:	0f 90       	pop	r0
    50e4:	0f 90       	pop	r0
	} else {
		interface->rx++;
		interface->rxbytes += packet->length;
	}

}
    50e6:	0f 90       	pop	r0
    50e8:	0f 90       	pop	r0
    50ea:	0f 90       	pop	r0
    50ec:	0f 90       	pop	r0
    50ee:	df 91       	pop	r29
    50f0:	cf 91       	pop	r28
    50f2:	1f 91       	pop	r17
    50f4:	0f 91       	pop	r16
    50f6:	ff 90       	pop	r15
    50f8:	ef 90       	pop	r14
    50fa:	df 90       	pop	r13
    50fc:	cf 90       	pop	r12
    50fe:	08 95       	ret

00005100 <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    5100:	40 e0       	ldi	r20, 0x00	; 0
    5102:	0c 94 bd 35 	jmp	0x6b7a	; 0x6b7a <xQueueGenericCreate>
    5106:	08 95       	ret

00005108 <csp_queue_enqueue>:
    5108:	0f 93       	push	r16
    510a:	1f 93       	push	r17
    510c:	cf 93       	push	r28
    510e:	df 93       	push	r29
    5110:	ec 01       	movw	r28, r24
    5112:	8b 01       	movw	r16, r22
    5114:	ca 01       	movw	r24, r20
    5116:	b9 01       	movw	r22, r18
    5118:	6f 3f       	cpi	r22, 0xFF	; 255
    511a:	2f ef       	ldi	r18, 0xFF	; 255
    511c:	72 07       	cpc	r23, r18
    511e:	81 05       	cpc	r24, r1
    5120:	91 05       	cpc	r25, r1
    5122:	41 f0       	breq	.+16     	; 0x5134 <csp_queue_enqueue+0x2c>
    5124:	2a e0       	ldi	r18, 0x0A	; 10
    5126:	30 e0       	ldi	r19, 0x00	; 0
    5128:	40 e0       	ldi	r20, 0x00	; 0
    512a:	50 e0       	ldi	r21, 0x00	; 0
    512c:	0e 94 c3 44 	call	0x8986	; 0x8986 <__udivmodsi4>
    5130:	ca 01       	movw	r24, r20
    5132:	b9 01       	movw	r22, r18
    5134:	20 e0       	ldi	r18, 0x00	; 0
    5136:	ab 01       	movw	r20, r22
    5138:	b8 01       	movw	r22, r16
    513a:	ce 01       	movw	r24, r28
    513c:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xQueueGenericSend>
    5140:	08 2e       	mov	r0, r24
    5142:	00 0c       	add	r0, r0
    5144:	99 0b       	sbc	r25, r25
    5146:	df 91       	pop	r29
    5148:	cf 91       	pop	r28
    514a:	1f 91       	pop	r17
    514c:	0f 91       	pop	r16
    514e:	08 95       	ret

00005150 <csp_queue_enqueue_isr>:
    5150:	20 e0       	ldi	r18, 0x00	; 0
    5152:	0e 94 95 36 	call	0x6d2a	; 0x6d2a <xQueueGenericSendFromISR>
    5156:	08 2e       	mov	r0, r24
    5158:	00 0c       	add	r0, r0
    515a:	99 0b       	sbc	r25, r25
    515c:	08 95       	ret

0000515e <csp_queue_dequeue>:
    515e:	0f 93       	push	r16
    5160:	1f 93       	push	r17
    5162:	cf 93       	push	r28
    5164:	df 93       	push	r29
    5166:	ec 01       	movw	r28, r24
    5168:	8b 01       	movw	r16, r22
    516a:	2f 3f       	cpi	r18, 0xFF	; 255
    516c:	8f ef       	ldi	r24, 0xFF	; 255
    516e:	38 07       	cpc	r19, r24
    5170:	41 05       	cpc	r20, r1
    5172:	51 05       	cpc	r21, r1
    5174:	41 f0       	breq	.+16     	; 0x5186 <csp_queue_dequeue+0x28>
    5176:	ca 01       	movw	r24, r20
    5178:	b9 01       	movw	r22, r18
    517a:	2a e0       	ldi	r18, 0x0A	; 10
    517c:	30 e0       	ldi	r19, 0x00	; 0
    517e:	40 e0       	ldi	r20, 0x00	; 0
    5180:	50 e0       	ldi	r21, 0x00	; 0
    5182:	0e 94 c3 44 	call	0x8986	; 0x8986 <__udivmodsi4>
    5186:	a9 01       	movw	r20, r18
    5188:	b8 01       	movw	r22, r16
    518a:	ce 01       	movw	r24, r28
    518c:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <xQueueReceive>
    5190:	08 2e       	mov	r0, r24
    5192:	00 0c       	add	r0, r0
    5194:	99 0b       	sbc	r25, r25
    5196:	df 91       	pop	r29
    5198:	cf 91       	pop	r28
    519a:	1f 91       	pop	r17
    519c:	0f 91       	pop	r16
    519e:	08 95       	ret

000051a0 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    51a0:	0e 94 47 38 	call	0x708e	; 0x708e <uxQueueMessagesWaiting>
}
    51a4:	90 e0       	ldi	r25, 0x00	; 0
    51a6:	08 95       	ret

000051a8 <csp_route_security_check>:
 * @param security_opts either socket_opts or conn_opts
 * @param interface pointer to incoming interface
 * @param packet pointer to packet
 * @return -1 Missing feature, -2 XTEA error, -3 CRC error, -4 HMAC error, 0 = OK.
 */
static int csp_route_security_check(uint32_t security_opts, csp_iface_t * interface, csp_packet_t * packet) {
    51a8:	0f 93       	push	r16
    51aa:	1f 93       	push	r17
    51ac:	cf 93       	push	r28
    51ae:	df 93       	push	r29
    51b0:	8a 01       	movw	r16, r20
    51b2:	e9 01       	movw	r28, r18
		return CSP_ERR_XTEA;
	}
#endif

	/* CRC32 verified packet */
	if (packet->id.flags & CSP_FCRC32) {
    51b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    51b6:	80 ff       	sbrs	r24, 0
    51b8:	32 c0       	rjmp	.+100    	; 0x521e <csp_route_security_check+0x76>
#ifdef CSP_USE_CRC32
		if (packet->length < 4)
    51ba:	88 85       	ldd	r24, Y+8	; 0x08
    51bc:	99 85       	ldd	r25, Y+9	; 0x09
    51be:	84 30       	cpi	r24, 0x04	; 4
    51c0:	91 05       	cpc	r25, r1
    51c2:	70 f4       	brcc	.+28     	; 0x51e0 <csp_route_security_check+0x38>
			csp_log_error("Too short packet for CRC32, %u", packet->length);
    51c4:	9f 93       	push	r25
    51c6:	8f 93       	push	r24
    51c8:	88 e4       	ldi	r24, 0x48	; 72
    51ca:	90 e1       	ldi	r25, 0x10	; 16
    51cc:	9f 93       	push	r25
    51ce:	8f 93       	push	r24
    51d0:	1f 92       	push	r1
    51d2:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    51d6:	0f 90       	pop	r0
    51d8:	0f 90       	pop	r0
    51da:	0f 90       	pop	r0
    51dc:	0f 90       	pop	r0
    51de:	0f 90       	pop	r0
		/* Verify CRC32 (does not include header for backwards compatability with csp1.x) */
		if (csp_crc32_verify(packet, false) != 0) {
    51e0:	60 e0       	ldi	r22, 0x00	; 0
    51e2:	ce 01       	movw	r24, r28
    51e4:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <csp_crc32_verify>
    51e8:	00 97       	sbiw	r24, 0x00	; 0
    51ea:	59 f1       	breq	.+86     	; 0x5242 <csp_route_security_check+0x9a>
			/* Checksum failed */
			csp_log_error("CRC32 verification error! Discarding packet");
    51ec:	8c e1       	ldi	r24, 0x1C	; 28
    51ee:	90 e1       	ldi	r25, 0x10	; 16
    51f0:	9f 93       	push	r25
    51f2:	8f 93       	push	r24
    51f4:	1f 92       	push	r1
    51f6:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			interface->rx_error++;
    51fa:	f8 01       	movw	r30, r16
    51fc:	85 89       	ldd	r24, Z+21	; 0x15
    51fe:	96 89       	ldd	r25, Z+22	; 0x16
    5200:	a7 89       	ldd	r26, Z+23	; 0x17
    5202:	b0 8d       	ldd	r27, Z+24	; 0x18
    5204:	01 96       	adiw	r24, 0x01	; 1
    5206:	a1 1d       	adc	r26, r1
    5208:	b1 1d       	adc	r27, r1
    520a:	85 8b       	std	Z+21, r24	; 0x15
    520c:	96 8b       	std	Z+22, r25	; 0x16
    520e:	a7 8b       	std	Z+23, r26	; 0x17
    5210:	b0 8f       	std	Z+24, r27	; 0x18
			return CSP_ERR_CRC32;
    5212:	0f 90       	pop	r0
    5214:	0f 90       	pop	r0
    5216:	0f 90       	pop	r0
    5218:	8a e9       	ldi	r24, 0x9A	; 154
    521a:	9f ef       	ldi	r25, 0xFF	; 255
    521c:	12 c0       	rjmp	.+36     	; 0x5242 <csp_route_security_check+0x9a>
		}
	} else if (security_opts & CSP_SO_CRC32REQ) {
    521e:	66 ff       	sbrs	r22, 6
    5220:	0e c0       	rjmp	.+28     	; 0x523e <csp_route_security_check+0x96>
		csp_log_warn("Received packet without CRC32. Accepting packet");
    5222:	8c ee       	ldi	r24, 0xEC	; 236
    5224:	9f e0       	ldi	r25, 0x0F	; 15
    5226:	9f 93       	push	r25
    5228:	8f 93       	push	r24
    522a:	81 e0       	ldi	r24, 0x01	; 1
    522c:	8f 93       	push	r24
    522e:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    5232:	0f 90       	pop	r0
    5234:	0f 90       	pop	r0
    5236:	0f 90       	pop	r0
			return CSP_ERR_INVAL;
		}
	}
#endif

	return CSP_ERR_NONE;
    5238:	80 e0       	ldi	r24, 0x00	; 0
    523a:	90 e0       	ldi	r25, 0x00	; 0
    523c:	02 c0       	rjmp	.+4      	; 0x5242 <csp_route_security_check+0x9a>
    523e:	80 e0       	ldi	r24, 0x00	; 0
    5240:	90 e0       	ldi	r25, 0x00	; 0

}
    5242:	df 91       	pop	r29
    5244:	cf 91       	pop	r28
    5246:	1f 91       	pop	r17
    5248:	0f 91       	pop	r16
    524a:	08 95       	ret

0000524c <csp_route_work>:

int csp_route_work(uint32_t timeout) {
    524c:	cf 92       	push	r12
    524e:	df 92       	push	r13
    5250:	ef 92       	push	r14
    5252:	ff 92       	push	r15
    5254:	0f 93       	push	r16
    5256:	1f 93       	push	r17
    5258:	cf 93       	push	r28
    525a:	df 93       	push	r29
    525c:	00 d0       	rcall	.+0      	; 0x525e <csp_route_work+0x12>
    525e:	00 d0       	rcall	.+0      	; 0x5260 <csp_route_work+0x14>
    5260:	cd b7       	in	r28, 0x3d	; 61
    5262:	de b7       	in	r29, 0x3e	; 62
	/* Check connection timeouts (currently only for RDP) */
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
    5264:	ce 01       	movw	r24, r28
    5266:	01 96       	adiw	r24, 0x01	; 1
    5268:	85 de       	rcall	.-758    	; 0x4f74 <csp_qfifo_read>
    526a:	6c 01       	movw	r12, r24
    526c:	89 2b       	or	r24, r25
    526e:	09 f0       	breq	.+2      	; 0x5272 <csp_route_work+0x26>
    5270:	a0 c1       	rjmp	.+832    	; 0x55b2 <csp_route_work+0x366>
		return -1;

	packet = input.packet;
    5272:	eb 81       	ldd	r30, Y+3	; 0x03
    5274:	fc 81       	ldd	r31, Y+4	; 0x04
    5276:	fe 83       	std	Y+6, r31	; 0x06
    5278:	ed 83       	std	Y+5, r30	; 0x05

	csp_log_packet("INP: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %"PRIu16" VIA: %s",
    527a:	a9 81       	ldd	r26, Y+1	; 0x01
    527c:	ba 81       	ldd	r27, Y+2	; 0x02
    527e:	11 96       	adiw	r26, 0x01	; 1
    5280:	8c 91       	ld	r24, X
    5282:	11 97       	sbiw	r26, 0x01	; 1
    5284:	8f 93       	push	r24
    5286:	8c 91       	ld	r24, X
    5288:	8f 93       	push	r24
    528a:	81 85       	ldd	r24, Z+9	; 0x09
    528c:	8f 93       	push	r24
    528e:	80 85       	ldd	r24, Z+8	; 0x08
    5290:	8f 93       	push	r24
    5292:	82 85       	ldd	r24, Z+10	; 0x0a
    5294:	1f 92       	push	r1
    5296:	8f 93       	push	r24
    5298:	85 85       	ldd	r24, Z+13	; 0x0d
    529a:	82 95       	swap	r24
    529c:	86 95       	lsr	r24
    529e:	86 95       	lsr	r24
    52a0:	83 70       	andi	r24, 0x03	; 3
    52a2:	1f 92       	push	r1
    52a4:	8f 93       	push	r24
    52a6:	83 85       	ldd	r24, Z+11	; 0x0b
    52a8:	8f 73       	andi	r24, 0x3F	; 63
    52aa:	1f 92       	push	r1
    52ac:	8f 93       	push	r24
    52ae:	83 85       	ldd	r24, Z+11	; 0x0b
    52b0:	98 2f       	mov	r25, r24
    52b2:	92 95       	swap	r25
    52b4:	96 95       	lsr	r25
    52b6:	96 95       	lsr	r25
    52b8:	93 70       	andi	r25, 0x03	; 3
    52ba:	84 85       	ldd	r24, Z+12	; 0x0c
    52bc:	8f 70       	andi	r24, 0x0F	; 15
    52be:	88 0f       	add	r24, r24
    52c0:	88 0f       	add	r24, r24
    52c2:	89 2b       	or	r24, r25
    52c4:	1f 92       	push	r1
    52c6:	8f 93       	push	r24
    52c8:	84 85       	ldd	r24, Z+12	; 0x0c
    52ca:	98 2f       	mov	r25, r24
    52cc:	92 95       	swap	r25
    52ce:	9f 70       	andi	r25, 0x0F	; 15
    52d0:	85 85       	ldd	r24, Z+13	; 0x0d
    52d2:	81 70       	andi	r24, 0x01	; 1
    52d4:	82 95       	swap	r24
    52d6:	80 7f       	andi	r24, 0xF0	; 240
    52d8:	89 2b       	or	r24, r25
    52da:	1f 92       	push	r1
    52dc:	8f 93       	push	r24
    52de:	85 85       	ldd	r24, Z+13	; 0x0d
    52e0:	86 95       	lsr	r24
    52e2:	8f 71       	andi	r24, 0x1F	; 31
    52e4:	1f 92       	push	r1
    52e6:	8f 93       	push	r24
    52e8:	8d eb       	ldi	r24, 0xBD	; 189
    52ea:	91 e1       	ldi	r25, 0x11	; 17
    52ec:	9f 93       	push	r25
    52ee:	8f 93       	push	r24
    52f0:	84 e0       	ldi	r24, 0x04	; 4
    52f2:	8f 93       	push	r24
    52f4:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return 0;
	}
#endif

	/* If the message is not to me, route the message to the correct interface */
	if ((packet->id.dst != csp_get_address()) && (packet->id.dst != CSP_BROADCAST_ADDR)) {
    52f8:	ed 81       	ldd	r30, Y+5	; 0x05
    52fa:	fe 81       	ldd	r31, Y+6	; 0x06
    52fc:	04 85       	ldd	r16, Z+12	; 0x0c
    52fe:	80 2f       	mov	r24, r16
    5300:	82 95       	swap	r24
    5302:	8f 70       	andi	r24, 0x0F	; 15
    5304:	05 85       	ldd	r16, Z+13	; 0x0d
    5306:	01 70       	andi	r16, 0x01	; 1
    5308:	02 95       	swap	r16
    530a:	00 7f       	andi	r16, 0xF0	; 240
    530c:	08 2b       	or	r16, r24
    530e:	10 e0       	ldi	r17, 0x00	; 0
    5310:	1b db       	rcall	.-2506   	; 0x4948 <csp_get_address>
    5312:	90 e0       	ldi	r25, 0x00	; 0
    5314:	0f b6       	in	r0, 0x3f	; 63
    5316:	f8 94       	cli
    5318:	de bf       	out	0x3e, r29	; 62
    531a:	0f be       	out	0x3f, r0	; 63
    531c:	cd bf       	out	0x3d, r28	; 61
    531e:	08 17       	cp	r16, r24
    5320:	19 07       	cpc	r17, r25
    5322:	09 f4       	brne	.+2      	; 0x5326 <csp_route_work+0xda>
    5324:	3f c0       	rjmp	.+126    	; 0x53a4 <csp_route_work+0x158>
    5326:	ed 81       	ldd	r30, Y+5	; 0x05
    5328:	fe 81       	ldd	r31, Y+6	; 0x06
    532a:	84 85       	ldd	r24, Z+12	; 0x0c
    532c:	98 2f       	mov	r25, r24
    532e:	92 95       	swap	r25
    5330:	9f 70       	andi	r25, 0x0F	; 15
    5332:	85 85       	ldd	r24, Z+13	; 0x0d
    5334:	81 70       	andi	r24, 0x01	; 1
    5336:	82 95       	swap	r24
    5338:	80 7f       	andi	r24, 0xF0	; 240
    533a:	89 2b       	or	r24, r25
    533c:	8f 31       	cpi	r24, 0x1F	; 31

		/* Find the destination interface */
		csp_iface_t * dstif = csp_rtable_find_iface(packet->id.dst);
    533e:	91 f1       	breq	.+100    	; 0x53a4 <csp_route_work+0x158>
    5340:	d6 d1       	rcall	.+940    	; 0x56ee <csp_rtable_find_iface>
    5342:	fc 01       	movw	r30, r24

		/* If the message resolves to the input interface, don't loop it back out */
		if ((dstif == NULL) || ((dstif == input.interface) && (input.interface->split_horizon_off == 0))) {
    5344:	00 97       	sbiw	r24, 0x00	; 0
    5346:	41 f0       	breq	.+16     	; 0x5358 <csp_route_work+0x10c>
    5348:	29 81       	ldd	r18, Y+1	; 0x01
    534a:	3a 81       	ldd	r19, Y+2	; 0x02
    534c:	82 17       	cp	r24, r18
    534e:	93 07       	cpc	r25, r19
    5350:	41 f4       	brne	.+16     	; 0x5362 <csp_route_work+0x116>
    5352:	20 85       	ldd	r18, Z+8	; 0x08
    5354:	21 11       	cpse	r18, r1
    5356:	05 c0       	rjmp	.+10     	; 0x5362 <csp_route_work+0x116>
			csp_buffer_free(packet);
    5358:	8d 81       	ldd	r24, Y+5	; 0x05
    535a:	9e 81       	ldd	r25, Y+6	; 0x06
    535c:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    5360:	67 c1       	rjmp	.+718    	; 0x5630 <csp_route_work+0x3e4>
		}

		/* Otherwise, actually send the message */
		if (csp_send_direct(packet->id, packet, dstif, 0) != CSP_ERR_NONE) {
    5362:	4d 81       	ldd	r20, Y+5	; 0x05
    5364:	5e 81       	ldd	r21, Y+6	; 0x06
    5366:	da 01       	movw	r26, r20
    5368:	1a 96       	adiw	r26, 0x0a	; 10
    536a:	6d 91       	ld	r22, X+
    536c:	7d 91       	ld	r23, X+
    536e:	8d 91       	ld	r24, X+
    5370:	9c 91       	ld	r25, X
    5372:	1d 97       	sbiw	r26, 0x0d	; 13
    5374:	e1 2c       	mov	r14, r1
    5376:	f1 2c       	mov	r15, r1
    5378:	87 01       	movw	r16, r14
    537a:	9f 01       	movw	r18, r30
    537c:	d7 db       	rcall	.-2130   	; 0x4b2c <csp_send_direct>
    537e:	00 97       	sbiw	r24, 0x00	; 0
    5380:	09 f4       	brne	.+2      	; 0x5384 <csp_route_work+0x138>
    5382:	1b c1       	rjmp	.+566    	; 0x55ba <csp_route_work+0x36e>
			csp_log_warn("Router failed to send");
    5384:	87 ea       	ldi	r24, 0xA7	; 167
    5386:	91 e1       	ldi	r25, 0x11	; 17
    5388:	9f 93       	push	r25
    538a:	8f 93       	push	r24
    538c:	81 e0       	ldi	r24, 0x01	; 1
    538e:	8f 93       	push	r24
    5390:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			csp_buffer_free(packet);
    5394:	8d 81       	ldd	r24, Y+5	; 0x05
    5396:	9e 81       	ldd	r25, Y+6	; 0x06
    5398:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    539c:	0f 90       	pop	r0
    539e:	0f 90       	pop	r0
    53a0:	0f 90       	pop	r0
    53a2:	46 c1       	rjmp	.+652    	; 0x5630 <csp_route_work+0x3e4>
		/* Next message, please */
		return 0;
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
    53a4:	ed 81       	ldd	r30, Y+5	; 0x05
    53a6:	fe 81       	ldd	r31, Y+6	; 0x06
    53a8:	09 81       	ldd	r16, Y+1	; 0x01
    53aa:	1a 81       	ldd	r17, Y+2	; 0x02
 */
static int csp_route_check_options(csp_iface_t *interface, csp_packet_t *packet)
{
#ifndef CSP_USE_XTEA
	/* Drop XTEA packets */
	if (packet->id.flags & CSP_FXTEA) {
    53ac:	82 85       	ldd	r24, Z+10	; 0x0a
    53ae:	82 ff       	sbrs	r24, 2
    53b0:	17 c0       	rjmp	.+46     	; 0x53e0 <csp_route_work+0x194>
		csp_log_error("Received XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    53b2:	80 e1       	ldi	r24, 0x10	; 16
    53b4:	91 e1       	ldi	r25, 0x11	; 17
    53b6:	9f 93       	push	r25
    53b8:	8f 93       	push	r24
    53ba:	1f 92       	push	r1
    53bc:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		interface->autherr++;
    53c0:	f8 01       	movw	r30, r16
    53c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    53c4:	96 8d       	ldd	r25, Z+30	; 0x1e
    53c6:	a7 8d       	ldd	r26, Z+31	; 0x1f
    53c8:	b0 a1       	ldd	r27, Z+32	; 0x20
    53ca:	01 96       	adiw	r24, 0x01	; 1
    53cc:	a1 1d       	adc	r26, r1
    53ce:	b1 1d       	adc	r27, r1
    53d0:	85 8f       	std	Z+29, r24	; 0x1d
    53d2:	96 8f       	std	Z+30, r25	; 0x1e
    53d4:	a7 8f       	std	Z+31, r26	; 0x1f
    53d6:	b0 a3       	std	Z+32, r27	; 0x20
    53d8:	0f 90       	pop	r0
    53da:	0f 90       	pop	r0
    53dc:	0f 90       	pop	r0
    53de:	ef c0       	rjmp	.+478    	; 0x55be <csp_route_work+0x372>
	}
#endif

#ifndef CSP_USE_HMAC
	/* Drop HMAC packets */
	if (packet->id.flags & CSP_FHMAC) {
    53e0:	83 ff       	sbrs	r24, 3
    53e2:	17 c0       	rjmp	.+46     	; 0x5412 <csp_route_work+0x1c6>
		csp_log_error("Received packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    53e4:	88 eb       	ldi	r24, 0xB8	; 184
    53e6:	90 e1       	ldi	r25, 0x10	; 16
    53e8:	9f 93       	push	r25
    53ea:	8f 93       	push	r24
    53ec:	1f 92       	push	r1
    53ee:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		interface->autherr++;
    53f2:	f8 01       	movw	r30, r16
    53f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    53f6:	96 8d       	ldd	r25, Z+30	; 0x1e
    53f8:	a7 8d       	ldd	r26, Z+31	; 0x1f
    53fa:	b0 a1       	ldd	r27, Z+32	; 0x20
    53fc:	01 96       	adiw	r24, 0x01	; 1
    53fe:	a1 1d       	adc	r26, r1
    5400:	b1 1d       	adc	r27, r1
    5402:	85 8f       	std	Z+29, r24	; 0x1d
    5404:	96 8f       	std	Z+30, r25	; 0x1e
    5406:	a7 8f       	std	Z+31, r26	; 0x1f
    5408:	b0 a3       	std	Z+32, r27	; 0x20
    540a:	0f 90       	pop	r0
    540c:	0f 90       	pop	r0
    540e:	0f 90       	pop	r0
    5410:	d6 c0       	rjmp	.+428    	; 0x55be <csp_route_work+0x372>
	}
#endif

#ifndef CSP_USE_RDP
	/* Drop RDP packets */
	if (packet->id.flags & CSP_FRDP) {
    5412:	81 ff       	sbrs	r24, 1
    5414:	d9 c0       	rjmp	.+434    	; 0x55c8 <csp_route_work+0x37c>
		csp_log_error("Received RDP packet, but CSP was compiled without RDP support. Discarding packet");
    5416:	87 e6       	ldi	r24, 0x67	; 103
    5418:	90 e1       	ldi	r25, 0x10	; 16
    541a:	9f 93       	push	r25
    541c:	8f 93       	push	r24
    541e:	1f 92       	push	r1
    5420:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		interface->rx_error++;
    5424:	f8 01       	movw	r30, r16
    5426:	85 89       	ldd	r24, Z+21	; 0x15
    5428:	96 89       	ldd	r25, Z+22	; 0x16
    542a:	a7 89       	ldd	r26, Z+23	; 0x17
    542c:	b0 8d       	ldd	r27, Z+24	; 0x18
    542e:	01 96       	adiw	r24, 0x01	; 1
    5430:	a1 1d       	adc	r26, r1
    5432:	b1 1d       	adc	r27, r1
    5434:	85 8b       	std	Z+21, r24	; 0x15
    5436:	96 8b       	std	Z+22, r25	; 0x16
    5438:	a7 8b       	std	Z+23, r26	; 0x17
    543a:	b0 8f       	std	Z+24, r27	; 0x18
    543c:	0f 90       	pop	r0
    543e:	0f 90       	pop	r0
    5440:	0f 90       	pop	r0
    5442:	bd c0       	rjmp	.+378    	; 0x55be <csp_route_work+0x372>

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    5444:	d8 01       	movw	r26, r16
    5446:	54 96       	adiw	r26, 0x14	; 20
    5448:	6d 91       	ld	r22, X+
    544a:	7d 91       	ld	r23, X+
    544c:	8d 91       	ld	r24, X+
    544e:	9c 91       	ld	r25, X
    5450:	57 97       	sbiw	r26, 0x17	; 23
    5452:	70 ff       	sbrs	r23, 0
    5454:	cb c0       	rjmp	.+406    	; 0x55ec <csp_route_work+0x3a0>
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    5456:	2d 81       	ldd	r18, Y+5	; 0x05
    5458:	3e 81       	ldd	r19, Y+6	; 0x06
    545a:	49 81       	ldd	r20, Y+1	; 0x01
    545c:	5a 81       	ldd	r21, Y+2	; 0x02
    545e:	a4 de       	rcall	.-696    	; 0x51a8 <csp_route_security_check>
    5460:	99 23       	and	r25, r25
    5462:	2c f4       	brge	.+10     	; 0x546e <csp_route_work+0x222>
			csp_buffer_free(packet);
    5464:	8d 81       	ldd	r24, Y+5	; 0x05
    5466:	9e 81       	ldd	r25, Y+6	; 0x06
    5468:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    546c:	e1 c0       	rjmp	.+450    	; 0x5630 <csp_route_work+0x3e4>
		}
		if (csp_queue_enqueue(socket->socket, &packet, 0) != CSP_QUEUE_OK) {
    546e:	20 e0       	ldi	r18, 0x00	; 0
    5470:	30 e0       	ldi	r19, 0x00	; 0
    5472:	a9 01       	movw	r20, r18
    5474:	be 01       	movw	r22, r28
    5476:	6b 5f       	subi	r22, 0xFB	; 251
    5478:	7f 4f       	sbci	r23, 0xFF	; 255
    547a:	f8 01       	movw	r30, r16
    547c:	86 85       	ldd	r24, Z+14	; 0x0e
    547e:	97 85       	ldd	r25, Z+15	; 0x0f
    5480:	43 de       	rcall	.-890    	; 0x5108 <csp_queue_enqueue>
    5482:	01 97       	sbiw	r24, 0x01	; 1
    5484:	09 f4       	brne	.+2      	; 0x5488 <csp_route_work+0x23c>
    5486:	d4 c0       	rjmp	.+424    	; 0x5630 <csp_route_work+0x3e4>
			csp_log_error("Conn-less socket queue full");
    5488:	8b e8       	ldi	r24, 0x8B	; 139
    548a:	91 e1       	ldi	r25, 0x11	; 17
    548c:	9f 93       	push	r25
    548e:	8f 93       	push	r24
    5490:	1f 92       	push	r1
    5492:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			csp_buffer_free(packet);
    5496:	8d 81       	ldd	r24, Y+5	; 0x05
    5498:	9e 81       	ldd	r25, Y+6	; 0x06
    549a:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    549e:	0f 90       	pop	r0
    54a0:	0f 90       	pop	r0
    54a2:	0f 90       	pop	r0
    54a4:	c5 c0       	rjmp	.+394    	; 0x5630 <csp_route_work+0x3e4>
	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {

		/* Reject packet if no matching socket is found */
		if (!socket) {
			csp_buffer_free(packet);
    54a6:	8d 81       	ldd	r24, Y+5	; 0x05
    54a8:	9e 81       	ldd	r25, Y+6	; 0x06
    54aa:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    54ae:	c0 c0       	rjmp	.+384    	; 0x5630 <csp_route_work+0x3e4>
		}

		/* Run security check on incoming packet */
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    54b0:	2d 81       	ldd	r18, Y+5	; 0x05
    54b2:	3e 81       	ldd	r19, Y+6	; 0x06
    54b4:	49 81       	ldd	r20, Y+1	; 0x01
    54b6:	5a 81       	ldd	r21, Y+2	; 0x02
    54b8:	d8 01       	movw	r26, r16
    54ba:	54 96       	adiw	r26, 0x14	; 20
    54bc:	6d 91       	ld	r22, X+
    54be:	7d 91       	ld	r23, X+
    54c0:	8d 91       	ld	r24, X+
    54c2:	9c 91       	ld	r25, X
    54c4:	57 97       	sbiw	r26, 0x17	; 23
    54c6:	70 de       	rcall	.-800    	; 0x51a8 <csp_route_security_check>
    54c8:	99 23       	and	r25, r25
    54ca:	2c f4       	brge	.+10     	; 0x54d6 <csp_route_work+0x28a>
			csp_buffer_free(packet);
    54cc:	8d 81       	ldd	r24, Y+5	; 0x05
    54ce:	9e 81       	ldd	r25, Y+6	; 0x06
    54d0:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
		}

		/* New incoming connection accepted */
		csp_id_t idout;
		idout.pri   = packet->id.pri;
    54d4:	ad c0       	rjmp	.+346    	; 0x5630 <csp_route_work+0x3e4>
    54d6:	ed 81       	ldd	r30, Y+5	; 0x05
    54d8:	fe 81       	ldd	r31, Y+6	; 0x06
    54da:	85 85       	ldd	r24, Z+13	; 0x0d
    54dc:	80 7c       	andi	r24, 0xC0	; 192
		idout.src   = csp_get_address();
    54de:	f8 2e       	mov	r15, r24
    54e0:	33 da       	rcall	.-2970   	; 0x4948 <csp_get_address>
    54e2:	8f 71       	andi	r24, 0x1F	; 31
    54e4:	88 0f       	add	r24, r24
    54e6:	f8 2a       	or	r15, r24

		idout.dst   = packet->id.src;
    54e8:	ed 81       	ldd	r30, Y+5	; 0x05
    54ea:	fe 81       	ldd	r31, Y+6	; 0x06
    54ec:	85 85       	ldd	r24, Z+13	; 0x0d
    54ee:	86 95       	lsr	r24
    54f0:	84 fb       	bst	r24, 4
    54f2:	99 27       	eor	r25, r25
    54f4:	90 f9       	bld	r25, 0
    54f6:	f9 2a       	or	r15, r25
		idout.dport = packet->id.sport;
    54f8:	53 85       	ldd	r21, Z+11	; 0x0b
    54fa:	45 2f       	mov	r20, r21
    54fc:	4f 73       	andi	r20, 0x3F	; 63
    54fe:	46 95       	lsr	r20
    5500:	46 95       	lsr	r20
    5502:	82 95       	swap	r24
    5504:	80 7f       	andi	r24, 0xF0	; 240
    5506:	48 2b       	or	r20, r24
		idout.sport = packet->id.dport;
    5508:	25 2f       	mov	r18, r21
    550a:	22 95       	swap	r18
    550c:	26 95       	lsr	r18
    550e:	26 95       	lsr	r18
    5510:	23 70       	andi	r18, 0x03	; 3
    5512:	34 85       	ldd	r19, Z+12	; 0x0c
    5514:	3f 70       	andi	r19, 0x0F	; 15
    5516:	33 0f       	add	r19, r19
    5518:	33 0f       	add	r19, r19
    551a:	93 2f       	mov	r25, r19
    551c:	92 2b       	or	r25, r18
    551e:	35 2f       	mov	r19, r21
    5520:	32 95       	swap	r19
    5522:	33 0f       	add	r19, r19
    5524:	33 0f       	add	r19, r19
    5526:	30 7c       	andi	r19, 0xC0	; 192
    5528:	39 2b       	or	r19, r25
		idout.flags = packet->id.flags;
    552a:	22 85       	ldd	r18, Z+10	; 0x0a

		/* Create connection */
		conn = csp_conn_new(packet->id, idout);
    552c:	62 85       	ldd	r22, Z+10	; 0x0a
    552e:	73 85       	ldd	r23, Z+11	; 0x0b
    5530:	84 85       	ldd	r24, Z+12	; 0x0c
    5532:	95 85       	ldd	r25, Z+13	; 0x0d
    5534:	5f 2d       	mov	r21, r15
    5536:	0e 94 cb 1a 	call	0x3596	; 0x3596 <csp_conn_new>
    553a:	7c 01       	movw	r14, r24

		if (!conn) {
    553c:	89 2b       	or	r24, r25
    553e:	79 f4       	brne	.+30     	; 0x555e <csp_route_work+0x312>
			csp_log_error("No more connections available");
    5540:	8d e6       	ldi	r24, 0x6D	; 109
    5542:	91 e1       	ldi	r25, 0x11	; 17
    5544:	9f 93       	push	r25
    5546:	8f 93       	push	r24
    5548:	1f 92       	push	r1
    554a:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			csp_buffer_free(packet);
    554e:	8d 81       	ldd	r24, Y+5	; 0x05
    5550:	9e 81       	ldd	r25, Y+6	; 0x06
    5552:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    5556:	0f 90       	pop	r0
    5558:	0f 90       	pop	r0
    555a:	0f 90       	pop	r0
    555c:	69 c0       	rjmp	.+210    	; 0x5630 <csp_route_work+0x3e4>
		}

		/* Store the socket queue and options */
		conn->socket = socket->socket;
    555e:	f8 01       	movw	r30, r16
    5560:	86 85       	ldd	r24, Z+14	; 0x0e
    5562:	97 85       	ldd	r25, Z+15	; 0x0f
    5564:	d7 01       	movw	r26, r14
    5566:	1f 96       	adiw	r26, 0x0f	; 15
    5568:	9c 93       	st	X, r25
    556a:	8e 93       	st	-X, r24
    556c:	1e 97       	sbiw	r26, 0x0e	; 14
		conn->opts = socket->opts;
    556e:	84 89       	ldd	r24, Z+20	; 0x14
    5570:	95 89       	ldd	r25, Z+21	; 0x15
    5572:	a6 89       	ldd	r26, Z+22	; 0x16
    5574:	b7 89       	ldd	r27, Z+23	; 0x17
    5576:	f7 01       	movw	r30, r14
    5578:	84 8b       	std	Z+20, r24	; 0x14
    557a:	95 8b       	std	Z+21, r25	; 0x15
    557c:	a6 8b       	std	Z+22, r26	; 0x16
    557e:	b7 8b       	std	Z+23, r27	; 0x17
    5580:	13 c0       	rjmp	.+38     	; 0x55a8 <csp_route_work+0x35c>

	/* Packet to existing connection */
	} else {

		/* Run security check on incoming packet */
		if (csp_route_security_check(conn->opts, input.interface, packet) < 0) {
    5582:	2d 81       	ldd	r18, Y+5	; 0x05
    5584:	3e 81       	ldd	r19, Y+6	; 0x06
    5586:	49 81       	ldd	r20, Y+1	; 0x01
    5588:	5a 81       	ldd	r21, Y+2	; 0x02
    558a:	d7 01       	movw	r26, r14
    558c:	54 96       	adiw	r26, 0x14	; 20
    558e:	6d 91       	ld	r22, X+
    5590:	7d 91       	ld	r23, X+
    5592:	8d 91       	ld	r24, X+
    5594:	9c 91       	ld	r25, X
    5596:	57 97       	sbiw	r26, 0x17	; 23
    5598:	07 de       	rcall	.-1010   	; 0x51a8 <csp_route_security_check>
    559a:	99 23       	and	r25, r25
    559c:	2c f4       	brge	.+10     	; 0x55a8 <csp_route_work+0x35c>
			csp_buffer_free(packet);
    559e:	8d 81       	ldd	r24, Y+5	; 0x05
    55a0:	9e 81       	ldd	r25, Y+6	; 0x06
    55a2:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return 0;
    55a6:	44 c0       	rjmp	.+136    	; 0x5630 <csp_route_work+0x3e4>
		return 0;
	}
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
    55a8:	6d 81       	ldd	r22, Y+5	; 0x05
    55aa:	7e 81       	ldd	r23, Y+6	; 0x06
    55ac:	c7 01       	movw	r24, r14
    55ae:	48 d6       	rcall	.+3216   	; 0x6240 <csp_udp_new_packet>
    55b0:	3f c0       	rjmp	.+126    	; 0x5630 <csp_route_work+0x3e4>
	return 0;
    55b2:	cc 24       	eor	r12, r12
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
		return -1;
    55b4:	ca 94       	dec	r12
    55b6:	dc 2c       	mov	r13, r12
    55b8:	3b c0       	rjmp	.+118    	; 0x5630 <csp_route_work+0x3e4>
    55ba:	6c 01       	movw	r12, r24
			csp_log_warn("Router failed to send");
			csp_buffer_free(packet);
		}

		/* Next message, please */
		return 0;
    55bc:	39 c0       	rjmp	.+114    	; 0x5630 <csp_route_work+0x3e4>
    55be:	8d 81       	ldd	r24, Y+5	; 0x05
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
		csp_buffer_free(packet);
    55c0:	9e 81       	ldd	r25, Y+6	; 0x06
    55c2:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    55c6:	34 c0       	rjmp	.+104    	; 0x5630 <csp_route_work+0x3e4>
		return 0;
    55c8:	83 85       	ldd	r24, Z+11	; 0x0b
	}

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);
    55ca:	98 2f       	mov	r25, r24
    55cc:	92 95       	swap	r25
    55ce:	96 95       	lsr	r25
    55d0:	96 95       	lsr	r25
    55d2:	93 70       	andi	r25, 0x03	; 3
    55d4:	84 85       	ldd	r24, Z+12	; 0x0c
    55d6:	8f 70       	andi	r24, 0x0F	; 15
    55d8:	88 0f       	add	r24, r24
    55da:	88 0f       	add	r24, r24
    55dc:	89 2b       	or	r24, r25
    55de:	90 e0       	ldi	r25, 0x00	; 0
    55e0:	03 dc       	rcall	.-2042   	; 0x4de8 <csp_port_get_socket>
    55e2:	8c 01       	movw	r16, r24
    55e4:	89 2b       	or	r24, r25

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    55e6:	09 f0       	breq	.+2      	; 0x55ea <csp_route_work+0x39e>
    55e8:	2d cf       	rjmp	.-422    	; 0x5444 <csp_route_work+0x1f8>
    55ea:	11 c0       	rjmp	.+34     	; 0x560e <csp_route_work+0x3c2>
    55ec:	ed 81       	ldd	r30, Y+5	; 0x05
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    55ee:	fe 81       	ldd	r31, Y+6	; 0x06
    55f0:	62 85       	ldd	r22, Z+10	; 0x0a
    55f2:	73 85       	ldd	r23, Z+11	; 0x0b
    55f4:	84 85       	ldd	r24, Z+12	; 0x0c
    55f6:	95 85       	ldd	r25, Z+13	; 0x0d
    55f8:	20 e0       	ldi	r18, 0x00	; 0
    55fa:	3f ef       	ldi	r19, 0xFF	; 255
    55fc:	4f ef       	ldi	r20, 0xFF	; 255
    55fe:	5f e3       	ldi	r21, 0x3F	; 63
    5600:	0e 94 0d 1a 	call	0x341a	; 0x341a <csp_conn_find>
    5604:	7c 01       	movw	r14, r24
    5606:	89 2b       	or	r24, r25

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    5608:	09 f0       	breq	.+2      	; 0x560c <csp_route_work+0x3c0>
    560a:	bb cf       	rjmp	.-138    	; 0x5582 <csp_route_work+0x336>
    560c:	51 cf       	rjmp	.-350    	; 0x54b0 <csp_route_work+0x264>
    560e:	ed 81       	ldd	r30, Y+5	; 0x05
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    5610:	fe 81       	ldd	r31, Y+6	; 0x06
    5612:	62 85       	ldd	r22, Z+10	; 0x0a
    5614:	73 85       	ldd	r23, Z+11	; 0x0b
    5616:	84 85       	ldd	r24, Z+12	; 0x0c
    5618:	95 85       	ldd	r25, Z+13	; 0x0d
    561a:	20 e0       	ldi	r18, 0x00	; 0
    561c:	3f ef       	ldi	r19, 0xFF	; 255
    561e:	4f ef       	ldi	r20, 0xFF	; 255
    5620:	5f e3       	ldi	r21, 0x3F	; 63
    5622:	0e 94 0d 1a 	call	0x341a	; 0x341a <csp_conn_find>
    5626:	7c 01       	movw	r14, r24
    5628:	89 2b       	or	r24, r25

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    562a:	09 f0       	breq	.+2      	; 0x562e <csp_route_work+0x3e2>
    562c:	aa cf       	rjmp	.-172    	; 0x5582 <csp_route_work+0x336>
    562e:	3b cf       	rjmp	.-394    	; 0x54a6 <csp_route_work+0x25a>
    5630:	c6 01       	movw	r24, r12
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
	return 0;
}
    5632:	26 96       	adiw	r28, 0x06	; 6
    5634:	0f b6       	in	r0, 0x3f	; 63
    5636:	f8 94       	cli
    5638:	de bf       	out	0x3e, r29	; 62
    563a:	0f be       	out	0x3f, r0	; 63
    563c:	cd bf       	out	0x3d, r28	; 61
    563e:	df 91       	pop	r29
    5640:	cf 91       	pop	r28
    5642:	1f 91       	pop	r17
    5644:	0f 91       	pop	r16
    5646:	ff 90       	pop	r15
    5648:	ef 90       	pop	r14
    564a:	df 90       	pop	r13
    564c:	cf 90       	pop	r12
    564e:	08 95       	ret

00005650 <csp_task_router>:
    5650:	c9 ec       	ldi	r28, 0xC9	; 201

static CSP_DEFINE_TASK(csp_task_router) {

	/* Here there be routing */
	while (1) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    5652:	df e0       	ldi	r29, 0x0F	; 15
    5654:	68 94       	set
    5656:	ff 24       	eor	r15, r15
    5658:	f1 f8       	bld	r15, 1
    565a:	80 e0       	ldi	r24, 0x00	; 0
    565c:	90 e0       	ldi	r25, 0x00	; 0
    565e:	0e 94 a1 3e 	call	0x7d42	; 0x7d42 <uxTaskGetStackHighWaterMark2>
    5662:	18 2f       	mov	r17, r24
    5664:	09 2f       	mov	r16, r25
    5666:	80 e0       	ldi	r24, 0x00	; 0
    5668:	90 e0       	ldi	r25, 0x00	; 0
    566a:	0e 94 87 3b 	call	0x770e	; 0x770e <pcTaskGetName>
    566e:	0f 93       	push	r16
    5670:	1f 93       	push	r17
    5672:	9f 93       	push	r25
    5674:	8f 93       	push	r24
    5676:	df 93       	push	r29
    5678:	cf 93       	push	r28
    567a:	ff 92       	push	r15
    567c:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		csp_route_work(FIFO_TIMEOUT);
    5680:	6f ef       	ldi	r22, 0xFF	; 255
    5682:	7f ef       	ldi	r23, 0xFF	; 255
    5684:	80 e0       	ldi	r24, 0x00	; 0
    5686:	90 e0       	ldi	r25, 0x00	; 0
    5688:	e1 dd       	rcall	.-1086   	; 0x524c <csp_route_work>
    568a:	8d b7       	in	r24, 0x3d	; 61
    568c:	9e b7       	in	r25, 0x3e	; 62
    568e:	07 96       	adiw	r24, 0x07	; 7
    5690:	0f b6       	in	r0, 0x3f	; 63
    5692:	f8 94       	cli
    5694:	9e bf       	out	0x3e, r25	; 62
    5696:	0f be       	out	0x3f, r0	; 63
    5698:	8d bf       	out	0x3d, r24	; 61
    569a:	df cf       	rjmp	.-66     	; 0x565a <csp_task_router+0xa>

0000569c <csp_route_start_task>:
	}

}

int csp_route_start_task(unsigned int task_stack_size, unsigned int priority) {
    569c:	ef 92       	push	r14
    569e:	ff 92       	push	r15
    56a0:	0f 93       	push	r16
    56a2:	1f 93       	push	r17

	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);
    56a4:	0f 2e       	mov	r0, r31
    56a6:	ff e0       	ldi	r31, 0x0F	; 15
    56a8:	ef 2e       	mov	r14, r31
    56aa:	f6 e0       	ldi	r31, 0x06	; 6
    56ac:	ff 2e       	mov	r15, r31
    56ae:	f0 2d       	mov	r31, r0
    56b0:	8b 01       	movw	r16, r22
    56b2:	20 e0       	ldi	r18, 0x00	; 0
    56b4:	30 e0       	ldi	r19, 0x00	; 0
    56b6:	ac 01       	movw	r20, r24
    56b8:	6f e8       	ldi	r22, 0x8F	; 143
    56ba:	72 e0       	ldi	r23, 0x02	; 2
    56bc:	88 e2       	ldi	r24, 0x28	; 40
    56be:	9b e2       	ldi	r25, 0x2B	; 43
    56c0:	8b d5       	rcall	.+2838   	; 0x61d8 <csp_thread_create>

	if (ret != 0) {
    56c2:	89 2b       	or	r24, r25
    56c4:	69 f0       	breq	.+26     	; 0x56e0 <csp_route_start_task+0x44>
		csp_log_error("Failed to start router task");
    56c6:	80 ed       	ldi	r24, 0xD0	; 208
    56c8:	9f e0       	ldi	r25, 0x0F	; 15
    56ca:	9f 93       	push	r25
    56cc:	8f 93       	push	r24
    56ce:	1f 92       	push	r1
    56d0:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_NOMEM;
    56d4:	0f 90       	pop	r0
    56d6:	0f 90       	pop	r0
    56d8:	0f 90       	pop	r0
    56da:	8f ef       	ldi	r24, 0xFF	; 255
    56dc:	9f ef       	ldi	r25, 0xFF	; 255
    56de:	02 c0       	rjmp	.+4      	; 0x56e4 <csp_route_start_task+0x48>
	}

	return CSP_ERR_NONE;
    56e0:	80 e0       	ldi	r24, 0x00	; 0
    56e2:	90 e0       	ldi	r25, 0x00	; 0

}
    56e4:	1f 91       	pop	r17
    56e6:	0f 91       	pop	r16
    56e8:	ff 90       	pop	r15
    56ea:	ef 90       	pop	r14
    56ec:	08 95       	ret

000056ee <csp_rtable_find_iface>:
void csp_route_table_load(uint8_t route_table_in[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(routes, route_table_in, sizeof(routes[0]) * CSP_ROUTE_COUNT);
}

void csp_route_table_save(uint8_t route_table_out[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(route_table_out, routes, sizeof(routes[0]) * CSP_ROUTE_COUNT);
    56ee:	90 e0       	ldi	r25, 0x00	; 0
    56f0:	fc 01       	movw	r30, r24
    56f2:	ee 0f       	add	r30, r30
    56f4:	ff 1f       	adc	r31, r31
    56f6:	e8 0f       	add	r30, r24
    56f8:	f9 1f       	adc	r31, r25
    56fa:	ef 5e       	subi	r30, 0xEF	; 239
    56fc:	f9 4f       	sbci	r31, 0xF9	; 249
    56fe:	20 81       	ld	r18, Z
    5700:	31 81       	ldd	r19, Z+1	; 0x01
    5702:	23 2b       	or	r18, r19
    5704:	49 f0       	breq	.+18     	; 0x5718 <csp_rtable_find_iface+0x2a>
    5706:	fc 01       	movw	r30, r24
    5708:	ee 0f       	add	r30, r30
    570a:	ff 1f       	adc	r31, r31
    570c:	8e 0f       	add	r24, r30
    570e:	9f 1f       	adc	r25, r31
    5710:	fc 01       	movw	r30, r24
    5712:	ef 5e       	subi	r30, 0xEF	; 239
    5714:	f9 4f       	sbci	r31, 0xF9	; 249
    5716:	08 c0       	rjmp	.+16     	; 0x5728 <csp_rtable_find_iface+0x3a>
    5718:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <routes+0x60>
    571c:	90 91 72 06 	lds	r25, 0x0672	; 0x800672 <routes+0x61>
    5720:	00 97       	sbiw	r24, 0x00	; 0
    5722:	21 f0       	breq	.+8      	; 0x572c <csp_rtable_find_iface+0x3e>
    5724:	e1 e7       	ldi	r30, 0x71	; 113
    5726:	f6 e0       	ldi	r31, 0x06	; 6
    5728:	80 81       	ld	r24, Z
    572a:	91 81       	ldd	r25, Z+1	; 0x01
    572c:	08 95       	ret

0000572e <csp_rtable_find_mac>:
    572e:	90 e0       	ldi	r25, 0x00	; 0
    5730:	fc 01       	movw	r30, r24
    5732:	ee 0f       	add	r30, r30
    5734:	ff 1f       	adc	r31, r31
    5736:	e8 0f       	add	r30, r24
    5738:	f9 1f       	adc	r31, r25
    573a:	ef 5e       	subi	r30, 0xEF	; 239
    573c:	f9 4f       	sbci	r31, 0xF9	; 249
    573e:	20 81       	ld	r18, Z
    5740:	31 81       	ldd	r19, Z+1	; 0x01
    5742:	23 2b       	or	r18, r19
    5744:	49 f0       	breq	.+18     	; 0x5758 <csp_rtable_find_mac+0x2a>
    5746:	fc 01       	movw	r30, r24
    5748:	ee 0f       	add	r30, r30
    574a:	ff 1f       	adc	r31, r31
    574c:	8e 0f       	add	r24, r30
    574e:	9f 1f       	adc	r25, r31
    5750:	fc 01       	movw	r30, r24
    5752:	ef 5e       	subi	r30, 0xEF	; 239
    5754:	f9 4f       	sbci	r31, 0xF9	; 249
    5756:	08 c0       	rjmp	.+16     	; 0x5768 <csp_rtable_find_mac+0x3a>
    5758:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <routes+0x60>
    575c:	90 91 72 06 	lds	r25, 0x0672	; 0x800672 <routes+0x61>
    5760:	89 2b       	or	r24, r25
    5762:	21 f0       	breq	.+8      	; 0x576c <csp_rtable_find_mac+0x3e>
    5764:	e1 e7       	ldi	r30, 0x71	; 113
    5766:	f6 e0       	ldi	r31, 0x06	; 6
    5768:	82 81       	ldd	r24, Z+2	; 0x02
    576a:	08 95       	ret
    576c:	8f ef       	ldi	r24, 0xFF	; 255
    576e:	08 95       	ret

00005770 <csp_rtable_set>:
}

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {
    5770:	0f 93       	push	r16
    5772:	1f 93       	push	r17
    5774:	cf 93       	push	r28
    5776:	df 93       	push	r29

	/* Don't add nothing */
	if (ifc == NULL)
    5778:	41 15       	cp	r20, r1
    577a:	51 05       	cpc	r21, r1
    577c:	41 f1       	breq	.+80     	; 0x57ce <csp_rtable_set+0x5e>
    577e:	d2 2f       	mov	r29, r18
    5780:	8a 01       	movw	r16, r20
    5782:	c8 2f       	mov	r28, r24
	 * NOTE: For future implementations, interfaces should call
	 * csp_route_add_if in its csp_if_<name>_init function, instead
	 * of registering at first route_set, in order to make the interface
	 * available to network based (CMP) route configuration.
	 */
	csp_iflist_add(ifc);
    5784:	ca 01       	movw	r24, r20
    5786:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <csp_iflist_add>

	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
    578a:	c1 32       	cpi	r28, 0x21	; 33
    578c:	78 f4       	brcc	.+30     	; 0x57ac <csp_rtable_set+0x3c>
		routes[node].interface = ifc;
    578e:	8c 2f       	mov	r24, r28
    5790:	90 e0       	ldi	r25, 0x00	; 0
    5792:	fc 01       	movw	r30, r24
    5794:	ee 0f       	add	r30, r30
    5796:	ff 1f       	adc	r31, r31
    5798:	e8 0f       	add	r30, r24
    579a:	f9 1f       	adc	r31, r25
    579c:	ef 5e       	subi	r30, 0xEF	; 239
    579e:	f9 4f       	sbci	r31, 0xF9	; 249
    57a0:	11 83       	std	Z+1, r17	; 0x01
    57a2:	00 83       	st	Z, r16
		routes[node].mac = mac;
    57a4:	d2 83       	std	Z+2, r29	; 0x02
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;
    57a6:	80 e0       	ldi	r24, 0x00	; 0
    57a8:	90 e0       	ldi	r25, 0x00	; 0
    57aa:	13 c0       	rjmp	.+38     	; 0x57d2 <csp_rtable_set+0x62>
	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
    57ac:	1f 92       	push	r1
    57ae:	cf 93       	push	r28
    57b0:	88 e3       	ldi	r24, 0x38	; 56
    57b2:	92 e1       	ldi	r25, 0x12	; 18
    57b4:	9f 93       	push	r25
    57b6:	8f 93       	push	r24
    57b8:	1f 92       	push	r1
    57ba:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		return CSP_ERR_INVAL;
    57be:	0f 90       	pop	r0
    57c0:	0f 90       	pop	r0
    57c2:	0f 90       	pop	r0
    57c4:	0f 90       	pop	r0
    57c6:	0f 90       	pop	r0
    57c8:	8e ef       	ldi	r24, 0xFE	; 254
    57ca:	9f ef       	ldi	r25, 0xFF	; 255
    57cc:	02 c0       	rjmp	.+4      	; 0x57d2 <csp_rtable_set+0x62>

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {

	/* Don't add nothing */
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    57ce:	8e ef       	ldi	r24, 0xFE	; 254
    57d0:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;

}
    57d2:	df 91       	pop	r29
    57d4:	cf 91       	pop	r28
    57d6:	1f 91       	pop	r17
    57d8:	0f 91       	pop	r16
    57da:	08 95       	ret

000057dc <csp_rtable_print>:

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
    57dc:	ef 92       	push	r14
    57de:	ff 92       	push	r15
    57e0:	0f 93       	push	r16
    57e2:	1f 93       	push	r17
    57e4:	cf 93       	push	r28
    57e6:	df 93       	push	r29
	int i;
	printf("Node  Interface  Address\r\n");
    57e8:	8d e1       	ldi	r24, 0x1D	; 29
    57ea:	92 e1       	ldi	r25, 0x12	; 18
    57ec:	9f 93       	push	r25
    57ee:	8f 93       	push	r24
    57f0:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
    57f4:	01 e1       	ldi	r16, 0x11	; 17
    57f6:	16 e0       	ldi	r17, 0x06	; 6
    57f8:	0f 90       	pop	r0
    57fa:	0f 90       	pop	r0
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    57fc:	c0 e0       	ldi	r28, 0x00	; 0
    57fe:	d0 e0       	ldi	r29, 0x00	; 0
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
    5800:	0f 2e       	mov	r0, r31
    5802:	fd e0       	ldi	r31, 0x0D	; 13
    5804:	ef 2e       	mov	r14, r31
    5806:	f2 e1       	ldi	r31, 0x12	; 18
    5808:	ff 2e       	mov	r15, r31
    580a:	f0 2d       	mov	r31, r0
#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
		if (routes[i].interface != NULL)
    580c:	d8 01       	movw	r26, r16
    580e:	ed 91       	ld	r30, X+
    5810:	fc 91       	ld	r31, X
    5812:	11 97       	sbiw	r26, 0x01	; 1
    5814:	30 97       	sbiw	r30, 0x00	; 0
    5816:	d9 f0       	breq	.+54     	; 0x584e <csp_rtable_print+0x72>
			printf("%4u  %-9s  %u\r\n", i,
    5818:	12 96       	adiw	r26, 0x02	; 2
    581a:	8c 91       	ld	r24, X
    581c:	8f 3f       	cpi	r24, 0xFF	; 255
    581e:	11 f0       	breq	.+4      	; 0x5824 <csp_rtable_print+0x48>
    5820:	90 e0       	ldi	r25, 0x00	; 0
    5822:	01 c0       	rjmp	.+2      	; 0x5826 <csp_rtable_print+0x4a>
    5824:	ce 01       	movw	r24, r28
    5826:	9f 93       	push	r25
    5828:	8f 93       	push	r24
    582a:	81 81       	ldd	r24, Z+1	; 0x01
    582c:	8f 93       	push	r24
    582e:	80 81       	ld	r24, Z
    5830:	8f 93       	push	r24
    5832:	df 93       	push	r29
    5834:	cf 93       	push	r28
    5836:	ff 92       	push	r15
    5838:	ef 92       	push	r14
    583a:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
    583e:	ad b7       	in	r26, 0x3d	; 61
    5840:	be b7       	in	r27, 0x3e	; 62
    5842:	18 96       	adiw	r26, 0x08	; 8
    5844:	0f b6       	in	r0, 0x3f	; 63
    5846:	f8 94       	cli
    5848:	be bf       	out	0x3e, r27	; 62
    584a:	0f be       	out	0x3f, r0	; 63
    584c:	ad bf       	out	0x3d, r26	; 61

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    584e:	21 96       	adiw	r28, 0x01	; 1
    5850:	0d 5f       	subi	r16, 0xFD	; 253
    5852:	1f 4f       	sbci	r17, 0xFF	; 255
    5854:	c0 32       	cpi	r28, 0x20	; 32
    5856:	d1 05       	cpc	r29, r1
    5858:	c9 f6       	brne	.-78     	; 0x580c <csp_rtable_print+0x30>
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
				routes[i].interface->name,
				routes[i].mac == CSP_NODE_MAC ? i : routes[i].mac);
	printf("   *  %-9s  %u\r\n", routes[CSP_DEFAULT_ROUTE].interface->name, routes[CSP_DEFAULT_ROUTE].mac);
    585a:	80 91 73 06 	lds	r24, 0x0673	; 0x800673 <routes+0x62>
    585e:	1f 92       	push	r1
    5860:	8f 93       	push	r24
    5862:	e0 91 71 06 	lds	r30, 0x0671	; 0x800671 <routes+0x60>
    5866:	f0 91 72 06 	lds	r31, 0x0672	; 0x800672 <routes+0x61>
    586a:	81 81       	ldd	r24, Z+1	; 0x01
    586c:	8f 93       	push	r24
    586e:	80 81       	ld	r24, Z
    5870:	8f 93       	push	r24
    5872:	8c ef       	ldi	r24, 0xFC	; 252
    5874:	91 e1       	ldi	r25, 0x11	; 17
    5876:	9f 93       	push	r25
    5878:	8f 93       	push	r24
    587a:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>

}
    587e:	0f 90       	pop	r0
    5880:	0f 90       	pop	r0
    5882:	0f 90       	pop	r0
    5884:	0f 90       	pop	r0
    5886:	0f 90       	pop	r0
    5888:	0f 90       	pop	r0
    588a:	df 91       	pop	r29
    588c:	cf 91       	pop	r28
    588e:	1f 91       	pop	r17
    5890:	0f 91       	pop	r16
    5892:	ff 90       	pop	r15
    5894:	ef 90       	pop	r14
    5896:	08 95       	ret

00005898 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    5898:	cf 93       	push	r28
    589a:	df 93       	push	r29
    589c:	ec 01       	movw	r28, r24
    589e:	81 e0       	ldi	r24, 0x01	; 1
    58a0:	0e 94 7d 36 	call	0x6cfa	; 0x6cfa <xQueueCreateMutex>
    58a4:	99 83       	std	Y+1, r25	; 0x01
    58a6:	88 83       	st	Y, r24
    58a8:	21 e0       	ldi	r18, 0x01	; 1
    58aa:	30 e0       	ldi	r19, 0x00	; 0
    58ac:	89 2b       	or	r24, r25
    58ae:	11 f4       	brne	.+4      	; 0x58b4 <csp_mutex_create+0x1c>
    58b0:	20 e0       	ldi	r18, 0x00	; 0
    58b2:	30 e0       	ldi	r19, 0x00	; 0
    58b4:	c9 01       	movw	r24, r18
    58b6:	df 91       	pop	r29
    58b8:	cf 91       	pop	r28
    58ba:	08 95       	ret

000058bc <csp_bin_sem_create>:
    58bc:	cf 93       	push	r28
    58be:	df 93       	push	r29
    58c0:	ec 01       	movw	r28, r24
    58c2:	43 e0       	ldi	r20, 0x03	; 3
    58c4:	60 e0       	ldi	r22, 0x00	; 0
    58c6:	81 e0       	ldi	r24, 0x01	; 1
    58c8:	0e 94 bd 35 	call	0x6b7a	; 0x6b7a <xQueueGenericCreate>
    58cc:	99 83       	std	Y+1, r25	; 0x01
    58ce:	88 83       	st	Y, r24
    58d0:	00 97       	sbiw	r24, 0x00	; 0
    58d2:	39 f0       	breq	.+14     	; 0x58e2 <csp_bin_sem_create+0x26>
    58d4:	20 e0       	ldi	r18, 0x00	; 0
    58d6:	40 e0       	ldi	r20, 0x00	; 0
    58d8:	50 e0       	ldi	r21, 0x00	; 0
    58da:	60 e0       	ldi	r22, 0x00	; 0
    58dc:	70 e0       	ldi	r23, 0x00	; 0
    58de:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xQueueGenericSend>
    58e2:	81 e0       	ldi	r24, 0x01	; 1
    58e4:	90 e0       	ldi	r25, 0x00	; 0
    58e6:	df 91       	pop	r29
    58e8:	cf 91       	pop	r28
    58ea:	08 95       	ret

000058ec <csp_bin_sem_wait>:
    58ec:	cf 92       	push	r12
    58ee:	df 92       	push	r13
    58f0:	ef 92       	push	r14
    58f2:	ff 92       	push	r15
    58f4:	cf 93       	push	r28
    58f6:	df 93       	push	r29
    58f8:	ec 01       	movw	r28, r24
    58fa:	6a 01       	movw	r12, r20
    58fc:	7b 01       	movw	r14, r22
    58fe:	df 93       	push	r29
    5900:	cf 93       	push	r28
    5902:	89 e6       	ldi	r24, 0x69	; 105
    5904:	92 e1       	ldi	r25, 0x12	; 18
    5906:	9f 93       	push	r25
    5908:	8f 93       	push	r24
    590a:	87 e0       	ldi	r24, 0x07	; 7
    590c:	8f 93       	push	r24
    590e:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
    5912:	0f 90       	pop	r0
    5914:	0f 90       	pop	r0
    5916:	0f 90       	pop	r0
    5918:	0f 90       	pop	r0
    591a:	0f 90       	pop	r0
    591c:	8f ef       	ldi	r24, 0xFF	; 255
    591e:	c8 16       	cp	r12, r24
    5920:	d8 06       	cpc	r13, r24
    5922:	e1 04       	cpc	r14, r1
    5924:	f1 04       	cpc	r15, r1
    5926:	51 f0       	breq	.+20     	; 0x593c <csp_bin_sem_wait+0x50>
    5928:	c7 01       	movw	r24, r14
    592a:	b6 01       	movw	r22, r12
    592c:	2a e0       	ldi	r18, 0x0A	; 10
    592e:	30 e0       	ldi	r19, 0x00	; 0
    5930:	40 e0       	ldi	r20, 0x00	; 0
    5932:	50 e0       	ldi	r21, 0x00	; 0
    5934:	0e 94 c3 44 	call	0x8986	; 0x8986 <__udivmodsi4>
    5938:	69 01       	movw	r12, r18
    593a:	7a 01       	movw	r14, r20
    593c:	b6 01       	movw	r22, r12
    593e:	88 81       	ld	r24, Y
    5940:	99 81       	ldd	r25, Y+1	; 0x01
    5942:	0e 94 56 37 	call	0x6eac	; 0x6eac <xQueueSemaphoreTake>
    5946:	21 e0       	ldi	r18, 0x01	; 1
    5948:	30 e0       	ldi	r19, 0x00	; 0
    594a:	81 30       	cpi	r24, 0x01	; 1
    594c:	11 f0       	breq	.+4      	; 0x5952 <csp_bin_sem_wait+0x66>
    594e:	20 e0       	ldi	r18, 0x00	; 0
    5950:	30 e0       	ldi	r19, 0x00	; 0
    5952:	c9 01       	movw	r24, r18
    5954:	df 91       	pop	r29
    5956:	cf 91       	pop	r28
    5958:	ff 90       	pop	r15
    595a:	ef 90       	pop	r14
    595c:	df 90       	pop	r13
    595e:	cf 90       	pop	r12
    5960:	08 95       	ret

00005962 <csp_bin_sem_post>:
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
    5962:	cf 93       	push	r28
    5964:	df 93       	push	r29
    5966:	ec 01       	movw	r28, r24
	csp_log_lock("Post: %p", sem);
    5968:	df 93       	push	r29
    596a:	cf 93       	push	r28
    596c:	80 e6       	ldi	r24, 0x60	; 96
    596e:	92 e1       	ldi	r25, 0x12	; 18
    5970:	9f 93       	push	r25
    5972:	8f 93       	push	r24
    5974:	87 e0       	ldi	r24, 0x07	; 7
    5976:	8f 93       	push	r24
    5978:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
	if (xSemaphoreGive(*sem) == pdPASS) {
    597c:	20 e0       	ldi	r18, 0x00	; 0
    597e:	40 e0       	ldi	r20, 0x00	; 0
    5980:	50 e0       	ldi	r21, 0x00	; 0
    5982:	60 e0       	ldi	r22, 0x00	; 0
    5984:	70 e0       	ldi	r23, 0x00	; 0
    5986:	88 81       	ld	r24, Y
    5988:	99 81       	ldd	r25, Y+1	; 0x01
    598a:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xQueueGenericSend>
    598e:	21 e0       	ldi	r18, 0x01	; 1
    5990:	30 e0       	ldi	r19, 0x00	; 0
    5992:	0f 90       	pop	r0
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	0f 90       	pop	r0
    599c:	81 30       	cpi	r24, 0x01	; 1
    599e:	11 f0       	breq	.+4      	; 0x59a4 <csp_bin_sem_post+0x42>
    59a0:	20 e0       	ldi	r18, 0x00	; 0
    59a2:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    59a4:	c9 01       	movw	r24, r18
    59a6:	df 91       	pop	r29
    59a8:	cf 91       	pop	r28
    59aa:	08 95       	ret

000059ac <csp_ping>:
#include "csp_endian.h"

#include "csp_time.h"


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {
    59ac:	3f 92       	push	r3
    59ae:	4f 92       	push	r4
    59b0:	5f 92       	push	r5
    59b2:	6f 92       	push	r6
    59b4:	7f 92       	push	r7
    59b6:	8f 92       	push	r8
    59b8:	9f 92       	push	r9
    59ba:	af 92       	push	r10
    59bc:	bf 92       	push	r11
    59be:	cf 92       	push	r12
    59c0:	df 92       	push	r13
    59c2:	ef 92       	push	r14
    59c4:	ff 92       	push	r15
    59c6:	0f 93       	push	r16
    59c8:	1f 93       	push	r17
    59ca:	cf 93       	push	r28
    59cc:	df 93       	push	r29
    59ce:	38 2e       	mov	r3, r24
    59d0:	4a 01       	movw	r8, r20
    59d2:	5b 01       	movw	r10, r22
    59d4:	e9 01       	movw	r28, r18

	unsigned int i;
	uint32_t start, time, status = 0;

	/* Counter */
	start = csp_get_ms();
    59d6:	13 d4       	rcall	.+2086   	; 0x61fe <csp_get_ms>
    59d8:	2b 01       	movw	r4, r22
    59da:	3c 01       	movw	r6, r24

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
    59dc:	c0 2e       	mov	r12, r16
    59de:	d1 2c       	mov	r13, r1
    59e0:	e1 2c       	mov	r14, r1
    59e2:	f1 2c       	mov	r15, r1
    59e4:	95 01       	movw	r18, r10
    59e6:	84 01       	movw	r16, r8
    59e8:	41 e0       	ldi	r20, 0x01	; 1
    59ea:	63 2d       	mov	r22, r3
    59ec:	82 e0       	ldi	r24, 0x02	; 2
    59ee:	0e 94 3d 1b 	call	0x367a	; 0x367a <csp_connect>
    59f2:	8c 01       	movw	r16, r24
	if (conn == NULL)
    59f4:	89 2b       	or	r24, r25
    59f6:	e1 f1       	breq	.+120    	; 0x5a70 <csp_ping+0xc4>
		return -1;

	/* Prepare data */
	csp_packet_t * packet;
	packet = csp_buffer_get(size);
    59f8:	ce 01       	movw	r24, r28
    59fa:	0e 94 0d 18 	call	0x301a	; 0x301a <csp_buffer_get>
    59fe:	7c 01       	movw	r14, r24
	if (packet == NULL)
    5a00:	00 97       	sbiw	r24, 0x00	; 0
    5a02:	c9 f1       	breq	.+114    	; 0x5a76 <csp_ping+0xca>
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
    5a04:	fc 01       	movw	r30, r24
    5a06:	d1 87       	std	Z+9, r29	; 0x09
    5a08:	c0 87       	std	Z+8, r28	; 0x08
	for (i = 0; i < size; i++)
    5a0a:	20 97       	sbiw	r28, 0x00	; 0
    5a0c:	41 f0       	breq	.+16     	; 0x5a1e <csp_ping+0x72>
    5a0e:	3e 96       	adiw	r30, 0x0e	; 14
    5a10:	80 e0       	ldi	r24, 0x00	; 0
    5a12:	90 e0       	ldi	r25, 0x00	; 0
		packet->data[i] = i;
    5a14:	81 93       	st	Z+, r24
	if (packet == NULL)
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
	for (i = 0; i < size; i++)
    5a16:	01 96       	adiw	r24, 0x01	; 1
    5a18:	c8 17       	cp	r28, r24
    5a1a:	d9 07       	cpc	r29, r25
    5a1c:	d9 f7       	brne	.-10     	; 0x5a14 <csp_ping+0x68>
		packet->data[i] = i;

	/* Try to send frame */
	if (!csp_send(conn, packet, 0))
    5a1e:	20 e0       	ldi	r18, 0x00	; 0
    5a20:	30 e0       	ldi	r19, 0x00	; 0
    5a22:	a9 01       	movw	r20, r18
    5a24:	b7 01       	movw	r22, r14
    5a26:	c8 01       	movw	r24, r16
    5a28:	8f d9       	rcall	.-3298   	; 0x4d48 <csp_send>
    5a2a:	89 2b       	or	r24, r25
    5a2c:	59 f1       	breq	.+86     	; 0x5a84 <csp_ping+0xd8>
		goto out;

	/* Read incoming frame */
	packet = csp_read(conn, timeout);
    5a2e:	b5 01       	movw	r22, r10
    5a30:	a4 01       	movw	r20, r8
    5a32:	c8 01       	movw	r24, r16
    5a34:	53 d8       	rcall	.-3930   	; 0x4adc <csp_read>
    5a36:	7c 01       	movw	r14, r24
	if (packet == NULL)
    5a38:	00 97       	sbiw	r24, 0x00	; 0
    5a3a:	e9 f0       	breq	.+58     	; 0x5a76 <csp_ping+0xca>
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    5a3c:	20 97       	sbiw	r28, 0x00	; 0
    5a3e:	31 f1       	breq	.+76     	; 0x5a8c <csp_ping+0xe0>
		if (packet->data[i] != i % (0xff + 1))
    5a40:	fc 01       	movw	r30, r24
    5a42:	86 85       	ldd	r24, Z+14	; 0x0e
    5a44:	81 11       	cpse	r24, r1
    5a46:	27 c0       	rjmp	.+78     	; 0x5a96 <csp_ping+0xea>
    5a48:	3f 96       	adiw	r30, 0x0f	; 15
    5a4a:	80 e0       	ldi	r24, 0x00	; 0
    5a4c:	90 e0       	ldi	r25, 0x00	; 0
    5a4e:	07 c0       	rjmp	.+14     	; 0x5a5e <csp_ping+0xb2>
    5a50:	21 91       	ld	r18, Z+
    5a52:	30 e0       	ldi	r19, 0x00	; 0
    5a54:	ac 01       	movw	r20, r24
    5a56:	55 27       	eor	r21, r21
    5a58:	24 17       	cp	r18, r20
    5a5a:	35 07       	cpc	r19, r21
    5a5c:	01 f5       	brne	.+64     	; 0x5a9e <csp_ping+0xf2>
	packet = csp_read(conn, timeout);
	if (packet == NULL)
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    5a5e:	01 96       	adiw	r24, 0x01	; 1
    5a60:	c8 17       	cp	r28, r24
    5a62:	d9 07       	cpc	r29, r25
    5a64:	a9 f7       	brne	.-22     	; 0x5a50 <csp_ping+0xa4>
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    5a66:	81 2c       	mov	r8, r1
    5a68:	91 2c       	mov	r9, r1
    5a6a:	54 01       	movw	r10, r8
    5a6c:	83 94       	inc	r8
    5a6e:	1a c0       	rjmp	.+52     	; 0x5aa4 <csp_ping+0xf8>
	start = csp_get_ms();

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
	if (conn == NULL)
		return -1;
    5a70:	8f ef       	ldi	r24, 0xFF	; 255
    5a72:	9f ef       	ldi	r25, 0xFF	; 255
    5a74:	2a c0       	rjmp	.+84     	; 0x5aca <csp_ping+0x11e>

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
	csp_close(conn);
    5a76:	c8 01       	movw	r24, r16
    5a78:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    5a7c:	c0 d3       	rcall	.+1920   	; 0x61fe <csp_get_ms>

	if (status) {
		return time;
	} else {
		return -1;
    5a7e:	8f ef       	ldi	r24, 0xFF	; 255
    5a80:	9f ef       	ldi	r25, 0xFF	; 255
    5a82:	23 c0       	rjmp	.+70     	; 0x5aca <csp_ping+0x11e>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    5a84:	81 2c       	mov	r8, r1
    5a86:	91 2c       	mov	r9, r1
    5a88:	54 01       	movw	r10, r8
    5a8a:	0c c0       	rjmp	.+24     	; 0x5aa4 <csp_ping+0xf8>
	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    5a8c:	81 2c       	mov	r8, r1
    5a8e:	91 2c       	mov	r9, r1
    5a90:	54 01       	movw	r10, r8
    5a92:	83 94       	inc	r8
    5a94:	07 c0       	rjmp	.+14     	; 0x5aa4 <csp_ping+0xf8>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    5a96:	81 2c       	mov	r8, r1
    5a98:	91 2c       	mov	r9, r1
    5a9a:	54 01       	movw	r10, r8
    5a9c:	03 c0       	rjmp	.+6      	; 0x5aa4 <csp_ping+0xf8>
    5a9e:	81 2c       	mov	r8, r1
    5aa0:	91 2c       	mov	r9, r1
    5aa2:	54 01       	movw	r10, r8
	status = 1;

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
    5aa4:	c7 01       	movw	r24, r14
    5aa6:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
	csp_close(conn);
    5aaa:	c8 01       	movw	r24, r16
    5aac:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    5ab0:	a6 d3       	rcall	.+1868   	; 0x61fe <csp_get_ms>
    5ab2:	dc 01       	movw	r26, r24
    5ab4:	cb 01       	movw	r24, r22
    5ab6:	84 19       	sub	r24, r4
    5ab8:	95 09       	sbc	r25, r5
    5aba:	a6 09       	sbc	r26, r6
    5abc:	b7 09       	sbc	r27, r7

	if (status) {
    5abe:	89 28       	or	r8, r9
    5ac0:	8a 28       	or	r8, r10
    5ac2:	8b 28       	or	r8, r11
    5ac4:	11 f4       	brne	.+4      	; 0x5aca <csp_ping+0x11e>
		return time;
	} else {
		return -1;
    5ac6:	8f ef       	ldi	r24, 0xFF	; 255
    5ac8:	9f ef       	ldi	r25, 0xFF	; 255
	}

}
    5aca:	df 91       	pop	r29
    5acc:	cf 91       	pop	r28
    5ace:	1f 91       	pop	r17
    5ad0:	0f 91       	pop	r16
    5ad2:	ff 90       	pop	r15
    5ad4:	ef 90       	pop	r14
    5ad6:	df 90       	pop	r13
    5ad8:	cf 90       	pop	r12
    5ada:	bf 90       	pop	r11
    5adc:	af 90       	pop	r10
    5ade:	9f 90       	pop	r9
    5ae0:	8f 90       	pop	r8
    5ae2:	7f 90       	pop	r7
    5ae4:	6f 90       	pop	r6
    5ae6:	5f 90       	pop	r5
    5ae8:	4f 90       	pop	r4
    5aea:	3f 90       	pop	r3
    5aec:	08 95       	ret

00005aee <wrap_32bit_memcpy>:
static csp_memcpy_fnc_t csp_cmp_memcpy_fnc = (csp_memcpy_fnc_t) memcpy;
#endif


void csp_cmp_set_memcpy(csp_memcpy_fnc_t fnc) {
	csp_cmp_memcpy_fnc = fnc;
    5aee:	cf 92       	push	r12
    5af0:	df 92       	push	r13
    5af2:	ef 92       	push	r14
    5af4:	ff 92       	push	r15
    5af6:	0f 93       	push	r16
    5af8:	1f 93       	push	r17
    5afa:	dc 01       	movw	r26, r24
    5afc:	cb 01       	movw	r24, r22
    5afe:	69 01       	movw	r12, r18
    5b00:	7a 01       	movw	r14, r20
    5b02:	a8 01       	movw	r20, r16
    5b04:	b6 01       	movw	r22, r12
    5b06:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>
    5b0a:	bc 01       	movw	r22, r24
    5b0c:	80 e0       	ldi	r24, 0x00	; 0
    5b0e:	90 e0       	ldi	r25, 0x00	; 0
    5b10:	1f 91       	pop	r17
    5b12:	0f 91       	pop	r16
    5b14:	ff 90       	pop	r15
    5b16:	ef 90       	pop	r14
    5b18:	df 90       	pop	r13
    5b1a:	cf 90       	pop	r12
    5b1c:	08 95       	ret

00005b1e <csp_service_handler>:
	cmp->type = CSP_CMP_REPLY;

	return ret;
}

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    5b1e:	6f 92       	push	r6
    5b20:	7f 92       	push	r7
    5b22:	8f 92       	push	r8
    5b24:	9f 92       	push	r9
    5b26:	af 92       	push	r10
    5b28:	bf 92       	push	r11
    5b2a:	cf 92       	push	r12
    5b2c:	df 92       	push	r13
    5b2e:	ef 92       	push	r14
    5b30:	ff 92       	push	r15
    5b32:	0f 93       	push	r16
    5b34:	1f 93       	push	r17
    5b36:	cf 93       	push	r28
    5b38:	df 93       	push	r29
    5b3a:	7c 01       	movw	r14, r24
    5b3c:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    5b3e:	0e 94 13 1c 	call	0x3826	; 0x3826 <csp_conn_dport>
    5b42:	87 30       	cpi	r24, 0x07	; 7
    5b44:	91 05       	cpc	r25, r1
    5b46:	08 f0       	brcs	.+2      	; 0x5b4a <csp_service_handler+0x2c>
    5b48:	38 c2       	rjmp	.+1136   	; 0x5fba <csp_service_handler+0x49c>
    5b4a:	fc 01       	movw	r30, r24
    5b4c:	88 27       	eor	r24, r24
    5b4e:	e6 58       	subi	r30, 0x86	; 134
    5b50:	ff 4f       	sbci	r31, 0xFF	; 255
    5b52:	8f 4f       	sbci	r24, 0xFF	; 255
    5b54:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    5b58:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b5a:	81 11       	cpse	r24, r1
    5b5c:	74 c1       	rjmp	.+744    	; 0x5e46 <csp_service_handler+0x328>
		return ret;

	switch (cmp->code) {
    5b5e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5b60:	83 30       	cpi	r24, 0x03	; 3
    5b62:	09 f4       	brne	.+2      	; 0x5b66 <csp_service_handler+0x48>
    5b64:	70 c0       	rjmp	.+224    	; 0x5c46 <csp_service_handler+0x128>
    5b66:	30 f4       	brcc	.+12     	; 0x5b74 <csp_service_handler+0x56>
    5b68:	81 30       	cpi	r24, 0x01	; 1
    5b6a:	69 f0       	breq	.+26     	; 0x5b86 <csp_service_handler+0x68>
    5b6c:	82 30       	cpi	r24, 0x02	; 2
    5b6e:	09 f4       	brne	.+2      	; 0x5b72 <csp_service_handler+0x54>
    5b70:	50 c0       	rjmp	.+160    	; 0x5c12 <csp_service_handler+0xf4>
    5b72:	62 c1       	rjmp	.+708    	; 0x5e38 <csp_service_handler+0x31a>
    5b74:	85 30       	cpi	r24, 0x05	; 5
    5b76:	09 f4       	brne	.+2      	; 0x5b7a <csp_service_handler+0x5c>
    5b78:	04 c1       	rjmp	.+520    	; 0x5d82 <csp_service_handler+0x264>
    5b7a:	08 f4       	brcc	.+2      	; 0x5b7e <csp_service_handler+0x60>
    5b7c:	e6 c0       	rjmp	.+460    	; 0x5d4a <csp_service_handler+0x22c>
    5b7e:	86 30       	cpi	r24, 0x06	; 6
    5b80:	09 f4       	brne	.+2      	; 0x5b84 <csp_service_handler+0x66>
    5b82:	19 c1       	rjmp	.+562    	; 0x5db6 <csp_service_handler+0x298>
    5b84:	59 c1       	rjmp	.+690    	; 0x5e38 <csp_service_handler+0x31a>
}

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, csp_get_revision(), CSP_CMP_IDENT_REV_LEN);
    5b86:	0e 94 b1 24 	call	0x4962	; 0x4962 <csp_get_revision>
    5b8a:	44 e1       	ldi	r20, 0x14	; 20
    5b8c:	50 e0       	ldi	r21, 0x00	; 0
    5b8e:	bc 01       	movw	r22, r24
    5b90:	ce 01       	movw	r24, r28
    5b92:	8e 5b       	subi	r24, 0xBE	; 190
    5b94:	9f 4f       	sbci	r25, 0xFF	; 255
    5b96:	0e 94 b3 45 	call	0x8b66	; 0x8b66 <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    5b9a:	fe 01       	movw	r30, r28
    5b9c:	eb 5a       	subi	r30, 0xAB	; 171
    5b9e:	ff 4f       	sbci	r31, 0xFF	; 255
    5ba0:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    5ba2:	8c e0       	ldi	r24, 0x0C	; 12
    5ba4:	e3 e9       	ldi	r30, 0x93	; 147
    5ba6:	f2 e0       	ldi	r31, 0x02	; 2
    5ba8:	de 01       	movw	r26, r28
    5baa:	aa 5a       	subi	r26, 0xAA	; 170
    5bac:	bf 4f       	sbci	r27, 0xFF	; 255
    5bae:	01 90       	ld	r0, Z+
    5bb0:	0d 92       	st	X+, r0
    5bb2:	8a 95       	dec	r24
    5bb4:	e1 f7       	brne	.-8      	; 0x5bae <csp_service_handler+0x90>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    5bb6:	fe 01       	movw	r30, r28
    5bb8:	ef 59       	subi	r30, 0x9F	; 159
    5bba:	ff 4f       	sbci	r31, 0xFF	; 255
    5bbc:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    5bbe:	89 e0       	ldi	r24, 0x09	; 9
    5bc0:	ef e9       	ldi	r30, 0x9F	; 159
    5bc2:	f2 e0       	ldi	r31, 0x02	; 2
    5bc4:	de 01       	movw	r26, r28
    5bc6:	ae 59       	subi	r26, 0x9E	; 158
    5bc8:	bf 4f       	sbci	r27, 0xFF	; 255
    5bca:	01 90       	ld	r0, Z+
    5bcc:	0d 92       	st	X+, r0
    5bce:	8a 95       	dec	r24
    5bd0:	e1 f7       	brne	.-8      	; 0x5bca <csp_service_handler+0xac>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    5bd2:	fe 01       	movw	r30, r28
    5bd4:	e6 59       	subi	r30, 0x96	; 150
    5bd6:	ff 4f       	sbci	r31, 0xFF	; 255
    5bd8:	10 82       	st	Z, r1

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    5bda:	0e 94 a7 24 	call	0x494e	; 0x494e <csp_get_hostname>
    5bde:	44 e1       	ldi	r20, 0x14	; 20
    5be0:	50 e0       	ldi	r21, 0x00	; 0
    5be2:	bc 01       	movw	r22, r24
    5be4:	ce 01       	movw	r24, r28
    5be6:	40 96       	adiw	r24, 0x10	; 16
    5be8:	0e 94 b3 45 	call	0x8b66	; 0x8b66 <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';
    5bec:	1b a2       	std	Y+35, r1	; 0x23

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    5bee:	0e 94 ac 24 	call	0x4958	; 0x4958 <csp_get_model>
    5bf2:	4e e1       	ldi	r20, 0x1E	; 30
    5bf4:	50 e0       	ldi	r21, 0x00	; 0
    5bf6:	bc 01       	movw	r22, r24
    5bf8:	ce 01       	movw	r24, r28
    5bfa:	84 96       	adiw	r24, 0x24	; 36
    5bfc:	0e 94 b3 45 	call	0x8b66	; 0x8b66 <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    5c00:	fe 01       	movw	r30, r28
    5c02:	ef 5b       	subi	r30, 0xBF	; 191
    5c04:	ff 4f       	sbci	r31, 0xFF	; 255
    5c06:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    5c08:	8d e5       	ldi	r24, 0x5D	; 93
    5c0a:	90 e0       	ldi	r25, 0x00	; 0
    5c0c:	99 87       	std	Y+9, r25	; 0x09
    5c0e:	88 87       	std	Y+8, r24	; 0x08
    5c10:	ea c1       	rjmp	.+980    	; 0x5fe6 <csp_service_handler+0x4c8>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
    5c12:	ce 01       	movw	r24, r28
    5c14:	42 96       	adiw	r24, 0x12	; 18
    5c16:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <csp_iflist_get_by_name>
	if (ifc == NULL)
    5c1a:	00 97       	sbiw	r24, 0x00	; 0
    5c1c:	51 f0       	breq	.+20     	; 0x5c32 <csp_service_handler+0x114>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    5c1e:	29 89       	ldd	r18, Y+17	; 0x11
    5c20:	ac 01       	movw	r20, r24
    5c22:	65 e0       	ldi	r22, 0x05	; 5
    5c24:	88 89       	ldd	r24, Y+16	; 0x10
    5c26:	a4 dd       	rcall	.-1208   	; 0x5770 <csp_rtable_set>
    5c28:	89 2b       	or	r24, r25
    5c2a:	31 f4       	brne	.+12     	; 0x5c38 <csp_service_handler+0x11a>
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    5c2c:	80 e0       	ldi	r24, 0x00	; 0
    5c2e:	90 e0       	ldi	r25, 0x00	; 0
    5c30:	05 c0       	rjmp	.+10     	; 0x5c3c <csp_service_handler+0x11e>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    5c32:	8e ef       	ldi	r24, 0xFE	; 254
    5c34:	9f ef       	ldi	r25, 0xFF	; 255
    5c36:	02 c0       	rjmp	.+4      	; 0x5c3c <csp_service_handler+0x11e>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;
    5c38:	8e ef       	ldi	r24, 0xFE	; 254
    5c3a:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    5c3c:	2f e0       	ldi	r18, 0x0F	; 15
    5c3e:	30 e0       	ldi	r19, 0x00	; 0
    5c40:	39 87       	std	Y+9, r19	; 0x09
    5c42:	28 87       	std	Y+8, r18	; 0x08
    5c44:	fb c0       	rjmp	.+502    	; 0x5e3c <csp_service_handler+0x31e>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
    5c46:	ce 01       	movw	r24, r28
    5c48:	40 96       	adiw	r24, 0x10	; 16
    5c4a:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <csp_iflist_get_by_name>
    5c4e:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    5c50:	00 97       	sbiw	r24, 0x00	; 0
    5c52:	09 f4       	brne	.+2      	; 0x5c56 <csp_service_handler+0x138>
    5c54:	73 c0       	rjmp	.+230    	; 0x5d3c <csp_service_handler+0x21e>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    5c56:	fc 01       	movw	r30, r24
    5c58:	61 85       	ldd	r22, Z+9	; 0x09
    5c5a:	72 85       	ldd	r23, Z+10	; 0x0a
    5c5c:	83 85       	ldd	r24, Z+11	; 0x0b
    5c5e:	94 85       	ldd	r25, Z+12	; 0x0c
    5c60:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5c64:	6b 8f       	std	Y+27, r22	; 0x1b
    5c66:	7c 8f       	std	Y+28, r23	; 0x1c
    5c68:	8d 8f       	std	Y+29, r24	; 0x1d
    5c6a:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    5c6c:	f8 01       	movw	r30, r16
    5c6e:	65 85       	ldd	r22, Z+13	; 0x0d
    5c70:	76 85       	ldd	r23, Z+14	; 0x0e
    5c72:	87 85       	ldd	r24, Z+15	; 0x0f
    5c74:	90 89       	ldd	r25, Z+16	; 0x10
    5c76:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5c7a:	6f 8f       	std	Y+31, r22	; 0x1f
    5c7c:	78 a3       	std	Y+32, r23	; 0x20
    5c7e:	89 a3       	std	Y+33, r24	; 0x21
    5c80:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    5c82:	f8 01       	movw	r30, r16
    5c84:	61 89       	ldd	r22, Z+17	; 0x11
    5c86:	72 89       	ldd	r23, Z+18	; 0x12
    5c88:	83 89       	ldd	r24, Z+19	; 0x13
    5c8a:	94 89       	ldd	r25, Z+20	; 0x14
    5c8c:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5c90:	6b a3       	std	Y+35, r22	; 0x23
    5c92:	7c a3       	std	Y+36, r23	; 0x24
    5c94:	8d a3       	std	Y+37, r24	; 0x25
    5c96:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    5c98:	f8 01       	movw	r30, r16
    5c9a:	65 89       	ldd	r22, Z+21	; 0x15
    5c9c:	76 89       	ldd	r23, Z+22	; 0x16
    5c9e:	87 89       	ldd	r24, Z+23	; 0x17
    5ca0:	90 8d       	ldd	r25, Z+24	; 0x18
    5ca2:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5ca6:	6f a3       	std	Y+39, r22	; 0x27
    5ca8:	78 a7       	std	Y+40, r23	; 0x28
    5caa:	89 a7       	std	Y+41, r24	; 0x29
    5cac:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    5cae:	f8 01       	movw	r30, r16
    5cb0:	61 8d       	ldd	r22, Z+25	; 0x19
    5cb2:	72 8d       	ldd	r23, Z+26	; 0x1a
    5cb4:	83 8d       	ldd	r24, Z+27	; 0x1b
    5cb6:	94 8d       	ldd	r25, Z+28	; 0x1c
    5cb8:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5cbc:	6b a7       	std	Y+43, r22	; 0x2b
    5cbe:	7c a7       	std	Y+44, r23	; 0x2c
    5cc0:	8d a7       	std	Y+45, r24	; 0x2d
    5cc2:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    5cc4:	f8 01       	movw	r30, r16
    5cc6:	65 8d       	ldd	r22, Z+29	; 0x1d
    5cc8:	76 8d       	ldd	r23, Z+30	; 0x1e
    5cca:	87 8d       	ldd	r24, Z+31	; 0x1f
    5ccc:	90 a1       	ldd	r25, Z+32	; 0x20
    5cce:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5cd2:	6f a7       	std	Y+47, r22	; 0x2f
    5cd4:	78 ab       	std	Y+48, r23	; 0x30
    5cd6:	89 ab       	std	Y+49, r24	; 0x31
    5cd8:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    5cda:	f8 01       	movw	r30, r16
    5cdc:	61 a1       	ldd	r22, Z+33	; 0x21
    5cde:	72 a1       	ldd	r23, Z+34	; 0x22
    5ce0:	83 a1       	ldd	r24, Z+35	; 0x23
    5ce2:	94 a1       	ldd	r25, Z+36	; 0x24
    5ce4:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5ce8:	6b ab       	std	Y+51, r22	; 0x33
    5cea:	7c ab       	std	Y+52, r23	; 0x34
    5cec:	8d ab       	std	Y+53, r24	; 0x35
    5cee:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    5cf0:	f8 01       	movw	r30, r16
    5cf2:	65 a1       	ldd	r22, Z+37	; 0x25
    5cf4:	76 a1       	ldd	r23, Z+38	; 0x26
    5cf6:	87 a1       	ldd	r24, Z+39	; 0x27
    5cf8:	90 a5       	ldd	r25, Z+40	; 0x28
    5cfa:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5cfe:	6f ab       	std	Y+55, r22	; 0x37
    5d00:	78 af       	std	Y+56, r23	; 0x38
    5d02:	89 af       	std	Y+57, r24	; 0x39
    5d04:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    5d06:	f8 01       	movw	r30, r16
    5d08:	61 a5       	ldd	r22, Z+41	; 0x29
    5d0a:	72 a5       	ldd	r23, Z+42	; 0x2a
    5d0c:	83 a5       	ldd	r24, Z+43	; 0x2b
    5d0e:	94 a5       	ldd	r25, Z+44	; 0x2c
    5d10:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5d14:	6b af       	std	Y+59, r22	; 0x3b
    5d16:	7c af       	std	Y+60, r23	; 0x3c
    5d18:	8d af       	std	Y+61, r24	; 0x3d
    5d1a:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    5d1c:	f8 01       	movw	r30, r16
    5d1e:	65 a5       	ldd	r22, Z+45	; 0x2d
    5d20:	76 a5       	ldd	r23, Z+46	; 0x2e
    5d22:	87 a5       	ldd	r24, Z+47	; 0x2f
    5d24:	90 a9       	ldd	r25, Z+48	; 0x30
    5d26:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5d2a:	fe 01       	movw	r30, r28
    5d2c:	ff 96       	adiw	r30, 0x3f	; 63
    5d2e:	60 83       	st	Z, r22
    5d30:	71 83       	std	Z+1, r23	; 0x01
    5d32:	82 83       	std	Z+2, r24	; 0x02
    5d34:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    5d36:	80 e0       	ldi	r24, 0x00	; 0
    5d38:	90 e0       	ldi	r25, 0x00	; 0
    5d3a:	02 c0       	rjmp	.+4      	; 0x5d40 <csp_service_handler+0x222>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    5d3c:	8e ef       	ldi	r24, 0xFE	; 254
    5d3e:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    5d40:	25 e3       	ldi	r18, 0x35	; 53
    5d42:	30 e0       	ldi	r19, 0x00	; 0
    5d44:	39 87       	std	Y+9, r19	; 0x09
    5d46:	28 87       	std	Y+8, r18	; 0x08
    5d48:	79 c0       	rjmp	.+242    	; 0x5e3c <csp_service_handler+0x31e>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    5d4a:	68 89       	ldd	r22, Y+16	; 0x10
    5d4c:	79 89       	ldd	r23, Y+17	; 0x11
    5d4e:	8a 89       	ldd	r24, Y+18	; 0x12
    5d50:	9b 89       	ldd	r25, Y+19	; 0x13
    5d52:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5d56:	9b 01       	movw	r18, r22
    5d58:	ac 01       	movw	r20, r24
    5d5a:	68 8b       	std	Y+16, r22	; 0x10
    5d5c:	79 8b       	std	Y+17, r23	; 0x11
    5d5e:	8a 8b       	std	Y+18, r24	; 0x12
    5d60:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    5d62:	0c 89       	ldd	r16, Y+20	; 0x14
    5d64:	09 3c       	cpi	r16, 0xC9	; 201
    5d66:	08 f0       	brcs	.+2      	; 0x5d6a <csp_service_handler+0x24c>
    5d68:	3b c1       	rjmp	.+630    	; 0x5fe0 <csp_service_handler+0x4c2>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (uintptr_t) cmp->peek.data, (csp_memptr_t) (unsigned long) cmp->peek.addr, cmp->peek.len);
    5d6a:	10 e0       	ldi	r17, 0x00	; 0
    5d6c:	ce 01       	movw	r24, r28
    5d6e:	45 96       	adiw	r24, 0x15	; 21
    5d70:	bc 01       	movw	r22, r24
    5d72:	80 e0       	ldi	r24, 0x00	; 0
    5d74:	90 e0       	ldi	r25, 0x00	; 0
    5d76:	e0 91 7a 02 	lds	r30, 0x027A	; 0x80027a <csp_cmp_memcpy_fnc>
    5d7a:	f0 91 7b 02 	lds	r31, 0x027B	; 0x80027b <csp_cmp_memcpy_fnc+0x1>
    5d7e:	19 95       	eicall
    5d80:	32 c1       	rjmp	.+612    	; 0x5fe6 <csp_service_handler+0x4c8>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    5d82:	68 89       	ldd	r22, Y+16	; 0x10
    5d84:	79 89       	ldd	r23, Y+17	; 0x11
    5d86:	8a 89       	ldd	r24, Y+18	; 0x12
    5d88:	9b 89       	ldd	r25, Y+19	; 0x13
    5d8a:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5d8e:	68 8b       	std	Y+16, r22	; 0x10
    5d90:	79 8b       	std	Y+17, r23	; 0x11
    5d92:	8a 8b       	std	Y+18, r24	; 0x12
    5d94:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    5d96:	0c 89       	ldd	r16, Y+20	; 0x14
    5d98:	09 3c       	cpi	r16, 0xC9	; 201
    5d9a:	08 f0       	brcs	.+2      	; 0x5d9e <csp_service_handler+0x280>
    5d9c:	21 c1       	rjmp	.+578    	; 0x5fe0 <csp_service_handler+0x4c2>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (unsigned long) cmp->poke.addr, (csp_memptr_t) (uintptr_t) cmp->poke.data, cmp->poke.len);
    5d9e:	10 e0       	ldi	r17, 0x00	; 0
    5da0:	9e 01       	movw	r18, r28
    5da2:	2b 5e       	subi	r18, 0xEB	; 235
    5da4:	3f 4f       	sbci	r19, 0xFF	; 255
    5da6:	40 e0       	ldi	r20, 0x00	; 0
    5da8:	50 e0       	ldi	r21, 0x00	; 0
    5daa:	e0 91 7a 02 	lds	r30, 0x027A	; 0x80027a <csp_cmp_memcpy_fnc>
    5dae:	f0 91 7b 02 	lds	r31, 0x027B	; 0x80027b <csp_cmp_memcpy_fnc+0x1>
    5db2:	19 95       	eicall
    5db4:	18 c1       	rjmp	.+560    	; 0x5fe6 <csp_service_handler+0x4c8>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    5db6:	68 89       	ldd	r22, Y+16	; 0x10
    5db8:	79 89       	ldd	r23, Y+17	; 0x11
    5dba:	8a 89       	ldd	r24, Y+18	; 0x12
    5dbc:	9b 89       	ldd	r25, Y+19	; 0x13
    5dbe:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <csp_ntoh32>
    5dc2:	68 8b       	std	Y+16, r22	; 0x10
    5dc4:	79 8b       	std	Y+17, r23	; 0x11
    5dc6:	8a 8b       	std	Y+18, r24	; 0x12
    5dc8:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    5dca:	6c 89       	ldd	r22, Y+20	; 0x14
    5dcc:	7d 89       	ldd	r23, Y+21	; 0x15
    5dce:	8e 89       	ldd	r24, Y+22	; 0x16
    5dd0:	9f 89       	ldd	r25, Y+23	; 0x17
    5dd2:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <csp_ntoh32>
    5dd6:	6c 8b       	std	Y+20, r22	; 0x14
    5dd8:	7d 8b       	std	Y+21, r23	; 0x15
    5dda:	8e 8b       	std	Y+22, r24	; 0x16
    5ddc:	9f 8b       	std	Y+23, r25	; 0x17

	if ((cmp->clock.tv_sec != 0) && (clock_set_time != NULL)) {
    5dde:	88 89       	ldd	r24, Y+16	; 0x10
    5de0:	99 89       	ldd	r25, Y+17	; 0x11
    5de2:	aa 89       	ldd	r26, Y+18	; 0x12
    5de4:	bb 89       	ldd	r27, Y+19	; 0x13
    5de6:	89 2b       	or	r24, r25
    5de8:	8a 2b       	or	r24, r26
    5dea:	8b 2b       	or	r24, r27
    5dec:	41 f0       	breq	.+16     	; 0x5dfe <csp_service_handler+0x2e0>
    5dee:	80 e0       	ldi	r24, 0x00	; 0
    5df0:	90 e0       	ldi	r25, 0x00	; 0
    5df2:	89 2b       	or	r24, r25
    5df4:	21 f0       	breq	.+8      	; 0x5dfe <csp_service_handler+0x2e0>
		clock_set_time(&cmp->clock);
    5df6:	ce 01       	movw	r24, r28
    5df8:	40 96       	adiw	r24, 0x10	; 16
    5dfa:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	if (clock_get_time != NULL) {
    5dfe:	80 e0       	ldi	r24, 0x00	; 0
    5e00:	90 e0       	ldi	r25, 0x00	; 0
    5e02:	89 2b       	or	r24, r25
    5e04:	21 f0       	breq	.+8      	; 0x5e0e <csp_service_handler+0x2f0>
		clock_get_time(&cmp->clock);
    5e06:	ce 01       	movw	r24, r28
    5e08:	40 96       	adiw	r24, 0x10	; 16
    5e0a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    5e0e:	68 89       	ldd	r22, Y+16	; 0x10
    5e10:	79 89       	ldd	r23, Y+17	; 0x11
    5e12:	8a 89       	ldd	r24, Y+18	; 0x12
    5e14:	9b 89       	ldd	r25, Y+19	; 0x13
    5e16:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5e1a:	68 8b       	std	Y+16, r22	; 0x10
    5e1c:	79 8b       	std	Y+17, r23	; 0x11
    5e1e:	8a 8b       	std	Y+18, r24	; 0x12
    5e20:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    5e22:	6c 89       	ldd	r22, Y+20	; 0x14
    5e24:	7d 89       	ldd	r23, Y+21	; 0x15
    5e26:	8e 89       	ldd	r24, Y+22	; 0x16
    5e28:	9f 89       	ldd	r25, Y+23	; 0x17
    5e2a:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
    5e2e:	6c 8b       	std	Y+20, r22	; 0x14
    5e30:	7d 8b       	std	Y+21, r23	; 0x15
    5e32:	8e 8b       	std	Y+22, r24	; 0x16
    5e34:	9f 8b       	std	Y+23, r25	; 0x17
    5e36:	d7 c0       	rjmp	.+430    	; 0x5fe6 <csp_service_handler+0x4c8>
		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
			break;

		default:
			ret = CSP_ERR_INVAL;
    5e38:	8e ef       	ldi	r24, 0xFE	; 254
    5e3a:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5e3c:	2f ef       	ldi	r18, 0xFF	; 255
    5e3e:	2e 87       	std	Y+14, r18	; 0x0e

	switch (csp_conn_dport(conn)) {

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    5e40:	89 2b       	or	r24, r25
    5e42:	09 f4       	brne	.+2      	; 0x5e46 <csp_service_handler+0x328>
    5e44:	be c0       	rjmp	.+380    	; 0x5fc2 <csp_service_handler+0x4a4>
			csp_buffer_free(packet);
    5e46:	ce 01       	movw	r24, r28
    5e48:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			return;
    5e4c:	cf c0       	rjmp	.+414    	; 0x5fec <csp_service_handler+0x4ce>
		}
		break;

	case CSP_PING:
		/* A ping means, just echo the packet, so no changes */
		csp_log_info("SERVICE: Ping received");
    5e4e:	82 e7       	ldi	r24, 0x72	; 114
    5e50:	92 e1       	ldi	r25, 0x12	; 18
    5e52:	9f 93       	push	r25
    5e54:	8f 93       	push	r24
    5e56:	82 e0       	ldi	r24, 0x02	; 2
    5e58:	8f 93       	push	r24
    5e5a:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		break;
    5e5e:	0f 90       	pop	r0
    5e60:	0f 90       	pop	r0
    5e62:	0f 90       	pop	r0
    5e64:	ae c0       	rjmp	.+348    	; 0x5fc2 <csp_service_handler+0x4a4>

	case CSP_PS: {
		/* Sanity check on request */
		if ((packet->length != 1) || (packet->data[0] != 0x55)) {
    5e66:	88 85       	ldd	r24, Y+8	; 0x08
    5e68:	99 85       	ldd	r25, Y+9	; 0x09
    5e6a:	01 97       	sbiw	r24, 0x01	; 1
    5e6c:	19 f4       	brne	.+6      	; 0x5e74 <csp_service_handler+0x356>
    5e6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e70:	85 35       	cpi	r24, 0x55	; 85
    5e72:	21 f0       	breq	.+8      	; 0x5e7c <csp_service_handler+0x35e>
			/* Sanity check failed */
			csp_buffer_free(packet);
    5e74:	ce 01       	movw	r24, r28
    5e76:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
			/* Clear the packet, it has been freed */
			packet = NULL;
			break;
		}
		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    5e7a:	b8 c0       	rjmp	.+368    	; 0x5fec <csp_service_handler+0x4ce>
    5e7c:	cb d0       	rcall	.+406    	; 0x6014 <csp_sys_tasklist_size>
    5e7e:	8c 01       	movw	r16, r24
		char * pslist = csp_malloc(task_list_size);
    5e80:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <csp_malloc>
    5e84:	4c 01       	movw	r8, r24
		/* Check for malloc fail */
		if (pslist == NULL) {
    5e86:	00 97       	sbiw	r24, 0x00	; 0
    5e88:	a1 f4       	brne	.+40     	; 0x5eb2 <csp_service_handler+0x394>
			/* Send out the data */
			strcpy((char *)packet->data, "Not enough memory");
    5e8a:	22 e1       	ldi	r18, 0x12	; 18
    5e8c:	e8 ea       	ldi	r30, 0xA8	; 168
    5e8e:	f2 e0       	ldi	r31, 0x02	; 2
    5e90:	ce 01       	movw	r24, r28
    5e92:	0e 96       	adiw	r24, 0x0e	; 14
    5e94:	dc 01       	movw	r26, r24
    5e96:	01 90       	ld	r0, Z+
    5e98:	0d 92       	st	X+, r0
    5e9a:	2a 95       	dec	r18
    5e9c:	e1 f7       	brne	.-8      	; 0x5e96 <csp_service_handler+0x378>
			packet->length = strlen((char *)packet->data);
    5e9e:	fc 01       	movw	r30, r24
    5ea0:	01 90       	ld	r0, Z+
    5ea2:	00 20       	and	r0, r0
    5ea4:	e9 f7       	brne	.-6      	; 0x5ea0 <csp_service_handler+0x382>
    5ea6:	31 97       	sbiw	r30, 0x01	; 1
    5ea8:	e8 1b       	sub	r30, r24
    5eaa:	f9 0b       	sbc	r31, r25
    5eac:	f9 87       	std	Y+9, r31	; 0x09
			/* Break and let the default handling send packet */
			break;
    5eae:	e8 87       	std	Y+8, r30	; 0x08
		}

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    5eb0:	88 c0       	rjmp	.+272    	; 0x5fc2 <csp_service_handler+0x4a4>
    5eb2:	ab d0       	rcall	.+342    	; 0x600a <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    5eb4:	b8 01       	movw	r22, r16
    5eb6:	c4 01       	movw	r24, r8
    5eb8:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <strnlen>
    5ebc:	5c 01       	movw	r10, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    5ebe:	18 16       	cp	r1, r24
    5ec0:	19 06       	cpc	r1, r25
    5ec2:	a4 f5       	brge	.+104    	; 0x5f2c <csp_service_handler+0x40e>
    5ec4:	c1 2c       	mov	r12, r1
    5ec6:	d1 2c       	mov	r13, r1
    5ec8:	61 2c       	mov	r6, r1
    5eca:	71 2c       	mov	r7, r1

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    5ecc:	20 97       	sbiw	r28, 0x00	; 0
    5ece:	39 f4       	brne	.+14     	; 0x5ede <csp_service_handler+0x3c0>
				packet = csp_buffer_get(CSP_RPS_MTU);
    5ed0:	84 ec       	ldi	r24, 0xC4	; 196
    5ed2:	90 e0       	ldi	r25, 0x00	; 0
    5ed4:	0e 94 0d 18 	call	0x301a	; 0x301a <csp_buffer_get>
    5ed8:	ec 01       	movw	r28, r24
			if (packet == NULL)
    5eda:	89 2b       	or	r24, r25
    5edc:	39 f1       	breq	.+78     	; 0x5f2c <csp_service_handler+0x40e>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    5ede:	85 01       	movw	r16, r10
    5ee0:	0c 19       	sub	r16, r12
    5ee2:	1d 09       	sbc	r17, r13
    5ee4:	05 3c       	cpi	r16, 0xC5	; 197
    5ee6:	11 05       	cpc	r17, r1
    5ee8:	14 f0       	brlt	.+4      	; 0x5eee <csp_service_handler+0x3d0>
    5eea:	04 ec       	ldi	r16, 0xC4	; 196
    5eec:	10 e0       	ldi	r17, 0x00	; 0
    5eee:	19 87       	std	Y+9, r17	; 0x09
    5ef0:	08 87       	std	Y+8, r16	; 0x08

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    5ef2:	b4 01       	movw	r22, r8
    5ef4:	6c 0d       	add	r22, r12
    5ef6:	7d 1d       	adc	r23, r13
    5ef8:	a8 01       	movw	r20, r16
    5efa:	ce 01       	movw	r24, r28
    5efc:	0e 96       	adiw	r24, 0x0e	; 14
    5efe:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>
			i += packet->length;
    5f02:	c0 0e       	add	r12, r16
    5f04:	d1 1e       	adc	r13, r17
			if (!csp_send(conn, packet, 0))
    5f06:	20 e0       	ldi	r18, 0x00	; 0
    5f08:	30 e0       	ldi	r19, 0x00	; 0
    5f0a:	a9 01       	movw	r20, r18
    5f0c:	be 01       	movw	r22, r28
    5f0e:	c7 01       	movw	r24, r14
    5f10:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <csp_send>
    5f14:	89 2b       	or	r24, r25
    5f16:	19 f4       	brne	.+6      	; 0x5f1e <csp_service_handler+0x400>
				csp_buffer_free(packet);
    5f18:	ce 01       	movw	r24, r28
    5f1a:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    5f1e:	c6 2d       	mov	r28, r6
    5f20:	d7 2d       	mov	r29, r7
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    5f22:	ca 14       	cp	r12, r10
    5f24:	db 04       	cpc	r13, r11
    5f26:	94 f2       	brlt	.-92     	; 0x5ecc <csp_service_handler+0x3ae>
    5f28:	c0 e0       	ldi	r28, 0x00	; 0
    5f2a:	d0 e0       	ldi	r29, 0x00	; 0

			/* Clear the packet reference when sent */
			packet = NULL;

		}
		csp_free(pslist);
    5f2c:	c4 01       	movw	r24, r8
    5f2e:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <csp_free>
		break;
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    5f32:	47 c0       	rjmp	.+142    	; 0x5fc2 <csp_service_handler+0x4a4>
    5f34:	76 d0       	rcall	.+236    	; 0x6022 <csp_sys_memfree>

		total = csp_hton32(total);
    5f36:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    5f3a:	6e 87       	std	Y+14, r22	; 0x0e
    5f3c:	7f 87       	std	Y+15, r23	; 0x0f
    5f3e:	88 8b       	std	Y+16, r24	; 0x10
    5f40:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    5f42:	84 e0       	ldi	r24, 0x04	; 4
    5f44:	90 e0       	ldi	r25, 0x00	; 0
    5f46:	99 87       	std	Y+9, r25	; 0x09
    5f48:	88 87       	std	Y+8, r24	; 0x08
    5f4a:	3b c0       	rjmp	.+118    	; 0x5fc2 <csp_service_handler+0x4a4>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    5f4c:	6e 85       	ldd	r22, Y+14	; 0x0e
    5f4e:	7f 85       	ldd	r23, Y+15	; 0x0f
    5f50:	88 89       	ldd	r24, Y+16	; 0x10
    5f52:	99 89       	ldd	r25, Y+17	; 0x11
    5f54:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <csp_ntoh32>

		/* If the magic word is valid, reboot */
		if (magic_word == CSP_REBOOT_MAGIC) {
    5f58:	67 30       	cpi	r22, 0x07	; 7
    5f5a:	e0 e8       	ldi	r30, 0x80	; 128
    5f5c:	7e 07       	cpc	r23, r30
    5f5e:	e7 e0       	ldi	r30, 0x07	; 7
    5f60:	8e 07       	cpc	r24, r30
    5f62:	e0 e8       	ldi	r30, 0x80	; 128
    5f64:	9e 07       	cpc	r25, r30
			csp_sys_reboot();
    5f66:	11 f4       	brne	.+4      	; 0x5f6c <csp_service_handler+0x44e>
    5f68:	b1 d0       	rcall	.+354    	; 0x60cc <csp_sys_reboot>
    5f6a:	06 c0       	rjmp	.+12     	; 0x5f78 <csp_service_handler+0x45a>
		} else if (magic_word == CSP_REBOOT_SHUTDOWN_MAGIC) {
    5f6c:	6a 39       	cpi	r22, 0x9A	; 154
    5f6e:	72 45       	sbci	r23, 0x52	; 82
    5f70:	85 4e       	sbci	r24, 0xE5	; 229
    5f72:	91 4d       	sbci	r25, 0xD1	; 209
			csp_sys_shutdown();
    5f74:	09 f4       	brne	.+2      	; 0x5f78 <csp_service_handler+0x45a>
    5f76:	c6 d0       	rcall	.+396    	; 0x6104 <csp_sys_shutdown>
		}


		
		csp_buffer_free(packet);
    5f78:	ce 01       	movw	r24, r28
    5f7a:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    5f7e:	36 c0       	rjmp	.+108    	; 0x5fec <csp_service_handler+0x4ce>
		return;
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    5f80:	0e 94 3a 19 	call	0x3274	; 0x3274 <csp_buffer_remaining>
		size = csp_hton32(size);
    5f84:	bc 01       	movw	r22, r24
    5f86:	99 0f       	add	r25, r25
    5f88:	88 0b       	sbc	r24, r24
    5f8a:	99 0b       	sbc	r25, r25
    5f8c:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    5f90:	6e 87       	std	Y+14, r22	; 0x0e
    5f92:	7f 87       	std	Y+15, r23	; 0x0f
    5f94:	88 8b       	std	Y+16, r24	; 0x10
		packet->length = sizeof(size);
    5f96:	99 8b       	std	Y+17, r25	; 0x11
    5f98:	84 e0       	ldi	r24, 0x04	; 4
    5f9a:	90 e0       	ldi	r25, 0x00	; 0
    5f9c:	99 87       	std	Y+9, r25	; 0x09
    5f9e:	88 87       	std	Y+8, r24	; 0x08
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    5fa0:	10 c0       	rjmp	.+32     	; 0x5fc2 <csp_service_handler+0x4a4>
    5fa2:	3d d1       	rcall	.+634    	; 0x621e <csp_get_s>
		time = csp_hton32(time);
    5fa4:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    5fa8:	6e 87       	std	Y+14, r22	; 0x0e
    5faa:	7f 87       	std	Y+15, r23	; 0x0f
    5fac:	88 8b       	std	Y+16, r24	; 0x10
    5fae:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    5fb0:	84 e0       	ldi	r24, 0x04	; 4
    5fb2:	90 e0       	ldi	r25, 0x00	; 0
    5fb4:	99 87       	std	Y+9, r25	; 0x09
    5fb6:	88 87       	std	Y+8, r24	; 0x08
    5fb8:	04 c0       	rjmp	.+8      	; 0x5fc2 <csp_service_handler+0x4a4>
		break;
	}

	default:
		csp_buffer_free(packet);
    5fba:	ce 01       	movw	r24, r28
    5fbc:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
		return;
    5fc0:	15 c0       	rjmp	.+42     	; 0x5fec <csp_service_handler+0x4ce>
	}

	if (packet != NULL) {
    5fc2:	20 97       	sbiw	r28, 0x00	; 0
    5fc4:	99 f0       	breq	.+38     	; 0x5fec <csp_service_handler+0x4ce>
		if (!csp_send(conn, packet, 0))
    5fc6:	20 e0       	ldi	r18, 0x00	; 0
    5fc8:	30 e0       	ldi	r19, 0x00	; 0
    5fca:	a9 01       	movw	r20, r18
    5fcc:	be 01       	movw	r22, r28
    5fce:	c7 01       	movw	r24, r14
    5fd0:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <csp_send>
    5fd4:	89 2b       	or	r24, r25
    5fd6:	51 f4       	brne	.+20     	; 0x5fec <csp_service_handler+0x4ce>
			csp_buffer_free(packet);
    5fd8:	ce 01       	movw	r24, r28
    5fda:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
    5fde:	06 c0       	rjmp	.+12     	; 0x5fec <csp_service_handler+0x4ce>
		default:
			ret = CSP_ERR_INVAL;
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5fe0:	8f ef       	ldi	r24, 0xFF	; 255
    5fe2:	8e 87       	std	Y+14, r24	; 0x0e
    5fe4:	30 cf       	rjmp	.-416    	; 0x5e46 <csp_service_handler+0x328>
    5fe6:	8f ef       	ldi	r24, 0xFF	; 255
    5fe8:	8e 87       	std	Y+14, r24	; 0x0e
    5fea:	eb cf       	rjmp	.-42     	; 0x5fc2 <csp_service_handler+0x4a4>
	if (packet != NULL) {
		if (!csp_send(conn, packet, 0))
			csp_buffer_free(packet);
	}

}
    5fec:	df 91       	pop	r29
    5fee:	cf 91       	pop	r28
    5ff0:	1f 91       	pop	r17
    5ff2:	0f 91       	pop	r16
    5ff4:	ff 90       	pop	r15
    5ff6:	ef 90       	pop	r14
    5ff8:	df 90       	pop	r13
    5ffa:	cf 90       	pop	r12
    5ffc:	bf 90       	pop	r11
    5ffe:	af 90       	pop	r10
    6000:	9f 90       	pop	r9
    6002:	8f 90       	pop	r8
    6004:	7f 90       	pop	r7
    6006:	6f 90       	pop	r6
    6008:	08 95       	ret

0000600a <csp_sys_tasklist>:

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed portCHAR *) out);
#else
	vTaskList(out);
    600a:	0e 94 ce 3f 	call	0x7f9c	; 0x7f9c <vTaskList>
#endif
	return CSP_ERR_NONE;
}
    600e:	80 e0       	ldi	r24, 0x00	; 0
    6010:	90 e0       	ldi	r25, 0x00	; 0
    6012:	08 95       	ret

00006014 <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    6014:	0e 94 84 3b 	call	0x7708	; 0x7708 <uxTaskGetNumberOfTasks>
}
    6018:	28 e2       	ldi	r18, 0x28	; 40
    601a:	82 9f       	mul	r24, r18
    601c:	c0 01       	movw	r24, r0
    601e:	11 24       	eor	r1, r1
    6020:	08 95       	ret

00006022 <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    6022:	4f 92       	push	r4
    6024:	5f 92       	push	r5
    6026:	6f 92       	push	r6
    6028:	7f 92       	push	r7
    602a:	8f 92       	push	r8
    602c:	9f 92       	push	r9
    602e:	af 92       	push	r10
    6030:	bf 92       	push	r11
    6032:	cf 92       	push	r12
    6034:	df 92       	push	r13
    6036:	ef 92       	push	r14
    6038:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    603a:	0f 2e       	mov	r0, r31
    603c:	f0 e1       	ldi	r31, 0x10	; 16
    603e:	cf 2e       	mov	r12, r31
    6040:	f7 e2       	ldi	r31, 0x27	; 39
    6042:	df 2e       	mov	r13, r31
    6044:	e1 2c       	mov	r14, r1
    6046:	f1 2c       	mov	r15, r1
    6048:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    604a:	44 24       	eor	r4, r4
    604c:	4a 94       	dec	r4
    604e:	54 2c       	mov	r5, r4
    6050:	32 01       	movw	r6, r4
    6052:	81 2c       	mov	r8, r1
    6054:	91 2c       	mov	r9, r1
    6056:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    6058:	c6 01       	movw	r24, r12
    605a:	88 0d       	add	r24, r8
    605c:	99 1d       	adc	r25, r9
    605e:	c5 d1       	rcall	.+906    	; 0x63ea <pvPortMalloc>
		if (pmem == NULL) {
    6060:	00 97       	sbiw	r24, 0x00	; 0
    6062:	59 f4       	brne	.+22     	; 0x607a <csp_sys_memfree+0x58>
			max = size + total;
    6064:	24 01       	movw	r4, r8
    6066:	35 01       	movw	r6, r10
    6068:	4c 0c       	add	r4, r12
    606a:	5d 1c       	adc	r5, r13
    606c:	6e 1c       	adc	r6, r14
    606e:	7f 1c       	adc	r7, r15
			size = size / 2;
    6070:	f6 94       	lsr	r15
    6072:	e7 94       	ror	r14
    6074:	d7 94       	ror	r13
    6076:	c7 94       	ror	r12
    6078:	14 c0       	rjmp	.+40     	; 0x60a2 <csp_sys_memfree+0x80>
		} else {
			total += size;
    607a:	8c 0c       	add	r8, r12
    607c:	9d 1c       	adc	r9, r13
    607e:	ae 1c       	adc	r10, r14
    6080:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    6082:	b7 01       	movw	r22, r14
    6084:	a6 01       	movw	r20, r12
    6086:	48 0d       	add	r20, r8
    6088:	59 1d       	adc	r21, r9
    608a:	6a 1d       	adc	r22, r10
    608c:	7b 1d       	adc	r23, r11
    608e:	44 15       	cp	r20, r4
    6090:	55 05       	cpc	r21, r5
    6092:	66 05       	cpc	r22, r6
    6094:	77 05       	cpc	r23, r7
    6096:	20 f0       	brcs	.+8      	; 0x60a0 <csp_sys_memfree+0x7e>
				size = size / 2;
    6098:	f6 94       	lsr	r15
    609a:	e7 94       	ror	r14
    609c:	d7 94       	ror	r13
			vPortFree(pmem);
    609e:	c7 94       	ror	r12
    60a0:	64 d1       	rcall	.+712    	; 0x636a <vPortFree>
		}
		if (size < 32) break;
    60a2:	80 e2       	ldi	r24, 0x20	; 32
    60a4:	c8 16       	cp	r12, r24
    60a6:	d1 04       	cpc	r13, r1
    60a8:	e1 04       	cpc	r14, r1
    60aa:	f1 04       	cpc	r15, r1
    60ac:	a8 f6       	brcc	.-86     	; 0x6058 <csp_sys_memfree+0x36>
	}

	return total;
}
    60ae:	c5 01       	movw	r24, r10
    60b0:	b4 01       	movw	r22, r8
    60b2:	ff 90       	pop	r15
    60b4:	ef 90       	pop	r14
    60b6:	df 90       	pop	r13
    60b8:	cf 90       	pop	r12
    60ba:	bf 90       	pop	r11
    60bc:	af 90       	pop	r10
    60be:	9f 90       	pop	r9
    60c0:	8f 90       	pop	r8
    60c2:	7f 90       	pop	r7
    60c4:	6f 90       	pop	r6
    60c6:	5f 90       	pop	r5
    60c8:	4f 90       	pop	r4
    60ca:	08 95       	ret

000060cc <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    60cc:	80 e0       	ldi	r24, 0x00	; 0
    60ce:	90 e0       	ldi	r25, 0x00	; 0
    60d0:	89 2b       	or	r24, r25
    60d2:	21 f0       	breq	.+8      	; 0x60dc <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    60d4:	81 e0       	ldi	r24, 0x01	; 1
    60d6:	90 e0       	ldi	r25, 0x00	; 0
    60d8:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    60dc:	80 e0       	ldi	r24, 0x00	; 0
    60de:	90 e0       	ldi	r25, 0x00	; 0
    60e0:	89 2b       	or	r24, r25
    60e2:	19 f0       	breq	.+6      	; 0x60ea <csp_sys_reboot+0x1e>
		cpu_reset();
    60e4:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    60e8:	ff cf       	rjmp	.-2      	; 0x60e8 <csp_sys_reboot+0x1c>
		while (1);
	}
	
	csp_log_error("Failed to reboot");
    60ea:	85 ea       	ldi	r24, 0xA5	; 165
    60ec:	92 e1       	ldi	r25, 0x12	; 18
    60ee:	9f 93       	push	r25
    60f0:	8f 93       	push	r24
    60f2:	1f 92       	push	r1
    60f4:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>

	return CSP_ERR_INVAL;
    60f8:	0f 90       	pop	r0
    60fa:	0f 90       	pop	r0
    60fc:	0f 90       	pop	r0
}
    60fe:	8e ef       	ldi	r24, 0xFE	; 254
    6100:	9f ef       	ldi	r25, 0xFF	; 255
    6102:	08 95       	ret

00006104 <csp_sys_shutdown>:

int csp_sys_shutdown(void) {

	extern void __attribute__((weak)) cpu_shutdown(void);
	if (cpu_shutdown) {
    6104:	80 e0       	ldi	r24, 0x00	; 0
    6106:	90 e0       	ldi	r25, 0x00	; 0
    6108:	89 2b       	or	r24, r25
    610a:	19 f0       	breq	.+6      	; 0x6112 <csp_sys_shutdown+0xe>
		cpu_shutdown();
    610c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    6110:	ff cf       	rjmp	.-2      	; 0x6110 <csp_sys_shutdown+0xc>
		while (1);
	}

	csp_log_error("Failed to shutdown");
    6112:	82 e9       	ldi	r24, 0x92	; 146
    6114:	92 e1       	ldi	r25, 0x12	; 18
    6116:	9f 93       	push	r25
    6118:	8f 93       	push	r24
    611a:	1f 92       	push	r1
    611c:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>

	return CSP_ERR_INVAL;
    6120:	0f 90       	pop	r0
    6122:	0f 90       	pop	r0
    6124:	0f 90       	pop	r0
}
    6126:	8e ef       	ldi	r24, 0xFE	; 254
    6128:	9f ef       	ldi	r25, 0xFF	; 255
    612a:	08 95       	ret

0000612c <csp_sys_set_color>:

void csp_sys_set_color(csp_color_t color) {
    612c:	98 2f       	mov	r25, r24

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
    612e:	e8 2f       	mov	r30, r24
    6130:	ef 70       	andi	r30, 0x0F	; 15
    6132:	4e 2f       	mov	r20, r30
    6134:	50 e0       	ldi	r21, 0x00	; 0
    6136:	fa 01       	movw	r30, r20
    6138:	31 97       	sbiw	r30, 0x01	; 1
    613a:	e8 30       	cpi	r30, 0x08	; 8
    613c:	f1 05       	cpc	r31, r1
    613e:	d8 f4       	brcc	.+54     	; 0x6176 <csp_sys_set_color+0x4a>
    6140:	88 27       	eor	r24, r24
    6142:	ef 57       	subi	r30, 0x7F	; 127
    6144:	ff 4f       	sbci	r31, 0xFF	; 255
    6146:	8f 4f       	sbci	r24, 0xFF	; 255
    6148:	0c 94 01 45 	jmp	0x8a02	; 0x8a02 <__tablejump2__>
		case COLOR_BLACK:
			color_code = 30; break;
		case COLOR_RED:
			color_code = 31; break;
    614c:	2f e1       	ldi	r18, 0x1F	; 31
    614e:	30 e0       	ldi	r19, 0x00	; 0
    6150:	17 c0       	rjmp	.+46     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_GREEN:
			color_code = 32; break;
    6152:	20 e2       	ldi	r18, 0x20	; 32
    6154:	30 e0       	ldi	r19, 0x00	; 0
    6156:	14 c0       	rjmp	.+40     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_YELLOW:
			color_code = 33; break;
    6158:	21 e2       	ldi	r18, 0x21	; 33
    615a:	30 e0       	ldi	r19, 0x00	; 0
    615c:	11 c0       	rjmp	.+34     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_BLUE:
			color_code = 34; break;
    615e:	22 e2       	ldi	r18, 0x22	; 34
    6160:	30 e0       	ldi	r19, 0x00	; 0
    6162:	0e c0       	rjmp	.+28     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_MAGENTA:
			color_code = 35; break;
    6164:	23 e2       	ldi	r18, 0x23	; 35
    6166:	30 e0       	ldi	r19, 0x00	; 0
    6168:	0b c0       	rjmp	.+22     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_CYAN:
			color_code = 36; break;
    616a:	24 e2       	ldi	r18, 0x24	; 36
    616c:	30 e0       	ldi	r19, 0x00	; 0
    616e:	08 c0       	rjmp	.+16     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_WHITE:
			color_code = 37; break;
    6170:	25 e2       	ldi	r18, 0x25	; 37
    6172:	30 e0       	ldi	r19, 0x00	; 0
    6174:	05 c0       	rjmp	.+10     	; 0x6180 <csp_sys_set_color+0x54>
		case COLOR_RESET:
		default:
			color_code = 0; break;
    6176:	20 e0       	ldi	r18, 0x00	; 0
    6178:	30 e0       	ldi	r19, 0x00	; 0
    617a:	02 c0       	rjmp	.+4      	; 0x6180 <csp_sys_set_color+0x54>
void csp_sys_set_color(csp_color_t color) {

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
		case COLOR_BLACK:
			color_code = 30; break;
    617c:	2e e1       	ldi	r18, 0x1E	; 30
    617e:	30 e0       	ldi	r19, 0x00	; 0
		case COLOR_RESET:
		default:
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
    6180:	89 2f       	mov	r24, r25
    6182:	80 7f       	andi	r24, 0xF0	; 240
    6184:	80 32       	cpi	r24, 0x20	; 32
    6186:	49 f0       	breq	.+18     	; 0x619a <csp_sys_set_color+0x6e>
    6188:	18 f4       	brcc	.+6      	; 0x6190 <csp_sys_set_color+0x64>
    618a:	80 31       	cpi	r24, 0x10	; 16
    618c:	91 f0       	breq	.+36     	; 0x61b2 <csp_sys_set_color+0x86>
    618e:	0e c0       	rjmp	.+28     	; 0x61ac <csp_sys_set_color+0x80>
    6190:	80 33       	cpi	r24, 0x30	; 48
    6192:	31 f0       	breq	.+12     	; 0x61a0 <csp_sys_set_color+0x74>
    6194:	80 34       	cpi	r24, 0x40	; 64
    6196:	39 f0       	breq	.+14     	; 0x61a6 <csp_sys_set_color+0x7a>
    6198:	09 c0       	rjmp	.+18     	; 0x61ac <csp_sys_set_color+0x80>
		case COLOR_BOLD:
			modifier_code = 1; break;
		case COLOR_UNDERLINE:
			modifier_code = 2; break;
    619a:	82 e0       	ldi	r24, 0x02	; 2
    619c:	90 e0       	ldi	r25, 0x00	; 0
    619e:	0b c0       	rjmp	.+22     	; 0x61b6 <csp_sys_set_color+0x8a>
		case COLOR_BLINK:
			modifier_code = 3; break;
    61a0:	83 e0       	ldi	r24, 0x03	; 3
    61a2:	90 e0       	ldi	r25, 0x00	; 0
    61a4:	08 c0       	rjmp	.+16     	; 0x61b6 <csp_sys_set_color+0x8a>
		case COLOR_HIDE:
			modifier_code = 4; break;
    61a6:	84 e0       	ldi	r24, 0x04	; 4
    61a8:	90 e0       	ldi	r25, 0x00	; 0
    61aa:	05 c0       	rjmp	.+10     	; 0x61b6 <csp_sys_set_color+0x8a>
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
    61ac:	80 e0       	ldi	r24, 0x00	; 0
    61ae:	90 e0       	ldi	r25, 0x00	; 0
    61b0:	02 c0       	rjmp	.+4      	; 0x61b6 <csp_sys_set_color+0x8a>
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
		case COLOR_BOLD:
			modifier_code = 1; break;
    61b2:	81 e0       	ldi	r24, 0x01	; 1
    61b4:	90 e0       	ldi	r25, 0x00	; 0
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
	}

	printf("\033[%u;%um", modifier_code, color_code);
    61b6:	3f 93       	push	r19
    61b8:	2f 93       	push	r18
    61ba:	9f 93       	push	r25
    61bc:	8f 93       	push	r24
    61be:	89 e8       	ldi	r24, 0x89	; 137
    61c0:	92 e1       	ldi	r25, 0x12	; 18
    61c2:	9f 93       	push	r25
    61c4:	8f 93       	push	r24
    61c6:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <printf_P>
}
    61ca:	0f 90       	pop	r0
    61cc:	0f 90       	pop	r0
    61ce:	0f 90       	pop	r0
    61d0:	0f 90       	pop	r0
    61d2:	0f 90       	pop	r0
    61d4:	0f 90       	pop	r0
    61d6:	08 95       	ret

000061d8 <csp_thread_create>:
/* CSP includes */
#include "csp.h"

#include "csp_thread.h"

int csp_thread_create(csp_thread_return_t (* routine)(void *), const char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    61d8:	ef 92       	push	r14
    61da:	ff 92       	push	r15
    61dc:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
    61de:	0e 94 9a 39 	call	0x7334	; 0x7334 <xTaskCreate>
    61e2:	21 e0       	ldi	r18, 0x01	; 1
    61e4:	30 e0       	ldi	r19, 0x00	; 0
    61e6:	81 30       	cpi	r24, 0x01	; 1
    61e8:	11 f4       	brne	.+4      	; 0x61ee <csp_thread_create+0x16>
    61ea:	20 e0       	ldi	r18, 0x00	; 0
    61ec:	30 e0       	ldi	r19, 0x00	; 0
	portBASE_TYPE ret = xTaskCreate(routine, (signed char *) thread_name, stack_depth, parameters, priority, handle);
#endif
	if (ret != pdTRUE)
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    61ee:	88 27       	eor	r24, r24
    61f0:	99 27       	eor	r25, r25
    61f2:	82 1b       	sub	r24, r18
    61f4:	93 0b       	sbc	r25, r19
    61f6:	0f 91       	pop	r16
    61f8:	ff 90       	pop	r15
    61fa:	ef 90       	pop	r14
    61fc:	08 95       	ret

000061fe <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    61fe:	0e 94 7a 3b 	call	0x76f4	; 0x76f4 <xTaskGetTickCount>
    6202:	bc 01       	movw	r22, r24
    6204:	66 0f       	add	r22, r22
    6206:	77 1f       	adc	r23, r23
    6208:	88 0f       	add	r24, r24
    620a:	99 1f       	adc	r25, r25
    620c:	88 0f       	add	r24, r24
    620e:	99 1f       	adc	r25, r25
    6210:	88 0f       	add	r24, r24
    6212:	99 1f       	adc	r25, r25
    6214:	68 0f       	add	r22, r24
    6216:	79 1f       	adc	r23, r25
    6218:	80 e0       	ldi	r24, 0x00	; 0
    621a:	90 e0       	ldi	r25, 0x00	; 0
    621c:	08 95       	ret

0000621e <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    621e:	0e 94 7a 3b 	call	0x76f4	; 0x76f4 <xTaskGetTickCount>
    6222:	9c 01       	movw	r18, r24
    6224:	36 95       	lsr	r19
    6226:	27 95       	ror	r18
    6228:	36 95       	lsr	r19
    622a:	27 95       	ror	r18
    622c:	ab e7       	ldi	r26, 0x7B	; 123
    622e:	b4 e1       	ldi	r27, 0x14	; 20
    6230:	0e 94 09 45 	call	0x8a12	; 0x8a12 <__umulhisi3>
    6234:	96 95       	lsr	r25
    6236:	87 95       	ror	r24
    6238:	bc 01       	movw	r22, r24
    623a:	80 e0       	ldi	r24, 0x00	; 0
    623c:	90 e0       	ldi	r25, 0x00	; 0
}
    623e:	08 95       	ret

00006240 <csp_udp_new_packet>:
#include "csp_queue.h"
#include "csp_port.h"
#include "csp_conn.h"
#include "csp_transport.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    6240:	0f 93       	push	r16
    6242:	1f 93       	push	r17
    6244:	cf 93       	push	r28
    6246:	df 93       	push	r29
    6248:	1f 92       	push	r1
    624a:	1f 92       	push	r1
    624c:	cd b7       	in	r28, 0x3d	; 61
    624e:	de b7       	in	r29, 0x3e	; 62
    6250:	9a 83       	std	Y+2, r25	; 0x02
    6252:	89 83       	std	Y+1, r24	; 0x01
    6254:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    6256:	0e 94 66 19 	call	0x32cc	; 0x32cc <csp_conn_enqueue_packet>
    625a:	99 23       	and	r25, r25
    625c:	74 f4       	brge	.+28     	; 0x627a <csp_udp_new_packet+0x3a>
		csp_log_error("Connection buffer queue full!");
    625e:	8b ed       	ldi	r24, 0xDB	; 219
    6260:	92 e1       	ldi	r25, 0x12	; 18
    6262:	9f 93       	push	r25
    6264:	8f 93       	push	r24
    6266:	1f 92       	push	r1
    6268:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
		csp_buffer_free(packet);
    626c:	c8 01       	movw	r24, r16
    626e:	0e 94 c0 18 	call	0x3180	; 0x3180 <csp_buffer_free>
		return;
    6272:	0f 90       	pop	r0
    6274:	0f 90       	pop	r0
    6276:	0f 90       	pop	r0
    6278:	24 c0       	rjmp	.+72     	; 0x62c2 <csp_udp_new_packet+0x82>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    627a:	e9 81       	ldd	r30, Y+1	; 0x01
    627c:	fa 81       	ldd	r31, Y+2	; 0x02
    627e:	86 85       	ldd	r24, Z+14	; 0x0e
    6280:	97 85       	ldd	r25, Z+15	; 0x0f
    6282:	00 97       	sbiw	r24, 0x00	; 0
    6284:	f1 f0       	breq	.+60     	; 0x62c2 <csp_udp_new_packet+0x82>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    6286:	20 e0       	ldi	r18, 0x00	; 0
    6288:	30 e0       	ldi	r19, 0x00	; 0
    628a:	a9 01       	movw	r20, r18
    628c:	be 01       	movw	r22, r28
    628e:	6f 5f       	subi	r22, 0xFF	; 255
    6290:	7f 4f       	sbci	r23, 0xFF	; 255
    6292:	0e 94 84 28 	call	0x5108	; 0x5108 <csp_queue_enqueue>
    6296:	01 97       	sbiw	r24, 0x01	; 1
    6298:	81 f0       	breq	.+32     	; 0x62ba <csp_udp_new_packet+0x7a>
			csp_log_warn("Warning socket connection queue full");
    629a:	86 eb       	ldi	r24, 0xB6	; 182
    629c:	92 e1       	ldi	r25, 0x12	; 18
    629e:	9f 93       	push	r25
    62a0:	8f 93       	push	r24
    62a2:	81 e0       	ldi	r24, 0x01	; 1
    62a4:	8f 93       	push	r24
    62a6:	0e 94 70 1d 	call	0x3ae0	; 0x3ae0 <do_csp_debug>
			csp_close(conn);
    62aa:	89 81       	ldd	r24, Y+1	; 0x01
    62ac:	9a 81       	ldd	r25, Y+2	; 0x02
    62ae:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <csp_close>
			return;
    62b2:	0f 90       	pop	r0
    62b4:	0f 90       	pop	r0
    62b6:	0f 90       	pop	r0
    62b8:	04 c0       	rjmp	.+8      	; 0x62c2 <csp_udp_new_packet+0x82>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    62ba:	e9 81       	ldd	r30, Y+1	; 0x01
    62bc:	fa 81       	ldd	r31, Y+2	; 0x02
    62be:	17 86       	std	Z+15, r1	; 0x0f
    62c0:	16 86       	std	Z+14, r1	; 0x0e
	}

}
    62c2:	0f 90       	pop	r0
    62c4:	0f 90       	pop	r0
    62c6:	df 91       	pop	r29
    62c8:	cf 91       	pop	r28
    62ca:	1f 91       	pop	r17
    62cc:	0f 91       	pop	r16
    62ce:	08 95       	ret

000062d0 <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    62d0:	cf 93       	push	r28
    62d2:	df 93       	push	r29
    62d4:	dc 01       	movw	r26, r24
    62d6:	e0 e8       	ldi	r30, 0x80	; 128
    62d8:	f6 e0       	ldi	r31, 0x06	; 6
    62da:	01 c0       	rjmp	.+2      	; 0x62de <prvInsertBlockIntoFreeList+0xe>
    62dc:	f9 01       	movw	r30, r18
    62de:	20 81       	ld	r18, Z
    62e0:	31 81       	ldd	r19, Z+1	; 0x01
    62e2:	2a 17       	cp	r18, r26
    62e4:	3b 07       	cpc	r19, r27
    62e6:	d0 f3       	brcs	.-12     	; 0x62dc <prvInsertBlockIntoFreeList+0xc>
    62e8:	82 81       	ldd	r24, Z+2	; 0x02
    62ea:	93 81       	ldd	r25, Z+3	; 0x03
    62ec:	af 01       	movw	r20, r30
    62ee:	48 0f       	add	r20, r24
    62f0:	59 1f       	adc	r21, r25
    62f2:	a4 17       	cp	r26, r20
    62f4:	b5 07       	cpc	r27, r21
    62f6:	49 f4       	brne	.+18     	; 0x630a <prvInsertBlockIntoFreeList+0x3a>
    62f8:	12 96       	adiw	r26, 0x02	; 2
    62fa:	4d 91       	ld	r20, X+
    62fc:	5c 91       	ld	r21, X
    62fe:	13 97       	sbiw	r26, 0x03	; 3
    6300:	84 0f       	add	r24, r20
    6302:	95 1f       	adc	r25, r21
    6304:	93 83       	std	Z+3, r25	; 0x03
    6306:	82 83       	std	Z+2, r24	; 0x02
    6308:	df 01       	movw	r26, r30
    630a:	12 96       	adiw	r26, 0x02	; 2
    630c:	8d 91       	ld	r24, X+
    630e:	9c 91       	ld	r25, X
    6310:	13 97       	sbiw	r26, 0x03	; 3
    6312:	ed 01       	movw	r28, r26
    6314:	c8 0f       	add	r28, r24
    6316:	d9 1f       	adc	r29, r25
    6318:	2c 17       	cp	r18, r28
    631a:	3d 07       	cpc	r19, r29
    631c:	d9 f4       	brne	.+54     	; 0x6354 <prvInsertBlockIntoFreeList+0x84>
    631e:	20 91 7e 06 	lds	r18, 0x067E	; 0x80067e <pxEnd>
    6322:	30 91 7f 06 	lds	r19, 0x067F	; 0x80067f <pxEnd+0x1>
    6326:	c2 17       	cp	r28, r18
    6328:	d3 07       	cpc	r29, r19
    632a:	81 f0       	breq	.+32     	; 0x634c <prvInsertBlockIntoFreeList+0x7c>
    632c:	2a 81       	ldd	r18, Y+2	; 0x02
    632e:	3b 81       	ldd	r19, Y+3	; 0x03
    6330:	82 0f       	add	r24, r18
    6332:	93 1f       	adc	r25, r19
    6334:	13 96       	adiw	r26, 0x03	; 3
    6336:	9c 93       	st	X, r25
    6338:	8e 93       	st	-X, r24
    633a:	12 97       	sbiw	r26, 0x02	; 2
    633c:	c0 81       	ld	r28, Z
    633e:	d1 81       	ldd	r29, Z+1	; 0x01
    6340:	88 81       	ld	r24, Y
    6342:	99 81       	ldd	r25, Y+1	; 0x01
    6344:	11 96       	adiw	r26, 0x01	; 1
    6346:	9c 93       	st	X, r25
    6348:	8e 93       	st	-X, r24
    634a:	07 c0       	rjmp	.+14     	; 0x635a <prvInsertBlockIntoFreeList+0x8a>
    634c:	11 96       	adiw	r26, 0x01	; 1
    634e:	dc 93       	st	X, r29
    6350:	ce 93       	st	-X, r28
    6352:	03 c0       	rjmp	.+6      	; 0x635a <prvInsertBlockIntoFreeList+0x8a>
    6354:	11 96       	adiw	r26, 0x01	; 1
    6356:	3c 93       	st	X, r19
    6358:	2e 93       	st	-X, r18
    635a:	ae 17       	cp	r26, r30
    635c:	bf 07       	cpc	r27, r31
    635e:	11 f0       	breq	.+4      	; 0x6364 <prvInsertBlockIntoFreeList+0x94>
    6360:	b1 83       	std	Z+1, r27	; 0x01
    6362:	a0 83       	st	Z, r26
    6364:	df 91       	pop	r29
    6366:	cf 91       	pop	r28
    6368:	08 95       	ret

0000636a <vPortFree>:
    636a:	cf 93       	push	r28
    636c:	df 93       	push	r29
    636e:	00 97       	sbiw	r24, 0x00	; 0
    6370:	51 f1       	breq	.+84     	; 0x63c6 <vPortFree+0x5c>
    6372:	fc 01       	movw	r30, r24
    6374:	34 97       	sbiw	r30, 0x04	; 4
    6376:	22 81       	ldd	r18, Z+2	; 0x02
    6378:	33 81       	ldd	r19, Z+3	; 0x03
    637a:	40 91 78 06 	lds	r20, 0x0678	; 0x800678 <xBlockAllocatedBit>
    637e:	50 91 79 06 	lds	r21, 0x0679	; 0x800679 <xBlockAllocatedBit+0x1>
    6382:	b9 01       	movw	r22, r18
    6384:	64 23       	and	r22, r20
    6386:	75 23       	and	r23, r21
    6388:	67 2b       	or	r22, r23
    638a:	e9 f0       	breq	.+58     	; 0x63c6 <vPortFree+0x5c>
    638c:	60 81       	ld	r22, Z
    638e:	71 81       	ldd	r23, Z+1	; 0x01
    6390:	67 2b       	or	r22, r23
    6392:	c9 f4       	brne	.+50     	; 0x63c6 <vPortFree+0x5c>
    6394:	ef 01       	movw	r28, r30
    6396:	40 95       	com	r20
    6398:	50 95       	com	r21
    639a:	24 23       	and	r18, r20
    639c:	35 23       	and	r19, r21
    639e:	33 83       	std	Z+3, r19	; 0x03
    63a0:	22 83       	std	Z+2, r18	; 0x02
    63a2:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
    63a6:	20 91 7c 06 	lds	r18, 0x067C	; 0x80067c <xFreeBytesRemaining>
    63aa:	30 91 7d 06 	lds	r19, 0x067D	; 0x80067d <xFreeBytesRemaining+0x1>
    63ae:	8a 81       	ldd	r24, Y+2	; 0x02
    63b0:	9b 81       	ldd	r25, Y+3	; 0x03
    63b2:	82 0f       	add	r24, r18
    63b4:	93 1f       	adc	r25, r19
    63b6:	90 93 7d 06 	sts	0x067D, r25	; 0x80067d <xFreeBytesRemaining+0x1>
    63ba:	80 93 7c 06 	sts	0x067C, r24	; 0x80067c <xFreeBytesRemaining>
    63be:	ce 01       	movw	r24, r28
    63c0:	87 df       	rcall	.-242    	; 0x62d0 <prvInsertBlockIntoFreeList>
    63c2:	0e 94 31 3c 	call	0x7862	; 0x7862 <xTaskResumeAll>
    63c6:	df 91       	pop	r29
    63c8:	cf 91       	pop	r28
    63ca:	08 95       	ret

000063cc <vApplicationMallocFailedHook>:
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
void vApplicationMallocFailedHook(void) {
	printf("outmem");
    63cc:	81 ec       	ldi	r24, 0xC1	; 193
    63ce:	92 e0       	ldi	r25, 0x02	; 2
    63d0:	9f 93       	push	r25
    63d2:	8f 93       	push	r24
    63d4:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <printf>
	FORCERESET
    63d8:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
    63dc:	88 ec       	ldi	r24, 0xC8	; 200
    63de:	92 e0       	ldi	r25, 0x02	; 2
    63e0:	0e 94 51 46 	call	0x8ca2	; 0x8ca2 <puts>
    63e4:	0f 90       	pop	r0
    63e6:	0f 90       	pop	r0
    63e8:	ff cf       	rjmp	.-2      	; 0x63e8 <vApplicationMallocFailedHook+0x1c>

000063ea <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    63ea:	cf 92       	push	r12
    63ec:	df 92       	push	r13
    63ee:	ef 92       	push	r14
    63f0:	ff 92       	push	r15
    63f2:	0f 93       	push	r16
    63f4:	1f 93       	push	r17
    63f6:	cf 93       	push	r28
    63f8:	df 93       	push	r29
    63fa:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    63fc:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    6400:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <pxEnd>
    6404:	90 91 7f 06 	lds	r25, 0x067F	; 0x80067f <pxEnd+0x1>
    6408:	89 2b       	or	r24, r25
    640a:	41 f5       	brne	.+80     	; 0x645c <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    640c:	e0 e8       	ldi	r30, 0x80	; 128
    640e:	f6 e0       	ldi	r31, 0x06	; 6
    6410:	a4 e8       	ldi	r26, 0x84	; 132
    6412:	b6 e0       	ldi	r27, 0x06	; 6
    6414:	b1 83       	std	Z+1, r27	; 0x01
    6416:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    6418:	13 82       	std	Z+3, r1	; 0x03
    641a:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    641c:	e4 ee       	ldi	r30, 0xE4	; 228
    641e:	ff e1       	ldi	r31, 0x1F	; 31
    6420:	f0 93 7f 06 	sts	0x067F, r31	; 0x80067f <pxEnd+0x1>
    6424:	e0 93 7e 06 	sts	0x067E, r30	; 0x80067e <pxEnd>
	pxEnd->xBlockSize = 0;
    6428:	13 82       	std	Z+3, r1	; 0x03
    642a:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    642c:	11 82       	std	Z+1, r1	; 0x01
    642e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    6430:	80 e6       	ldi	r24, 0x60	; 96
    6432:	99 e1       	ldi	r25, 0x19	; 25
    6434:	13 96       	adiw	r26, 0x03	; 3
    6436:	9c 93       	st	X, r25
    6438:	8e 93       	st	-X, r24
    643a:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    643c:	ed 93       	st	X+, r30
    643e:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    6440:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xMinimumEverFreeBytesRemaining+0x1>
    6444:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    6448:	90 93 7d 06 	sts	0x067D, r25	; 0x80067d <xFreeBytesRemaining+0x1>
    644c:	80 93 7c 06 	sts	0x067C, r24	; 0x80067c <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    6450:	80 e0       	ldi	r24, 0x00	; 0
    6452:	90 e8       	ldi	r25, 0x80	; 128
    6454:	90 93 79 06 	sts	0x0679, r25	; 0x800679 <xBlockAllocatedBit+0x1>
    6458:	80 93 78 06 	sts	0x0678, r24	; 0x800678 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    645c:	e0 90 78 06 	lds	r14, 0x0678	; 0x800678 <xBlockAllocatedBit>
    6460:	f0 90 79 06 	lds	r15, 0x0679	; 0x800679 <xBlockAllocatedBit+0x1>
    6464:	c7 01       	movw	r24, r14
    6466:	8c 23       	and	r24, r28
    6468:	9d 23       	and	r25, r29
    646a:	89 2b       	or	r24, r25
    646c:	09 f0       	breq	.+2      	; 0x6470 <pvPortMalloc+0x86>
    646e:	62 c0       	rjmp	.+196    	; 0x6534 <pvPortMalloc+0x14a>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    6470:	20 97       	sbiw	r28, 0x00	; 0
    6472:	09 f4       	brne	.+2      	; 0x6476 <pvPortMalloc+0x8c>
    6474:	62 c0       	rjmp	.+196    	; 0x653a <pvPortMalloc+0x150>
			{
				xWantedSize += xHeapStructSize;
    6476:	ae 01       	movw	r20, r28
    6478:	4c 5f       	subi	r20, 0xFC	; 252
    647a:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    647c:	09 f4       	brne	.+2      	; 0x6480 <pvPortMalloc+0x96>
    647e:	5a c0       	rjmp	.+180    	; 0x6534 <pvPortMalloc+0x14a>
    6480:	00 91 7c 06 	lds	r16, 0x067C	; 0x80067c <xFreeBytesRemaining>
    6484:	10 91 7d 06 	lds	r17, 0x067D	; 0x80067d <xFreeBytesRemaining+0x1>
    6488:	04 17       	cp	r16, r20
    648a:	15 07       	cpc	r17, r21
    648c:	08 f4       	brcc	.+2      	; 0x6490 <pvPortMalloc+0xa6>
    648e:	52 c0       	rjmp	.+164    	; 0x6534 <pvPortMalloc+0x14a>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    6490:	c0 91 80 06 	lds	r28, 0x0680	; 0x800680 <xStart>
    6494:	d0 91 81 06 	lds	r29, 0x0681	; 0x800681 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    6498:	e0 e8       	ldi	r30, 0x80	; 128
    649a:	f6 e0       	ldi	r31, 0x06	; 6
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    649c:	02 c0       	rjmp	.+4      	; 0x64a2 <pvPortMalloc+0xb8>
    649e:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    64a0:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    64a2:	2a 81       	ldd	r18, Y+2	; 0x02
    64a4:	3b 81       	ldd	r19, Y+3	; 0x03
    64a6:	24 17       	cp	r18, r20
    64a8:	35 07       	cpc	r19, r21
    64aa:	28 f4       	brcc	.+10     	; 0x64b6 <pvPortMalloc+0xcc>
    64ac:	28 81       	ld	r18, Y
    64ae:	39 81       	ldd	r19, Y+1	; 0x01
    64b0:	21 15       	cp	r18, r1
    64b2:	31 05       	cpc	r19, r1
    64b4:	a1 f7       	brne	.-24     	; 0x649e <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    64b6:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <pxEnd>
    64ba:	90 91 7f 06 	lds	r25, 0x067F	; 0x80067f <pxEnd+0x1>
    64be:	c8 17       	cp	r28, r24
    64c0:	d9 07       	cpc	r29, r25
    64c2:	c1 f1       	breq	.+112    	; 0x6534 <pvPortMalloc+0x14a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    64c4:	c0 80       	ld	r12, Z
    64c6:	d1 80       	ldd	r13, Z+1	; 0x01
    64c8:	84 e0       	ldi	r24, 0x04	; 4
    64ca:	c8 0e       	add	r12, r24
    64cc:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    64ce:	88 81       	ld	r24, Y
    64d0:	99 81       	ldd	r25, Y+1	; 0x01
    64d2:	91 83       	std	Z+1, r25	; 0x01
    64d4:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    64d6:	2a 81       	ldd	r18, Y+2	; 0x02
    64d8:	3b 81       	ldd	r19, Y+3	; 0x03
    64da:	24 1b       	sub	r18, r20
    64dc:	35 0b       	sbc	r19, r21
    64de:	29 30       	cpi	r18, 0x09	; 9
    64e0:	31 05       	cpc	r19, r1
    64e2:	48 f0       	brcs	.+18     	; 0x64f6 <pvPortMalloc+0x10c>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    64e4:	ce 01       	movw	r24, r28
    64e6:	84 0f       	add	r24, r20
    64e8:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    64ea:	fc 01       	movw	r30, r24
    64ec:	33 83       	std	Z+3, r19	; 0x03
    64ee:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    64f0:	5b 83       	std	Y+3, r21	; 0x03
    64f2:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    64f4:	ed de       	rcall	.-550    	; 0x62d0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    64f6:	8a 81       	ldd	r24, Y+2	; 0x02
    64f8:	9b 81       	ldd	r25, Y+3	; 0x03
    64fa:	08 1b       	sub	r16, r24
    64fc:	19 0b       	sbc	r17, r25
    64fe:	10 93 7d 06 	sts	0x067D, r17	; 0x80067d <xFreeBytesRemaining+0x1>
    6502:	00 93 7c 06 	sts	0x067C, r16	; 0x80067c <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    6506:	20 91 7a 06 	lds	r18, 0x067A	; 0x80067a <xMinimumEverFreeBytesRemaining>
    650a:	30 91 7b 06 	lds	r19, 0x067B	; 0x80067b <xMinimumEverFreeBytesRemaining+0x1>
    650e:	02 17       	cp	r16, r18
    6510:	13 07       	cpc	r17, r19
    6512:	20 f4       	brcc	.+8      	; 0x651c <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    6514:	10 93 7b 06 	sts	0x067B, r17	; 0x80067b <xMinimumEverFreeBytesRemaining+0x1>
    6518:	00 93 7a 06 	sts	0x067A, r16	; 0x80067a <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    651c:	e8 2a       	or	r14, r24
    651e:	f9 2a       	or	r15, r25
    6520:	fb 82       	std	Y+3, r15	; 0x03
    6522:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    6524:	19 82       	std	Y+1, r1	; 0x01
    6526:	18 82       	st	Y, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    6528:	0e 94 31 3c 	call	0x7862	; 0x7862 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    652c:	c1 14       	cp	r12, r1
    652e:	d1 04       	cpc	r13, r1
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    6530:	39 f4       	brne	.+14     	; 0x6540 <pvPortMalloc+0x156>
    6532:	4c df       	rcall	.-360    	; 0x63cc <vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    6534:	0e 94 31 3c 	call	0x7862	; 0x7862 <xTaskResumeAll>
    6538:	fc cf       	rjmp	.-8      	; 0x6532 <pvPortMalloc+0x148>
    653a:	0e 94 31 3c 	call	0x7862	; 0x7862 <xTaskResumeAll>
    653e:	f9 cf       	rjmp	.-14     	; 0x6532 <pvPortMalloc+0x148>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    6540:	c6 01       	movw	r24, r12
    6542:	df 91       	pop	r29
    6544:	cf 91       	pop	r28
    6546:	1f 91       	pop	r17
    6548:	0f 91       	pop	r16
    654a:	ff 90       	pop	r15
    654c:	ef 90       	pop	r14
    654e:	df 90       	pop	r13
    6550:	cf 90       	pop	r12
    6552:	08 95       	ret

00006554 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    6554:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    6556:	03 96       	adiw	r24, 0x03	; 3
    6558:	92 83       	std	Z+2, r25	; 0x02
    655a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    655c:	2f ef       	ldi	r18, 0xFF	; 255
    655e:	3f ef       	ldi	r19, 0xFF	; 255
    6560:	34 83       	std	Z+4, r19	; 0x04
    6562:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    6564:	96 83       	std	Z+6, r25	; 0x06
    6566:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    6568:	90 87       	std	Z+8, r25	; 0x08
    656a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    656c:	10 82       	st	Z, r1
    656e:	08 95       	ret

00006570 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    6570:	fc 01       	movw	r30, r24
    6572:	11 86       	std	Z+9, r1	; 0x09
    6574:	10 86       	std	Z+8, r1	; 0x08
    6576:	08 95       	ret

00006578 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    6578:	cf 93       	push	r28
    657a:	df 93       	push	r29
    657c:	9c 01       	movw	r18, r24
    657e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    6580:	dc 01       	movw	r26, r24
    6582:	11 96       	adiw	r26, 0x01	; 1
    6584:	cd 91       	ld	r28, X+
    6586:	dc 91       	ld	r29, X
    6588:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    658a:	d3 83       	std	Z+3, r29	; 0x03
    658c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    658e:	8c 81       	ldd	r24, Y+4	; 0x04
    6590:	9d 81       	ldd	r25, Y+5	; 0x05
    6592:	95 83       	std	Z+5, r25	; 0x05
    6594:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    6596:	8c 81       	ldd	r24, Y+4	; 0x04
    6598:	9d 81       	ldd	r25, Y+5	; 0x05
    659a:	dc 01       	movw	r26, r24
    659c:	13 96       	adiw	r26, 0x03	; 3
    659e:	7c 93       	st	X, r23
    65a0:	6e 93       	st	-X, r22
    65a2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    65a4:	7d 83       	std	Y+5, r23	; 0x05
    65a6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    65a8:	31 87       	std	Z+9, r19	; 0x09
    65aa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    65ac:	f9 01       	movw	r30, r18
    65ae:	80 81       	ld	r24, Z
    65b0:	8f 5f       	subi	r24, 0xFF	; 255
    65b2:	80 83       	st	Z, r24
}
    65b4:	df 91       	pop	r29
    65b6:	cf 91       	pop	r28
    65b8:	08 95       	ret

000065ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    65ba:	cf 93       	push	r28
    65bc:	df 93       	push	r29
    65be:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    65c0:	48 81       	ld	r20, Y
    65c2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    65c4:	4f 3f       	cpi	r20, 0xFF	; 255
    65c6:	2f ef       	ldi	r18, 0xFF	; 255
    65c8:	52 07       	cpc	r21, r18
    65ca:	21 f4       	brne	.+8      	; 0x65d4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    65cc:	fc 01       	movw	r30, r24
    65ce:	a7 81       	ldd	r26, Z+7	; 0x07
    65d0:	b0 85       	ldd	r27, Z+8	; 0x08
    65d2:	0d c0       	rjmp	.+26     	; 0x65ee <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    65d4:	dc 01       	movw	r26, r24
    65d6:	13 96       	adiw	r26, 0x03	; 3
    65d8:	01 c0       	rjmp	.+2      	; 0x65dc <vListInsert+0x22>
    65da:	df 01       	movw	r26, r30
    65dc:	12 96       	adiw	r26, 0x02	; 2
    65de:	ed 91       	ld	r30, X+
    65e0:	fc 91       	ld	r31, X
    65e2:	13 97       	sbiw	r26, 0x03	; 3
    65e4:	20 81       	ld	r18, Z
    65e6:	31 81       	ldd	r19, Z+1	; 0x01
    65e8:	42 17       	cp	r20, r18
    65ea:	53 07       	cpc	r21, r19
    65ec:	b0 f7       	brcc	.-20     	; 0x65da <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    65ee:	12 96       	adiw	r26, 0x02	; 2
    65f0:	ed 91       	ld	r30, X+
    65f2:	fc 91       	ld	r31, X
    65f4:	13 97       	sbiw	r26, 0x03	; 3
    65f6:	fb 83       	std	Y+3, r31	; 0x03
    65f8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    65fa:	d5 83       	std	Z+5, r29	; 0x05
    65fc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    65fe:	bd 83       	std	Y+5, r27	; 0x05
    6600:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    6602:	13 96       	adiw	r26, 0x03	; 3
    6604:	dc 93       	st	X, r29
    6606:	ce 93       	st	-X, r28
    6608:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    660a:	99 87       	std	Y+9, r25	; 0x09
    660c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    660e:	fc 01       	movw	r30, r24
    6610:	20 81       	ld	r18, Z
    6612:	2f 5f       	subi	r18, 0xFF	; 255
    6614:	20 83       	st	Z, r18
}
    6616:	df 91       	pop	r29
    6618:	cf 91       	pop	r28
    661a:	08 95       	ret

0000661c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    661c:	cf 93       	push	r28
    661e:	df 93       	push	r29
    6620:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    6622:	a0 85       	ldd	r26, Z+8	; 0x08
    6624:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    6626:	c2 81       	ldd	r28, Z+2	; 0x02
    6628:	d3 81       	ldd	r29, Z+3	; 0x03
    662a:	84 81       	ldd	r24, Z+4	; 0x04
    662c:	95 81       	ldd	r25, Z+5	; 0x05
    662e:	9d 83       	std	Y+5, r25	; 0x05
    6630:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    6632:	c4 81       	ldd	r28, Z+4	; 0x04
    6634:	d5 81       	ldd	r29, Z+5	; 0x05
    6636:	82 81       	ldd	r24, Z+2	; 0x02
    6638:	93 81       	ldd	r25, Z+3	; 0x03
    663a:	9b 83       	std	Y+3, r25	; 0x03
    663c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    663e:	11 96       	adiw	r26, 0x01	; 1
    6640:	8d 91       	ld	r24, X+
    6642:	9c 91       	ld	r25, X
    6644:	12 97       	sbiw	r26, 0x02	; 2
    6646:	e8 17       	cp	r30, r24
    6648:	f9 07       	cpc	r31, r25
    664a:	31 f4       	brne	.+12     	; 0x6658 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    664c:	84 81       	ldd	r24, Z+4	; 0x04
    664e:	95 81       	ldd	r25, Z+5	; 0x05
    6650:	12 96       	adiw	r26, 0x02	; 2
    6652:	9c 93       	st	X, r25
    6654:	8e 93       	st	-X, r24
    6656:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    6658:	11 86       	std	Z+9, r1	; 0x09
    665a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    665c:	8c 91       	ld	r24, X
    665e:	81 50       	subi	r24, 0x01	; 1
    6660:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    6662:	8c 91       	ld	r24, X
}
    6664:	df 91       	pop	r29
    6666:	cf 91       	pop	r28
    6668:	08 95       	ret

0000666a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    666a:	31 e1       	ldi	r19, 0x11	; 17
    666c:	fc 01       	movw	r30, r24
    666e:	30 83       	st	Z, r19
    6670:	31 97       	sbiw	r30, 0x01	; 1
    6672:	22 e2       	ldi	r18, 0x22	; 34
    6674:	20 83       	st	Z, r18
    6676:	31 97       	sbiw	r30, 0x01	; 1
    6678:	a3 e3       	ldi	r26, 0x33	; 51
    667a:	a0 83       	st	Z, r26
    667c:	31 97       	sbiw	r30, 0x01	; 1
    667e:	60 83       	st	Z, r22
    6680:	31 97       	sbiw	r30, 0x01	; 1
    6682:	70 83       	st	Z, r23
    6684:	31 97       	sbiw	r30, 0x01	; 1
    6686:	10 82       	st	Z, r1
    6688:	31 97       	sbiw	r30, 0x01	; 1
    668a:	10 82       	st	Z, r1
    668c:	31 97       	sbiw	r30, 0x01	; 1
    668e:	60 e8       	ldi	r22, 0x80	; 128
    6690:	60 83       	st	Z, r22
    6692:	31 97       	sbiw	r30, 0x01	; 1
    6694:	10 82       	st	Z, r1
    6696:	31 97       	sbiw	r30, 0x01	; 1
    6698:	10 82       	st	Z, r1
    669a:	31 97       	sbiw	r30, 0x01	; 1
    669c:	10 82       	st	Z, r1
    669e:	31 97       	sbiw	r30, 0x01	; 1
    66a0:	62 e0       	ldi	r22, 0x02	; 2
    66a2:	60 83       	st	Z, r22
    66a4:	31 97       	sbiw	r30, 0x01	; 1
    66a6:	63 e0       	ldi	r22, 0x03	; 3
    66a8:	60 83       	st	Z, r22
    66aa:	31 97       	sbiw	r30, 0x01	; 1
    66ac:	64 e0       	ldi	r22, 0x04	; 4
    66ae:	60 83       	st	Z, r22
    66b0:	31 97       	sbiw	r30, 0x01	; 1
    66b2:	65 e0       	ldi	r22, 0x05	; 5
    66b4:	60 83       	st	Z, r22
    66b6:	31 97       	sbiw	r30, 0x01	; 1
    66b8:	66 e0       	ldi	r22, 0x06	; 6
    66ba:	60 83       	st	Z, r22
    66bc:	31 97       	sbiw	r30, 0x01	; 1
    66be:	67 e0       	ldi	r22, 0x07	; 7
    66c0:	60 83       	st	Z, r22
    66c2:	31 97       	sbiw	r30, 0x01	; 1
    66c4:	68 e0       	ldi	r22, 0x08	; 8
    66c6:	60 83       	st	Z, r22
    66c8:	31 97       	sbiw	r30, 0x01	; 1
    66ca:	69 e0       	ldi	r22, 0x09	; 9
    66cc:	60 83       	st	Z, r22
    66ce:	31 97       	sbiw	r30, 0x01	; 1
    66d0:	60 e1       	ldi	r22, 0x10	; 16
    66d2:	60 83       	st	Z, r22
    66d4:	31 97       	sbiw	r30, 0x01	; 1
    66d6:	30 83       	st	Z, r19
    66d8:	31 97       	sbiw	r30, 0x01	; 1
    66da:	32 e1       	ldi	r19, 0x12	; 18
    66dc:	30 83       	st	Z, r19
    66de:	31 97       	sbiw	r30, 0x01	; 1
    66e0:	33 e1       	ldi	r19, 0x13	; 19
    66e2:	30 83       	st	Z, r19
    66e4:	31 97       	sbiw	r30, 0x01	; 1
    66e6:	34 e1       	ldi	r19, 0x14	; 20
    66e8:	30 83       	st	Z, r19
    66ea:	31 97       	sbiw	r30, 0x01	; 1
    66ec:	35 e1       	ldi	r19, 0x15	; 21
    66ee:	30 83       	st	Z, r19
    66f0:	31 97       	sbiw	r30, 0x01	; 1
    66f2:	36 e1       	ldi	r19, 0x16	; 22
    66f4:	30 83       	st	Z, r19
    66f6:	31 97       	sbiw	r30, 0x01	; 1
    66f8:	37 e1       	ldi	r19, 0x17	; 23
    66fa:	30 83       	st	Z, r19
    66fc:	31 97       	sbiw	r30, 0x01	; 1
    66fe:	38 e1       	ldi	r19, 0x18	; 24
    6700:	30 83       	st	Z, r19
    6702:	31 97       	sbiw	r30, 0x01	; 1
    6704:	39 e1       	ldi	r19, 0x19	; 25
    6706:	30 83       	st	Z, r19
    6708:	31 97       	sbiw	r30, 0x01	; 1
    670a:	30 e2       	ldi	r19, 0x20	; 32
    670c:	30 83       	st	Z, r19
    670e:	31 97       	sbiw	r30, 0x01	; 1
    6710:	31 e2       	ldi	r19, 0x21	; 33
    6712:	30 83       	st	Z, r19
    6714:	31 97       	sbiw	r30, 0x01	; 1
    6716:	20 83       	st	Z, r18
    6718:	31 97       	sbiw	r30, 0x01	; 1
    671a:	23 e2       	ldi	r18, 0x23	; 35
    671c:	20 83       	st	Z, r18
    671e:	31 97       	sbiw	r30, 0x01	; 1
    6720:	40 83       	st	Z, r20
    6722:	31 97       	sbiw	r30, 0x01	; 1
    6724:	50 83       	st	Z, r21
    6726:	31 97       	sbiw	r30, 0x01	; 1
    6728:	26 e2       	ldi	r18, 0x26	; 38
    672a:	20 83       	st	Z, r18
    672c:	31 97       	sbiw	r30, 0x01	; 1
    672e:	27 e2       	ldi	r18, 0x27	; 39
    6730:	20 83       	st	Z, r18
    6732:	31 97       	sbiw	r30, 0x01	; 1
    6734:	28 e2       	ldi	r18, 0x28	; 40
    6736:	20 83       	st	Z, r18
    6738:	31 97       	sbiw	r30, 0x01	; 1
    673a:	29 e2       	ldi	r18, 0x29	; 41
    673c:	20 83       	st	Z, r18
    673e:	31 97       	sbiw	r30, 0x01	; 1
    6740:	20 e3       	ldi	r18, 0x30	; 48
    6742:	20 83       	st	Z, r18
    6744:	31 97       	sbiw	r30, 0x01	; 1
    6746:	21 e3       	ldi	r18, 0x31	; 49
    6748:	20 83       	st	Z, r18
    674a:	89 97       	sbiw	r24, 0x29	; 41
    674c:	08 95       	ret

0000674e <xPortStartScheduler>:
    674e:	89 e0       	ldi	r24, 0x09	; 9
    6750:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
    6754:	83 ec       	ldi	r24, 0xC3	; 195
    6756:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
    675a:	8b e0       	ldi	r24, 0x0B	; 11
    675c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
    6760:	ef e6       	ldi	r30, 0x6F	; 111
    6762:	f0 e0       	ldi	r31, 0x00	; 0
    6764:	80 81       	ld	r24, Z
    6766:	82 60       	ori	r24, 0x02	; 2
    6768:	80 83       	st	Z, r24
    676a:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    676e:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    6772:	cd 91       	ld	r28, X+
    6774:	cd bf       	out	0x3d, r28	; 61
    6776:	dd 91       	ld	r29, X+
    6778:	de bf       	out	0x3e, r29	; 62
    677a:	ff 91       	pop	r31
    677c:	ef 91       	pop	r30
    677e:	df 91       	pop	r29
    6780:	cf 91       	pop	r28
    6782:	bf 91       	pop	r27
    6784:	af 91       	pop	r26
    6786:	9f 91       	pop	r25
    6788:	8f 91       	pop	r24
    678a:	7f 91       	pop	r23
    678c:	6f 91       	pop	r22
    678e:	5f 91       	pop	r21
    6790:	4f 91       	pop	r20
    6792:	3f 91       	pop	r19
    6794:	2f 91       	pop	r18
    6796:	1f 91       	pop	r17
    6798:	0f 91       	pop	r16
    679a:	ff 90       	pop	r15
    679c:	ef 90       	pop	r14
    679e:	df 90       	pop	r13
    67a0:	cf 90       	pop	r12
    67a2:	bf 90       	pop	r11
    67a4:	af 90       	pop	r10
    67a6:	9f 90       	pop	r9
    67a8:	8f 90       	pop	r8
    67aa:	7f 90       	pop	r7
    67ac:	6f 90       	pop	r6
    67ae:	5f 90       	pop	r5
    67b0:	4f 90       	pop	r4
    67b2:	3f 90       	pop	r3
    67b4:	2f 90       	pop	r2
    67b6:	1f 90       	pop	r1
    67b8:	0f 90       	pop	r0
    67ba:	0c be       	out	0x3c, r0	; 60
    67bc:	0f 90       	pop	r0
    67be:	0b be       	out	0x3b, r0	; 59
    67c0:	0f 90       	pop	r0
    67c2:	0f be       	out	0x3f, r0	; 63
    67c4:	0f 90       	pop	r0
    67c6:	08 95       	ret
    67c8:	81 e0       	ldi	r24, 0x01	; 1
    67ca:	08 95       	ret

000067cc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    67cc:	0f 92       	push	r0
    67ce:	0f b6       	in	r0, 0x3f	; 63
    67d0:	f8 94       	cli
    67d2:	0f 92       	push	r0
    67d4:	0b b6       	in	r0, 0x3b	; 59
    67d6:	0f 92       	push	r0
    67d8:	0c b6       	in	r0, 0x3c	; 60
    67da:	0f 92       	push	r0
    67dc:	1f 92       	push	r1
    67de:	11 24       	eor	r1, r1
    67e0:	2f 92       	push	r2
    67e2:	3f 92       	push	r3
    67e4:	4f 92       	push	r4
    67e6:	5f 92       	push	r5
    67e8:	6f 92       	push	r6
    67ea:	7f 92       	push	r7
    67ec:	8f 92       	push	r8
    67ee:	9f 92       	push	r9
    67f0:	af 92       	push	r10
    67f2:	bf 92       	push	r11
    67f4:	cf 92       	push	r12
    67f6:	df 92       	push	r13
    67f8:	ef 92       	push	r14
    67fa:	ff 92       	push	r15
    67fc:	0f 93       	push	r16
    67fe:	1f 93       	push	r17
    6800:	2f 93       	push	r18
    6802:	3f 93       	push	r19
    6804:	4f 93       	push	r20
    6806:	5f 93       	push	r21
    6808:	6f 93       	push	r22
    680a:	7f 93       	push	r23
    680c:	8f 93       	push	r24
    680e:	9f 93       	push	r25
    6810:	af 93       	push	r26
    6812:	bf 93       	push	r27
    6814:	cf 93       	push	r28
    6816:	df 93       	push	r29
    6818:	ef 93       	push	r30
    681a:	ff 93       	push	r31
    681c:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    6820:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    6824:	0d b6       	in	r0, 0x3d	; 61
    6826:	0d 92       	st	X+, r0
    6828:	0e b6       	in	r0, 0x3e	; 62
    682a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    682c:	0e 94 a8 40 	call	0x8150	; 0x8150 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    6830:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    6834:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    6838:	cd 91       	ld	r28, X+
    683a:	cd bf       	out	0x3d, r28	; 61
    683c:	dd 91       	ld	r29, X+
    683e:	de bf       	out	0x3e, r29	; 62
    6840:	ff 91       	pop	r31
    6842:	ef 91       	pop	r30
    6844:	df 91       	pop	r29
    6846:	cf 91       	pop	r28
    6848:	bf 91       	pop	r27
    684a:	af 91       	pop	r26
    684c:	9f 91       	pop	r25
    684e:	8f 91       	pop	r24
    6850:	7f 91       	pop	r23
    6852:	6f 91       	pop	r22
    6854:	5f 91       	pop	r21
    6856:	4f 91       	pop	r20
    6858:	3f 91       	pop	r19
    685a:	2f 91       	pop	r18
    685c:	1f 91       	pop	r17
    685e:	0f 91       	pop	r16
    6860:	ff 90       	pop	r15
    6862:	ef 90       	pop	r14
    6864:	df 90       	pop	r13
    6866:	cf 90       	pop	r12
    6868:	bf 90       	pop	r11
    686a:	af 90       	pop	r10
    686c:	9f 90       	pop	r9
    686e:	8f 90       	pop	r8
    6870:	7f 90       	pop	r7
    6872:	6f 90       	pop	r6
    6874:	5f 90       	pop	r5
    6876:	4f 90       	pop	r4
    6878:	3f 90       	pop	r3
    687a:	2f 90       	pop	r2
    687c:	1f 90       	pop	r1
    687e:	0f 90       	pop	r0
    6880:	0c be       	out	0x3c, r0	; 60
    6882:	0f 90       	pop	r0
    6884:	0b be       	out	0x3b, r0	; 59
    6886:	0f 90       	pop	r0
    6888:	0f be       	out	0x3f, r0	; 63
    688a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    688c:	08 95       	ret

0000688e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    688e:	0f 92       	push	r0
    6890:	0f b6       	in	r0, 0x3f	; 63
    6892:	f8 94       	cli
    6894:	0f 92       	push	r0
    6896:	0b b6       	in	r0, 0x3b	; 59
    6898:	0f 92       	push	r0
    689a:	0c b6       	in	r0, 0x3c	; 60
    689c:	0f 92       	push	r0
    689e:	1f 92       	push	r1
    68a0:	11 24       	eor	r1, r1
    68a2:	2f 92       	push	r2
    68a4:	3f 92       	push	r3
    68a6:	4f 92       	push	r4
    68a8:	5f 92       	push	r5
    68aa:	6f 92       	push	r6
    68ac:	7f 92       	push	r7
    68ae:	8f 92       	push	r8
    68b0:	9f 92       	push	r9
    68b2:	af 92       	push	r10
    68b4:	bf 92       	push	r11
    68b6:	cf 92       	push	r12
    68b8:	df 92       	push	r13
    68ba:	ef 92       	push	r14
    68bc:	ff 92       	push	r15
    68be:	0f 93       	push	r16
    68c0:	1f 93       	push	r17
    68c2:	2f 93       	push	r18
    68c4:	3f 93       	push	r19
    68c6:	4f 93       	push	r20
    68c8:	5f 93       	push	r21
    68ca:	6f 93       	push	r22
    68cc:	7f 93       	push	r23
    68ce:	8f 93       	push	r24
    68d0:	9f 93       	push	r25
    68d2:	af 93       	push	r26
    68d4:	bf 93       	push	r27
    68d6:	cf 93       	push	r28
    68d8:	df 93       	push	r29
    68da:	ef 93       	push	r30
    68dc:	ff 93       	push	r31
    68de:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    68e2:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    68e6:	0d b6       	in	r0, 0x3d	; 61
    68e8:	0d 92       	st	X+, r0
    68ea:	0e b6       	in	r0, 0x3e	; 62
    68ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    68ee:	17 d7       	rcall	.+3630   	; 0x771e <xTaskIncrementTick>
    68f0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    68f2:	0e 94 a8 40 	call	0x8150	; 0x8150 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    68f6:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    68fa:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    68fe:	cd 91       	ld	r28, X+
    6900:	cd bf       	out	0x3d, r28	; 61
    6902:	dd 91       	ld	r29, X+
    6904:	de bf       	out	0x3e, r29	; 62
    6906:	ff 91       	pop	r31
    6908:	ef 91       	pop	r30
    690a:	df 91       	pop	r29
    690c:	cf 91       	pop	r28
    690e:	bf 91       	pop	r27
    6910:	af 91       	pop	r26
    6912:	9f 91       	pop	r25
    6914:	8f 91       	pop	r24
    6916:	7f 91       	pop	r23
    6918:	6f 91       	pop	r22
    691a:	5f 91       	pop	r21
    691c:	4f 91       	pop	r20
    691e:	3f 91       	pop	r19
    6920:	2f 91       	pop	r18
    6922:	1f 91       	pop	r17
    6924:	0f 91       	pop	r16
    6926:	ff 90       	pop	r15
    6928:	ef 90       	pop	r14
    692a:	df 90       	pop	r13
    692c:	cf 90       	pop	r12
    692e:	bf 90       	pop	r11
    6930:	af 90       	pop	r10
    6932:	9f 90       	pop	r9
    6934:	8f 90       	pop	r8
    6936:	7f 90       	pop	r7
    6938:	6f 90       	pop	r6
    693a:	5f 90       	pop	r5
    693c:	4f 90       	pop	r4
    693e:	3f 90       	pop	r3
    6940:	2f 90       	pop	r2
    6942:	1f 90       	pop	r1
    6944:	0f 90       	pop	r0
    6946:	0c be       	out	0x3c, r0	; 60
    6948:	0f 90       	pop	r0
    694a:	0b be       	out	0x3b, r0	; 59
    694c:	0f 90       	pop	r0
    694e:	0f be       	out	0x3f, r0	; 63
    6950:	0f 90       	pop	r0

	asm volatile ( "ret" );
    6952:	08 95       	ret

00006954 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    6954:	9c df       	rcall	.-200    	; 0x688e <vPortYieldFromTick>
		asm volatile ( "reti" );
    6956:	18 95       	reti

00006958 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6958:	0f b6       	in	r0, 0x3f	; 63
    695a:	f8 94       	cli
    695c:	0f 92       	push	r0
    695e:	fc 01       	movw	r30, r24
    6960:	92 8d       	ldd	r25, Z+26	; 0x1a
    6962:	0f 90       	pop	r0
    6964:	0f be       	out	0x3f, r0	; 63
    6966:	81 e0       	ldi	r24, 0x01	; 1
    6968:	91 11       	cpse	r25, r1
    696a:	80 e0       	ldi	r24, 0x00	; 0
    696c:	08 95       	ret

0000696e <prvCopyDataToQueue>:
    696e:	0f 93       	push	r16
    6970:	1f 93       	push	r17
    6972:	cf 93       	push	r28
    6974:	df 93       	push	r29
    6976:	ec 01       	movw	r28, r24
    6978:	04 2f       	mov	r16, r20
    697a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    697c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    697e:	41 11       	cpse	r20, r1
    6980:	0c c0       	rjmp	.+24     	; 0x699a <prvCopyDataToQueue+0x2c>
    6982:	88 81       	ld	r24, Y
    6984:	99 81       	ldd	r25, Y+1	; 0x01
    6986:	89 2b       	or	r24, r25
    6988:	09 f0       	breq	.+2      	; 0x698c <prvCopyDataToQueue+0x1e>
    698a:	42 c0       	rjmp	.+132    	; 0x6a10 <prvCopyDataToQueue+0xa2>
    698c:	8c 81       	ldd	r24, Y+4	; 0x04
    698e:	9d 81       	ldd	r25, Y+5	; 0x05
    6990:	0e 94 3e 3f 	call	0x7e7c	; 0x7e7c <xTaskPriorityDisinherit>
    6994:	1d 82       	std	Y+5, r1	; 0x05
    6996:	1c 82       	std	Y+4, r1	; 0x04
    6998:	42 c0       	rjmp	.+132    	; 0x6a1e <prvCopyDataToQueue+0xb0>
    699a:	01 11       	cpse	r16, r1
    699c:	17 c0       	rjmp	.+46     	; 0x69cc <prvCopyDataToQueue+0x5e>
    699e:	50 e0       	ldi	r21, 0x00	; 0
    69a0:	8a 81       	ldd	r24, Y+2	; 0x02
    69a2:	9b 81       	ldd	r25, Y+3	; 0x03
    69a4:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>
    69a8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    69aa:	8a 81       	ldd	r24, Y+2	; 0x02
    69ac:	9b 81       	ldd	r25, Y+3	; 0x03
    69ae:	82 0f       	add	r24, r18
    69b0:	91 1d       	adc	r25, r1
    69b2:	9b 83       	std	Y+3, r25	; 0x03
    69b4:	8a 83       	std	Y+2, r24	; 0x02
    69b6:	2c 81       	ldd	r18, Y+4	; 0x04
    69b8:	3d 81       	ldd	r19, Y+5	; 0x05
    69ba:	82 17       	cp	r24, r18
    69bc:	93 07       	cpc	r25, r19
    69be:	50 f1       	brcs	.+84     	; 0x6a14 <prvCopyDataToQueue+0xa6>
    69c0:	88 81       	ld	r24, Y
    69c2:	99 81       	ldd	r25, Y+1	; 0x01
    69c4:	9b 83       	std	Y+3, r25	; 0x03
    69c6:	8a 83       	std	Y+2, r24	; 0x02
    69c8:	80 e0       	ldi	r24, 0x00	; 0
    69ca:	29 c0       	rjmp	.+82     	; 0x6a1e <prvCopyDataToQueue+0xb0>
    69cc:	50 e0       	ldi	r21, 0x00	; 0
    69ce:	8e 81       	ldd	r24, Y+6	; 0x06
    69d0:	9f 81       	ldd	r25, Y+7	; 0x07
    69d2:	0e 94 8e 45 	call	0x8b1c	; 0x8b1c <memcpy>
    69d6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    69d8:	90 e0       	ldi	r25, 0x00	; 0
    69da:	91 95       	neg	r25
    69dc:	81 95       	neg	r24
    69de:	91 09       	sbc	r25, r1
    69e0:	2e 81       	ldd	r18, Y+6	; 0x06
    69e2:	3f 81       	ldd	r19, Y+7	; 0x07
    69e4:	28 0f       	add	r18, r24
    69e6:	39 1f       	adc	r19, r25
    69e8:	3f 83       	std	Y+7, r19	; 0x07
    69ea:	2e 83       	std	Y+6, r18	; 0x06
    69ec:	48 81       	ld	r20, Y
    69ee:	59 81       	ldd	r21, Y+1	; 0x01
    69f0:	24 17       	cp	r18, r20
    69f2:	35 07       	cpc	r19, r21
    69f4:	30 f4       	brcc	.+12     	; 0x6a02 <prvCopyDataToQueue+0x94>
    69f6:	2c 81       	ldd	r18, Y+4	; 0x04
    69f8:	3d 81       	ldd	r19, Y+5	; 0x05
    69fa:	82 0f       	add	r24, r18
    69fc:	93 1f       	adc	r25, r19
    69fe:	9f 83       	std	Y+7, r25	; 0x07
    6a00:	8e 83       	std	Y+6, r24	; 0x06
    6a02:	02 30       	cpi	r16, 0x02	; 2
    6a04:	49 f4       	brne	.+18     	; 0x6a18 <prvCopyDataToQueue+0xaa>
    6a06:	11 23       	and	r17, r17
    6a08:	49 f0       	breq	.+18     	; 0x6a1c <prvCopyDataToQueue+0xae>
    6a0a:	11 50       	subi	r17, 0x01	; 1
    6a0c:	80 e0       	ldi	r24, 0x00	; 0
    6a0e:	07 c0       	rjmp	.+14     	; 0x6a1e <prvCopyDataToQueue+0xb0>
    6a10:	80 e0       	ldi	r24, 0x00	; 0
    6a12:	05 c0       	rjmp	.+10     	; 0x6a1e <prvCopyDataToQueue+0xb0>
    6a14:	80 e0       	ldi	r24, 0x00	; 0
    6a16:	03 c0       	rjmp	.+6      	; 0x6a1e <prvCopyDataToQueue+0xb0>
    6a18:	80 e0       	ldi	r24, 0x00	; 0
    6a1a:	01 c0       	rjmp	.+2      	; 0x6a1e <prvCopyDataToQueue+0xb0>
    6a1c:	80 e0       	ldi	r24, 0x00	; 0
    6a1e:	1f 5f       	subi	r17, 0xFF	; 255
    6a20:	1a 8f       	std	Y+26, r17	; 0x1a
    6a22:	df 91       	pop	r29
    6a24:	cf 91       	pop	r28
    6a26:	1f 91       	pop	r17
    6a28:	0f 91       	pop	r16
    6a2a:	08 95       	ret

00006a2c <prvCopyDataFromQueue>:
    6a2c:	fc 01       	movw	r30, r24
    6a2e:	44 8d       	ldd	r20, Z+28	; 0x1c
    6a30:	44 23       	and	r20, r20
    6a32:	a9 f0       	breq	.+42     	; 0x6a5e <prvCopyDataFromQueue+0x32>
    6a34:	50 e0       	ldi	r21, 0x00	; 0
    6a36:	26 81       	ldd	r18, Z+6	; 0x06
    6a38:	37 81       	ldd	r19, Z+7	; 0x07
    6a3a:	24 0f       	add	r18, r20
    6a3c:	35 1f       	adc	r19, r21
    6a3e:	37 83       	std	Z+7, r19	; 0x07
    6a40:	26 83       	std	Z+6, r18	; 0x06
    6a42:	84 81       	ldd	r24, Z+4	; 0x04
    6a44:	95 81       	ldd	r25, Z+5	; 0x05
    6a46:	28 17       	cp	r18, r24
    6a48:	39 07       	cpc	r19, r25
    6a4a:	20 f0       	brcs	.+8      	; 0x6a54 <prvCopyDataFromQueue+0x28>
    6a4c:	80 81       	ld	r24, Z
    6a4e:	91 81       	ldd	r25, Z+1	; 0x01
    6a50:	97 83       	std	Z+7, r25	; 0x07
    6a52:	86 83       	std	Z+6, r24	; 0x06
    6a54:	cb 01       	movw	r24, r22
    6a56:	66 81       	ldd	r22, Z+6	; 0x06
    6a58:	77 81       	ldd	r23, Z+7	; 0x07
    6a5a:	0c 94 8e 45 	jmp	0x8b1c	; 0x8b1c <memcpy>
    6a5e:	08 95       	ret

00006a60 <prvUnlockQueue>:
    6a60:	ef 92       	push	r14
    6a62:	ff 92       	push	r15
    6a64:	0f 93       	push	r16
    6a66:	1f 93       	push	r17
    6a68:	cf 93       	push	r28
    6a6a:	8c 01       	movw	r16, r24
    6a6c:	0f b6       	in	r0, 0x3f	; 63
    6a6e:	f8 94       	cli
    6a70:	0f 92       	push	r0
    6a72:	fc 01       	movw	r30, r24
    6a74:	c6 8d       	ldd	r28, Z+30	; 0x1e
    6a76:	1c 16       	cp	r1, r28
    6a78:	a4 f4       	brge	.+40     	; 0x6aa2 <prvUnlockQueue+0x42>
    6a7a:	81 89       	ldd	r24, Z+17	; 0x11
    6a7c:	81 11       	cpse	r24, r1
    6a7e:	06 c0       	rjmp	.+12     	; 0x6a8c <prvUnlockQueue+0x2c>
    6a80:	10 c0       	rjmp	.+32     	; 0x6aa2 <prvUnlockQueue+0x42>
    6a82:	f8 01       	movw	r30, r16
    6a84:	81 89       	ldd	r24, Z+17	; 0x11
    6a86:	81 11       	cpse	r24, r1
    6a88:	05 c0       	rjmp	.+10     	; 0x6a94 <prvUnlockQueue+0x34>
    6a8a:	0b c0       	rjmp	.+22     	; 0x6aa2 <prvUnlockQueue+0x42>
    6a8c:	78 01       	movw	r14, r16
    6a8e:	f1 e1       	ldi	r31, 0x11	; 17
    6a90:	ef 0e       	add	r14, r31
    6a92:	f1 1c       	adc	r15, r1
    6a94:	c7 01       	movw	r24, r14
    6a96:	9c d7       	rcall	.+3896   	; 0x79d0 <xTaskRemoveFromEventList>
    6a98:	81 11       	cpse	r24, r1
    6a9a:	0e 94 70 3d 	call	0x7ae0	; 0x7ae0 <vTaskMissedYield>
    6a9e:	c1 50       	subi	r28, 0x01	; 1
    6aa0:	81 f7       	brne	.-32     	; 0x6a82 <prvUnlockQueue+0x22>
    6aa2:	8f ef       	ldi	r24, 0xFF	; 255
    6aa4:	f8 01       	movw	r30, r16
    6aa6:	86 8f       	std	Z+30, r24	; 0x1e
    6aa8:	0f 90       	pop	r0
    6aaa:	0f be       	out	0x3f, r0	; 63
    6aac:	0f b6       	in	r0, 0x3f	; 63
    6aae:	f8 94       	cli
    6ab0:	0f 92       	push	r0
    6ab2:	c5 8d       	ldd	r28, Z+29	; 0x1d
    6ab4:	1c 16       	cp	r1, r28
    6ab6:	a4 f4       	brge	.+40     	; 0x6ae0 <prvUnlockQueue+0x80>
    6ab8:	80 85       	ldd	r24, Z+8	; 0x08
    6aba:	81 11       	cpse	r24, r1
    6abc:	06 c0       	rjmp	.+12     	; 0x6aca <prvUnlockQueue+0x6a>
    6abe:	10 c0       	rjmp	.+32     	; 0x6ae0 <prvUnlockQueue+0x80>
    6ac0:	f8 01       	movw	r30, r16
    6ac2:	80 85       	ldd	r24, Z+8	; 0x08
    6ac4:	81 11       	cpse	r24, r1
    6ac6:	05 c0       	rjmp	.+10     	; 0x6ad2 <prvUnlockQueue+0x72>
    6ac8:	0b c0       	rjmp	.+22     	; 0x6ae0 <prvUnlockQueue+0x80>
    6aca:	78 01       	movw	r14, r16
    6acc:	f8 e0       	ldi	r31, 0x08	; 8
    6ace:	ef 0e       	add	r14, r31
    6ad0:	f1 1c       	adc	r15, r1
    6ad2:	c7 01       	movw	r24, r14
    6ad4:	7d d7       	rcall	.+3834   	; 0x79d0 <xTaskRemoveFromEventList>
    6ad6:	81 11       	cpse	r24, r1
    6ad8:	0e 94 70 3d 	call	0x7ae0	; 0x7ae0 <vTaskMissedYield>
    6adc:	c1 50       	subi	r28, 0x01	; 1
    6ade:	81 f7       	brne	.-32     	; 0x6ac0 <prvUnlockQueue+0x60>
    6ae0:	8f ef       	ldi	r24, 0xFF	; 255
    6ae2:	f8 01       	movw	r30, r16
    6ae4:	85 8f       	std	Z+29, r24	; 0x1d
    6ae6:	0f 90       	pop	r0
    6ae8:	0f be       	out	0x3f, r0	; 63
    6aea:	cf 91       	pop	r28
    6aec:	1f 91       	pop	r17
    6aee:	0f 91       	pop	r16
    6af0:	ff 90       	pop	r15
    6af2:	ef 90       	pop	r14
    6af4:	08 95       	ret

00006af6 <xQueueGenericReset>:
    6af6:	cf 93       	push	r28
    6af8:	df 93       	push	r29
    6afa:	ec 01       	movw	r28, r24
    6afc:	0f b6       	in	r0, 0x3f	; 63
    6afe:	f8 94       	cli
    6b00:	0f 92       	push	r0
    6b02:	e8 81       	ld	r30, Y
    6b04:	f9 81       	ldd	r31, Y+1	; 0x01
    6b06:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6b08:	2c 8d       	ldd	r18, Y+28	; 0x1c
    6b0a:	90 e0       	ldi	r25, 0x00	; 0
    6b0c:	30 e0       	ldi	r19, 0x00	; 0
    6b0e:	82 9f       	mul	r24, r18
    6b10:	a0 01       	movw	r20, r0
    6b12:	83 9f       	mul	r24, r19
    6b14:	50 0d       	add	r21, r0
    6b16:	92 9f       	mul	r25, r18
    6b18:	50 0d       	add	r21, r0
    6b1a:	11 24       	eor	r1, r1
    6b1c:	4e 0f       	add	r20, r30
    6b1e:	5f 1f       	adc	r21, r31
    6b20:	5d 83       	std	Y+5, r21	; 0x05
    6b22:	4c 83       	std	Y+4, r20	; 0x04
    6b24:	1a 8e       	std	Y+26, r1	; 0x1a
    6b26:	fb 83       	std	Y+3, r31	; 0x03
    6b28:	ea 83       	std	Y+2, r30	; 0x02
    6b2a:	01 97       	sbiw	r24, 0x01	; 1
    6b2c:	82 9f       	mul	r24, r18
    6b2e:	a0 01       	movw	r20, r0
    6b30:	83 9f       	mul	r24, r19
    6b32:	50 0d       	add	r21, r0
    6b34:	92 9f       	mul	r25, r18
    6b36:	50 0d       	add	r21, r0
    6b38:	11 24       	eor	r1, r1
    6b3a:	cf 01       	movw	r24, r30
    6b3c:	84 0f       	add	r24, r20
    6b3e:	95 1f       	adc	r25, r21
    6b40:	9f 83       	std	Y+7, r25	; 0x07
    6b42:	8e 83       	std	Y+6, r24	; 0x06
    6b44:	8f ef       	ldi	r24, 0xFF	; 255
    6b46:	8d 8f       	std	Y+29, r24	; 0x1d
    6b48:	8e 8f       	std	Y+30, r24	; 0x1e
    6b4a:	61 11       	cpse	r22, r1
    6b4c:	0a c0       	rjmp	.+20     	; 0x6b62 <xQueueGenericReset+0x6c>
    6b4e:	88 85       	ldd	r24, Y+8	; 0x08
    6b50:	88 23       	and	r24, r24
    6b52:	69 f0       	breq	.+26     	; 0x6b6e <xQueueGenericReset+0x78>
    6b54:	ce 01       	movw	r24, r28
    6b56:	08 96       	adiw	r24, 0x08	; 8
    6b58:	3b d7       	rcall	.+3702   	; 0x79d0 <xTaskRemoveFromEventList>
    6b5a:	88 23       	and	r24, r24
    6b5c:	41 f0       	breq	.+16     	; 0x6b6e <xQueueGenericReset+0x78>
    6b5e:	36 de       	rcall	.-916    	; 0x67cc <vPortYield>
    6b60:	06 c0       	rjmp	.+12     	; 0x6b6e <xQueueGenericReset+0x78>
    6b62:	ce 01       	movw	r24, r28
    6b64:	08 96       	adiw	r24, 0x08	; 8
    6b66:	f6 dc       	rcall	.-1556   	; 0x6554 <vListInitialise>
    6b68:	ce 01       	movw	r24, r28
    6b6a:	41 96       	adiw	r24, 0x11	; 17
    6b6c:	f3 dc       	rcall	.-1562   	; 0x6554 <vListInitialise>
    6b6e:	0f 90       	pop	r0
    6b70:	0f be       	out	0x3f, r0	; 63
    6b72:	81 e0       	ldi	r24, 0x01	; 1
    6b74:	df 91       	pop	r29
    6b76:	cf 91       	pop	r28
    6b78:	08 95       	ret

00006b7a <xQueueGenericCreate>:
    6b7a:	ff 92       	push	r15
    6b7c:	0f 93       	push	r16
    6b7e:	1f 93       	push	r17
    6b80:	cf 93       	push	r28
    6b82:	df 93       	push	r29
    6b84:	08 2f       	mov	r16, r24
    6b86:	16 2f       	mov	r17, r22
    6b88:	f4 2e       	mov	r15, r20
    6b8a:	66 23       	and	r22, r22
    6b8c:	b9 f0       	breq	.+46     	; 0x6bbc <xQueueGenericCreate+0x42>
    6b8e:	86 9f       	mul	r24, r22
    6b90:	c0 01       	movw	r24, r0
    6b92:	11 24       	eor	r1, r1
    6b94:	81 96       	adiw	r24, 0x21	; 33
    6b96:	29 dc       	rcall	.-1966   	; 0x63ea <pvPortMalloc>
    6b98:	ec 01       	movw	r28, r24
    6b9a:	00 97       	sbiw	r24, 0x00	; 0
    6b9c:	41 f4       	brne	.+16     	; 0x6bae <xQueueGenericCreate+0x34>
    6b9e:	14 c0       	rjmp	.+40     	; 0x6bc8 <xQueueGenericCreate+0x4e>
    6ba0:	0b 8f       	std	Y+27, r16	; 0x1b
    6ba2:	1c 8f       	std	Y+28, r17	; 0x1c
    6ba4:	61 e0       	ldi	r22, 0x01	; 1
    6ba6:	ce 01       	movw	r24, r28
    6ba8:	a6 df       	rcall	.-180    	; 0x6af6 <xQueueGenericReset>
    6baa:	f8 a2       	std	Y+32, r15	; 0x20
    6bac:	0d c0       	rjmp	.+26     	; 0x6bc8 <xQueueGenericCreate+0x4e>
    6bae:	81 96       	adiw	r24, 0x21	; 33
    6bb0:	99 83       	std	Y+1, r25	; 0x01
    6bb2:	88 83       	st	Y, r24
    6bb4:	f5 cf       	rjmp	.-22     	; 0x6ba0 <xQueueGenericCreate+0x26>
    6bb6:	d9 83       	std	Y+1, r29	; 0x01
    6bb8:	c8 83       	st	Y, r28
    6bba:	f2 cf       	rjmp	.-28     	; 0x6ba0 <xQueueGenericCreate+0x26>
    6bbc:	81 e2       	ldi	r24, 0x21	; 33
    6bbe:	90 e0       	ldi	r25, 0x00	; 0
    6bc0:	14 dc       	rcall	.-2008   	; 0x63ea <pvPortMalloc>
    6bc2:	ec 01       	movw	r28, r24
    6bc4:	89 2b       	or	r24, r25
    6bc6:	b9 f7       	brne	.-18     	; 0x6bb6 <xQueueGenericCreate+0x3c>
    6bc8:	ce 01       	movw	r24, r28
    6bca:	df 91       	pop	r29
    6bcc:	cf 91       	pop	r28
    6bce:	1f 91       	pop	r17
    6bd0:	0f 91       	pop	r16
    6bd2:	ff 90       	pop	r15
    6bd4:	08 95       	ret

00006bd6 <xQueueGenericSend>:
    6bd6:	9f 92       	push	r9
    6bd8:	af 92       	push	r10
    6bda:	bf 92       	push	r11
    6bdc:	cf 92       	push	r12
    6bde:	df 92       	push	r13
    6be0:	ef 92       	push	r14
    6be2:	ff 92       	push	r15
    6be4:	0f 93       	push	r16
    6be6:	1f 93       	push	r17
    6be8:	cf 93       	push	r28
    6bea:	df 93       	push	r29
    6bec:	00 d0       	rcall	.+0      	; 0x6bee <xQueueGenericSend+0x18>
    6bee:	1f 92       	push	r1
    6bf0:	1f 92       	push	r1
    6bf2:	cd b7       	in	r28, 0x3d	; 61
    6bf4:	de b7       	in	r29, 0x3e	; 62
    6bf6:	8c 01       	movw	r16, r24
    6bf8:	6b 01       	movw	r12, r22
    6bfa:	5d 83       	std	Y+5, r21	; 0x05
    6bfc:	4c 83       	std	Y+4, r20	; 0x04
    6bfe:	a2 2e       	mov	r10, r18
    6c00:	b1 2c       	mov	r11, r1
    6c02:	99 24       	eor	r9, r9
    6c04:	93 94       	inc	r9
    6c06:	7c 01       	movw	r14, r24
    6c08:	88 e0       	ldi	r24, 0x08	; 8
    6c0a:	e8 0e       	add	r14, r24
    6c0c:	f1 1c       	adc	r15, r1
    6c0e:	0f b6       	in	r0, 0x3f	; 63
    6c10:	f8 94       	cli
    6c12:	0f 92       	push	r0
    6c14:	f8 01       	movw	r30, r16
    6c16:	92 8d       	ldd	r25, Z+26	; 0x1a
    6c18:	83 8d       	ldd	r24, Z+27	; 0x1b
    6c1a:	98 17       	cp	r25, r24
    6c1c:	18 f0       	brcs	.+6      	; 0x6c24 <xQueueGenericSend+0x4e>
    6c1e:	f2 e0       	ldi	r31, 0x02	; 2
    6c20:	af 12       	cpse	r10, r31
    6c22:	15 c0       	rjmp	.+42     	; 0x6c4e <xQueueGenericSend+0x78>
    6c24:	4a 2d       	mov	r20, r10
    6c26:	b6 01       	movw	r22, r12
    6c28:	c8 01       	movw	r24, r16
    6c2a:	a1 de       	rcall	.-702    	; 0x696e <prvCopyDataToQueue>
    6c2c:	f8 01       	movw	r30, r16
    6c2e:	91 89       	ldd	r25, Z+17	; 0x11
    6c30:	99 23       	and	r25, r25
    6c32:	39 f0       	breq	.+14     	; 0x6c42 <xQueueGenericSend+0x6c>
    6c34:	c8 01       	movw	r24, r16
    6c36:	41 96       	adiw	r24, 0x11	; 17
    6c38:	cb d6       	rcall	.+3478   	; 0x79d0 <xTaskRemoveFromEventList>
    6c3a:	88 23       	and	r24, r24
    6c3c:	21 f0       	breq	.+8      	; 0x6c46 <xQueueGenericSend+0x70>
    6c3e:	c6 dd       	rcall	.-1140   	; 0x67cc <vPortYield>
    6c40:	02 c0       	rjmp	.+4      	; 0x6c46 <xQueueGenericSend+0x70>
    6c42:	81 11       	cpse	r24, r1
    6c44:	c3 dd       	rcall	.-1146   	; 0x67cc <vPortYield>
    6c46:	0f 90       	pop	r0
    6c48:	0f be       	out	0x3f, r0	; 63
    6c4a:	81 e0       	ldi	r24, 0x01	; 1
    6c4c:	45 c0       	rjmp	.+138    	; 0x6cd8 <xQueueGenericSend+0x102>
    6c4e:	8c 81       	ldd	r24, Y+4	; 0x04
    6c50:	9d 81       	ldd	r25, Y+5	; 0x05
    6c52:	89 2b       	or	r24, r25
    6c54:	21 f4       	brne	.+8      	; 0x6c5e <xQueueGenericSend+0x88>
    6c56:	0f 90       	pop	r0
    6c58:	0f be       	out	0x3f, r0	; 63
    6c5a:	80 e0       	ldi	r24, 0x00	; 0
    6c5c:	3d c0       	rjmp	.+122    	; 0x6cd8 <xQueueGenericSend+0x102>
    6c5e:	b1 10       	cpse	r11, r1
    6c60:	04 c0       	rjmp	.+8      	; 0x6c6a <xQueueGenericSend+0x94>
    6c62:	ce 01       	movw	r24, r28
    6c64:	01 96       	adiw	r24, 0x01	; 1
    6c66:	fc d6       	rcall	.+3576   	; 0x7a60 <vTaskInternalSetTimeOutState>
    6c68:	b9 2c       	mov	r11, r9
    6c6a:	0f 90       	pop	r0
    6c6c:	0f be       	out	0x3f, r0	; 63
    6c6e:	3c d5       	rcall	.+2680   	; 0x76e8 <vTaskSuspendAll>
    6c70:	0f b6       	in	r0, 0x3f	; 63
    6c72:	f8 94       	cli
    6c74:	0f 92       	push	r0
    6c76:	f8 01       	movw	r30, r16
    6c78:	85 8d       	ldd	r24, Z+29	; 0x1d
    6c7a:	8f 3f       	cpi	r24, 0xFF	; 255
    6c7c:	09 f4       	brne	.+2      	; 0x6c80 <xQueueGenericSend+0xaa>
    6c7e:	15 8e       	std	Z+29, r1	; 0x1d
    6c80:	f8 01       	movw	r30, r16
    6c82:	86 8d       	ldd	r24, Z+30	; 0x1e
    6c84:	8f 3f       	cpi	r24, 0xFF	; 255
    6c86:	09 f4       	brne	.+2      	; 0x6c8a <xQueueGenericSend+0xb4>
    6c88:	16 8e       	std	Z+30, r1	; 0x1e
    6c8a:	0f 90       	pop	r0
    6c8c:	0f be       	out	0x3f, r0	; 63
    6c8e:	be 01       	movw	r22, r28
    6c90:	6c 5f       	subi	r22, 0xFC	; 252
    6c92:	7f 4f       	sbci	r23, 0xFF	; 255
    6c94:	ce 01       	movw	r24, r28
    6c96:	01 96       	adiw	r24, 0x01	; 1
    6c98:	ee d6       	rcall	.+3548   	; 0x7a76 <xTaskCheckForTimeOut>
    6c9a:	81 11       	cpse	r24, r1
    6c9c:	19 c0       	rjmp	.+50     	; 0x6cd0 <xQueueGenericSend+0xfa>
    6c9e:	0f b6       	in	r0, 0x3f	; 63
    6ca0:	f8 94       	cli
    6ca2:	0f 92       	push	r0
    6ca4:	f8 01       	movw	r30, r16
    6ca6:	92 8d       	ldd	r25, Z+26	; 0x1a
    6ca8:	0f 90       	pop	r0
    6caa:	0f be       	out	0x3f, r0	; 63
    6cac:	83 8d       	ldd	r24, Z+27	; 0x1b
    6cae:	98 13       	cpse	r25, r24
    6cb0:	0b c0       	rjmp	.+22     	; 0x6cc8 <xQueueGenericSend+0xf2>
    6cb2:	6c 81       	ldd	r22, Y+4	; 0x04
    6cb4:	7d 81       	ldd	r23, Y+5	; 0x05
    6cb6:	c7 01       	movw	r24, r14
    6cb8:	62 d6       	rcall	.+3268   	; 0x797e <vTaskPlaceOnEventList>
    6cba:	c8 01       	movw	r24, r16
    6cbc:	d1 de       	rcall	.-606    	; 0x6a60 <prvUnlockQueue>
    6cbe:	d1 d5       	rcall	.+2978   	; 0x7862 <xTaskResumeAll>
    6cc0:	81 11       	cpse	r24, r1
    6cc2:	a5 cf       	rjmp	.-182    	; 0x6c0e <xQueueGenericSend+0x38>
    6cc4:	83 dd       	rcall	.-1274   	; 0x67cc <vPortYield>
    6cc6:	a3 cf       	rjmp	.-186    	; 0x6c0e <xQueueGenericSend+0x38>
    6cc8:	c8 01       	movw	r24, r16
    6cca:	ca de       	rcall	.-620    	; 0x6a60 <prvUnlockQueue>
    6ccc:	ca d5       	rcall	.+2964   	; 0x7862 <xTaskResumeAll>
    6cce:	9f cf       	rjmp	.-194    	; 0x6c0e <xQueueGenericSend+0x38>
    6cd0:	c8 01       	movw	r24, r16
    6cd2:	c6 de       	rcall	.-628    	; 0x6a60 <prvUnlockQueue>
    6cd4:	c6 d5       	rcall	.+2956   	; 0x7862 <xTaskResumeAll>
    6cd6:	80 e0       	ldi	r24, 0x00	; 0
    6cd8:	0f 90       	pop	r0
    6cda:	0f 90       	pop	r0
    6cdc:	0f 90       	pop	r0
    6cde:	0f 90       	pop	r0
    6ce0:	0f 90       	pop	r0
    6ce2:	df 91       	pop	r29
    6ce4:	cf 91       	pop	r28
    6ce6:	1f 91       	pop	r17
    6ce8:	0f 91       	pop	r16
    6cea:	ff 90       	pop	r15
    6cec:	ef 90       	pop	r14
    6cee:	df 90       	pop	r13
    6cf0:	cf 90       	pop	r12
    6cf2:	bf 90       	pop	r11
    6cf4:	af 90       	pop	r10
    6cf6:	9f 90       	pop	r9
    6cf8:	08 95       	ret

00006cfa <xQueueCreateMutex>:
    6cfa:	cf 93       	push	r28
    6cfc:	df 93       	push	r29
    6cfe:	48 2f       	mov	r20, r24
    6d00:	60 e0       	ldi	r22, 0x00	; 0
    6d02:	81 e0       	ldi	r24, 0x01	; 1
    6d04:	3a df       	rcall	.-396    	; 0x6b7a <xQueueGenericCreate>
    6d06:	ec 01       	movw	r28, r24
    6d08:	00 97       	sbiw	r24, 0x00	; 0
    6d0a:	59 f0       	breq	.+22     	; 0x6d22 <xQueueCreateMutex+0x28>
    6d0c:	1d 82       	std	Y+5, r1	; 0x05
    6d0e:	1c 82       	std	Y+4, r1	; 0x04
    6d10:	19 82       	std	Y+1, r1	; 0x01
    6d12:	18 82       	st	Y, r1
    6d14:	1e 82       	std	Y+6, r1	; 0x06
    6d16:	20 e0       	ldi	r18, 0x00	; 0
    6d18:	40 e0       	ldi	r20, 0x00	; 0
    6d1a:	50 e0       	ldi	r21, 0x00	; 0
    6d1c:	60 e0       	ldi	r22, 0x00	; 0
    6d1e:	70 e0       	ldi	r23, 0x00	; 0
    6d20:	5a df       	rcall	.-332    	; 0x6bd6 <xQueueGenericSend>
    6d22:	ce 01       	movw	r24, r28
    6d24:	df 91       	pop	r29
    6d26:	cf 91       	pop	r28
    6d28:	08 95       	ret

00006d2a <xQueueGenericSendFromISR>:
    6d2a:	ef 92       	push	r14
    6d2c:	ff 92       	push	r15
    6d2e:	0f 93       	push	r16
    6d30:	1f 93       	push	r17
    6d32:	cf 93       	push	r28
    6d34:	df 93       	push	r29
    6d36:	8a 01       	movw	r16, r20
    6d38:	fc 01       	movw	r30, r24
    6d3a:	52 8d       	ldd	r21, Z+26	; 0x1a
    6d3c:	33 8d       	ldd	r19, Z+27	; 0x1b
    6d3e:	53 17       	cp	r21, r19
    6d40:	10 f0       	brcs	.+4      	; 0x6d46 <xQueueGenericSendFromISR+0x1c>
    6d42:	22 30       	cpi	r18, 0x02	; 2
    6d44:	e1 f4       	brne	.+56     	; 0x6d7e <xQueueGenericSendFromISR+0x54>
    6d46:	42 2f       	mov	r20, r18
    6d48:	78 01       	movw	r14, r16
    6d4a:	ec 01       	movw	r28, r24
    6d4c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    6d4e:	0f de       	rcall	.-994    	; 0x696e <prvCopyDataToQueue>
    6d50:	1f 3f       	cpi	r17, 0xFF	; 255
    6d52:	79 f4       	brne	.+30     	; 0x6d72 <xQueueGenericSendFromISR+0x48>
    6d54:	89 89       	ldd	r24, Y+17	; 0x11
    6d56:	88 23       	and	r24, r24
    6d58:	a1 f0       	breq	.+40     	; 0x6d82 <xQueueGenericSendFromISR+0x58>
    6d5a:	ce 01       	movw	r24, r28
    6d5c:	41 96       	adiw	r24, 0x11	; 17
    6d5e:	38 d6       	rcall	.+3184   	; 0x79d0 <xTaskRemoveFromEventList>
    6d60:	88 23       	and	r24, r24
    6d62:	89 f0       	breq	.+34     	; 0x6d86 <xQueueGenericSendFromISR+0x5c>
    6d64:	e1 14       	cp	r14, r1
    6d66:	f1 04       	cpc	r15, r1
    6d68:	81 f0       	breq	.+32     	; 0x6d8a <xQueueGenericSendFromISR+0x60>
    6d6a:	81 e0       	ldi	r24, 0x01	; 1
    6d6c:	f7 01       	movw	r30, r14
    6d6e:	80 83       	st	Z, r24
    6d70:	0d c0       	rjmp	.+26     	; 0x6d8c <xQueueGenericSendFromISR+0x62>
    6d72:	ff 24       	eor	r15, r15
    6d74:	f3 94       	inc	r15
    6d76:	f1 0e       	add	r15, r17
    6d78:	fe 8e       	std	Y+30, r15	; 0x1e
    6d7a:	81 e0       	ldi	r24, 0x01	; 1
    6d7c:	07 c0       	rjmp	.+14     	; 0x6d8c <xQueueGenericSendFromISR+0x62>
    6d7e:	80 e0       	ldi	r24, 0x00	; 0
    6d80:	05 c0       	rjmp	.+10     	; 0x6d8c <xQueueGenericSendFromISR+0x62>
    6d82:	81 e0       	ldi	r24, 0x01	; 1
    6d84:	03 c0       	rjmp	.+6      	; 0x6d8c <xQueueGenericSendFromISR+0x62>
    6d86:	81 e0       	ldi	r24, 0x01	; 1
    6d88:	01 c0       	rjmp	.+2      	; 0x6d8c <xQueueGenericSendFromISR+0x62>
    6d8a:	81 e0       	ldi	r24, 0x01	; 1
    6d8c:	df 91       	pop	r29
    6d8e:	cf 91       	pop	r28
    6d90:	1f 91       	pop	r17
    6d92:	0f 91       	pop	r16
    6d94:	ff 90       	pop	r15
    6d96:	ef 90       	pop	r14
    6d98:	08 95       	ret

00006d9a <xQueueReceive>:
    6d9a:	9f 92       	push	r9
    6d9c:	af 92       	push	r10
    6d9e:	bf 92       	push	r11
    6da0:	cf 92       	push	r12
    6da2:	df 92       	push	r13
    6da4:	ef 92       	push	r14
    6da6:	ff 92       	push	r15
    6da8:	0f 93       	push	r16
    6daa:	1f 93       	push	r17
    6dac:	cf 93       	push	r28
    6dae:	df 93       	push	r29
    6db0:	00 d0       	rcall	.+0      	; 0x6db2 <xQueueReceive+0x18>
    6db2:	1f 92       	push	r1
    6db4:	1f 92       	push	r1
    6db6:	cd b7       	in	r28, 0x3d	; 61
    6db8:	de b7       	in	r29, 0x3e	; 62
    6dba:	8c 01       	movw	r16, r24
    6dbc:	5b 01       	movw	r10, r22
    6dbe:	5d 83       	std	Y+5, r21	; 0x05
    6dc0:	4c 83       	std	Y+4, r20	; 0x04
    6dc2:	e1 2c       	mov	r14, r1
    6dc4:	99 24       	eor	r9, r9
    6dc6:	93 94       	inc	r9
    6dc8:	6c 01       	movw	r12, r24
    6dca:	81 e1       	ldi	r24, 0x11	; 17
    6dcc:	c8 0e       	add	r12, r24
    6dce:	d1 1c       	adc	r13, r1
    6dd0:	0f b6       	in	r0, 0x3f	; 63
    6dd2:	f8 94       	cli
    6dd4:	0f 92       	push	r0
    6dd6:	f8 01       	movw	r30, r16
    6dd8:	f2 8c       	ldd	r15, Z+26	; 0x1a
    6dda:	ff 20       	and	r15, r15
    6ddc:	91 f0       	breq	.+36     	; 0x6e02 <xQueueReceive+0x68>
    6dde:	b5 01       	movw	r22, r10
    6de0:	c8 01       	movw	r24, r16
    6de2:	24 de       	rcall	.-952    	; 0x6a2c <prvCopyDataFromQueue>
    6de4:	fa 94       	dec	r15
    6de6:	f8 01       	movw	r30, r16
    6de8:	f2 8e       	std	Z+26, r15	; 0x1a
    6dea:	80 85       	ldd	r24, Z+8	; 0x08
    6dec:	88 23       	and	r24, r24
    6dee:	29 f0       	breq	.+10     	; 0x6dfa <xQueueReceive+0x60>
    6df0:	c8 01       	movw	r24, r16
    6df2:	08 96       	adiw	r24, 0x08	; 8
    6df4:	ed d5       	rcall	.+3034   	; 0x79d0 <xTaskRemoveFromEventList>
    6df6:	81 11       	cpse	r24, r1
    6df8:	e9 dc       	rcall	.-1582   	; 0x67cc <vPortYield>
    6dfa:	0f 90       	pop	r0
    6dfc:	0f be       	out	0x3f, r0	; 63
    6dfe:	81 e0       	ldi	r24, 0x01	; 1
    6e00:	44 c0       	rjmp	.+136    	; 0x6e8a <xQueueReceive+0xf0>
    6e02:	8c 81       	ldd	r24, Y+4	; 0x04
    6e04:	9d 81       	ldd	r25, Y+5	; 0x05
    6e06:	89 2b       	or	r24, r25
    6e08:	21 f4       	brne	.+8      	; 0x6e12 <xQueueReceive+0x78>
    6e0a:	0f 90       	pop	r0
    6e0c:	0f be       	out	0x3f, r0	; 63
    6e0e:	80 e0       	ldi	r24, 0x00	; 0
    6e10:	3c c0       	rjmp	.+120    	; 0x6e8a <xQueueReceive+0xf0>
    6e12:	e1 10       	cpse	r14, r1
    6e14:	04 c0       	rjmp	.+8      	; 0x6e1e <xQueueReceive+0x84>
    6e16:	ce 01       	movw	r24, r28
    6e18:	01 96       	adiw	r24, 0x01	; 1
    6e1a:	22 d6       	rcall	.+3140   	; 0x7a60 <vTaskInternalSetTimeOutState>
    6e1c:	e9 2c       	mov	r14, r9
    6e1e:	0f 90       	pop	r0
    6e20:	0f be       	out	0x3f, r0	; 63
    6e22:	62 d4       	rcall	.+2244   	; 0x76e8 <vTaskSuspendAll>
    6e24:	0f b6       	in	r0, 0x3f	; 63
    6e26:	f8 94       	cli
    6e28:	0f 92       	push	r0
    6e2a:	f8 01       	movw	r30, r16
    6e2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    6e2e:	8f 3f       	cpi	r24, 0xFF	; 255
    6e30:	09 f4       	brne	.+2      	; 0x6e34 <xQueueReceive+0x9a>
    6e32:	15 8e       	std	Z+29, r1	; 0x1d
    6e34:	f8 01       	movw	r30, r16
    6e36:	86 8d       	ldd	r24, Z+30	; 0x1e
    6e38:	8f 3f       	cpi	r24, 0xFF	; 255
    6e3a:	09 f4       	brne	.+2      	; 0x6e3e <xQueueReceive+0xa4>
    6e3c:	16 8e       	std	Z+30, r1	; 0x1e
    6e3e:	0f 90       	pop	r0
    6e40:	0f be       	out	0x3f, r0	; 63
    6e42:	be 01       	movw	r22, r28
    6e44:	6c 5f       	subi	r22, 0xFC	; 252
    6e46:	7f 4f       	sbci	r23, 0xFF	; 255
    6e48:	ce 01       	movw	r24, r28
    6e4a:	01 96       	adiw	r24, 0x01	; 1
    6e4c:	14 d6       	rcall	.+3112   	; 0x7a76 <xTaskCheckForTimeOut>
    6e4e:	81 11       	cpse	r24, r1
    6e50:	13 c0       	rjmp	.+38     	; 0x6e78 <xQueueReceive+0xde>
    6e52:	c8 01       	movw	r24, r16
    6e54:	81 dd       	rcall	.-1278   	; 0x6958 <prvIsQueueEmpty>
    6e56:	88 23       	and	r24, r24
    6e58:	59 f0       	breq	.+22     	; 0x6e70 <xQueueReceive+0xd6>
    6e5a:	6c 81       	ldd	r22, Y+4	; 0x04
    6e5c:	7d 81       	ldd	r23, Y+5	; 0x05
    6e5e:	c6 01       	movw	r24, r12
    6e60:	8e d5       	rcall	.+2844   	; 0x797e <vTaskPlaceOnEventList>
    6e62:	c8 01       	movw	r24, r16
    6e64:	fd dd       	rcall	.-1030   	; 0x6a60 <prvUnlockQueue>
    6e66:	fd d4       	rcall	.+2554   	; 0x7862 <xTaskResumeAll>
    6e68:	81 11       	cpse	r24, r1
    6e6a:	b2 cf       	rjmp	.-156    	; 0x6dd0 <xQueueReceive+0x36>
    6e6c:	af dc       	rcall	.-1698   	; 0x67cc <vPortYield>
    6e6e:	b0 cf       	rjmp	.-160    	; 0x6dd0 <xQueueReceive+0x36>
    6e70:	c8 01       	movw	r24, r16
    6e72:	f6 dd       	rcall	.-1044   	; 0x6a60 <prvUnlockQueue>
    6e74:	f6 d4       	rcall	.+2540   	; 0x7862 <xTaskResumeAll>
    6e76:	ac cf       	rjmp	.-168    	; 0x6dd0 <xQueueReceive+0x36>
    6e78:	c8 01       	movw	r24, r16
    6e7a:	f2 dd       	rcall	.-1052   	; 0x6a60 <prvUnlockQueue>
    6e7c:	f2 d4       	rcall	.+2532   	; 0x7862 <xTaskResumeAll>
    6e7e:	c8 01       	movw	r24, r16
    6e80:	6b dd       	rcall	.-1322   	; 0x6958 <prvIsQueueEmpty>
    6e82:	88 23       	and	r24, r24
    6e84:	09 f4       	brne	.+2      	; 0x6e88 <xQueueReceive+0xee>
    6e86:	a4 cf       	rjmp	.-184    	; 0x6dd0 <xQueueReceive+0x36>
    6e88:	80 e0       	ldi	r24, 0x00	; 0
    6e8a:	0f 90       	pop	r0
    6e8c:	0f 90       	pop	r0
    6e8e:	0f 90       	pop	r0
    6e90:	0f 90       	pop	r0
    6e92:	0f 90       	pop	r0
    6e94:	df 91       	pop	r29
    6e96:	cf 91       	pop	r28
    6e98:	1f 91       	pop	r17
    6e9a:	0f 91       	pop	r16
    6e9c:	ff 90       	pop	r15
    6e9e:	ef 90       	pop	r14
    6ea0:	df 90       	pop	r13
    6ea2:	cf 90       	pop	r12
    6ea4:	bf 90       	pop	r11
    6ea6:	af 90       	pop	r10
    6ea8:	9f 90       	pop	r9
    6eaa:	08 95       	ret

00006eac <xQueueSemaphoreTake>:
    6eac:	bf 92       	push	r11
    6eae:	cf 92       	push	r12
    6eb0:	df 92       	push	r13
    6eb2:	ef 92       	push	r14
    6eb4:	ff 92       	push	r15
    6eb6:	0f 93       	push	r16
    6eb8:	1f 93       	push	r17
    6eba:	cf 93       	push	r28
    6ebc:	df 93       	push	r29
    6ebe:	00 d0       	rcall	.+0      	; 0x6ec0 <xQueueSemaphoreTake+0x14>
    6ec0:	1f 92       	push	r1
    6ec2:	1f 92       	push	r1
    6ec4:	cd b7       	in	r28, 0x3d	; 61
    6ec6:	de b7       	in	r29, 0x3e	; 62
    6ec8:	8c 01       	movw	r16, r24
    6eca:	7d 83       	std	Y+5, r23	; 0x05
    6ecc:	6c 83       	std	Y+4, r22	; 0x04
    6ece:	b1 2c       	mov	r11, r1
    6ed0:	d1 2c       	mov	r13, r1
    6ed2:	cc 24       	eor	r12, r12
    6ed4:	c3 94       	inc	r12
    6ed6:	7c 01       	movw	r14, r24
    6ed8:	81 e1       	ldi	r24, 0x11	; 17
    6eda:	e8 0e       	add	r14, r24
    6edc:	f1 1c       	adc	r15, r1
    6ede:	0f b6       	in	r0, 0x3f	; 63
    6ee0:	f8 94       	cli
    6ee2:	0f 92       	push	r0
    6ee4:	d8 01       	movw	r26, r16
    6ee6:	5a 96       	adiw	r26, 0x1a	; 26
    6ee8:	8c 91       	ld	r24, X
    6eea:	5a 97       	sbiw	r26, 0x1a	; 26
    6eec:	88 23       	and	r24, r24
    6eee:	d9 f0       	breq	.+54     	; 0x6f26 <xQueueSemaphoreTake+0x7a>
    6ef0:	81 50       	subi	r24, 0x01	; 1
    6ef2:	5a 96       	adiw	r26, 0x1a	; 26
    6ef4:	8c 93       	st	X, r24
    6ef6:	5a 97       	sbiw	r26, 0x1a	; 26
    6ef8:	8d 91       	ld	r24, X+
    6efa:	9c 91       	ld	r25, X
    6efc:	89 2b       	or	r24, r25
    6efe:	29 f4       	brne	.+10     	; 0x6f0a <xQueueSemaphoreTake+0x5e>
    6f00:	0e 94 86 40 	call	0x810c	; 0x810c <pvTaskIncrementMutexHeldCount>
    6f04:	f8 01       	movw	r30, r16
    6f06:	95 83       	std	Z+5, r25	; 0x05
    6f08:	84 83       	std	Z+4, r24	; 0x04
    6f0a:	d8 01       	movw	r26, r16
    6f0c:	18 96       	adiw	r26, 0x08	; 8
    6f0e:	8c 91       	ld	r24, X
    6f10:	88 23       	and	r24, r24
    6f12:	29 f0       	breq	.+10     	; 0x6f1e <xQueueSemaphoreTake+0x72>
    6f14:	c8 01       	movw	r24, r16
    6f16:	08 96       	adiw	r24, 0x08	; 8
    6f18:	5b d5       	rcall	.+2742   	; 0x79d0 <xTaskRemoveFromEventList>
    6f1a:	81 11       	cpse	r24, r1
    6f1c:	57 dc       	rcall	.-1874   	; 0x67cc <vPortYield>
    6f1e:	0f 90       	pop	r0
    6f20:	0f be       	out	0x3f, r0	; 63
    6f22:	81 e0       	ldi	r24, 0x01	; 1
    6f24:	70 c0       	rjmp	.+224    	; 0x7006 <xQueueSemaphoreTake+0x15a>
    6f26:	8c 81       	ldd	r24, Y+4	; 0x04
    6f28:	9d 81       	ldd	r25, Y+5	; 0x05
    6f2a:	89 2b       	or	r24, r25
    6f2c:	21 f4       	brne	.+8      	; 0x6f36 <xQueueSemaphoreTake+0x8a>
    6f2e:	0f 90       	pop	r0
    6f30:	0f be       	out	0x3f, r0	; 63
    6f32:	80 e0       	ldi	r24, 0x00	; 0
    6f34:	68 c0       	rjmp	.+208    	; 0x7006 <xQueueSemaphoreTake+0x15a>
    6f36:	d1 10       	cpse	r13, r1
    6f38:	04 c0       	rjmp	.+8      	; 0x6f42 <xQueueSemaphoreTake+0x96>
    6f3a:	ce 01       	movw	r24, r28
    6f3c:	01 96       	adiw	r24, 0x01	; 1
    6f3e:	90 d5       	rcall	.+2848   	; 0x7a60 <vTaskInternalSetTimeOutState>
    6f40:	dc 2c       	mov	r13, r12
    6f42:	0f 90       	pop	r0
    6f44:	0f be       	out	0x3f, r0	; 63
    6f46:	d0 d3       	rcall	.+1952   	; 0x76e8 <vTaskSuspendAll>
    6f48:	0f b6       	in	r0, 0x3f	; 63
    6f4a:	f8 94       	cli
    6f4c:	0f 92       	push	r0
    6f4e:	f8 01       	movw	r30, r16
    6f50:	85 8d       	ldd	r24, Z+29	; 0x1d
    6f52:	8f 3f       	cpi	r24, 0xFF	; 255
    6f54:	09 f4       	brne	.+2      	; 0x6f58 <xQueueSemaphoreTake+0xac>
    6f56:	15 8e       	std	Z+29, r1	; 0x1d
    6f58:	d8 01       	movw	r26, r16
    6f5a:	5e 96       	adiw	r26, 0x1e	; 30
    6f5c:	8c 91       	ld	r24, X
    6f5e:	5e 97       	sbiw	r26, 0x1e	; 30
    6f60:	8f 3f       	cpi	r24, 0xFF	; 255
    6f62:	11 f4       	brne	.+4      	; 0x6f68 <xQueueSemaphoreTake+0xbc>
    6f64:	5e 96       	adiw	r26, 0x1e	; 30
    6f66:	1c 92       	st	X, r1
    6f68:	0f 90       	pop	r0
    6f6a:	0f be       	out	0x3f, r0	; 63
    6f6c:	be 01       	movw	r22, r28
    6f6e:	6c 5f       	subi	r22, 0xFC	; 252
    6f70:	7f 4f       	sbci	r23, 0xFF	; 255
    6f72:	ce 01       	movw	r24, r28
    6f74:	01 96       	adiw	r24, 0x01	; 1
    6f76:	7f d5       	rcall	.+2814   	; 0x7a76 <xTaskCheckForTimeOut>
    6f78:	81 11       	cpse	r24, r1
    6f7a:	21 c0       	rjmp	.+66     	; 0x6fbe <xQueueSemaphoreTake+0x112>
    6f7c:	c8 01       	movw	r24, r16
    6f7e:	ec dc       	rcall	.-1576   	; 0x6958 <prvIsQueueEmpty>
    6f80:	88 23       	and	r24, r24
    6f82:	c9 f0       	breq	.+50     	; 0x6fb6 <xQueueSemaphoreTake+0x10a>
    6f84:	f8 01       	movw	r30, r16
    6f86:	80 81       	ld	r24, Z
    6f88:	91 81       	ldd	r25, Z+1	; 0x01
    6f8a:	89 2b       	or	r24, r25
    6f8c:	49 f4       	brne	.+18     	; 0x6fa0 <xQueueSemaphoreTake+0xf4>
    6f8e:	0f b6       	in	r0, 0x3f	; 63
    6f90:	f8 94       	cli
    6f92:	0f 92       	push	r0
    6f94:	84 81       	ldd	r24, Z+4	; 0x04
    6f96:	95 81       	ldd	r25, Z+5	; 0x05
    6f98:	ff d6       	rcall	.+3582   	; 0x7d98 <xTaskPriorityInherit>
    6f9a:	b8 2e       	mov	r11, r24
    6f9c:	0f 90       	pop	r0
    6f9e:	0f be       	out	0x3f, r0	; 63
    6fa0:	6c 81       	ldd	r22, Y+4	; 0x04
    6fa2:	7d 81       	ldd	r23, Y+5	; 0x05
    6fa4:	c7 01       	movw	r24, r14
    6fa6:	eb d4       	rcall	.+2518   	; 0x797e <vTaskPlaceOnEventList>
    6fa8:	c8 01       	movw	r24, r16
    6faa:	5a dd       	rcall	.-1356   	; 0x6a60 <prvUnlockQueue>
    6fac:	5a d4       	rcall	.+2228   	; 0x7862 <xTaskResumeAll>
    6fae:	81 11       	cpse	r24, r1
    6fb0:	96 cf       	rjmp	.-212    	; 0x6ede <xQueueSemaphoreTake+0x32>
    6fb2:	0c dc       	rcall	.-2024   	; 0x67cc <vPortYield>
    6fb4:	94 cf       	rjmp	.-216    	; 0x6ede <xQueueSemaphoreTake+0x32>
    6fb6:	c8 01       	movw	r24, r16
    6fb8:	53 dd       	rcall	.-1370   	; 0x6a60 <prvUnlockQueue>
    6fba:	53 d4       	rcall	.+2214   	; 0x7862 <xTaskResumeAll>
    6fbc:	90 cf       	rjmp	.-224    	; 0x6ede <xQueueSemaphoreTake+0x32>
    6fbe:	c8 01       	movw	r24, r16
    6fc0:	4f dd       	rcall	.-1378   	; 0x6a60 <prvUnlockQueue>
    6fc2:	4f d4       	rcall	.+2206   	; 0x7862 <xTaskResumeAll>
    6fc4:	c8 01       	movw	r24, r16
    6fc6:	c8 dc       	rcall	.-1648   	; 0x6958 <prvIsQueueEmpty>
    6fc8:	88 23       	and	r24, r24
    6fca:	09 f4       	brne	.+2      	; 0x6fce <xQueueSemaphoreTake+0x122>
    6fcc:	88 cf       	rjmp	.-240    	; 0x6ede <xQueueSemaphoreTake+0x32>
    6fce:	bb 20       	and	r11, r11
    6fd0:	c9 f0       	breq	.+50     	; 0x7004 <xQueueSemaphoreTake+0x158>
    6fd2:	0f b6       	in	r0, 0x3f	; 63
    6fd4:	f8 94       	cli
    6fd6:	0f 92       	push	r0
    6fd8:	f8 01       	movw	r30, r16
    6fda:	81 89       	ldd	r24, Z+17	; 0x11
    6fdc:	88 23       	and	r24, r24
    6fde:	39 f0       	breq	.+14     	; 0x6fee <xQueueSemaphoreTake+0x142>
    6fe0:	06 88       	ldd	r0, Z+22	; 0x16
    6fe2:	f7 89       	ldd	r31, Z+23	; 0x17
    6fe4:	e0 2d       	mov	r30, r0
    6fe6:	80 81       	ld	r24, Z
    6fe8:	64 e0       	ldi	r22, 0x04	; 4
    6fea:	68 1b       	sub	r22, r24
    6fec:	01 c0       	rjmp	.+2      	; 0x6ff0 <xQueueSemaphoreTake+0x144>
    6fee:	60 e0       	ldi	r22, 0x00	; 0
    6ff0:	d8 01       	movw	r26, r16
    6ff2:	14 96       	adiw	r26, 0x04	; 4
    6ff4:	8d 91       	ld	r24, X+
    6ff6:	9c 91       	ld	r25, X
    6ff8:	15 97       	sbiw	r26, 0x05	; 5
    6ffa:	80 d7       	rcall	.+3840   	; 0x7efc <vTaskPriorityDisinheritAfterTimeout>
    6ffc:	0f 90       	pop	r0
    6ffe:	0f be       	out	0x3f, r0	; 63
    7000:	80 e0       	ldi	r24, 0x00	; 0
    7002:	01 c0       	rjmp	.+2      	; 0x7006 <xQueueSemaphoreTake+0x15a>
    7004:	80 e0       	ldi	r24, 0x00	; 0
    7006:	0f 90       	pop	r0
    7008:	0f 90       	pop	r0
    700a:	0f 90       	pop	r0
    700c:	0f 90       	pop	r0
    700e:	0f 90       	pop	r0
    7010:	df 91       	pop	r29
    7012:	cf 91       	pop	r28
    7014:	1f 91       	pop	r17
    7016:	0f 91       	pop	r16
    7018:	ff 90       	pop	r15
    701a:	ef 90       	pop	r14
    701c:	df 90       	pop	r13
    701e:	cf 90       	pop	r12
    7020:	bf 90       	pop	r11
    7022:	08 95       	ret

00007024 <xQueueReceiveFromISR>:
    7024:	ef 92       	push	r14
    7026:	ff 92       	push	r15
    7028:	0f 93       	push	r16
    702a:	1f 93       	push	r17
    702c:	cf 93       	push	r28
    702e:	df 93       	push	r29
    7030:	fc 01       	movw	r30, r24
    7032:	c2 8d       	ldd	r28, Z+26	; 0x1a
    7034:	cc 23       	and	r28, r28
    7036:	e9 f0       	breq	.+58     	; 0x7072 <xQueueReceiveFromISR+0x4e>
    7038:	7a 01       	movw	r14, r20
    703a:	8c 01       	movw	r16, r24
    703c:	d5 8d       	ldd	r29, Z+29	; 0x1d
    703e:	f6 dc       	rcall	.-1556   	; 0x6a2c <prvCopyDataFromQueue>
    7040:	c1 50       	subi	r28, 0x01	; 1
    7042:	f8 01       	movw	r30, r16
    7044:	c2 8f       	std	Z+26, r28	; 0x1a
    7046:	df 3f       	cpi	r29, 0xFF	; 255
    7048:	79 f4       	brne	.+30     	; 0x7068 <xQueueReceiveFromISR+0x44>
    704a:	80 85       	ldd	r24, Z+8	; 0x08
    704c:	88 23       	and	r24, r24
    704e:	99 f0       	breq	.+38     	; 0x7076 <xQueueReceiveFromISR+0x52>
    7050:	c8 01       	movw	r24, r16
    7052:	08 96       	adiw	r24, 0x08	; 8
    7054:	bd d4       	rcall	.+2426   	; 0x79d0 <xTaskRemoveFromEventList>
    7056:	88 23       	and	r24, r24
    7058:	81 f0       	breq	.+32     	; 0x707a <xQueueReceiveFromISR+0x56>
    705a:	e1 14       	cp	r14, r1
    705c:	f1 04       	cpc	r15, r1
    705e:	79 f0       	breq	.+30     	; 0x707e <xQueueReceiveFromISR+0x5a>
    7060:	81 e0       	ldi	r24, 0x01	; 1
    7062:	f7 01       	movw	r30, r14
    7064:	80 83       	st	Z, r24
    7066:	0c c0       	rjmp	.+24     	; 0x7080 <xQueueReceiveFromISR+0x5c>
    7068:	df 5f       	subi	r29, 0xFF	; 255
    706a:	f8 01       	movw	r30, r16
    706c:	d5 8f       	std	Z+29, r29	; 0x1d
    706e:	81 e0       	ldi	r24, 0x01	; 1
    7070:	07 c0       	rjmp	.+14     	; 0x7080 <xQueueReceiveFromISR+0x5c>
    7072:	80 e0       	ldi	r24, 0x00	; 0
    7074:	05 c0       	rjmp	.+10     	; 0x7080 <xQueueReceiveFromISR+0x5c>
    7076:	81 e0       	ldi	r24, 0x01	; 1
    7078:	03 c0       	rjmp	.+6      	; 0x7080 <xQueueReceiveFromISR+0x5c>
    707a:	81 e0       	ldi	r24, 0x01	; 1
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <xQueueReceiveFromISR+0x5c>
    707e:	81 e0       	ldi	r24, 0x01	; 1
    7080:	df 91       	pop	r29
    7082:	cf 91       	pop	r28
    7084:	1f 91       	pop	r17
    7086:	0f 91       	pop	r16
    7088:	ff 90       	pop	r15
    708a:	ef 90       	pop	r14
    708c:	08 95       	ret

0000708e <uxQueueMessagesWaiting>:
    708e:	0f b6       	in	r0, 0x3f	; 63
    7090:	f8 94       	cli
    7092:	0f 92       	push	r0
    7094:	fc 01       	movw	r30, r24
    7096:	82 8d       	ldd	r24, Z+26	; 0x1a
    7098:	0f 90       	pop	r0
    709a:	0f be       	out	0x3f, r0	; 63
    709c:	08 95       	ret

0000709e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    709e:	cf 93       	push	r28
    70a0:	df 93       	push	r29
    70a2:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    70a4:	0f b6       	in	r0, 0x3f	; 63
    70a6:	f8 94       	cli
    70a8:	0f 92       	push	r0
    70aa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    70ac:	8f 3f       	cpi	r24, 0xFF	; 255
    70ae:	09 f4       	brne	.+2      	; 0x70b2 <vQueueWaitForMessageRestricted+0x14>
    70b0:	1d 8e       	std	Y+29, r1	; 0x1d
    70b2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    70b4:	8f 3f       	cpi	r24, 0xFF	; 255
    70b6:	09 f4       	brne	.+2      	; 0x70ba <vQueueWaitForMessageRestricted+0x1c>
    70b8:	1e 8e       	std	Y+30, r1	; 0x1e
    70ba:	0f 90       	pop	r0
    70bc:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    70be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    70c0:	81 11       	cpse	r24, r1
    70c2:	03 c0       	rjmp	.+6      	; 0x70ca <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    70c4:	ce 01       	movw	r24, r28
    70c6:	41 96       	adiw	r24, 0x11	; 17
    70c8:	6b d4       	rcall	.+2262   	; 0x79a0 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    70ca:	ce 01       	movw	r24, r28
    70cc:	c9 dc       	rcall	.-1646   	; 0x6a60 <prvUnlockQueue>
	}
    70ce:	df 91       	pop	r29
    70d0:	cf 91       	pop	r28
    70d2:	08 95       	ret

000070d4 <__vector_25>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART0_RX_vect )
{
    70d4:	1f 92       	push	r1
    70d6:	0f 92       	push	r0
    70d8:	0f b6       	in	r0, 0x3f	; 63
    70da:	0f 92       	push	r0
    70dc:	11 24       	eor	r1, r1
    70de:	0b b6       	in	r0, 0x3b	; 59
    70e0:	0f 92       	push	r0
    70e2:	2f 93       	push	r18
    70e4:	3f 93       	push	r19
    70e6:	4f 93       	push	r20
    70e8:	5f 93       	push	r21
    70ea:	6f 93       	push	r22
    70ec:	7f 93       	push	r23
    70ee:	8f 93       	push	r24
    70f0:	9f 93       	push	r25
    70f2:	af 93       	push	r26
    70f4:	bf 93       	push	r27
    70f6:	ef 93       	push	r30
    70f8:	ff 93       	push	r31
    70fa:	cf 93       	push	r28
    70fc:	df 93       	push	r29
    70fe:	1f 92       	push	r1
    7100:	1f 92       	push	r1
    7102:	cd b7       	in	r28, 0x3d	; 61
    7104:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    7106:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    7108:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    710c:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    710e:	20 e0       	ldi	r18, 0x00	; 0
    7110:	ae 01       	movw	r20, r28
    7112:	4e 5f       	subi	r20, 0xFE	; 254
    7114:	5f 4f       	sbci	r21, 0xFF	; 255
    7116:	be 01       	movw	r22, r28
    7118:	6f 5f       	subi	r22, 0xFF	; 255
    711a:	7f 4f       	sbci	r23, 0xFF	; 255
    711c:	80 91 ed 1f 	lds	r24, 0x1FED	; 0x801fed <xRxedChars>
    7120:	90 91 ee 1f 	lds	r25, 0x1FEE	; 0x801fee <xRxedChars+0x1>
    7124:	02 de       	rcall	.-1020   	; 0x6d2a <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    7126:	8a 81       	ldd	r24, Y+2	; 0x02
	{
		taskYIELD();
    7128:	81 11       	cpse	r24, r1
    712a:	50 db       	rcall	.-2400   	; 0x67cc <vPortYield>
	}
}
    712c:	0f 90       	pop	r0
    712e:	0f 90       	pop	r0
    7130:	df 91       	pop	r29
    7132:	cf 91       	pop	r28
    7134:	ff 91       	pop	r31
    7136:	ef 91       	pop	r30
    7138:	bf 91       	pop	r27
    713a:	af 91       	pop	r26
    713c:	9f 91       	pop	r25
    713e:	8f 91       	pop	r24
    7140:	7f 91       	pop	r23
    7142:	6f 91       	pop	r22
    7144:	5f 91       	pop	r21
    7146:	4f 91       	pop	r20
    7148:	3f 91       	pop	r19
    714a:	2f 91       	pop	r18
    714c:	0f 90       	pop	r0
    714e:	0b be       	out	0x3b, r0	; 59
    7150:	0f 90       	pop	r0
    7152:	0f be       	out	0x3f, r0	; 63
    7154:	0f 90       	pop	r0
    7156:	1f 90       	pop	r1
    7158:	18 95       	reti

0000715a <__vector_26>:
/*-----------------------------------------------------------*/

SIGNAL( USART0_UDRE_vect )
{
    715a:	1f 92       	push	r1
    715c:	0f 92       	push	r0
    715e:	0f b6       	in	r0, 0x3f	; 63
    7160:	0f 92       	push	r0
    7162:	11 24       	eor	r1, r1
    7164:	0b b6       	in	r0, 0x3b	; 59
    7166:	0f 92       	push	r0
    7168:	2f 93       	push	r18
    716a:	3f 93       	push	r19
    716c:	4f 93       	push	r20
    716e:	5f 93       	push	r21
    7170:	6f 93       	push	r22
    7172:	7f 93       	push	r23
    7174:	8f 93       	push	r24
    7176:	9f 93       	push	r25
    7178:	af 93       	push	r26
    717a:	bf 93       	push	r27
    717c:	ef 93       	push	r30
    717e:	ff 93       	push	r31
    7180:	cf 93       	push	r28
    7182:	df 93       	push	r29
    7184:	1f 92       	push	r1
    7186:	1f 92       	push	r1
    7188:	cd b7       	in	r28, 0x3d	; 61
    718a:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    718c:	ae 01       	movw	r20, r28
    718e:	4e 5f       	subi	r20, 0xFE	; 254
    7190:	5f 4f       	sbci	r21, 0xFF	; 255
    7192:	be 01       	movw	r22, r28
    7194:	6f 5f       	subi	r22, 0xFF	; 255
    7196:	7f 4f       	sbci	r23, 0xFF	; 255
    7198:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xCharsForTx>
    719c:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <xCharsForTx+0x1>
    71a0:	41 df       	rcall	.-382    	; 0x7024 <xQueueReceiveFromISR>
    71a2:	81 30       	cpi	r24, 0x01	; 1
    71a4:	21 f4       	brne	.+8      	; 0x71ae <__vector_26+0x54>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    71a6:	89 81       	ldd	r24, Y+1	; 0x01
    71a8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    71ac:	05 c0       	rjmp	.+10     	; 0x71b8 <__vector_26+0x5e>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    71ae:	e1 ec       	ldi	r30, 0xC1	; 193
    71b0:	f0 e0       	ldi	r31, 0x00	; 0
    71b2:	80 81       	ld	r24, Z
    71b4:	8f 7d       	andi	r24, 0xDF	; 223
    71b6:	80 83       	st	Z, r24
	}
}
    71b8:	0f 90       	pop	r0
    71ba:	0f 90       	pop	r0
    71bc:	df 91       	pop	r29
    71be:	cf 91       	pop	r28
    71c0:	ff 91       	pop	r31
    71c2:	ef 91       	pop	r30
    71c4:	bf 91       	pop	r27
    71c6:	af 91       	pop	r26
    71c8:	9f 91       	pop	r25
    71ca:	8f 91       	pop	r24
    71cc:	7f 91       	pop	r23
    71ce:	6f 91       	pop	r22
    71d0:	5f 91       	pop	r21
    71d2:	4f 91       	pop	r20
    71d4:	3f 91       	pop	r19
    71d6:	2f 91       	pop	r18
    71d8:	0f 90       	pop	r0
    71da:	0b be       	out	0x3b, r0	; 59
    71dc:	0f 90       	pop	r0
    71de:	0f be       	out	0x3f, r0	; 63
    71e0:	0f 90       	pop	r0
    71e2:	1f 90       	pop	r1
    71e4:	18 95       	reti

000071e6 <prvResetNextTaskUnblockTime>:
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
    71e6:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <pxDelayedTaskList>
    71ea:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    71ee:	80 81       	ld	r24, Z
    71f0:	81 11       	cpse	r24, r1
    71f2:	07 c0       	rjmp	.+14     	; 0x7202 <prvResetNextTaskUnblockTime+0x1c>
    71f4:	8f ef       	ldi	r24, 0xFF	; 255
    71f6:	9f ef       	ldi	r25, 0xFF	; 255
    71f8:	90 93 f7 1f 	sts	0x1FF7, r25	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    71fc:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <xNextTaskUnblockTime>
    7200:	08 95       	ret
    7202:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <pxDelayedTaskList>
    7206:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    720a:	05 80       	ldd	r0, Z+5	; 0x05
    720c:	f6 81       	ldd	r31, Z+6	; 0x06
    720e:	e0 2d       	mov	r30, r0
    7210:	06 80       	ldd	r0, Z+6	; 0x06
    7212:	f7 81       	ldd	r31, Z+7	; 0x07
    7214:	e0 2d       	mov	r30, r0
    7216:	82 81       	ldd	r24, Z+2	; 0x02
    7218:	93 81       	ldd	r25, Z+3	; 0x03
    721a:	90 93 f7 1f 	sts	0x1FF7, r25	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    721e:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <xNextTaskUnblockTime>
    7222:	08 95       	ret

00007224 <prvIdleTask>:
    7224:	0b e0       	ldi	r16, 0x0B	; 11
    7226:	10 e2       	ldi	r17, 0x20	; 32
    7228:	0f 2e       	mov	r0, r31
    722a:	f3 e3       	ldi	r31, 0x33	; 51
    722c:	ef 2e       	mov	r14, r31
    722e:	f0 e2       	ldi	r31, 0x20	; 32
    7230:	ff 2e       	mov	r15, r31
    7232:	f0 2d       	mov	r31, r0
    7234:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uxDeletedTasksWaitingCleanUp>
    7238:	88 23       	and	r24, r24
    723a:	11 f1       	breq	.+68     	; 0x7280 <prvIdleTask+0x5c>
    723c:	0f b6       	in	r0, 0x3f	; 63
    723e:	f8 94       	cli
    7240:	0f 92       	push	r0
    7242:	d8 01       	movw	r26, r16
    7244:	15 96       	adiw	r26, 0x05	; 5
    7246:	ed 91       	ld	r30, X+
    7248:	fc 91       	ld	r31, X
    724a:	16 97       	sbiw	r26, 0x06	; 6
    724c:	c6 81       	ldd	r28, Z+6	; 0x06
    724e:	d7 81       	ldd	r29, Z+7	; 0x07
    7250:	ce 01       	movw	r24, r28
    7252:	02 96       	adiw	r24, 0x02	; 2
    7254:	e3 d9       	rcall	.-3130   	; 0x661c <uxListRemove>
    7256:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    725a:	81 50       	subi	r24, 0x01	; 1
    725c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <uxCurrentNumberOfTasks>
    7260:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uxDeletedTasksWaitingCleanUp>
    7264:	81 50       	subi	r24, 0x01	; 1
    7266:	80 93 0a 20 	sts	0x200A, r24	; 0x80200a <uxDeletedTasksWaitingCleanUp>
    726a:	0f 90       	pop	r0
    726c:	0f be       	out	0x3f, r0	; 63
    726e:	8f 89       	ldd	r24, Y+23	; 0x17
    7270:	98 8d       	ldd	r25, Y+24	; 0x18
    7272:	7b d8       	rcall	.-3850   	; 0x636a <vPortFree>
    7274:	ce 01       	movw	r24, r28
    7276:	79 d8       	rcall	.-3854   	; 0x636a <vPortFree>
    7278:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uxDeletedTasksWaitingCleanUp>
    727c:	81 11       	cpse	r24, r1
    727e:	de cf       	rjmp	.-68     	; 0x723c <prvIdleTask+0x18>
    7280:	f7 01       	movw	r30, r14
    7282:	80 81       	ld	r24, Z
    7284:	82 30       	cpi	r24, 0x02	; 2
    7286:	b0 f2       	brcs	.-84     	; 0x7234 <prvIdleTask+0x10>
    7288:	a1 da       	rcall	.-2750   	; 0x67cc <vPortYield>
    728a:	d4 cf       	rjmp	.-88     	; 0x7234 <prvIdleTask+0x10>

0000728c <prvAddCurrentTaskToDelayedList>:
    728c:	ff 92       	push	r15
    728e:	0f 93       	push	r16
    7290:	1f 93       	push	r17
    7292:	cf 93       	push	r28
    7294:	df 93       	push	r29
    7296:	ec 01       	movw	r28, r24
    7298:	f6 2e       	mov	r15, r22
    729a:	00 91 fe 1f 	lds	r16, 0x1FFE	; 0x801ffe <xTickCount>
    729e:	10 91 ff 1f 	lds	r17, 0x1FFF	; 0x801fff <xTickCount+0x1>
    72a2:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    72a6:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    72aa:	02 96       	adiw	r24, 0x02	; 2
    72ac:	b7 d9       	rcall	.-3218   	; 0x661c <uxListRemove>
    72ae:	cf 3f       	cpi	r28, 0xFF	; 255
    72b0:	8f ef       	ldi	r24, 0xFF	; 255
    72b2:	d8 07       	cpc	r29, r24
    72b4:	61 f4       	brne	.+24     	; 0x72ce <prvAddCurrentTaskToDelayedList+0x42>
    72b6:	ff 20       	and	r15, r15
    72b8:	51 f0       	breq	.+20     	; 0x72ce <prvAddCurrentTaskToDelayedList+0x42>
    72ba:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    72be:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    72c2:	6e 5f       	subi	r22, 0xFE	; 254
    72c4:	7f 4f       	sbci	r23, 0xFF	; 255
    72c6:	81 e0       	ldi	r24, 0x01	; 1
    72c8:	90 e2       	ldi	r25, 0x20	; 32
    72ca:	56 d9       	rcall	.-3412   	; 0x6578 <vListInsertEnd>
    72cc:	2d c0       	rjmp	.+90     	; 0x7328 <prvAddCurrentTaskToDelayedList+0x9c>
    72ce:	c0 0f       	add	r28, r16
    72d0:	d1 1f       	adc	r29, r17
    72d2:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    72d6:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    72da:	d3 83       	std	Z+3, r29	; 0x03
    72dc:	c2 83       	std	Z+2, r28	; 0x02
    72de:	c0 17       	cp	r28, r16
    72e0:	d1 07       	cpc	r29, r17
    72e2:	60 f4       	brcc	.+24     	; 0x72fc <prvAddCurrentTaskToDelayedList+0x70>
    72e4:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    72e8:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    72ec:	80 91 1d 20 	lds	r24, 0x201D	; 0x80201d <pxOverflowDelayedTaskList>
    72f0:	90 91 1e 20 	lds	r25, 0x201E	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    72f4:	6e 5f       	subi	r22, 0xFE	; 254
    72f6:	7f 4f       	sbci	r23, 0xFF	; 255
    72f8:	60 d9       	rcall	.-3392   	; 0x65ba <vListInsert>
    72fa:	16 c0       	rjmp	.+44     	; 0x7328 <prvAddCurrentTaskToDelayedList+0x9c>
    72fc:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    7300:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7304:	80 91 1f 20 	lds	r24, 0x201F	; 0x80201f <pxDelayedTaskList>
    7308:	90 91 20 20 	lds	r25, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    730c:	6e 5f       	subi	r22, 0xFE	; 254
    730e:	7f 4f       	sbci	r23, 0xFF	; 255
    7310:	54 d9       	rcall	.-3416   	; 0x65ba <vListInsert>
    7312:	80 91 f6 1f 	lds	r24, 0x1FF6	; 0x801ff6 <xNextTaskUnblockTime>
    7316:	90 91 f7 1f 	lds	r25, 0x1FF7	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    731a:	c8 17       	cp	r28, r24
    731c:	d9 07       	cpc	r29, r25
    731e:	20 f4       	brcc	.+8      	; 0x7328 <prvAddCurrentTaskToDelayedList+0x9c>
    7320:	d0 93 f7 1f 	sts	0x1FF7, r29	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    7324:	c0 93 f6 1f 	sts	0x1FF6, r28	; 0x801ff6 <xNextTaskUnblockTime>
    7328:	df 91       	pop	r29
    732a:	cf 91       	pop	r28
    732c:	1f 91       	pop	r17
    732e:	0f 91       	pop	r16
    7330:	ff 90       	pop	r15
    7332:	08 95       	ret

00007334 <xTaskCreate>:
    7334:	4f 92       	push	r4
    7336:	5f 92       	push	r5
    7338:	6f 92       	push	r6
    733a:	7f 92       	push	r7
    733c:	8f 92       	push	r8
    733e:	9f 92       	push	r9
    7340:	af 92       	push	r10
    7342:	bf 92       	push	r11
    7344:	cf 92       	push	r12
    7346:	df 92       	push	r13
    7348:	ef 92       	push	r14
    734a:	ff 92       	push	r15
    734c:	0f 93       	push	r16
    734e:	cf 93       	push	r28
    7350:	df 93       	push	r29
    7352:	4c 01       	movw	r8, r24
    7354:	6b 01       	movw	r12, r22
    7356:	5a 01       	movw	r10, r20
    7358:	29 01       	movw	r4, r18
    735a:	ca 01       	movw	r24, r20
    735c:	46 d8       	rcall	.-3956   	; 0x63ea <pvPortMalloc>
    735e:	3c 01       	movw	r6, r24
    7360:	89 2b       	or	r24, r25
    7362:	09 f4       	brne	.+2      	; 0x7366 <xTaskCreate+0x32>
    7364:	ed c0       	rjmp	.+474    	; 0x7540 <xTaskCreate+0x20c>
    7366:	8c e3       	ldi	r24, 0x3C	; 60
    7368:	90 e0       	ldi	r25, 0x00	; 0
    736a:	3f d8       	rcall	.-3970   	; 0x63ea <pvPortMalloc>
    736c:	ec 01       	movw	r28, r24
    736e:	89 2b       	or	r24, r25
    7370:	99 f0       	breq	.+38     	; 0x7398 <xTaskCreate+0x64>
    7372:	78 8e       	std	Y+24, r7	; 0x18
    7374:	6f 8a       	std	Y+23, r6	; 0x17
    7376:	a5 01       	movw	r20, r10
    7378:	65 ea       	ldi	r22, 0xA5	; 165
    737a:	70 e0       	ldi	r23, 0x00	; 0
    737c:	c3 01       	movw	r24, r6
    737e:	0e 94 97 45 	call	0x8b2e	; 0x8b2e <memset>
    7382:	81 e0       	ldi	r24, 0x01	; 1
    7384:	a8 1a       	sub	r10, r24
    7386:	b1 08       	sbc	r11, r1
    7388:	8f 89       	ldd	r24, Y+23	; 0x17
    738a:	98 8d       	ldd	r25, Y+24	; 0x18
    738c:	a8 0e       	add	r10, r24
    738e:	b9 1e       	adc	r11, r25
    7390:	c1 14       	cp	r12, r1
    7392:	d1 04       	cpc	r13, r1
    7394:	29 f4       	brne	.+10     	; 0x73a0 <xTaskCreate+0x6c>
    7396:	20 c0       	rjmp	.+64     	; 0x73d8 <xTaskCreate+0xa4>
    7398:	c3 01       	movw	r24, r6
    739a:	0e 94 b5 31 	call	0x636a	; 0x636a <vPortFree>
    739e:	d0 c0       	rjmp	.+416    	; 0x7540 <xTaskCreate+0x20c>
    73a0:	d6 01       	movw	r26, r12
    73a2:	8c 91       	ld	r24, X
    73a4:	89 8f       	std	Y+25, r24	; 0x19
    73a6:	8c 91       	ld	r24, X
    73a8:	88 23       	and	r24, r24
    73aa:	a1 f0       	breq	.+40     	; 0x73d4 <xTaskCreate+0xa0>
    73ac:	ae 01       	movw	r20, r28
    73ae:	46 5e       	subi	r20, 0xE6	; 230
    73b0:	5f 4f       	sbci	r21, 0xFF	; 255
    73b2:	f6 01       	movw	r30, r12
    73b4:	31 96       	adiw	r30, 0x01	; 1
    73b6:	b0 e1       	ldi	r27, 0x10	; 16
    73b8:	cb 0e       	add	r12, r27
    73ba:	d1 1c       	adc	r13, r1
    73bc:	cf 01       	movw	r24, r30
    73be:	21 91       	ld	r18, Z+
    73c0:	da 01       	movw	r26, r20
    73c2:	2d 93       	st	X+, r18
    73c4:	ad 01       	movw	r20, r26
    73c6:	dc 01       	movw	r26, r24
    73c8:	8c 91       	ld	r24, X
    73ca:	88 23       	and	r24, r24
    73cc:	19 f0       	breq	.+6      	; 0x73d4 <xTaskCreate+0xa0>
    73ce:	ec 15       	cp	r30, r12
    73d0:	fd 05       	cpc	r31, r13
    73d2:	a1 f7       	brne	.-24     	; 0x73bc <xTaskCreate+0x88>
    73d4:	18 a6       	std	Y+40, r1	; 0x28
    73d6:	01 c0       	rjmp	.+2      	; 0x73da <xTaskCreate+0xa6>
    73d8:	19 8e       	std	Y+25, r1	; 0x19
    73da:	04 30       	cpi	r16, 0x04	; 4
    73dc:	08 f0       	brcs	.+2      	; 0x73e0 <xTaskCreate+0xac>
    73de:	03 e0       	ldi	r16, 0x03	; 3
    73e0:	0e 8b       	std	Y+22, r16	; 0x16
    73e2:	0b a7       	std	Y+43, r16	; 0x2b
    73e4:	1c a6       	std	Y+44, r1	; 0x2c
    73e6:	6e 01       	movw	r12, r28
    73e8:	b2 e0       	ldi	r27, 0x02	; 2
    73ea:	cb 0e       	add	r12, r27
    73ec:	d1 1c       	adc	r13, r1
    73ee:	c6 01       	movw	r24, r12
    73f0:	bf d8       	rcall	.-3714   	; 0x6570 <vListInitialiseItem>
    73f2:	ce 01       	movw	r24, r28
    73f4:	0c 96       	adiw	r24, 0x0c	; 12
    73f6:	bc d8       	rcall	.-3720   	; 0x6570 <vListInitialiseItem>
    73f8:	d9 87       	std	Y+9, r29	; 0x09
    73fa:	c8 87       	std	Y+8, r28	; 0x08
    73fc:	84 e0       	ldi	r24, 0x04	; 4
    73fe:	90 e0       	ldi	r25, 0x00	; 0
    7400:	80 1b       	sub	r24, r16
    7402:	91 09       	sbc	r25, r1
    7404:	9d 87       	std	Y+13, r25	; 0x0d
    7406:	8c 87       	std	Y+12, r24	; 0x0c
    7408:	db 8b       	std	Y+19, r29	; 0x13
    740a:	ca 8b       	std	Y+18, r28	; 0x12
    740c:	1e a6       	std	Y+46, r1	; 0x2e
    740e:	1d a6       	std	Y+45, r1	; 0x2d
    7410:	18 aa       	std	Y+48, r1	; 0x30
    7412:	1f a6       	std	Y+47, r1	; 0x2f
    7414:	1a aa       	std	Y+50, r1	; 0x32
    7416:	19 aa       	std	Y+49, r1	; 0x31
    7418:	1c aa       	std	Y+52, r1	; 0x34
    741a:	1b aa       	std	Y+51, r1	; 0x33
    741c:	1e aa       	std	Y+54, r1	; 0x36
    741e:	1d aa       	std	Y+53, r1	; 0x35
    7420:	1f aa       	std	Y+55, r1	; 0x37
    7422:	18 ae       	std	Y+56, r1	; 0x38
    7424:	19 ae       	std	Y+57, r1	; 0x39
    7426:	1a ae       	std	Y+58, r1	; 0x3a
    7428:	1b ae       	std	Y+59, r1	; 0x3b
    742a:	a2 01       	movw	r20, r4
    742c:	b4 01       	movw	r22, r8
    742e:	c5 01       	movw	r24, r10
    7430:	1c d9       	rcall	.-3528   	; 0x666a <pxPortInitialiseStack>
    7432:	99 83       	std	Y+1, r25	; 0x01
    7434:	88 83       	st	Y, r24
    7436:	e1 14       	cp	r14, r1
    7438:	f1 04       	cpc	r15, r1
    743a:	19 f0       	breq	.+6      	; 0x7442 <xTaskCreate+0x10e>
    743c:	f7 01       	movw	r30, r14
    743e:	d1 83       	std	Z+1, r29	; 0x01
    7440:	c0 83       	st	Z, r28
    7442:	0f b6       	in	r0, 0x3f	; 63
    7444:	f8 94       	cli
    7446:	0f 92       	push	r0
    7448:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    744c:	8f 5f       	subi	r24, 0xFF	; 255
    744e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <uxCurrentNumberOfTasks>
    7452:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    7456:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    745a:	89 2b       	or	r24, r25
    745c:	89 f5       	brne	.+98     	; 0x74c0 <xTaskCreate+0x18c>
    745e:	d0 93 58 20 	sts	0x2058, r29	; 0x802058 <pxCurrentTCB+0x1>
    7462:	c0 93 57 20 	sts	0x2057, r28	; 0x802057 <pxCurrentTCB>
    7466:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    746a:	81 30       	cpi	r24, 0x01	; 1
    746c:	09 f0       	breq	.+2      	; 0x7470 <xTaskCreate+0x13c>
    746e:	38 c0       	rjmp	.+112    	; 0x74e0 <xTaskCreate+0x1ac>
    7470:	83 e3       	ldi	r24, 0x33	; 51
    7472:	90 e2       	ldi	r25, 0x20	; 32
    7474:	6f d8       	rcall	.-3874   	; 0x6554 <vListInitialise>
    7476:	8c e3       	ldi	r24, 0x3C	; 60
    7478:	90 e2       	ldi	r25, 0x20	; 32
    747a:	6c d8       	rcall	.-3880   	; 0x6554 <vListInitialise>
    747c:	85 e4       	ldi	r24, 0x45	; 69
    747e:	90 e2       	ldi	r25, 0x20	; 32
    7480:	69 d8       	rcall	.-3886   	; 0x6554 <vListInitialise>
    7482:	8e e4       	ldi	r24, 0x4E	; 78
    7484:	90 e2       	ldi	r25, 0x20	; 32
    7486:	66 d8       	rcall	.-3892   	; 0x6554 <vListInitialise>
    7488:	8a e2       	ldi	r24, 0x2A	; 42
    748a:	90 e2       	ldi	r25, 0x20	; 32
    748c:	63 d8       	rcall	.-3898   	; 0x6554 <vListInitialise>
    748e:	81 e2       	ldi	r24, 0x21	; 33
    7490:	90 e2       	ldi	r25, 0x20	; 32
    7492:	60 d8       	rcall	.-3904   	; 0x6554 <vListInitialise>
    7494:	84 e1       	ldi	r24, 0x14	; 20
    7496:	90 e2       	ldi	r25, 0x20	; 32
    7498:	5d d8       	rcall	.-3910   	; 0x6554 <vListInitialise>
    749a:	8b e0       	ldi	r24, 0x0B	; 11
    749c:	90 e2       	ldi	r25, 0x20	; 32
    749e:	5a d8       	rcall	.-3916   	; 0x6554 <vListInitialise>
    74a0:	81 e0       	ldi	r24, 0x01	; 1
    74a2:	90 e2       	ldi	r25, 0x20	; 32
    74a4:	57 d8       	rcall	.-3922   	; 0x6554 <vListInitialise>
    74a6:	8a e2       	ldi	r24, 0x2A	; 42
    74a8:	90 e2       	ldi	r25, 0x20	; 32
    74aa:	90 93 20 20 	sts	0x2020, r25	; 0x802020 <pxDelayedTaskList+0x1>
    74ae:	80 93 1f 20 	sts	0x201F, r24	; 0x80201f <pxDelayedTaskList>
    74b2:	81 e2       	ldi	r24, 0x21	; 33
    74b4:	90 e2       	ldi	r25, 0x20	; 32
    74b6:	90 93 1e 20 	sts	0x201E, r25	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    74ba:	80 93 1d 20 	sts	0x201D, r24	; 0x80201d <pxOverflowDelayedTaskList>
    74be:	10 c0       	rjmp	.+32     	; 0x74e0 <xTaskCreate+0x1ac>
    74c0:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xSchedulerRunning>
    74c4:	81 11       	cpse	r24, r1
    74c6:	0c c0       	rjmp	.+24     	; 0x74e0 <xTaskCreate+0x1ac>
    74c8:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    74cc:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    74d0:	96 89       	ldd	r25, Z+22	; 0x16
    74d2:	8e 89       	ldd	r24, Y+22	; 0x16
    74d4:	89 17       	cp	r24, r25
    74d6:	20 f0       	brcs	.+8      	; 0x74e0 <xTaskCreate+0x1ac>
    74d8:	d0 93 58 20 	sts	0x2058, r29	; 0x802058 <pxCurrentTCB+0x1>
    74dc:	c0 93 57 20 	sts	0x2057, r28	; 0x802057 <pxCurrentTCB>
    74e0:	80 91 f8 1f 	lds	r24, 0x1FF8	; 0x801ff8 <uxTaskNumber>
    74e4:	8f 5f       	subi	r24, 0xFF	; 255
    74e6:	80 93 f8 1f 	sts	0x1FF8, r24	; 0x801ff8 <uxTaskNumber>
    74ea:	89 a7       	std	Y+41, r24	; 0x29
    74ec:	8e 89       	ldd	r24, Y+22	; 0x16
    74ee:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    74f2:	98 17       	cp	r25, r24
    74f4:	10 f4       	brcc	.+4      	; 0x74fa <xTaskCreate+0x1c6>
    74f6:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    74fa:	90 e0       	ldi	r25, 0x00	; 0
    74fc:	9c 01       	movw	r18, r24
    74fe:	22 0f       	add	r18, r18
    7500:	33 1f       	adc	r19, r19
    7502:	22 0f       	add	r18, r18
    7504:	33 1f       	adc	r19, r19
    7506:	22 0f       	add	r18, r18
    7508:	33 1f       	adc	r19, r19
    750a:	82 0f       	add	r24, r18
    750c:	93 1f       	adc	r25, r19
    750e:	b6 01       	movw	r22, r12
    7510:	8d 5c       	subi	r24, 0xCD	; 205
    7512:	9f 4d       	sbci	r25, 0xDF	; 223
    7514:	31 d8       	rcall	.-3998   	; 0x6578 <vListInsertEnd>
    7516:	0f 90       	pop	r0
    7518:	0f be       	out	0x3f, r0	; 63
    751a:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xSchedulerRunning>
    751e:	88 23       	and	r24, r24
    7520:	59 f0       	breq	.+22     	; 0x7538 <xTaskCreate+0x204>
    7522:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    7526:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    752a:	96 89       	ldd	r25, Z+22	; 0x16
    752c:	8e 89       	ldd	r24, Y+22	; 0x16
    752e:	98 17       	cp	r25, r24
    7530:	28 f4       	brcc	.+10     	; 0x753c <xTaskCreate+0x208>
    7532:	4c d9       	rcall	.-3432   	; 0x67cc <vPortYield>
    7534:	81 e0       	ldi	r24, 0x01	; 1
    7536:	05 c0       	rjmp	.+10     	; 0x7542 <xTaskCreate+0x20e>
    7538:	81 e0       	ldi	r24, 0x01	; 1
    753a:	03 c0       	rjmp	.+6      	; 0x7542 <xTaskCreate+0x20e>
    753c:	81 e0       	ldi	r24, 0x01	; 1
    753e:	01 c0       	rjmp	.+2      	; 0x7542 <xTaskCreate+0x20e>
    7540:	8f ef       	ldi	r24, 0xFF	; 255
    7542:	df 91       	pop	r29
    7544:	cf 91       	pop	r28
    7546:	0f 91       	pop	r16
    7548:	ff 90       	pop	r15
    754a:	ef 90       	pop	r14
    754c:	df 90       	pop	r13
    754e:	cf 90       	pop	r12
    7550:	bf 90       	pop	r11
    7552:	af 90       	pop	r10
    7554:	9f 90       	pop	r9
    7556:	8f 90       	pop	r8
    7558:	7f 90       	pop	r7
    755a:	6f 90       	pop	r6
    755c:	5f 90       	pop	r5
    755e:	4f 90       	pop	r4
    7560:	08 95       	ret

00007562 <eTaskGetState>:
    7562:	20 91 57 20 	lds	r18, 0x2057	; 0x802057 <pxCurrentTCB>
    7566:	30 91 58 20 	lds	r19, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    756a:	82 17       	cp	r24, r18
    756c:	93 07       	cpc	r25, r19
    756e:	61 f1       	breq	.+88     	; 0x75c8 <eTaskGetState+0x66>
    7570:	0f b6       	in	r0, 0x3f	; 63
    7572:	f8 94       	cli
    7574:	0f 92       	push	r0
    7576:	fc 01       	movw	r30, r24
    7578:	22 85       	ldd	r18, Z+10	; 0x0a
    757a:	33 85       	ldd	r19, Z+11	; 0x0b
    757c:	40 91 1f 20 	lds	r20, 0x201F	; 0x80201f <pxDelayedTaskList>
    7580:	50 91 20 20 	lds	r21, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    7584:	60 91 1d 20 	lds	r22, 0x201D	; 0x80201d <pxOverflowDelayedTaskList>
    7588:	70 91 1e 20 	lds	r23, 0x201E	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    758c:	0f 90       	pop	r0
    758e:	0f be       	out	0x3f, r0	; 63
    7590:	24 17       	cp	r18, r20
    7592:	35 07       	cpc	r19, r21
    7594:	d9 f0       	breq	.+54     	; 0x75cc <eTaskGetState+0x6a>
    7596:	26 17       	cp	r18, r22
    7598:	37 07       	cpc	r19, r23
    759a:	d1 f0       	breq	.+52     	; 0x75d0 <eTaskGetState+0x6e>
    759c:	f0 e2       	ldi	r31, 0x20	; 32
    759e:	21 30       	cpi	r18, 0x01	; 1
    75a0:	3f 07       	cpc	r19, r31
    75a2:	51 f4       	brne	.+20     	; 0x75b8 <eTaskGetState+0x56>
    75a4:	fc 01       	movw	r30, r24
    75a6:	24 89       	ldd	r18, Z+20	; 0x14
    75a8:	35 89       	ldd	r19, Z+21	; 0x15
    75aa:	23 2b       	or	r18, r19
    75ac:	99 f4       	brne	.+38     	; 0x75d4 <eTaskGetState+0x72>
    75ae:	83 ad       	ldd	r24, Z+59	; 0x3b
    75b0:	81 30       	cpi	r24, 0x01	; 1
    75b2:	91 f0       	breq	.+36     	; 0x75d8 <eTaskGetState+0x76>
    75b4:	83 e0       	ldi	r24, 0x03	; 3
    75b6:	08 95       	ret
    75b8:	f0 e2       	ldi	r31, 0x20	; 32
    75ba:	2b 30       	cpi	r18, 0x0B	; 11
    75bc:	3f 07       	cpc	r19, r31
    75be:	71 f0       	breq	.+28     	; 0x75dc <eTaskGetState+0x7a>
    75c0:	23 2b       	or	r18, r19
    75c2:	71 f0       	breq	.+28     	; 0x75e0 <eTaskGetState+0x7e>
    75c4:	81 e0       	ldi	r24, 0x01	; 1
    75c6:	08 95       	ret
    75c8:	80 e0       	ldi	r24, 0x00	; 0
    75ca:	08 95       	ret
    75cc:	82 e0       	ldi	r24, 0x02	; 2
    75ce:	08 95       	ret
    75d0:	82 e0       	ldi	r24, 0x02	; 2
    75d2:	08 95       	ret
    75d4:	82 e0       	ldi	r24, 0x02	; 2
    75d6:	08 95       	ret
    75d8:	82 e0       	ldi	r24, 0x02	; 2
    75da:	08 95       	ret
    75dc:	84 e0       	ldi	r24, 0x04	; 4
    75de:	08 95       	ret
    75e0:	84 e0       	ldi	r24, 0x04	; 4
    75e2:	08 95       	ret

000075e4 <xTaskResumeFromISR>:
    75e4:	ef 92       	push	r14
    75e6:	ff 92       	push	r15
    75e8:	1f 93       	push	r17
    75ea:	cf 93       	push	r28
    75ec:	df 93       	push	r29
    75ee:	fc 01       	movw	r30, r24
    75f0:	22 85       	ldd	r18, Z+10	; 0x0a
    75f2:	33 85       	ldd	r19, Z+11	; 0x0b
    75f4:	21 50       	subi	r18, 0x01	; 1
    75f6:	30 42       	sbci	r19, 0x20	; 32
    75f8:	09 f0       	breq	.+2      	; 0x75fc <xTaskResumeFromISR+0x18>
    75fa:	3f c0       	rjmp	.+126    	; 0x767a <xTaskResumeFromISR+0x96>
    75fc:	fc 01       	movw	r30, r24
    75fe:	24 89       	ldd	r18, Z+20	; 0x14
    7600:	35 89       	ldd	r19, Z+21	; 0x15
    7602:	f0 e2       	ldi	r31, 0x20	; 32
    7604:	24 31       	cpi	r18, 0x14	; 20
    7606:	3f 07       	cpc	r19, r31
    7608:	d1 f1       	breq	.+116    	; 0x767e <xTaskResumeFromISR+0x9a>
    760a:	23 2b       	or	r18, r19
    760c:	d1 f5       	brne	.+116    	; 0x7682 <xTaskResumeFromISR+0x9e>
    760e:	ec 01       	movw	r28, r24
    7610:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    7614:	81 11       	cpse	r24, r1
    7616:	28 c0       	rjmp	.+80     	; 0x7668 <xTaskResumeFromISR+0x84>
    7618:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    761c:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7620:	11 e0       	ldi	r17, 0x01	; 1
    7622:	9e 89       	ldd	r25, Y+22	; 0x16
    7624:	86 89       	ldd	r24, Z+22	; 0x16
    7626:	98 17       	cp	r25, r24
    7628:	08 f4       	brcc	.+2      	; 0x762c <xTaskResumeFromISR+0x48>
    762a:	10 e0       	ldi	r17, 0x00	; 0
    762c:	7e 01       	movw	r14, r28
    762e:	42 e0       	ldi	r20, 0x02	; 2
    7630:	e4 0e       	add	r14, r20
    7632:	f1 1c       	adc	r15, r1
    7634:	c7 01       	movw	r24, r14
    7636:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    763a:	8e 89       	ldd	r24, Y+22	; 0x16
    763c:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    7640:	98 17       	cp	r25, r24
    7642:	10 f4       	brcc	.+4      	; 0x7648 <xTaskResumeFromISR+0x64>
    7644:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7648:	90 e0       	ldi	r25, 0x00	; 0
    764a:	9c 01       	movw	r18, r24
    764c:	22 0f       	add	r18, r18
    764e:	33 1f       	adc	r19, r19
    7650:	22 0f       	add	r18, r18
    7652:	33 1f       	adc	r19, r19
    7654:	22 0f       	add	r18, r18
    7656:	33 1f       	adc	r19, r19
    7658:	82 0f       	add	r24, r18
    765a:	93 1f       	adc	r25, r19
    765c:	b7 01       	movw	r22, r14
    765e:	8d 5c       	subi	r24, 0xCD	; 205
    7660:	9f 4d       	sbci	r25, 0xDF	; 223
    7662:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7666:	0e c0       	rjmp	.+28     	; 0x7684 <xTaskResumeFromISR+0xa0>
    7668:	be 01       	movw	r22, r28
    766a:	64 5f       	subi	r22, 0xF4	; 244
    766c:	7f 4f       	sbci	r23, 0xFF	; 255
    766e:	84 e1       	ldi	r24, 0x14	; 20
    7670:	90 e2       	ldi	r25, 0x20	; 32
    7672:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7676:	10 e0       	ldi	r17, 0x00	; 0
    7678:	05 c0       	rjmp	.+10     	; 0x7684 <xTaskResumeFromISR+0xa0>
    767a:	10 e0       	ldi	r17, 0x00	; 0
    767c:	03 c0       	rjmp	.+6      	; 0x7684 <xTaskResumeFromISR+0xa0>
    767e:	10 e0       	ldi	r17, 0x00	; 0
    7680:	01 c0       	rjmp	.+2      	; 0x7684 <xTaskResumeFromISR+0xa0>
    7682:	10 e0       	ldi	r17, 0x00	; 0
    7684:	81 2f       	mov	r24, r17
    7686:	df 91       	pop	r29
    7688:	cf 91       	pop	r28
    768a:	1f 91       	pop	r17
    768c:	ff 90       	pop	r15
    768e:	ef 90       	pop	r14
    7690:	08 95       	ret

00007692 <vTaskStartScheduler>:
    7692:	ef 92       	push	r14
    7694:	ff 92       	push	r15
    7696:	0f 93       	push	r16
    7698:	0f 2e       	mov	r0, r31
    769a:	f4 ef       	ldi	r31, 0xF4	; 244
    769c:	ef 2e       	mov	r14, r31
    769e:	ff e1       	ldi	r31, 0x1F	; 31
    76a0:	ff 2e       	mov	r15, r31
    76a2:	f0 2d       	mov	r31, r0
    76a4:	00 e0       	ldi	r16, 0x00	; 0
    76a6:	20 e0       	ldi	r18, 0x00	; 0
    76a8:	30 e0       	ldi	r19, 0x00	; 0
    76aa:	44 e6       	ldi	r20, 0x64	; 100
    76ac:	50 e0       	ldi	r21, 0x00	; 0
    76ae:	6b ef       	ldi	r22, 0xFB	; 251
    76b0:	72 e0       	ldi	r23, 0x02	; 2
    76b2:	82 e1       	ldi	r24, 0x12	; 18
    76b4:	99 e3       	ldi	r25, 0x39	; 57
    76b6:	3e de       	rcall	.-900    	; 0x7334 <xTaskCreate>
    76b8:	81 30       	cpi	r24, 0x01	; 1
    76ba:	91 f4       	brne	.+36     	; 0x76e0 <vTaskStartScheduler+0x4e>
    76bc:	8e d6       	rcall	.+3356   	; 0x83da <xTimerCreateTimerTask>
    76be:	81 30       	cpi	r24, 0x01	; 1
    76c0:	79 f4       	brne	.+30     	; 0x76e0 <vTaskStartScheduler+0x4e>
    76c2:	f8 94       	cli
    76c4:	8f ef       	ldi	r24, 0xFF	; 255
    76c6:	9f ef       	ldi	r25, 0xFF	; 255
    76c8:	90 93 f7 1f 	sts	0x1FF7, r25	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    76cc:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <xNextTaskUnblockTime>
    76d0:	81 e0       	ldi	r24, 0x01	; 1
    76d2:	80 93 fc 1f 	sts	0x1FFC, r24	; 0x801ffc <xSchedulerRunning>
    76d6:	10 92 ff 1f 	sts	0x1FFF, r1	; 0x801fff <xTickCount+0x1>
    76da:	10 92 fe 1f 	sts	0x1FFE, r1	; 0x801ffe <xTickCount>
    76de:	37 d8       	rcall	.-3986   	; 0x674e <xPortStartScheduler>
    76e0:	0f 91       	pop	r16
    76e2:	ff 90       	pop	r15
    76e4:	ef 90       	pop	r14
    76e6:	08 95       	ret

000076e8 <vTaskSuspendAll>:
    76e8:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    76ec:	8f 5f       	subi	r24, 0xFF	; 255
    76ee:	80 93 f3 1f 	sts	0x1FF3, r24	; 0x801ff3 <uxSchedulerSuspended>
    76f2:	08 95       	ret

000076f4 <xTaskGetTickCount>:
    76f4:	0f b6       	in	r0, 0x3f	; 63
    76f6:	f8 94       	cli
    76f8:	0f 92       	push	r0
    76fa:	80 91 fe 1f 	lds	r24, 0x1FFE	; 0x801ffe <xTickCount>
    76fe:	90 91 ff 1f 	lds	r25, 0x1FFF	; 0x801fff <xTickCount+0x1>
    7702:	0f 90       	pop	r0
    7704:	0f be       	out	0x3f, r0	; 63
    7706:	08 95       	ret

00007708 <uxTaskGetNumberOfTasks>:
    7708:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    770c:	08 95       	ret

0000770e <pcTaskGetName>:
    770e:	00 97       	sbiw	r24, 0x00	; 0
    7710:	21 f4       	brne	.+8      	; 0x771a <pcTaskGetName+0xc>
    7712:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    7716:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    771a:	49 96       	adiw	r24, 0x19	; 25
    771c:	08 95       	ret

0000771e <xTaskIncrementTick>:
    771e:	cf 92       	push	r12
    7720:	df 92       	push	r13
    7722:	ef 92       	push	r14
    7724:	ff 92       	push	r15
    7726:	0f 93       	push	r16
    7728:	1f 93       	push	r17
    772a:	cf 93       	push	r28
    772c:	df 93       	push	r29
    772e:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    7732:	81 11       	cpse	r24, r1
    7734:	80 c0       	rjmp	.+256    	; 0x7836 <xTaskIncrementTick+0x118>
    7736:	e0 90 fe 1f 	lds	r14, 0x1FFE	; 0x801ffe <xTickCount>
    773a:	f0 90 ff 1f 	lds	r15, 0x1FFF	; 0x801fff <xTickCount+0x1>
    773e:	8f ef       	ldi	r24, 0xFF	; 255
    7740:	e8 1a       	sub	r14, r24
    7742:	f8 0a       	sbc	r15, r24
    7744:	f0 92 ff 1f 	sts	0x1FFF, r15	; 0x801fff <xTickCount+0x1>
    7748:	e0 92 fe 1f 	sts	0x1FFE, r14	; 0x801ffe <xTickCount>
    774c:	e1 14       	cp	r14, r1
    774e:	f1 04       	cpc	r15, r1
    7750:	b1 f4       	brne	.+44     	; 0x777e <xTaskIncrementTick+0x60>
    7752:	80 91 1f 20 	lds	r24, 0x201F	; 0x80201f <pxDelayedTaskList>
    7756:	90 91 20 20 	lds	r25, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    775a:	20 91 1d 20 	lds	r18, 0x201D	; 0x80201d <pxOverflowDelayedTaskList>
    775e:	30 91 1e 20 	lds	r19, 0x201E	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    7762:	30 93 20 20 	sts	0x2020, r19	; 0x802020 <pxDelayedTaskList+0x1>
    7766:	20 93 1f 20 	sts	0x201F, r18	; 0x80201f <pxDelayedTaskList>
    776a:	90 93 1e 20 	sts	0x201E, r25	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    776e:	80 93 1d 20 	sts	0x201D, r24	; 0x80201d <pxOverflowDelayedTaskList>
    7772:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <xNumOfOverflows>
    7776:	8f 5f       	subi	r24, 0xFF	; 255
    7778:	80 93 f9 1f 	sts	0x1FF9, r24	; 0x801ff9 <xNumOfOverflows>
    777c:	34 dd       	rcall	.-1432   	; 0x71e6 <prvResetNextTaskUnblockTime>
    777e:	80 91 f6 1f 	lds	r24, 0x1FF6	; 0x801ff6 <xNextTaskUnblockTime>
    7782:	90 91 f7 1f 	lds	r25, 0x1FF7	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    7786:	e8 16       	cp	r14, r24
    7788:	f9 06       	cpc	r15, r25
    778a:	10 f4       	brcc	.+4      	; 0x7790 <xTaskIncrementTick+0x72>
    778c:	d1 2c       	mov	r13, r1
    778e:	59 c0       	rjmp	.+178    	; 0x7842 <xTaskIncrementTick+0x124>
    7790:	d1 2c       	mov	r13, r1
    7792:	cc 24       	eor	r12, r12
    7794:	c3 94       	inc	r12
    7796:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <pxDelayedTaskList>
    779a:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    779e:	80 81       	ld	r24, Z
    77a0:	81 11       	cpse	r24, r1
    77a2:	07 c0       	rjmp	.+14     	; 0x77b2 <xTaskIncrementTick+0x94>
    77a4:	8f ef       	ldi	r24, 0xFF	; 255
    77a6:	9f ef       	ldi	r25, 0xFF	; 255
    77a8:	90 93 f7 1f 	sts	0x1FF7, r25	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    77ac:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <xNextTaskUnblockTime>
    77b0:	48 c0       	rjmp	.+144    	; 0x7842 <xTaskIncrementTick+0x124>
    77b2:	e0 91 1f 20 	lds	r30, 0x201F	; 0x80201f <pxDelayedTaskList>
    77b6:	f0 91 20 20 	lds	r31, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    77ba:	05 80       	ldd	r0, Z+5	; 0x05
    77bc:	f6 81       	ldd	r31, Z+6	; 0x06
    77be:	e0 2d       	mov	r30, r0
    77c0:	c6 81       	ldd	r28, Z+6	; 0x06
    77c2:	d7 81       	ldd	r29, Z+7	; 0x07
    77c4:	8a 81       	ldd	r24, Y+2	; 0x02
    77c6:	9b 81       	ldd	r25, Y+3	; 0x03
    77c8:	e8 16       	cp	r14, r24
    77ca:	f9 06       	cpc	r15, r25
    77cc:	28 f4       	brcc	.+10     	; 0x77d8 <xTaskIncrementTick+0xba>
    77ce:	90 93 f7 1f 	sts	0x1FF7, r25	; 0x801ff7 <xNextTaskUnblockTime+0x1>
    77d2:	80 93 f6 1f 	sts	0x1FF6, r24	; 0x801ff6 <xNextTaskUnblockTime>
    77d6:	35 c0       	rjmp	.+106    	; 0x7842 <xTaskIncrementTick+0x124>
    77d8:	8e 01       	movw	r16, r28
    77da:	0e 5f       	subi	r16, 0xFE	; 254
    77dc:	1f 4f       	sbci	r17, 0xFF	; 255
    77de:	c8 01       	movw	r24, r16
    77e0:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    77e4:	8c 89       	ldd	r24, Y+20	; 0x14
    77e6:	9d 89       	ldd	r25, Y+21	; 0x15
    77e8:	89 2b       	or	r24, r25
    77ea:	21 f0       	breq	.+8      	; 0x77f4 <xTaskIncrementTick+0xd6>
    77ec:	ce 01       	movw	r24, r28
    77ee:	0c 96       	adiw	r24, 0x0c	; 12
    77f0:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    77f4:	8e 89       	ldd	r24, Y+22	; 0x16
    77f6:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    77fa:	98 17       	cp	r25, r24
    77fc:	10 f4       	brcc	.+4      	; 0x7802 <xTaskIncrementTick+0xe4>
    77fe:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7802:	90 e0       	ldi	r25, 0x00	; 0
    7804:	9c 01       	movw	r18, r24
    7806:	22 0f       	add	r18, r18
    7808:	33 1f       	adc	r19, r19
    780a:	22 0f       	add	r18, r18
    780c:	33 1f       	adc	r19, r19
    780e:	22 0f       	add	r18, r18
    7810:	33 1f       	adc	r19, r19
    7812:	82 0f       	add	r24, r18
    7814:	93 1f       	adc	r25, r19
    7816:	b8 01       	movw	r22, r16
    7818:	8d 5c       	subi	r24, 0xCD	; 205
    781a:	9f 4d       	sbci	r25, 0xDF	; 223
    781c:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7820:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    7824:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7828:	9e 89       	ldd	r25, Y+22	; 0x16
    782a:	86 89       	ldd	r24, Z+22	; 0x16
    782c:	98 17       	cp	r25, r24
    782e:	08 f4       	brcc	.+2      	; 0x7832 <xTaskIncrementTick+0x114>
    7830:	b2 cf       	rjmp	.-156    	; 0x7796 <xTaskIncrementTick+0x78>
    7832:	dc 2c       	mov	r13, r12
    7834:	b0 cf       	rjmp	.-160    	; 0x7796 <xTaskIncrementTick+0x78>
    7836:	80 91 fb 1f 	lds	r24, 0x1FFB	; 0x801ffb <uxPendedTicks>
    783a:	8f 5f       	subi	r24, 0xFF	; 255
    783c:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <uxPendedTicks>
    7840:	d1 2c       	mov	r13, r1
    7842:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xYieldPending>
    7846:	88 23       	and	r24, r24
    7848:	11 f0       	breq	.+4      	; 0x784e <xTaskIncrementTick+0x130>
    784a:	dd 24       	eor	r13, r13
    784c:	d3 94       	inc	r13
    784e:	8d 2d       	mov	r24, r13
    7850:	df 91       	pop	r29
    7852:	cf 91       	pop	r28
    7854:	1f 91       	pop	r17
    7856:	0f 91       	pop	r16
    7858:	ff 90       	pop	r15
    785a:	ef 90       	pop	r14
    785c:	df 90       	pop	r13
    785e:	cf 90       	pop	r12
    7860:	08 95       	ret

00007862 <xTaskResumeAll>:
    7862:	df 92       	push	r13
    7864:	ef 92       	push	r14
    7866:	ff 92       	push	r15
    7868:	0f 93       	push	r16
    786a:	1f 93       	push	r17
    786c:	cf 93       	push	r28
    786e:	df 93       	push	r29
    7870:	0f b6       	in	r0, 0x3f	; 63
    7872:	f8 94       	cli
    7874:	0f 92       	push	r0
    7876:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    787a:	81 50       	subi	r24, 0x01	; 1
    787c:	80 93 f3 1f 	sts	0x1FF3, r24	; 0x801ff3 <uxSchedulerSuspended>
    7880:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    7884:	81 11       	cpse	r24, r1
    7886:	5d c0       	rjmp	.+186    	; 0x7942 <xTaskResumeAll+0xe0>
    7888:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    788c:	81 11       	cpse	r24, r1
    788e:	33 c0       	rjmp	.+102    	; 0x78f6 <xTaskResumeAll+0x94>
    7890:	5b c0       	rjmp	.+182    	; 0x7948 <xTaskResumeAll+0xe6>
    7892:	d7 01       	movw	r26, r14
    7894:	15 96       	adiw	r26, 0x05	; 5
    7896:	ed 91       	ld	r30, X+
    7898:	fc 91       	ld	r31, X
    789a:	16 97       	sbiw	r26, 0x06	; 6
    789c:	c6 81       	ldd	r28, Z+6	; 0x06
    789e:	d7 81       	ldd	r29, Z+7	; 0x07
    78a0:	ce 01       	movw	r24, r28
    78a2:	0c 96       	adiw	r24, 0x0c	; 12
    78a4:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    78a8:	8e 01       	movw	r16, r28
    78aa:	0e 5f       	subi	r16, 0xFE	; 254
    78ac:	1f 4f       	sbci	r17, 0xFF	; 255
    78ae:	c8 01       	movw	r24, r16
    78b0:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    78b4:	8e 89       	ldd	r24, Y+22	; 0x16
    78b6:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    78ba:	98 17       	cp	r25, r24
    78bc:	10 f4       	brcc	.+4      	; 0x78c2 <xTaskResumeAll+0x60>
    78be:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    78c2:	90 e0       	ldi	r25, 0x00	; 0
    78c4:	9c 01       	movw	r18, r24
    78c6:	22 0f       	add	r18, r18
    78c8:	33 1f       	adc	r19, r19
    78ca:	22 0f       	add	r18, r18
    78cc:	33 1f       	adc	r19, r19
    78ce:	22 0f       	add	r18, r18
    78d0:	33 1f       	adc	r19, r19
    78d2:	82 0f       	add	r24, r18
    78d4:	93 1f       	adc	r25, r19
    78d6:	b8 01       	movw	r22, r16
    78d8:	8d 5c       	subi	r24, 0xCD	; 205
    78da:	9f 4d       	sbci	r25, 0xDF	; 223
    78dc:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    78e0:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    78e4:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    78e8:	9e 89       	ldd	r25, Y+22	; 0x16
    78ea:	86 89       	ldd	r24, Z+22	; 0x16
    78ec:	98 17       	cp	r25, r24
    78ee:	68 f0       	brcs	.+26     	; 0x790a <xTaskResumeAll+0xa8>
    78f0:	d0 92 fa 1f 	sts	0x1FFA, r13	; 0x801ffa <xYieldPending>
    78f4:	0a c0       	rjmp	.+20     	; 0x790a <xTaskResumeAll+0xa8>
    78f6:	c0 e0       	ldi	r28, 0x00	; 0
    78f8:	d0 e0       	ldi	r29, 0x00	; 0
    78fa:	0f 2e       	mov	r0, r31
    78fc:	f4 e1       	ldi	r31, 0x14	; 20
    78fe:	ef 2e       	mov	r14, r31
    7900:	f0 e2       	ldi	r31, 0x20	; 32
    7902:	ff 2e       	mov	r15, r31
    7904:	f0 2d       	mov	r31, r0
    7906:	dd 24       	eor	r13, r13
    7908:	d3 94       	inc	r13
    790a:	f7 01       	movw	r30, r14
    790c:	80 81       	ld	r24, Z
    790e:	81 11       	cpse	r24, r1
    7910:	c0 cf       	rjmp	.-128    	; 0x7892 <xTaskResumeAll+0x30>
    7912:	cd 2b       	or	r28, r29
    7914:	09 f0       	breq	.+2      	; 0x7918 <xTaskResumeAll+0xb6>
    7916:	67 dc       	rcall	.-1842   	; 0x71e6 <prvResetNextTaskUnblockTime>
    7918:	c0 91 fb 1f 	lds	r28, 0x1FFB	; 0x801ffb <uxPendedTicks>
    791c:	cc 23       	and	r28, r28
    791e:	49 f0       	breq	.+18     	; 0x7932 <xTaskResumeAll+0xd0>
    7920:	d1 e0       	ldi	r29, 0x01	; 1
    7922:	fd de       	rcall	.-518    	; 0x771e <xTaskIncrementTick>
    7924:	81 11       	cpse	r24, r1
    7926:	d0 93 fa 1f 	sts	0x1FFA, r29	; 0x801ffa <xYieldPending>
    792a:	c1 50       	subi	r28, 0x01	; 1
    792c:	d1 f7       	brne	.-12     	; 0x7922 <xTaskResumeAll+0xc0>
    792e:	10 92 fb 1f 	sts	0x1FFB, r1	; 0x801ffb <uxPendedTicks>
    7932:	80 91 fa 1f 	lds	r24, 0x1FFA	; 0x801ffa <xYieldPending>
    7936:	88 23       	and	r24, r24
    7938:	31 f0       	breq	.+12     	; 0x7946 <xTaskResumeAll+0xe4>
    793a:	0e 94 e6 33 	call	0x67cc	; 0x67cc <vPortYield>
    793e:	81 e0       	ldi	r24, 0x01	; 1
    7940:	03 c0       	rjmp	.+6      	; 0x7948 <xTaskResumeAll+0xe6>
    7942:	80 e0       	ldi	r24, 0x00	; 0
    7944:	01 c0       	rjmp	.+2      	; 0x7948 <xTaskResumeAll+0xe6>
    7946:	80 e0       	ldi	r24, 0x00	; 0
    7948:	0f 90       	pop	r0
    794a:	0f be       	out	0x3f, r0	; 63
    794c:	df 91       	pop	r29
    794e:	cf 91       	pop	r28
    7950:	1f 91       	pop	r17
    7952:	0f 91       	pop	r16
    7954:	ff 90       	pop	r15
    7956:	ef 90       	pop	r14
    7958:	df 90       	pop	r13
    795a:	08 95       	ret

0000795c <vTaskDelay>:
    795c:	cf 93       	push	r28
    795e:	df 93       	push	r29
    7960:	ec 01       	movw	r28, r24
    7962:	89 2b       	or	r24, r25
    7964:	39 f0       	breq	.+14     	; 0x7974 <vTaskDelay+0x18>
    7966:	c0 de       	rcall	.-640    	; 0x76e8 <vTaskSuspendAll>
    7968:	60 e0       	ldi	r22, 0x00	; 0
    796a:	ce 01       	movw	r24, r28
    796c:	8f dc       	rcall	.-1762   	; 0x728c <prvAddCurrentTaskToDelayedList>
    796e:	79 df       	rcall	.-270    	; 0x7862 <xTaskResumeAll>
    7970:	81 11       	cpse	r24, r1
    7972:	02 c0       	rjmp	.+4      	; 0x7978 <vTaskDelay+0x1c>
    7974:	0e 94 e6 33 	call	0x67cc	; 0x67cc <vPortYield>
    7978:	df 91       	pop	r29
    797a:	cf 91       	pop	r28
    797c:	08 95       	ret

0000797e <vTaskPlaceOnEventList>:
    797e:	cf 93       	push	r28
    7980:	df 93       	push	r29
    7982:	eb 01       	movw	r28, r22
    7984:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    7988:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    798c:	64 5f       	subi	r22, 0xF4	; 244
    798e:	7f 4f       	sbci	r23, 0xFF	; 255
    7990:	0e 94 dd 32 	call	0x65ba	; 0x65ba <vListInsert>
    7994:	61 e0       	ldi	r22, 0x01	; 1
    7996:	ce 01       	movw	r24, r28
    7998:	79 dc       	rcall	.-1806   	; 0x728c <prvAddCurrentTaskToDelayedList>
    799a:	df 91       	pop	r29
    799c:	cf 91       	pop	r28
    799e:	08 95       	ret

000079a0 <vTaskPlaceOnEventListRestricted>:
    79a0:	0f 93       	push	r16
    79a2:	1f 93       	push	r17
    79a4:	cf 93       	push	r28
    79a6:	8b 01       	movw	r16, r22
    79a8:	c4 2f       	mov	r28, r20
    79aa:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    79ae:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    79b2:	64 5f       	subi	r22, 0xF4	; 244
    79b4:	7f 4f       	sbci	r23, 0xFF	; 255
    79b6:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    79ba:	cc 23       	and	r28, r28
    79bc:	11 f0       	breq	.+4      	; 0x79c2 <vTaskPlaceOnEventListRestricted+0x22>
    79be:	0f ef       	ldi	r16, 0xFF	; 255
    79c0:	1f ef       	ldi	r17, 0xFF	; 255
    79c2:	6c 2f       	mov	r22, r28
    79c4:	c8 01       	movw	r24, r16
    79c6:	62 dc       	rcall	.-1852   	; 0x728c <prvAddCurrentTaskToDelayedList>
    79c8:	cf 91       	pop	r28
    79ca:	1f 91       	pop	r17
    79cc:	0f 91       	pop	r16
    79ce:	08 95       	ret

000079d0 <xTaskRemoveFromEventList>:
    79d0:	0f 93       	push	r16
    79d2:	1f 93       	push	r17
    79d4:	cf 93       	push	r28
    79d6:	df 93       	push	r29
    79d8:	dc 01       	movw	r26, r24
    79da:	15 96       	adiw	r26, 0x05	; 5
    79dc:	ed 91       	ld	r30, X+
    79de:	fc 91       	ld	r31, X
    79e0:	16 97       	sbiw	r26, 0x06	; 6
    79e2:	c6 81       	ldd	r28, Z+6	; 0x06
    79e4:	d7 81       	ldd	r29, Z+7	; 0x07
    79e6:	8e 01       	movw	r16, r28
    79e8:	04 5f       	subi	r16, 0xF4	; 244
    79ea:	1f 4f       	sbci	r17, 0xFF	; 255
    79ec:	c8 01       	movw	r24, r16
    79ee:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    79f2:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    79f6:	81 11       	cpse	r24, r1
    79f8:	1c c0       	rjmp	.+56     	; 0x7a32 <xTaskRemoveFromEventList+0x62>
    79fa:	0a 50       	subi	r16, 0x0A	; 10
    79fc:	11 09       	sbc	r17, r1
    79fe:	c8 01       	movw	r24, r16
    7a00:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    7a04:	8e 89       	ldd	r24, Y+22	; 0x16
    7a06:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    7a0a:	98 17       	cp	r25, r24
    7a0c:	10 f4       	brcc	.+4      	; 0x7a12 <xTaskRemoveFromEventList+0x42>
    7a0e:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7a12:	90 e0       	ldi	r25, 0x00	; 0
    7a14:	9c 01       	movw	r18, r24
    7a16:	22 0f       	add	r18, r18
    7a18:	33 1f       	adc	r19, r19
    7a1a:	22 0f       	add	r18, r18
    7a1c:	33 1f       	adc	r19, r19
    7a1e:	22 0f       	add	r18, r18
    7a20:	33 1f       	adc	r19, r19
    7a22:	82 0f       	add	r24, r18
    7a24:	93 1f       	adc	r25, r19
    7a26:	b8 01       	movw	r22, r16
    7a28:	8d 5c       	subi	r24, 0xCD	; 205
    7a2a:	9f 4d       	sbci	r25, 0xDF	; 223
    7a2c:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7a30:	05 c0       	rjmp	.+10     	; 0x7a3c <xTaskRemoveFromEventList+0x6c>
    7a32:	b8 01       	movw	r22, r16
    7a34:	84 e1       	ldi	r24, 0x14	; 20
    7a36:	90 e2       	ldi	r25, 0x20	; 32
    7a38:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7a3c:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    7a40:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7a44:	9e 89       	ldd	r25, Y+22	; 0x16
    7a46:	86 89       	ldd	r24, Z+22	; 0x16
    7a48:	89 17       	cp	r24, r25
    7a4a:	20 f4       	brcc	.+8      	; 0x7a54 <xTaskRemoveFromEventList+0x84>
    7a4c:	81 e0       	ldi	r24, 0x01	; 1
    7a4e:	80 93 fa 1f 	sts	0x1FFA, r24	; 0x801ffa <xYieldPending>
    7a52:	01 c0       	rjmp	.+2      	; 0x7a56 <xTaskRemoveFromEventList+0x86>
    7a54:	80 e0       	ldi	r24, 0x00	; 0
    7a56:	df 91       	pop	r29
    7a58:	cf 91       	pop	r28
    7a5a:	1f 91       	pop	r17
    7a5c:	0f 91       	pop	r16
    7a5e:	08 95       	ret

00007a60 <vTaskInternalSetTimeOutState>:
    7a60:	20 91 f9 1f 	lds	r18, 0x1FF9	; 0x801ff9 <xNumOfOverflows>
    7a64:	fc 01       	movw	r30, r24
    7a66:	20 83       	st	Z, r18
    7a68:	20 91 fe 1f 	lds	r18, 0x1FFE	; 0x801ffe <xTickCount>
    7a6c:	30 91 ff 1f 	lds	r19, 0x1FFF	; 0x801fff <xTickCount+0x1>
    7a70:	32 83       	std	Z+2, r19	; 0x02
    7a72:	21 83       	std	Z+1, r18	; 0x01
    7a74:	08 95       	ret

00007a76 <xTaskCheckForTimeOut>:
    7a76:	cf 93       	push	r28
    7a78:	df 93       	push	r29
    7a7a:	0f b6       	in	r0, 0x3f	; 63
    7a7c:	f8 94       	cli
    7a7e:	0f 92       	push	r0
    7a80:	20 91 fe 1f 	lds	r18, 0x1FFE	; 0x801ffe <xTickCount>
    7a84:	30 91 ff 1f 	lds	r19, 0x1FFF	; 0x801fff <xTickCount+0x1>
    7a88:	db 01       	movw	r26, r22
    7a8a:	4d 91       	ld	r20, X+
    7a8c:	5c 91       	ld	r21, X
    7a8e:	4f 3f       	cpi	r20, 0xFF	; 255
    7a90:	bf ef       	ldi	r27, 0xFF	; 255
    7a92:	5b 07       	cpc	r21, r27
    7a94:	e9 f0       	breq	.+58     	; 0x7ad0 <xTaskCheckForTimeOut+0x5a>
    7a96:	ec 01       	movw	r28, r24
    7a98:	e9 81       	ldd	r30, Y+1	; 0x01
    7a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    7a9c:	a0 91 f9 1f 	lds	r26, 0x1FF9	; 0x801ff9 <xNumOfOverflows>
    7aa0:	b8 81       	ld	r27, Y
    7aa2:	ba 17       	cp	r27, r26
    7aa4:	19 f0       	breq	.+6      	; 0x7aac <xTaskCheckForTimeOut+0x36>
    7aa6:	2e 17       	cp	r18, r30
    7aa8:	3f 07       	cpc	r19, r31
    7aaa:	a0 f4       	brcc	.+40     	; 0x7ad4 <xTaskCheckForTimeOut+0x5e>
    7aac:	2e 1b       	sub	r18, r30
    7aae:	3f 0b       	sbc	r19, r31
    7ab0:	24 17       	cp	r18, r20
    7ab2:	35 07       	cpc	r19, r21
    7ab4:	40 f4       	brcc	.+16     	; 0x7ac6 <xTaskCheckForTimeOut+0x50>
    7ab6:	fb 01       	movw	r30, r22
    7ab8:	42 1b       	sub	r20, r18
    7aba:	53 0b       	sbc	r21, r19
    7abc:	51 83       	std	Z+1, r21	; 0x01
    7abe:	40 83       	st	Z, r20
    7ac0:	cf df       	rcall	.-98     	; 0x7a60 <vTaskInternalSetTimeOutState>
    7ac2:	80 e0       	ldi	r24, 0x00	; 0
    7ac4:	08 c0       	rjmp	.+16     	; 0x7ad6 <xTaskCheckForTimeOut+0x60>
    7ac6:	fb 01       	movw	r30, r22
    7ac8:	11 82       	std	Z+1, r1	; 0x01
    7aca:	10 82       	st	Z, r1
    7acc:	81 e0       	ldi	r24, 0x01	; 1
    7ace:	03 c0       	rjmp	.+6      	; 0x7ad6 <xTaskCheckForTimeOut+0x60>
    7ad0:	80 e0       	ldi	r24, 0x00	; 0
    7ad2:	01 c0       	rjmp	.+2      	; 0x7ad6 <xTaskCheckForTimeOut+0x60>
    7ad4:	81 e0       	ldi	r24, 0x01	; 1
    7ad6:	0f 90       	pop	r0
    7ad8:	0f be       	out	0x3f, r0	; 63
    7ada:	df 91       	pop	r29
    7adc:	cf 91       	pop	r28
    7ade:	08 95       	ret

00007ae0 <vTaskMissedYield>:
    7ae0:	81 e0       	ldi	r24, 0x01	; 1
    7ae2:	80 93 fa 1f 	sts	0x1FFA, r24	; 0x801ffa <xYieldPending>
    7ae6:	08 95       	ret

00007ae8 <vTaskGetInfo>:
    7ae8:	ff 92       	push	r15
    7aea:	0f 93       	push	r16
    7aec:	1f 93       	push	r17
    7aee:	cf 93       	push	r28
    7af0:	df 93       	push	r29
    7af2:	8c 01       	movw	r16, r24
    7af4:	eb 01       	movw	r28, r22
    7af6:	f4 2e       	mov	r15, r20
    7af8:	89 2b       	or	r24, r25
    7afa:	21 f4       	brne	.+8      	; 0x7b04 <vTaskGetInfo+0x1c>
    7afc:	00 91 57 20 	lds	r16, 0x2057	; 0x802057 <pxCurrentTCB>
    7b00:	10 91 58 20 	lds	r17, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7b04:	19 83       	std	Y+1, r17	; 0x01
    7b06:	08 83       	st	Y, r16
    7b08:	c8 01       	movw	r24, r16
    7b0a:	49 96       	adiw	r24, 0x19	; 25
    7b0c:	9b 83       	std	Y+3, r25	; 0x03
    7b0e:	8a 83       	std	Y+2, r24	; 0x02
    7b10:	d8 01       	movw	r26, r16
    7b12:	56 96       	adiw	r26, 0x16	; 22
    7b14:	8c 91       	ld	r24, X
    7b16:	56 97       	sbiw	r26, 0x16	; 22
    7b18:	8e 83       	std	Y+6, r24	; 0x06
    7b1a:	57 96       	adiw	r26, 0x17	; 23
    7b1c:	8d 91       	ld	r24, X+
    7b1e:	9c 91       	ld	r25, X
    7b20:	58 97       	sbiw	r26, 0x18	; 24
    7b22:	9d 87       	std	Y+13, r25	; 0x0d
    7b24:	8c 87       	std	Y+12, r24	; 0x0c
    7b26:	99 96       	adiw	r26, 0x29	; 41
    7b28:	8c 91       	ld	r24, X
    7b2a:	99 97       	sbiw	r26, 0x29	; 41
    7b2c:	8c 83       	std	Y+4, r24	; 0x04
    7b2e:	9b 96       	adiw	r26, 0x2b	; 43
    7b30:	8c 91       	ld	r24, X
    7b32:	8f 83       	std	Y+7, r24	; 0x07
    7b34:	18 86       	std	Y+8, r1	; 0x08
    7b36:	19 86       	std	Y+9, r1	; 0x09
    7b38:	1a 86       	std	Y+10, r1	; 0x0a
    7b3a:	1b 86       	std	Y+11, r1	; 0x0b
    7b3c:	25 30       	cpi	r18, 0x05	; 5
    7b3e:	b1 f0       	breq	.+44     	; 0x7b6c <vTaskGetInfo+0x84>
    7b40:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    7b44:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7b48:	08 17       	cp	r16, r24
    7b4a:	19 07       	cpc	r17, r25
    7b4c:	11 f4       	brne	.+4      	; 0x7b52 <vTaskGetInfo+0x6a>
    7b4e:	1d 82       	std	Y+5, r1	; 0x05
    7b50:	10 c0       	rjmp	.+32     	; 0x7b72 <vTaskGetInfo+0x8a>
    7b52:	2d 83       	std	Y+5, r18	; 0x05
    7b54:	23 30       	cpi	r18, 0x03	; 3
    7b56:	69 f4       	brne	.+26     	; 0x7b72 <vTaskGetInfo+0x8a>
    7b58:	c7 dd       	rcall	.-1138   	; 0x76e8 <vTaskSuspendAll>
    7b5a:	f8 01       	movw	r30, r16
    7b5c:	84 89       	ldd	r24, Z+20	; 0x14
    7b5e:	95 89       	ldd	r25, Z+21	; 0x15
    7b60:	89 2b       	or	r24, r25
    7b62:	11 f0       	breq	.+4      	; 0x7b68 <vTaskGetInfo+0x80>
    7b64:	82 e0       	ldi	r24, 0x02	; 2
    7b66:	8d 83       	std	Y+5, r24	; 0x05
    7b68:	7c de       	rcall	.-776    	; 0x7862 <xTaskResumeAll>
    7b6a:	03 c0       	rjmp	.+6      	; 0x7b72 <vTaskGetInfo+0x8a>
    7b6c:	c8 01       	movw	r24, r16
    7b6e:	f9 dc       	rcall	.-1550   	; 0x7562 <eTaskGetState>
    7b70:	8d 83       	std	Y+5, r24	; 0x05
    7b72:	ff 20       	and	r15, r15
    7b74:	c9 f0       	breq	.+50     	; 0x7ba8 <vTaskGetInfo+0xc0>
    7b76:	d8 01       	movw	r26, r16
    7b78:	57 96       	adiw	r26, 0x17	; 23
    7b7a:	ed 91       	ld	r30, X+
    7b7c:	fc 91       	ld	r31, X
    7b7e:	58 97       	sbiw	r26, 0x18	; 24
    7b80:	80 81       	ld	r24, Z
    7b82:	85 3a       	cpi	r24, 0xA5	; 165
    7b84:	59 f4       	brne	.+22     	; 0x7b9c <vTaskGetInfo+0xb4>
    7b86:	31 96       	adiw	r30, 0x01	; 1
    7b88:	80 e0       	ldi	r24, 0x00	; 0
    7b8a:	90 e0       	ldi	r25, 0x00	; 0
    7b8c:	dc 01       	movw	r26, r24
    7b8e:	01 96       	adiw	r24, 0x01	; 1
    7b90:	a1 1d       	adc	r26, r1
    7b92:	b1 1d       	adc	r27, r1
    7b94:	21 91       	ld	r18, Z+
    7b96:	25 3a       	cpi	r18, 0xA5	; 165
    7b98:	d1 f3       	breq	.-12     	; 0x7b8e <vTaskGetInfo+0xa6>
    7b9a:	03 c0       	rjmp	.+6      	; 0x7ba2 <vTaskGetInfo+0xba>
    7b9c:	80 e0       	ldi	r24, 0x00	; 0
    7b9e:	90 e0       	ldi	r25, 0x00	; 0
    7ba0:	dc 01       	movw	r26, r24
    7ba2:	9f 87       	std	Y+15, r25	; 0x0f
    7ba4:	8e 87       	std	Y+14, r24	; 0x0e
    7ba6:	02 c0       	rjmp	.+4      	; 0x7bac <vTaskGetInfo+0xc4>
    7ba8:	1f 86       	std	Y+15, r1	; 0x0f
    7baa:	1e 86       	std	Y+14, r1	; 0x0e
    7bac:	df 91       	pop	r29
    7bae:	cf 91       	pop	r28
    7bb0:	1f 91       	pop	r17
    7bb2:	0f 91       	pop	r16
    7bb4:	ff 90       	pop	r15
    7bb6:	08 95       	ret

00007bb8 <prvListTasksWithinSingleList>:
    7bb8:	8f 92       	push	r8
    7bba:	9f 92       	push	r9
    7bbc:	af 92       	push	r10
    7bbe:	bf 92       	push	r11
    7bc0:	cf 92       	push	r12
    7bc2:	df 92       	push	r13
    7bc4:	ef 92       	push	r14
    7bc6:	ff 92       	push	r15
    7bc8:	0f 93       	push	r16
    7bca:	1f 93       	push	r17
    7bcc:	cf 93       	push	r28
    7bce:	df 93       	push	r29
    7bd0:	6c 01       	movw	r12, r24
    7bd2:	eb 01       	movw	r28, r22
    7bd4:	98 81       	ld	r25, Y
    7bd6:	99 23       	and	r25, r25
    7bd8:	c1 f1       	breq	.+112    	; 0x7c4a <prvListTasksWithinSingleList+0x92>
    7bda:	e9 81       	ldd	r30, Y+1	; 0x01
    7bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    7bde:	02 80       	ldd	r0, Z+2	; 0x02
    7be0:	f3 81       	ldd	r31, Z+3	; 0x03
    7be2:	e0 2d       	mov	r30, r0
    7be4:	fa 83       	std	Y+2, r31	; 0x02
    7be6:	e9 83       	std	Y+1, r30	; 0x01
    7be8:	5b 01       	movw	r10, r22
    7bea:	83 e0       	ldi	r24, 0x03	; 3
    7bec:	a8 0e       	add	r10, r24
    7bee:	b1 1c       	adc	r11, r1
    7bf0:	ea 15       	cp	r30, r10
    7bf2:	fb 05       	cpc	r31, r11
    7bf4:	21 f4       	brne	.+8      	; 0x7bfe <prvListTasksWithinSingleList+0x46>
    7bf6:	82 81       	ldd	r24, Z+2	; 0x02
    7bf8:	93 81       	ldd	r25, Z+3	; 0x03
    7bfa:	9a 83       	std	Y+2, r25	; 0x02
    7bfc:	89 83       	std	Y+1, r24	; 0x01
    7bfe:	04 2f       	mov	r16, r20
    7c00:	e9 81       	ldd	r30, Y+1	; 0x01
    7c02:	fa 81       	ldd	r31, Y+2	; 0x02
    7c04:	86 80       	ldd	r8, Z+6	; 0x06
    7c06:	97 80       	ldd	r9, Z+7	; 0x07
    7c08:	10 e0       	ldi	r17, 0x00	; 0
    7c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    7c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    7c0e:	82 81       	ldd	r24, Z+2	; 0x02
    7c10:	93 81       	ldd	r25, Z+3	; 0x03
    7c12:	9a 83       	std	Y+2, r25	; 0x02
    7c14:	89 83       	std	Y+1, r24	; 0x01
    7c16:	a8 16       	cp	r10, r24
    7c18:	b9 06       	cpc	r11, r25
    7c1a:	21 f4       	brne	.+8      	; 0x7c24 <prvListTasksWithinSingleList+0x6c>
    7c1c:	8d 81       	ldd	r24, Y+5	; 0x05
    7c1e:	9e 81       	ldd	r25, Y+6	; 0x06
    7c20:	9a 83       	std	Y+2, r25	; 0x02
    7c22:	89 83       	std	Y+1, r24	; 0x01
    7c24:	e9 81       	ldd	r30, Y+1	; 0x01
    7c26:	fa 81       	ldd	r31, Y+2	; 0x02
    7c28:	e6 80       	ldd	r14, Z+6	; 0x06
    7c2a:	f7 80       	ldd	r15, Z+7	; 0x07
    7c2c:	b6 01       	movw	r22, r12
    7c2e:	80 e1       	ldi	r24, 0x10	; 16
    7c30:	18 9f       	mul	r17, r24
    7c32:	60 0d       	add	r22, r0
    7c34:	71 1d       	adc	r23, r1
    7c36:	11 24       	eor	r1, r1
    7c38:	20 2f       	mov	r18, r16
    7c3a:	41 e0       	ldi	r20, 0x01	; 1
    7c3c:	c7 01       	movw	r24, r14
    7c3e:	54 df       	rcall	.-344    	; 0x7ae8 <vTaskGetInfo>
    7c40:	1f 5f       	subi	r17, 0xFF	; 255
    7c42:	8e 14       	cp	r8, r14
    7c44:	9f 04       	cpc	r9, r15
    7c46:	09 f7       	brne	.-62     	; 0x7c0a <prvListTasksWithinSingleList+0x52>
    7c48:	01 c0       	rjmp	.+2      	; 0x7c4c <prvListTasksWithinSingleList+0x94>
    7c4a:	10 e0       	ldi	r17, 0x00	; 0
    7c4c:	81 2f       	mov	r24, r17
    7c4e:	df 91       	pop	r29
    7c50:	cf 91       	pop	r28
    7c52:	1f 91       	pop	r17
    7c54:	0f 91       	pop	r16
    7c56:	ff 90       	pop	r15
    7c58:	ef 90       	pop	r14
    7c5a:	df 90       	pop	r13
    7c5c:	cf 90       	pop	r12
    7c5e:	bf 90       	pop	r11
    7c60:	af 90       	pop	r10
    7c62:	9f 90       	pop	r9
    7c64:	8f 90       	pop	r8
    7c66:	08 95       	ret

00007c68 <uxTaskGetSystemState>:
    7c68:	ef 92       	push	r14
    7c6a:	ff 92       	push	r15
    7c6c:	0f 93       	push	r16
    7c6e:	1f 93       	push	r17
    7c70:	cf 93       	push	r28
    7c72:	df 93       	push	r29
    7c74:	7c 01       	movw	r14, r24
    7c76:	c6 2f       	mov	r28, r22
    7c78:	8a 01       	movw	r16, r20
    7c7a:	36 dd       	rcall	.-1428   	; 0x76e8 <vTaskSuspendAll>
    7c7c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    7c80:	c8 17       	cp	r28, r24
    7c82:	08 f4       	brcc	.+2      	; 0x7c86 <uxTaskGetSystemState+0x1e>
    7c84:	54 c0       	rjmp	.+168    	; 0x7d2e <uxTaskGetSystemState+0xc6>
    7c86:	d4 e0       	ldi	r29, 0x04	; 4
    7c88:	c0 e0       	ldi	r28, 0x00	; 0
    7c8a:	d1 50       	subi	r29, 0x01	; 1
    7c8c:	6d 2f       	mov	r22, r29
    7c8e:	70 e0       	ldi	r23, 0x00	; 0
    7c90:	cb 01       	movw	r24, r22
    7c92:	88 0f       	add	r24, r24
    7c94:	99 1f       	adc	r25, r25
    7c96:	88 0f       	add	r24, r24
    7c98:	99 1f       	adc	r25, r25
    7c9a:	88 0f       	add	r24, r24
    7c9c:	99 1f       	adc	r25, r25
    7c9e:	68 0f       	add	r22, r24
    7ca0:	79 1f       	adc	r23, r25
    7ca2:	6d 5c       	subi	r22, 0xCD	; 205
    7ca4:	7f 4d       	sbci	r23, 0xDF	; 223
    7ca6:	41 e0       	ldi	r20, 0x01	; 1
    7ca8:	c7 01       	movw	r24, r14
    7caa:	20 e1       	ldi	r18, 0x10	; 16
    7cac:	c2 9f       	mul	r28, r18
    7cae:	80 0d       	add	r24, r0
    7cb0:	91 1d       	adc	r25, r1
    7cb2:	11 24       	eor	r1, r1
    7cb4:	81 df       	rcall	.-254    	; 0x7bb8 <prvListTasksWithinSingleList>
    7cb6:	c8 0f       	add	r28, r24
    7cb8:	d1 11       	cpse	r29, r1
    7cba:	e7 cf       	rjmp	.-50     	; 0x7c8a <uxTaskGetSystemState+0x22>
    7cbc:	60 91 1f 20 	lds	r22, 0x201F	; 0x80201f <pxDelayedTaskList>
    7cc0:	70 91 20 20 	lds	r23, 0x2020	; 0x802020 <pxDelayedTaskList+0x1>
    7cc4:	42 e0       	ldi	r20, 0x02	; 2
    7cc6:	c7 01       	movw	r24, r14
    7cc8:	e0 e1       	ldi	r30, 0x10	; 16
    7cca:	ce 9f       	mul	r28, r30
    7ccc:	80 0d       	add	r24, r0
    7cce:	91 1d       	adc	r25, r1
    7cd0:	11 24       	eor	r1, r1
    7cd2:	72 df       	rcall	.-284    	; 0x7bb8 <prvListTasksWithinSingleList>
    7cd4:	c8 0f       	add	r28, r24
    7cd6:	60 91 1d 20 	lds	r22, 0x201D	; 0x80201d <pxOverflowDelayedTaskList>
    7cda:	70 91 1e 20 	lds	r23, 0x201E	; 0x80201e <pxOverflowDelayedTaskList+0x1>
    7cde:	42 e0       	ldi	r20, 0x02	; 2
    7ce0:	c7 01       	movw	r24, r14
    7ce2:	f0 e1       	ldi	r31, 0x10	; 16
    7ce4:	cf 9f       	mul	r28, r31
    7ce6:	80 0d       	add	r24, r0
    7ce8:	91 1d       	adc	r25, r1
    7cea:	11 24       	eor	r1, r1
    7cec:	65 df       	rcall	.-310    	; 0x7bb8 <prvListTasksWithinSingleList>
    7cee:	c8 0f       	add	r28, r24
    7cf0:	44 e0       	ldi	r20, 0x04	; 4
    7cf2:	6b e0       	ldi	r22, 0x0B	; 11
    7cf4:	70 e2       	ldi	r23, 0x20	; 32
    7cf6:	c7 01       	movw	r24, r14
    7cf8:	20 e1       	ldi	r18, 0x10	; 16
    7cfa:	c2 9f       	mul	r28, r18
    7cfc:	80 0d       	add	r24, r0
    7cfe:	91 1d       	adc	r25, r1
    7d00:	11 24       	eor	r1, r1
    7d02:	5a df       	rcall	.-332    	; 0x7bb8 <prvListTasksWithinSingleList>
    7d04:	c8 0f       	add	r28, r24
    7d06:	43 e0       	ldi	r20, 0x03	; 3
    7d08:	61 e0       	ldi	r22, 0x01	; 1
    7d0a:	70 e2       	ldi	r23, 0x20	; 32
    7d0c:	c7 01       	movw	r24, r14
    7d0e:	e0 e1       	ldi	r30, 0x10	; 16
    7d10:	ce 9f       	mul	r28, r30
    7d12:	80 0d       	add	r24, r0
    7d14:	91 1d       	adc	r25, r1
    7d16:	11 24       	eor	r1, r1
    7d18:	4f df       	rcall	.-354    	; 0x7bb8 <prvListTasksWithinSingleList>
    7d1a:	c8 0f       	add	r28, r24
    7d1c:	01 15       	cp	r16, r1
    7d1e:	11 05       	cpc	r17, r1
    7d20:	39 f0       	breq	.+14     	; 0x7d30 <uxTaskGetSystemState+0xc8>
    7d22:	f8 01       	movw	r30, r16
    7d24:	10 82       	st	Z, r1
    7d26:	11 82       	std	Z+1, r1	; 0x01
    7d28:	12 82       	std	Z+2, r1	; 0x02
    7d2a:	13 82       	std	Z+3, r1	; 0x03
    7d2c:	01 c0       	rjmp	.+2      	; 0x7d30 <uxTaskGetSystemState+0xc8>
    7d2e:	c0 e0       	ldi	r28, 0x00	; 0
    7d30:	98 dd       	rcall	.-1232   	; 0x7862 <xTaskResumeAll>
    7d32:	8c 2f       	mov	r24, r28
    7d34:	df 91       	pop	r29
    7d36:	cf 91       	pop	r28
    7d38:	1f 91       	pop	r17
    7d3a:	0f 91       	pop	r16
    7d3c:	ff 90       	pop	r15
    7d3e:	ef 90       	pop	r14
    7d40:	08 95       	ret

00007d42 <uxTaskGetStackHighWaterMark2>:
    7d42:	00 97       	sbiw	r24, 0x00	; 0
    7d44:	21 f4       	brne	.+8      	; 0x7d4e <uxTaskGetStackHighWaterMark2+0xc>
    7d46:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    7d4a:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7d4e:	dc 01       	movw	r26, r24
    7d50:	57 96       	adiw	r26, 0x17	; 23
    7d52:	ed 91       	ld	r30, X+
    7d54:	fc 91       	ld	r31, X
    7d56:	58 97       	sbiw	r26, 0x18	; 24
    7d58:	80 81       	ld	r24, Z
    7d5a:	85 3a       	cpi	r24, 0xA5	; 165
    7d5c:	59 f4       	brne	.+22     	; 0x7d74 <uxTaskGetStackHighWaterMark2+0x32>
    7d5e:	31 96       	adiw	r30, 0x01	; 1
    7d60:	80 e0       	ldi	r24, 0x00	; 0
    7d62:	90 e0       	ldi	r25, 0x00	; 0
    7d64:	dc 01       	movw	r26, r24
    7d66:	01 96       	adiw	r24, 0x01	; 1
    7d68:	a1 1d       	adc	r26, r1
    7d6a:	b1 1d       	adc	r27, r1
    7d6c:	21 91       	ld	r18, Z+
    7d6e:	25 3a       	cpi	r18, 0xA5	; 165
    7d70:	d1 f3       	breq	.-12     	; 0x7d66 <uxTaskGetStackHighWaterMark2+0x24>
    7d72:	08 95       	ret
    7d74:	80 e0       	ldi	r24, 0x00	; 0
    7d76:	90 e0       	ldi	r25, 0x00	; 0
    7d78:	dc 01       	movw	r26, r24
    7d7a:	08 95       	ret

00007d7c <xTaskGetSchedulerState>:
    7d7c:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xSchedulerRunning>
    7d80:	88 23       	and	r24, r24
    7d82:	31 f0       	breq	.+12     	; 0x7d90 <xTaskGetSchedulerState+0x14>
    7d84:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
    7d88:	88 23       	and	r24, r24
    7d8a:	21 f0       	breq	.+8      	; 0x7d94 <xTaskGetSchedulerState+0x18>
    7d8c:	80 e0       	ldi	r24, 0x00	; 0
    7d8e:	08 95       	ret
    7d90:	81 e0       	ldi	r24, 0x01	; 1
    7d92:	08 95       	ret
    7d94:	82 e0       	ldi	r24, 0x02	; 2
    7d96:	08 95       	ret

00007d98 <xTaskPriorityInherit>:
    7d98:	0f 93       	push	r16
    7d9a:	1f 93       	push	r17
    7d9c:	cf 93       	push	r28
    7d9e:	df 93       	push	r29
    7da0:	fc 01       	movw	r30, r24
    7da2:	89 2b       	or	r24, r25
    7da4:	09 f4       	brne	.+2      	; 0x7da8 <xTaskPriorityInherit+0x10>
    7da6:	64 c0       	rjmp	.+200    	; 0x7e70 <xTaskPriorityInherit+0xd8>
    7da8:	26 89       	ldd	r18, Z+22	; 0x16
    7daa:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    7dae:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7db2:	56 96       	adiw	r26, 0x16	; 22
    7db4:	8c 91       	ld	r24, X
    7db6:	28 17       	cp	r18, r24
    7db8:	08 f0       	brcs	.+2      	; 0x7dbc <xTaskPriorityInherit+0x24>
    7dba:	4e c0       	rjmp	.+156    	; 0x7e58 <xTaskPriorityInherit+0xc0>
    7dbc:	84 85       	ldd	r24, Z+12	; 0x0c
    7dbe:	95 85       	ldd	r25, Z+13	; 0x0d
    7dc0:	99 23       	and	r25, r25
    7dc2:	64 f0       	brlt	.+24     	; 0x7ddc <xTaskPriorityInherit+0x44>
    7dc4:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    7dc8:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7dcc:	56 96       	adiw	r26, 0x16	; 22
    7dce:	3c 91       	ld	r19, X
    7dd0:	84 e0       	ldi	r24, 0x04	; 4
    7dd2:	90 e0       	ldi	r25, 0x00	; 0
    7dd4:	83 1b       	sub	r24, r19
    7dd6:	91 09       	sbc	r25, r1
    7dd8:	95 87       	std	Z+13, r25	; 0x0d
    7dda:	84 87       	std	Z+12, r24	; 0x0c
    7ddc:	30 e0       	ldi	r19, 0x00	; 0
    7dde:	c9 01       	movw	r24, r18
    7de0:	88 0f       	add	r24, r24
    7de2:	99 1f       	adc	r25, r25
    7de4:	88 0f       	add	r24, r24
    7de6:	99 1f       	adc	r25, r25
    7de8:	88 0f       	add	r24, r24
    7dea:	99 1f       	adc	r25, r25
    7dec:	28 0f       	add	r18, r24
    7dee:	39 1f       	adc	r19, r25
    7df0:	2d 5c       	subi	r18, 0xCD	; 205
    7df2:	3f 4d       	sbci	r19, 0xDF	; 223
    7df4:	82 85       	ldd	r24, Z+10	; 0x0a
    7df6:	93 85       	ldd	r25, Z+11	; 0x0b
    7df8:	82 17       	cp	r24, r18
    7dfa:	93 07       	cpc	r25, r19
    7dfc:	21 f5       	brne	.+72     	; 0x7e46 <xTaskPriorityInherit+0xae>
    7dfe:	8f 01       	movw	r16, r30
    7e00:	ef 01       	movw	r28, r30
    7e02:	22 96       	adiw	r28, 0x02	; 2
    7e04:	ce 01       	movw	r24, r28
    7e06:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    7e0a:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    7e0e:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7e12:	86 89       	ldd	r24, Z+22	; 0x16
    7e14:	f8 01       	movw	r30, r16
    7e16:	86 8b       	std	Z+22, r24	; 0x16
    7e18:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    7e1c:	98 17       	cp	r25, r24
    7e1e:	10 f4       	brcc	.+4      	; 0x7e24 <xTaskPriorityInherit+0x8c>
    7e20:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7e24:	90 e0       	ldi	r25, 0x00	; 0
    7e26:	9c 01       	movw	r18, r24
    7e28:	22 0f       	add	r18, r18
    7e2a:	33 1f       	adc	r19, r19
    7e2c:	22 0f       	add	r18, r18
    7e2e:	33 1f       	adc	r19, r19
    7e30:	22 0f       	add	r18, r18
    7e32:	33 1f       	adc	r19, r19
    7e34:	82 0f       	add	r24, r18
    7e36:	93 1f       	adc	r25, r19
    7e38:	be 01       	movw	r22, r28
    7e3a:	8d 5c       	subi	r24, 0xCD	; 205
    7e3c:	9f 4d       	sbci	r25, 0xDF	; 223
    7e3e:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7e42:	81 e0       	ldi	r24, 0x01	; 1
    7e44:	16 c0       	rjmp	.+44     	; 0x7e72 <xTaskPriorityInherit+0xda>
    7e46:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    7e4a:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7e4e:	56 96       	adiw	r26, 0x16	; 22
    7e50:	8c 91       	ld	r24, X
    7e52:	86 8b       	std	Z+22, r24	; 0x16
    7e54:	81 e0       	ldi	r24, 0x01	; 1
    7e56:	0d c0       	rjmp	.+26     	; 0x7e72 <xTaskPriorityInherit+0xda>
    7e58:	a0 91 57 20 	lds	r26, 0x2057	; 0x802057 <pxCurrentTCB>
    7e5c:	b0 91 58 20 	lds	r27, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    7e60:	81 e0       	ldi	r24, 0x01	; 1
    7e62:	23 a5       	ldd	r18, Z+43	; 0x2b
    7e64:	56 96       	adiw	r26, 0x16	; 22
    7e66:	9c 91       	ld	r25, X
    7e68:	29 17       	cp	r18, r25
    7e6a:	18 f0       	brcs	.+6      	; 0x7e72 <xTaskPriorityInherit+0xda>
    7e6c:	80 e0       	ldi	r24, 0x00	; 0
    7e6e:	01 c0       	rjmp	.+2      	; 0x7e72 <xTaskPriorityInherit+0xda>
    7e70:	80 e0       	ldi	r24, 0x00	; 0
    7e72:	df 91       	pop	r29
    7e74:	cf 91       	pop	r28
    7e76:	1f 91       	pop	r17
    7e78:	0f 91       	pop	r16
    7e7a:	08 95       	ret

00007e7c <xTaskPriorityDisinherit>:
    7e7c:	0f 93       	push	r16
    7e7e:	1f 93       	push	r17
    7e80:	cf 93       	push	r28
    7e82:	df 93       	push	r29
    7e84:	fc 01       	movw	r30, r24
    7e86:	89 2b       	or	r24, r25
    7e88:	79 f1       	breq	.+94     	; 0x7ee8 <xTaskPriorityDisinherit+0x6c>
    7e8a:	84 a5       	ldd	r24, Z+44	; 0x2c
    7e8c:	81 50       	subi	r24, 0x01	; 1
    7e8e:	84 a7       	std	Z+44, r24	; 0x2c
    7e90:	26 89       	ldd	r18, Z+22	; 0x16
    7e92:	93 a5       	ldd	r25, Z+43	; 0x2b
    7e94:	29 17       	cp	r18, r25
    7e96:	51 f1       	breq	.+84     	; 0x7eec <xTaskPriorityDisinherit+0x70>
    7e98:	81 11       	cpse	r24, r1
    7e9a:	2a c0       	rjmp	.+84     	; 0x7ef0 <xTaskPriorityDisinherit+0x74>
    7e9c:	ef 01       	movw	r28, r30
    7e9e:	8f 01       	movw	r16, r30
    7ea0:	0e 5f       	subi	r16, 0xFE	; 254
    7ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    7ea4:	c8 01       	movw	r24, r16
    7ea6:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    7eaa:	8b a5       	ldd	r24, Y+43	; 0x2b
    7eac:	8e 8b       	std	Y+22, r24	; 0x16
    7eae:	24 e0       	ldi	r18, 0x04	; 4
    7eb0:	30 e0       	ldi	r19, 0x00	; 0
    7eb2:	28 1b       	sub	r18, r24
    7eb4:	31 09       	sbc	r19, r1
    7eb6:	3d 87       	std	Y+13, r19	; 0x0d
    7eb8:	2c 87       	std	Y+12, r18	; 0x0c
    7eba:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    7ebe:	98 17       	cp	r25, r24
    7ec0:	10 f4       	brcc	.+4      	; 0x7ec6 <xTaskPriorityDisinherit+0x4a>
    7ec2:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7ec6:	90 e0       	ldi	r25, 0x00	; 0
    7ec8:	9c 01       	movw	r18, r24
    7eca:	22 0f       	add	r18, r18
    7ecc:	33 1f       	adc	r19, r19
    7ece:	22 0f       	add	r18, r18
    7ed0:	33 1f       	adc	r19, r19
    7ed2:	22 0f       	add	r18, r18
    7ed4:	33 1f       	adc	r19, r19
    7ed6:	82 0f       	add	r24, r18
    7ed8:	93 1f       	adc	r25, r19
    7eda:	b8 01       	movw	r22, r16
    7edc:	8d 5c       	subi	r24, 0xCD	; 205
    7ede:	9f 4d       	sbci	r25, 0xDF	; 223
    7ee0:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7ee4:	81 e0       	ldi	r24, 0x01	; 1
    7ee6:	05 c0       	rjmp	.+10     	; 0x7ef2 <xTaskPriorityDisinherit+0x76>
    7ee8:	80 e0       	ldi	r24, 0x00	; 0
    7eea:	03 c0       	rjmp	.+6      	; 0x7ef2 <xTaskPriorityDisinherit+0x76>
    7eec:	80 e0       	ldi	r24, 0x00	; 0
    7eee:	01 c0       	rjmp	.+2      	; 0x7ef2 <xTaskPriorityDisinherit+0x76>
    7ef0:	80 e0       	ldi	r24, 0x00	; 0
    7ef2:	df 91       	pop	r29
    7ef4:	cf 91       	pop	r28
    7ef6:	1f 91       	pop	r17
    7ef8:	0f 91       	pop	r16
    7efa:	08 95       	ret

00007efc <vTaskPriorityDisinheritAfterTimeout>:
    7efc:	0f 93       	push	r16
    7efe:	1f 93       	push	r17
    7f00:	cf 93       	push	r28
    7f02:	df 93       	push	r29
    7f04:	fc 01       	movw	r30, r24
    7f06:	89 2b       	or	r24, r25
    7f08:	09 f4       	brne	.+2      	; 0x7f0c <vTaskPriorityDisinheritAfterTimeout+0x10>
    7f0a:	43 c0       	rjmp	.+134    	; 0x7f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    7f0c:	93 a5       	ldd	r25, Z+43	; 0x2b
    7f0e:	96 17       	cp	r25, r22
    7f10:	08 f4       	brcc	.+2      	; 0x7f14 <vTaskPriorityDisinheritAfterTimeout+0x18>
    7f12:	96 2f       	mov	r25, r22
    7f14:	86 89       	ldd	r24, Z+22	; 0x16
    7f16:	89 17       	cp	r24, r25
    7f18:	e1 f1       	breq	.+120    	; 0x7f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    7f1a:	24 a5       	ldd	r18, Z+44	; 0x2c
    7f1c:	21 30       	cpi	r18, 0x01	; 1
    7f1e:	c9 f5       	brne	.+114    	; 0x7f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    7f20:	96 8b       	std	Z+22, r25	; 0x16
    7f22:	24 85       	ldd	r18, Z+12	; 0x0c
    7f24:	35 85       	ldd	r19, Z+13	; 0x0d
    7f26:	33 23       	and	r19, r19
    7f28:	34 f0       	brlt	.+12     	; 0x7f36 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    7f2a:	24 e0       	ldi	r18, 0x04	; 4
    7f2c:	30 e0       	ldi	r19, 0x00	; 0
    7f2e:	29 1b       	sub	r18, r25
    7f30:	31 09       	sbc	r19, r1
    7f32:	35 87       	std	Z+13, r19	; 0x0d
    7f34:	24 87       	std	Z+12, r18	; 0x0c
    7f36:	90 e0       	ldi	r25, 0x00	; 0
    7f38:	9c 01       	movw	r18, r24
    7f3a:	22 0f       	add	r18, r18
    7f3c:	33 1f       	adc	r19, r19
    7f3e:	22 0f       	add	r18, r18
    7f40:	33 1f       	adc	r19, r19
    7f42:	22 0f       	add	r18, r18
    7f44:	33 1f       	adc	r19, r19
    7f46:	82 0f       	add	r24, r18
    7f48:	93 1f       	adc	r25, r19
    7f4a:	8d 5c       	subi	r24, 0xCD	; 205
    7f4c:	9f 4d       	sbci	r25, 0xDF	; 223
    7f4e:	22 85       	ldd	r18, Z+10	; 0x0a
    7f50:	33 85       	ldd	r19, Z+11	; 0x0b
    7f52:	28 17       	cp	r18, r24
    7f54:	39 07       	cpc	r19, r25
    7f56:	e9 f4       	brne	.+58     	; 0x7f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    7f58:	ef 01       	movw	r28, r30
    7f5a:	8f 01       	movw	r16, r30
    7f5c:	0e 5f       	subi	r16, 0xFE	; 254
    7f5e:	1f 4f       	sbci	r17, 0xFF	; 255
    7f60:	c8 01       	movw	r24, r16
    7f62:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
    7f66:	8e 89       	ldd	r24, Y+22	; 0x16
    7f68:	90 91 fd 1f 	lds	r25, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    7f6c:	98 17       	cp	r25, r24
    7f6e:	10 f4       	brcc	.+4      	; 0x7f74 <vTaskPriorityDisinheritAfterTimeout+0x78>
    7f70:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <uxTopReadyPriority>
    7f74:	90 e0       	ldi	r25, 0x00	; 0
    7f76:	9c 01       	movw	r18, r24
    7f78:	22 0f       	add	r18, r18
    7f7a:	33 1f       	adc	r19, r19
    7f7c:	22 0f       	add	r18, r18
    7f7e:	33 1f       	adc	r19, r19
    7f80:	22 0f       	add	r18, r18
    7f82:	33 1f       	adc	r19, r19
    7f84:	82 0f       	add	r24, r18
    7f86:	93 1f       	adc	r25, r19
    7f88:	b8 01       	movw	r22, r16
    7f8a:	8d 5c       	subi	r24, 0xCD	; 205
    7f8c:	9f 4d       	sbci	r25, 0xDF	; 223
    7f8e:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>
    7f92:	df 91       	pop	r29
    7f94:	cf 91       	pop	r28
    7f96:	1f 91       	pop	r17
    7f98:	0f 91       	pop	r16
    7f9a:	08 95       	ret

00007f9c <vTaskList>:
    7f9c:	3f 92       	push	r3
    7f9e:	4f 92       	push	r4
    7fa0:	5f 92       	push	r5
    7fa2:	6f 92       	push	r6
    7fa4:	7f 92       	push	r7
    7fa6:	8f 92       	push	r8
    7fa8:	9f 92       	push	r9
    7faa:	af 92       	push	r10
    7fac:	bf 92       	push	r11
    7fae:	cf 92       	push	r12
    7fb0:	df 92       	push	r13
    7fb2:	ef 92       	push	r14
    7fb4:	ff 92       	push	r15
    7fb6:	0f 93       	push	r16
    7fb8:	1f 93       	push	r17
    7fba:	cf 93       	push	r28
    7fbc:	df 93       	push	r29
    7fbe:	ec 01       	movw	r28, r24
    7fc0:	18 82       	st	Y, r1
    7fc2:	10 91 00 20 	lds	r17, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    7fc6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    7fca:	20 e1       	ldi	r18, 0x10	; 16
    7fcc:	82 9f       	mul	r24, r18
    7fce:	c0 01       	movw	r24, r0
    7fd0:	11 24       	eor	r1, r1
    7fd2:	0e 94 f5 31 	call	0x63ea	; 0x63ea <pvPortMalloc>
    7fd6:	6c 01       	movw	r12, r24
    7fd8:	00 97       	sbiw	r24, 0x00	; 0
    7fda:	09 f4       	brne	.+2      	; 0x7fde <vTaskList+0x42>
    7fdc:	85 c0       	rjmp	.+266    	; 0x80e8 <vTaskList+0x14c>
    7fde:	40 e0       	ldi	r20, 0x00	; 0
    7fe0:	50 e0       	ldi	r21, 0x00	; 0
    7fe2:	61 2f       	mov	r22, r17
    7fe4:	41 de       	rcall	.-894    	; 0x7c68 <uxTaskGetSystemState>
    7fe6:	68 2e       	mov	r6, r24
    7fe8:	88 23       	and	r24, r24
    7fea:	09 f4       	brne	.+2      	; 0x7fee <vTaskList+0x52>
    7fec:	7a c0       	rjmp	.+244    	; 0x80e2 <vTaskList+0x146>
    7fee:	86 01       	movw	r16, r12
    7ff0:	81 2c       	mov	r8, r1
    7ff2:	31 2c       	mov	r3, r1
    7ff4:	68 94       	set
    7ff6:	99 24       	eor	r9, r9
    7ff8:	95 f8       	bld	r9, 5
    7ffa:	0f 2e       	mov	r0, r31
    7ffc:	ff e0       	ldi	r31, 0x0F	; 15
    7ffe:	4f 2e       	mov	r4, r31
    8000:	f0 2d       	mov	r31, r0
    8002:	51 2c       	mov	r5, r1
    8004:	0f 2e       	mov	r0, r31
    8006:	f0 e0       	ldi	r31, 0x00	; 0
    8008:	ef 2e       	mov	r14, r31
    800a:	f3 e0       	ldi	r31, 0x03	; 3
    800c:	ff 2e       	mov	r15, r31
    800e:	f0 2d       	mov	r31, r0
    8010:	58 01       	movw	r10, r16
    8012:	f8 01       	movw	r30, r16
    8014:	85 81       	ldd	r24, Z+5	; 0x05
    8016:	82 30       	cpi	r24, 0x02	; 2
    8018:	81 f0       	breq	.+32     	; 0x803a <vTaskList+0x9e>
    801a:	28 f4       	brcc	.+10     	; 0x8026 <vTaskList+0x8a>
    801c:	88 23       	and	r24, r24
    801e:	f1 f0       	breq	.+60     	; 0x805c <vTaskList+0xc0>
    8020:	81 30       	cpi	r24, 0x01	; 1
    8022:	31 f0       	breq	.+12     	; 0x8030 <vTaskList+0x94>
    8024:	19 c0       	rjmp	.+50     	; 0x8058 <vTaskList+0xbc>
    8026:	83 30       	cpi	r24, 0x03	; 3
    8028:	69 f0       	breq	.+26     	; 0x8044 <vTaskList+0xa8>
    802a:	84 30       	cpi	r24, 0x04	; 4
    802c:	81 f0       	breq	.+32     	; 0x804e <vTaskList+0xb2>
    802e:	14 c0       	rjmp	.+40     	; 0x8058 <vTaskList+0xbc>
    8030:	0f 2e       	mov	r0, r31
    8032:	f2 e5       	ldi	r31, 0x52	; 82
    8034:	7f 2e       	mov	r7, r31
    8036:	f0 2d       	mov	r31, r0
    8038:	15 c0       	rjmp	.+42     	; 0x8064 <vTaskList+0xc8>
    803a:	0f 2e       	mov	r0, r31
    803c:	f2 e4       	ldi	r31, 0x42	; 66
    803e:	7f 2e       	mov	r7, r31
    8040:	f0 2d       	mov	r31, r0
    8042:	10 c0       	rjmp	.+32     	; 0x8064 <vTaskList+0xc8>
    8044:	0f 2e       	mov	r0, r31
    8046:	f3 e5       	ldi	r31, 0x53	; 83
    8048:	7f 2e       	mov	r7, r31
    804a:	f0 2d       	mov	r31, r0
    804c:	0b c0       	rjmp	.+22     	; 0x8064 <vTaskList+0xc8>
    804e:	0f 2e       	mov	r0, r31
    8050:	f4 e4       	ldi	r31, 0x44	; 68
    8052:	7f 2e       	mov	r7, r31
    8054:	f0 2d       	mov	r31, r0
    8056:	06 c0       	rjmp	.+12     	; 0x8064 <vTaskList+0xc8>
    8058:	73 2c       	mov	r7, r3
    805a:	04 c0       	rjmp	.+8      	; 0x8064 <vTaskList+0xc8>
    805c:	0f 2e       	mov	r0, r31
    805e:	f8 e5       	ldi	r31, 0x58	; 88
    8060:	7f 2e       	mov	r7, r31
    8062:	f0 2d       	mov	r31, r0
    8064:	f5 01       	movw	r30, r10
    8066:	62 81       	ldd	r22, Z+2	; 0x02
    8068:	73 81       	ldd	r23, Z+3	; 0x03
    806a:	ce 01       	movw	r24, r28
    806c:	67 d5       	rcall	.+2766   	; 0x8b3c <strcpy>
    806e:	fe 01       	movw	r30, r28
    8070:	01 90       	ld	r0, Z+
    8072:	00 20       	and	r0, r0
    8074:	e9 f7       	brne	.-6      	; 0x8070 <vTaskList+0xd4>
    8076:	31 97       	sbiw	r30, 0x01	; 1
    8078:	ec 1b       	sub	r30, r28
    807a:	fd 0b       	sbc	r31, r29
    807c:	ef 30       	cpi	r30, 0x0F	; 15
    807e:	f1 05       	cpc	r31, r1
    8080:	50 f4       	brcc	.+20     	; 0x8096 <vTaskList+0xfa>
    8082:	ec 0f       	add	r30, r28
    8084:	fd 1f       	adc	r31, r29
    8086:	ce 01       	movw	r24, r28
    8088:	0f 96       	adiw	r24, 0x0f	; 15
    808a:	91 92       	st	Z+, r9
    808c:	e8 17       	cp	r30, r24
    808e:	f9 07       	cpc	r31, r25
    8090:	e1 f7       	brne	.-8      	; 0x808a <vTaskList+0xee>
    8092:	e4 2d       	mov	r30, r4
    8094:	f5 2d       	mov	r31, r5
    8096:	ce 0f       	add	r28, r30
    8098:	df 1f       	adc	r29, r31
    809a:	18 82       	st	Y, r1
    809c:	f5 01       	movw	r30, r10
    809e:	84 81       	ldd	r24, Z+4	; 0x04
    80a0:	1f 92       	push	r1
    80a2:	8f 93       	push	r24
    80a4:	87 85       	ldd	r24, Z+15	; 0x0f
    80a6:	8f 93       	push	r24
    80a8:	86 85       	ldd	r24, Z+14	; 0x0e
    80aa:	8f 93       	push	r24
    80ac:	86 81       	ldd	r24, Z+6	; 0x06
    80ae:	1f 92       	push	r1
    80b0:	8f 93       	push	r24
    80b2:	1f 92       	push	r1
    80b4:	7f 92       	push	r7
    80b6:	ff 92       	push	r15
    80b8:	ef 92       	push	r14
    80ba:	df 93       	push	r29
    80bc:	cf 93       	push	r28
    80be:	5d d6       	rcall	.+3258   	; 0x8d7a <sprintf>
    80c0:	09 90       	ld	r0, Y+
    80c2:	00 20       	and	r0, r0
    80c4:	e9 f7       	brne	.-6      	; 0x80c0 <vTaskList+0x124>
    80c6:	21 97       	sbiw	r28, 0x01	; 1
    80c8:	83 94       	inc	r8
    80ca:	00 5f       	subi	r16, 0xF0	; 240
    80cc:	1f 4f       	sbci	r17, 0xFF	; 255
    80ce:	8d b7       	in	r24, 0x3d	; 61
    80d0:	9e b7       	in	r25, 0x3e	; 62
    80d2:	0c 96       	adiw	r24, 0x0c	; 12
    80d4:	0f b6       	in	r0, 0x3f	; 63
    80d6:	f8 94       	cli
    80d8:	9e bf       	out	0x3e, r25	; 62
    80da:	0f be       	out	0x3f, r0	; 63
    80dc:	8d bf       	out	0x3d, r24	; 61
    80de:	68 10       	cpse	r6, r8
    80e0:	97 cf       	rjmp	.-210    	; 0x8010 <vTaskList+0x74>
    80e2:	c6 01       	movw	r24, r12
    80e4:	0e 94 b5 31 	call	0x636a	; 0x636a <vPortFree>
    80e8:	df 91       	pop	r29
    80ea:	cf 91       	pop	r28
    80ec:	1f 91       	pop	r17
    80ee:	0f 91       	pop	r16
    80f0:	ff 90       	pop	r15
    80f2:	ef 90       	pop	r14
    80f4:	df 90       	pop	r13
    80f6:	cf 90       	pop	r12
    80f8:	bf 90       	pop	r11
    80fa:	af 90       	pop	r10
    80fc:	9f 90       	pop	r9
    80fe:	8f 90       	pop	r8
    8100:	7f 90       	pop	r7
    8102:	6f 90       	pop	r6
    8104:	5f 90       	pop	r5
    8106:	4f 90       	pop	r4
    8108:	3f 90       	pop	r3
    810a:	08 95       	ret

0000810c <pvTaskIncrementMutexHeldCount>:
    810c:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    8110:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    8114:	89 2b       	or	r24, r25
    8116:	39 f0       	breq	.+14     	; 0x8126 <pvTaskIncrementMutexHeldCount+0x1a>
    8118:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    811c:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    8120:	84 a5       	ldd	r24, Z+44	; 0x2c
    8122:	8f 5f       	subi	r24, 0xFF	; 255
    8124:	84 a7       	std	Z+44, r24	; 0x2c
    8126:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    812a:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    812e:	08 95       	ret

00008130 <vApplicationStackOverflowHook>:
	#endif

#endif

extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
	printf("ov %s",pcTaskName);
    8130:	7f 93       	push	r23
    8132:	6f 93       	push	r22
    8134:	8f e0       	ldi	r24, 0x0F	; 15
    8136:	93 e0       	ldi	r25, 0x03	; 3
    8138:	9f 93       	push	r25
    813a:	8f 93       	push	r24
    813c:	78 d5       	rcall	.+2800   	; 0x8c2e <printf>
	FORCERESET
    813e:	d4 da       	rcall	.-2648   	; 0x76e8 <vTaskSuspendAll>
    8140:	88 ec       	ldi	r24, 0xC8	; 200
    8142:	92 e0       	ldi	r25, 0x02	; 2
    8144:	ae d5       	rcall	.+2908   	; 0x8ca2 <puts>
    8146:	0f 90       	pop	r0
    8148:	0f 90       	pop	r0
    814a:	0f 90       	pop	r0
    814c:	0f 90       	pop	r0
    814e:	ff cf       	rjmp	.-2      	; 0x814e <vApplicationStackOverflowHook+0x1e>

00008150 <vTaskSwitchContext>:
    8150:	80 91 f3 1f 	lds	r24, 0x1FF3	; 0x801ff3 <uxSchedulerSuspended>
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    8154:	88 23       	and	r24, r24
    8156:	21 f0       	breq	.+8      	; 0x8160 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    8158:	81 e0       	ldi	r24, 0x01	; 1
    815a:	80 93 fa 1f 	sts	0x1FFA, r24	; 0x801ffa <xYieldPending>
    815e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    8160:	10 92 fa 1f 	sts	0x1FFA, r1	; 0x801ffa <xYieldPending>
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    8164:	e0 91 57 20 	lds	r30, 0x2057	; 0x802057 <pxCurrentTCB>
    8168:	f0 91 58 20 	lds	r31, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    816c:	07 88       	ldd	r0, Z+23	; 0x17
    816e:	f0 8d       	ldd	r31, Z+24	; 0x18
    8170:	e0 2d       	mov	r30, r0
    8172:	80 81       	ld	r24, Z
    8174:	91 81       	ldd	r25, Z+1	; 0x01
    8176:	a2 81       	ldd	r26, Z+2	; 0x02
    8178:	b3 81       	ldd	r27, Z+3	; 0x03
    817a:	85 3a       	cpi	r24, 0xA5	; 165
    817c:	95 4a       	sbci	r25, 0xA5	; 165
    817e:	a5 4a       	sbci	r26, 0xA5	; 165
    8180:	b5 4a       	sbci	r27, 0xA5	; 165
    8182:	d9 f4       	brne	.+54     	; 0x81ba <vTaskSwitchContext+0x6a>
    8184:	84 81       	ldd	r24, Z+4	; 0x04
    8186:	95 81       	ldd	r25, Z+5	; 0x05
    8188:	a6 81       	ldd	r26, Z+6	; 0x06
    818a:	b7 81       	ldd	r27, Z+7	; 0x07
    818c:	85 3a       	cpi	r24, 0xA5	; 165
    818e:	95 4a       	sbci	r25, 0xA5	; 165
    8190:	a5 4a       	sbci	r26, 0xA5	; 165
    8192:	b5 4a       	sbci	r27, 0xA5	; 165
    8194:	91 f4       	brne	.+36     	; 0x81ba <vTaskSwitchContext+0x6a>
    8196:	80 85       	ldd	r24, Z+8	; 0x08
    8198:	91 85       	ldd	r25, Z+9	; 0x09
    819a:	a2 85       	ldd	r26, Z+10	; 0x0a
    819c:	b3 85       	ldd	r27, Z+11	; 0x0b
    819e:	85 3a       	cpi	r24, 0xA5	; 165
    81a0:	95 4a       	sbci	r25, 0xA5	; 165
    81a2:	a5 4a       	sbci	r26, 0xA5	; 165
    81a4:	b5 4a       	sbci	r27, 0xA5	; 165
    81a6:	49 f4       	brne	.+18     	; 0x81ba <vTaskSwitchContext+0x6a>
    81a8:	84 85       	ldd	r24, Z+12	; 0x0c
    81aa:	95 85       	ldd	r25, Z+13	; 0x0d
    81ac:	a6 85       	ldd	r26, Z+14	; 0x0e
    81ae:	b7 85       	ldd	r27, Z+15	; 0x0f
    81b0:	85 3a       	cpi	r24, 0xA5	; 165
    81b2:	95 4a       	sbci	r25, 0xA5	; 165
    81b4:	a5 4a       	sbci	r26, 0xA5	; 165
    81b6:	b5 4a       	sbci	r27, 0xA5	; 165
    81b8:	59 f0       	breq	.+22     	; 0x81d0 <vTaskSwitchContext+0x80>
    81ba:	60 91 57 20 	lds	r22, 0x2057	; 0x802057 <pxCurrentTCB>
    81be:	70 91 58 20 	lds	r23, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    81c2:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    81c6:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    81ca:	67 5e       	subi	r22, 0xE7	; 231
    81cc:	7f 4f       	sbci	r23, 0xFF	; 255
    81ce:	b0 df       	rcall	.-160    	; 0x8130 <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    81d0:	20 91 fd 1f 	lds	r18, 0x1FFD	; 0x801ffd <uxTopReadyPriority>
    81d4:	82 2f       	mov	r24, r18
    81d6:	90 e0       	ldi	r25, 0x00	; 0
    81d8:	fc 01       	movw	r30, r24
    81da:	ee 0f       	add	r30, r30
    81dc:	ff 1f       	adc	r31, r31
    81de:	ee 0f       	add	r30, r30
    81e0:	ff 1f       	adc	r31, r31
    81e2:	ee 0f       	add	r30, r30
    81e4:	ff 1f       	adc	r31, r31
    81e6:	e8 0f       	add	r30, r24
    81e8:	f9 1f       	adc	r31, r25
    81ea:	ed 5c       	subi	r30, 0xCD	; 205
    81ec:	ff 4d       	sbci	r31, 0xDF	; 223
    81ee:	30 81       	ld	r19, Z
    81f0:	31 11       	cpse	r19, r1
    81f2:	11 c0       	rjmp	.+34     	; 0x8216 <vTaskSwitchContext+0xc6>
    81f4:	21 50       	subi	r18, 0x01	; 1
    81f6:	82 2f       	mov	r24, r18
    81f8:	90 e0       	ldi	r25, 0x00	; 0
    81fa:	fc 01       	movw	r30, r24
    81fc:	ee 0f       	add	r30, r30
    81fe:	ff 1f       	adc	r31, r31
    8200:	ee 0f       	add	r30, r30
    8202:	ff 1f       	adc	r31, r31
    8204:	ee 0f       	add	r30, r30
    8206:	ff 1f       	adc	r31, r31
    8208:	e8 0f       	add	r30, r24
    820a:	f9 1f       	adc	r31, r25
    820c:	ed 5c       	subi	r30, 0xCD	; 205
    820e:	ff 4d       	sbci	r31, 0xDF	; 223
    8210:	30 81       	ld	r19, Z
    8212:	33 23       	and	r19, r19
    8214:	79 f3       	breq	.-34     	; 0x81f4 <vTaskSwitchContext+0xa4>
    8216:	ac 01       	movw	r20, r24
    8218:	44 0f       	add	r20, r20
    821a:	55 1f       	adc	r21, r21
    821c:	44 0f       	add	r20, r20
    821e:	55 1f       	adc	r21, r21
    8220:	44 0f       	add	r20, r20
    8222:	55 1f       	adc	r21, r21
    8224:	48 0f       	add	r20, r24
    8226:	59 1f       	adc	r21, r25
    8228:	da 01       	movw	r26, r20
    822a:	ad 5c       	subi	r26, 0xCD	; 205
    822c:	bf 4d       	sbci	r27, 0xDF	; 223
    822e:	11 96       	adiw	r26, 0x01	; 1
    8230:	ed 91       	ld	r30, X+
    8232:	fc 91       	ld	r31, X
    8234:	12 97       	sbiw	r26, 0x02	; 2
    8236:	02 80       	ldd	r0, Z+2	; 0x02
    8238:	f3 81       	ldd	r31, Z+3	; 0x03
    823a:	e0 2d       	mov	r30, r0
    823c:	12 96       	adiw	r26, 0x02	; 2
    823e:	fc 93       	st	X, r31
    8240:	ee 93       	st	-X, r30
    8242:	11 97       	sbiw	r26, 0x01	; 1
    8244:	4a 5c       	subi	r20, 0xCA	; 202
    8246:	5f 4d       	sbci	r21, 0xDF	; 223
    8248:	e4 17       	cp	r30, r20
    824a:	f5 07       	cpc	r31, r21
    824c:	29 f4       	brne	.+10     	; 0x8258 <vTaskSwitchContext+0x108>
    824e:	42 81       	ldd	r20, Z+2	; 0x02
    8250:	53 81       	ldd	r21, Z+3	; 0x03
    8252:	fd 01       	movw	r30, r26
    8254:	52 83       	std	Z+2, r21	; 0x02
    8256:	41 83       	std	Z+1, r20	; 0x01
    8258:	fc 01       	movw	r30, r24
    825a:	ee 0f       	add	r30, r30
    825c:	ff 1f       	adc	r31, r31
    825e:	ee 0f       	add	r30, r30
    8260:	ff 1f       	adc	r31, r31
    8262:	ee 0f       	add	r30, r30
    8264:	ff 1f       	adc	r31, r31
    8266:	8e 0f       	add	r24, r30
    8268:	9f 1f       	adc	r25, r31
    826a:	fc 01       	movw	r30, r24
    826c:	ed 5c       	subi	r30, 0xCD	; 205
    826e:	ff 4d       	sbci	r31, 0xDF	; 223
    8270:	01 80       	ldd	r0, Z+1	; 0x01
    8272:	f2 81       	ldd	r31, Z+2	; 0x02
    8274:	e0 2d       	mov	r30, r0
    8276:	86 81       	ldd	r24, Z+6	; 0x06
    8278:	97 81       	ldd	r25, Z+7	; 0x07
    827a:	90 93 58 20 	sts	0x2058, r25	; 0x802058 <pxCurrentTCB+0x1>
    827e:	80 93 57 20 	sts	0x2057, r24	; 0x802057 <pxCurrentTCB>
    8282:	20 93 fd 1f 	sts	0x1FFD, r18	; 0x801ffd <uxTopReadyPriority>
    8286:	08 95       	ret

00008288 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    8288:	0f 93       	push	r16
    828a:	1f 93       	push	r17
    828c:	cf 93       	push	r28
    828e:	df 93       	push	r29
    8290:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    8292:	0f b6       	in	r0, 0x3f	; 63
    8294:	f8 94       	cli
    8296:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    8298:	89 2b       	or	r24, r25
    829a:	21 f4       	brne	.+8      	; 0x82a4 <vTaskSuspend+0x1c>
    829c:	c0 91 57 20 	lds	r28, 0x2057	; 0x802057 <pxCurrentTCB>
    82a0:	d0 91 58 20 	lds	r29, 0x2058	; 0x802058 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    82a4:	8e 01       	movw	r16, r28
    82a6:	0e 5f       	subi	r16, 0xFE	; 254
    82a8:	1f 4f       	sbci	r17, 0xFF	; 255
    82aa:	c8 01       	movw	r24, r16
    82ac:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    82b0:	8c 89       	ldd	r24, Y+20	; 0x14
    82b2:	9d 89       	ldd	r25, Y+21	; 0x15
    82b4:	89 2b       	or	r24, r25
    82b6:	21 f0       	breq	.+8      	; 0x82c0 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    82b8:	ce 01       	movw	r24, r28
    82ba:	0c 96       	adiw	r24, 0x0c	; 12
    82bc:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    82c0:	b8 01       	movw	r22, r16
    82c2:	81 e0       	ldi	r24, 0x01	; 1
    82c4:	90 e2       	ldi	r25, 0x20	; 32
    82c6:	0e 94 bc 32 	call	0x6578	; 0x6578 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    82ca:	8b ad       	ldd	r24, Y+59	; 0x3b
    82cc:	81 30       	cpi	r24, 0x01	; 1
    82ce:	09 f4       	brne	.+2      	; 0x82d2 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    82d0:	1b ae       	std	Y+59, r1	; 0x3b
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    82d2:	0f 90       	pop	r0
    82d4:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    82d6:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xSchedulerRunning>
    82da:	88 23       	and	r24, r24
    82dc:	39 f0       	breq	.+14     	; 0x82ec <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    82de:	0f b6       	in	r0, 0x3f	; 63
    82e0:	f8 94       	cli
    82e2:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    82e4:	0e 94 f3 38 	call	0x71e6	; 0x71e6 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    82e8:	0f 90       	pop	r0
    82ea:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    82ec:	80 91 57 20 	lds	r24, 0x2057	; 0x802057 <pxCurrentTCB>
    82f0:	90 91 58 20 	lds	r25, 0x2058	; 0x802058 <pxCurrentTCB+0x1>
    82f4:	c8 17       	cp	r28, r24
    82f6:	d9 07       	cpc	r29, r25
    82f8:	99 f4       	brne	.+38     	; 0x8320 <vTaskSuspend+0x98>
		{
			if( xSchedulerRunning != pdFALSE )
    82fa:	80 91 fc 1f 	lds	r24, 0x1FFC	; 0x801ffc <xSchedulerRunning>
    82fe:	88 23       	and	r24, r24
    8300:	19 f0       	breq	.+6      	; 0x8308 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    8302:	0e 94 e6 33 	call	0x67cc	; 0x67cc <vPortYield>
    8306:	0c c0       	rjmp	.+24     	; 0x8320 <vTaskSuspend+0x98>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    8308:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <xSuspendedTaskList>
    830c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <uxCurrentNumberOfTasks>
    8310:	98 13       	cpse	r25, r24
    8312:	05 c0       	rjmp	.+10     	; 0x831e <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    8314:	10 92 58 20 	sts	0x2058, r1	; 0x802058 <pxCurrentTCB+0x1>
    8318:	10 92 57 20 	sts	0x2057, r1	; 0x802057 <pxCurrentTCB>
    831c:	01 c0       	rjmp	.+2      	; 0x8320 <vTaskSuspend+0x98>
				}
				else
				{
					vTaskSwitchContext();
    831e:	18 df       	rcall	.-464    	; 0x8150 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    8320:	df 91       	pop	r29
    8322:	cf 91       	pop	r28
    8324:	1f 91       	pop	r17
    8326:	0f 91       	pop	r16
    8328:	08 95       	ret

0000832a <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    832a:	fc 01       	movw	r30, r24
    832c:	73 83       	std	Z+3, r23	; 0x03
    832e:	62 83       	std	Z+2, r22	; 0x02
    8330:	91 87       	std	Z+9, r25	; 0x09
    8332:	80 87       	std	Z+8, r24	; 0x08
    8334:	46 17       	cp	r20, r22
    8336:	57 07       	cpc	r21, r23
    8338:	90 f0       	brcs	.+36     	; 0x835e <prvInsertTimerInActiveList+0x34>
    833a:	42 1b       	sub	r20, r18
    833c:	53 0b       	sbc	r21, r19
    833e:	84 85       	ldd	r24, Z+12	; 0x0c
    8340:	95 85       	ldd	r25, Z+13	; 0x0d
    8342:	48 17       	cp	r20, r24
    8344:	59 07       	cpc	r21, r25
    8346:	e0 f4       	brcc	.+56     	; 0x8380 <prvInsertTimerInActiveList+0x56>
    8348:	bf 01       	movw	r22, r30
    834a:	6e 5f       	subi	r22, 0xFE	; 254
    834c:	7f 4f       	sbci	r23, 0xFF	; 255
    834e:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <pxOverflowTimerList>
    8352:	90 91 60 20 	lds	r25, 0x2060	; 0x802060 <pxOverflowTimerList+0x1>
    8356:	0e 94 dd 32 	call	0x65ba	; 0x65ba <vListInsert>
    835a:	80 e0       	ldi	r24, 0x00	; 0
    835c:	08 95       	ret
    835e:	42 17       	cp	r20, r18
    8360:	53 07       	cpc	r21, r19
    8362:	18 f4       	brcc	.+6      	; 0x836a <prvInsertTimerInActiveList+0x40>
    8364:	62 17       	cp	r22, r18
    8366:	73 07       	cpc	r23, r19
    8368:	68 f4       	brcc	.+26     	; 0x8384 <prvInsertTimerInActiveList+0x5a>
    836a:	bf 01       	movw	r22, r30
    836c:	6e 5f       	subi	r22, 0xFE	; 254
    836e:	7f 4f       	sbci	r23, 0xFF	; 255
    8370:	80 91 61 20 	lds	r24, 0x2061	; 0x802061 <pxCurrentTimerList>
    8374:	90 91 62 20 	lds	r25, 0x2062	; 0x802062 <pxCurrentTimerList+0x1>
    8378:	0e 94 dd 32 	call	0x65ba	; 0x65ba <vListInsert>
    837c:	80 e0       	ldi	r24, 0x00	; 0
    837e:	08 95       	ret
    8380:	81 e0       	ldi	r24, 0x01	; 1
    8382:	08 95       	ret
    8384:	81 e0       	ldi	r24, 0x01	; 1
    8386:	08 95       	ret

00008388 <prvCheckForValidListAndQueue>:
    8388:	0f b6       	in	r0, 0x3f	; 63
    838a:	f8 94       	cli
    838c:	0f 92       	push	r0
    838e:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    8392:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    8396:	89 2b       	or	r24, r25
    8398:	e9 f4       	brne	.+58     	; 0x83d4 <prvCheckForValidListAndQueue+0x4c>
    839a:	8c e6       	ldi	r24, 0x6C	; 108
    839c:	90 e2       	ldi	r25, 0x20	; 32
    839e:	0e 94 aa 32 	call	0x6554	; 0x6554 <vListInitialise>
    83a2:	83 e6       	ldi	r24, 0x63	; 99
    83a4:	90 e2       	ldi	r25, 0x20	; 32
    83a6:	0e 94 aa 32 	call	0x6554	; 0x6554 <vListInitialise>
    83aa:	8c e6       	ldi	r24, 0x6C	; 108
    83ac:	90 e2       	ldi	r25, 0x20	; 32
    83ae:	90 93 62 20 	sts	0x2062, r25	; 0x802062 <pxCurrentTimerList+0x1>
    83b2:	80 93 61 20 	sts	0x2061, r24	; 0x802061 <pxCurrentTimerList>
    83b6:	83 e6       	ldi	r24, 0x63	; 99
    83b8:	90 e2       	ldi	r25, 0x20	; 32
    83ba:	90 93 60 20 	sts	0x2060, r25	; 0x802060 <pxOverflowTimerList+0x1>
    83be:	80 93 5f 20 	sts	0x205F, r24	; 0x80205f <pxOverflowTimerList>
    83c2:	40 e0       	ldi	r20, 0x00	; 0
    83c4:	65 e0       	ldi	r22, 0x05	; 5
    83c6:	84 e1       	ldi	r24, 0x14	; 20
    83c8:	0e 94 bd 35 	call	0x6b7a	; 0x6b7a <xQueueGenericCreate>
    83cc:	90 93 5e 20 	sts	0x205E, r25	; 0x80205e <xTimerQueue+0x1>
    83d0:	80 93 5d 20 	sts	0x205D, r24	; 0x80205d <xTimerQueue>
    83d4:	0f 90       	pop	r0
    83d6:	0f be       	out	0x3f, r0	; 63
    83d8:	08 95       	ret

000083da <xTimerCreateTimerTask>:
    83da:	ef 92       	push	r14
    83dc:	ff 92       	push	r15
    83de:	0f 93       	push	r16
    83e0:	d3 df       	rcall	.-90     	; 0x8388 <prvCheckForValidListAndQueue>
    83e2:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    83e6:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    83ea:	89 2b       	or	r24, r25
    83ec:	91 f0       	breq	.+36     	; 0x8412 <xTimerCreateTimerTask+0x38>
    83ee:	0f 2e       	mov	r0, r31
    83f0:	fb e5       	ldi	r31, 0x5B	; 91
    83f2:	ef 2e       	mov	r14, r31
    83f4:	f0 e2       	ldi	r31, 0x20	; 32
    83f6:	ff 2e       	mov	r15, r31
    83f8:	f0 2d       	mov	r31, r0
    83fa:	03 e0       	ldi	r16, 0x03	; 3
    83fc:	20 e0       	ldi	r18, 0x00	; 0
    83fe:	30 e0       	ldi	r19, 0x00	; 0
    8400:	48 e7       	ldi	r20, 0x78	; 120
    8402:	50 e0       	ldi	r21, 0x00	; 0
    8404:	65 e1       	ldi	r22, 0x15	; 21
    8406:	73 e0       	ldi	r23, 0x03	; 3
    8408:	83 ec       	ldi	r24, 0xC3	; 195
    840a:	92 e4       	ldi	r25, 0x42	; 66
    840c:	0e 94 9a 39 	call	0x7334	; 0x7334 <xTaskCreate>
    8410:	01 c0       	rjmp	.+2      	; 0x8414 <xTimerCreateTimerTask+0x3a>
    8412:	80 e0       	ldi	r24, 0x00	; 0
    8414:	0f 91       	pop	r16
    8416:	ff 90       	pop	r15
    8418:	ef 90       	pop	r14
    841a:	08 95       	ret

0000841c <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    841c:	0f 93       	push	r16
    841e:	1f 93       	push	r17
    8420:	cf 93       	push	r28
    8422:	df 93       	push	r29
    8424:	00 d0       	rcall	.+0      	; 0x8426 <xTimerGenericCommand+0xa>
    8426:	1f 92       	push	r1
    8428:	1f 92       	push	r1
    842a:	cd b7       	in	r28, 0x3d	; 61
    842c:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    842e:	e0 91 5d 20 	lds	r30, 0x205D	; 0x80205d <xTimerQueue>
    8432:	f0 91 5e 20 	lds	r31, 0x205E	; 0x80205e <xTimerQueue+0x1>
    8436:	30 97       	sbiw	r30, 0x00	; 0
    8438:	69 f1       	breq	.+90     	; 0x8494 <xTimerGenericCommand+0x78>
    843a:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    843c:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    843e:	5b 83       	std	Y+3, r21	; 0x03
    8440:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    8442:	9d 83       	std	Y+5, r25	; 0x05
    8444:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    8446:	66 30       	cpi	r22, 0x06	; 6
    8448:	e4 f4       	brge	.+56     	; 0x8482 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    844a:	98 dc       	rcall	.-1744   	; 0x7d7c <xTaskGetSchedulerState>
    844c:	82 30       	cpi	r24, 0x02	; 2
    844e:	61 f4       	brne	.+24     	; 0x8468 <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    8450:	20 e0       	ldi	r18, 0x00	; 0
    8452:	a8 01       	movw	r20, r16
    8454:	be 01       	movw	r22, r28
    8456:	6f 5f       	subi	r22, 0xFF	; 255
    8458:	7f 4f       	sbci	r23, 0xFF	; 255
    845a:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    845e:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    8462:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xQueueGenericSend>
    8466:	17 c0       	rjmp	.+46     	; 0x8496 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    8468:	20 e0       	ldi	r18, 0x00	; 0
    846a:	40 e0       	ldi	r20, 0x00	; 0
    846c:	50 e0       	ldi	r21, 0x00	; 0
    846e:	be 01       	movw	r22, r28
    8470:	6f 5f       	subi	r22, 0xFF	; 255
    8472:	7f 4f       	sbci	r23, 0xFF	; 255
    8474:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    8478:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    847c:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <xQueueGenericSend>
    8480:	0a c0       	rjmp	.+20     	; 0x8496 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    8482:	20 e0       	ldi	r18, 0x00	; 0
    8484:	ad 01       	movw	r20, r26
    8486:	be 01       	movw	r22, r28
    8488:	6f 5f       	subi	r22, 0xFF	; 255
    848a:	7f 4f       	sbci	r23, 0xFF	; 255
    848c:	cf 01       	movw	r24, r30
    848e:	0e 94 95 36 	call	0x6d2a	; 0x6d2a <xQueueGenericSendFromISR>
    8492:	01 c0       	rjmp	.+2      	; 0x8496 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    8494:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    8496:	0f 90       	pop	r0
    8498:	0f 90       	pop	r0
    849a:	0f 90       	pop	r0
    849c:	0f 90       	pop	r0
    849e:	0f 90       	pop	r0
    84a0:	df 91       	pop	r29
    84a2:	cf 91       	pop	r28
    84a4:	1f 91       	pop	r17
    84a6:	0f 91       	pop	r16
    84a8:	08 95       	ret

000084aa <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    84aa:	af 92       	push	r10
    84ac:	bf 92       	push	r11
    84ae:	cf 92       	push	r12
    84b0:	df 92       	push	r13
    84b2:	ef 92       	push	r14
    84b4:	ff 92       	push	r15
    84b6:	0f 93       	push	r16
    84b8:	1f 93       	push	r17
    84ba:	cf 93       	push	r28
    84bc:	df 93       	push	r29
    84be:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    84c0:	19 d9       	rcall	.-3534   	; 0x76f4 <xTaskGetTickCount>
    84c2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    84c4:	80 91 59 20 	lds	r24, 0x2059	; 0x802059 <xLastTime.2399>
    84c8:	90 91 5a 20 	lds	r25, 0x205A	; 0x80205a <xLastTime.2399+0x1>
    84cc:	e8 16       	cp	r14, r24
    84ce:	f9 06       	cpc	r15, r25
    84d0:	08 f0       	brcs	.+2      	; 0x84d4 <prvSampleTimeNow+0x2a>
    84d2:	47 c0       	rjmp	.+142    	; 0x8562 <prvSampleTimeNow+0xb8>
    84d4:	2f c0       	rjmp	.+94     	; 0x8534 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    84d6:	05 80       	ldd	r0, Z+5	; 0x05
    84d8:	f6 81       	ldd	r31, Z+6	; 0x06
    84da:	e0 2d       	mov	r30, r0
    84dc:	a0 80       	ld	r10, Z
    84de:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    84e0:	c6 81       	ldd	r28, Z+6	; 0x06
    84e2:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    84e4:	8e 01       	movw	r16, r28
    84e6:	0e 5f       	subi	r16, 0xFE	; 254
    84e8:	1f 4f       	sbci	r17, 0xFF	; 255
    84ea:	c8 01       	movw	r24, r16
    84ec:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    84f0:	e8 89       	ldd	r30, Y+16	; 0x10
    84f2:	f9 89       	ldd	r31, Y+17	; 0x11
    84f4:	ce 01       	movw	r24, r28
    84f6:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    84f8:	8b 89       	ldd	r24, Y+19	; 0x13
    84fa:	82 ff       	sbrs	r24, 2
    84fc:	1b c0       	rjmp	.+54     	; 0x8534 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    84fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    8500:	9d 85       	ldd	r25, Y+13	; 0x0d
    8502:	8a 0d       	add	r24, r10
    8504:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    8506:	a8 16       	cp	r10, r24
    8508:	b9 06       	cpc	r11, r25
    850a:	60 f4       	brcc	.+24     	; 0x8524 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    850c:	9b 83       	std	Y+3, r25	; 0x03
    850e:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    8510:	d9 87       	std	Y+9, r29	; 0x09
    8512:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    8514:	b8 01       	movw	r22, r16
    8516:	80 91 61 20 	lds	r24, 0x2061	; 0x802061 <pxCurrentTimerList>
    851a:	90 91 62 20 	lds	r25, 0x2062	; 0x802062 <pxCurrentTimerList+0x1>
    851e:	0e 94 dd 32 	call	0x65ba	; 0x65ba <vListInsert>
    8522:	08 c0       	rjmp	.+16     	; 0x8534 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    8524:	00 e0       	ldi	r16, 0x00	; 0
    8526:	10 e0       	ldi	r17, 0x00	; 0
    8528:	20 e0       	ldi	r18, 0x00	; 0
    852a:	30 e0       	ldi	r19, 0x00	; 0
    852c:	a5 01       	movw	r20, r10
    852e:	60 e0       	ldi	r22, 0x00	; 0
    8530:	ce 01       	movw	r24, r28
    8532:	74 df       	rcall	.-280    	; 0x841c <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    8534:	e0 91 61 20 	lds	r30, 0x2061	; 0x802061 <pxCurrentTimerList>
    8538:	f0 91 62 20 	lds	r31, 0x2062	; 0x802062 <pxCurrentTimerList+0x1>
    853c:	80 81       	ld	r24, Z
    853e:	81 11       	cpse	r24, r1
    8540:	ca cf       	rjmp	.-108    	; 0x84d6 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    8542:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <pxOverflowTimerList>
    8546:	90 91 60 20 	lds	r25, 0x2060	; 0x802060 <pxOverflowTimerList+0x1>
    854a:	90 93 62 20 	sts	0x2062, r25	; 0x802062 <pxCurrentTimerList+0x1>
    854e:	80 93 61 20 	sts	0x2061, r24	; 0x802061 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    8552:	f0 93 60 20 	sts	0x2060, r31	; 0x802060 <pxOverflowTimerList+0x1>
    8556:	e0 93 5f 20 	sts	0x205F, r30	; 0x80205f <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    855a:	81 e0       	ldi	r24, 0x01	; 1
    855c:	f6 01       	movw	r30, r12
    855e:	80 83       	st	Z, r24
    8560:	02 c0       	rjmp	.+4      	; 0x8566 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    8562:	f6 01       	movw	r30, r12
    8564:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    8566:	f0 92 5a 20 	sts	0x205A, r15	; 0x80205a <xLastTime.2399+0x1>
    856a:	e0 92 59 20 	sts	0x2059, r14	; 0x802059 <xLastTime.2399>

	return xTimeNow;
}
    856e:	c7 01       	movw	r24, r14
    8570:	df 91       	pop	r29
    8572:	cf 91       	pop	r28
    8574:	1f 91       	pop	r17
    8576:	0f 91       	pop	r16
    8578:	ff 90       	pop	r15
    857a:	ef 90       	pop	r14
    857c:	df 90       	pop	r13
    857e:	cf 90       	pop	r12
    8580:	bf 90       	pop	r11
    8582:	af 90       	pop	r10
    8584:	08 95       	ret

00008586 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    8586:	cf 93       	push	r28
    8588:	df 93       	push	r29
    858a:	00 d0       	rcall	.+0      	; 0x858c <prvTimerTask+0x6>
    858c:	00 d0       	rcall	.+0      	; 0x858e <prvTimerTask+0x8>
    858e:	cd b7       	in	r28, 0x3d	; 61
    8590:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    8592:	ce 01       	movw	r24, r28
    8594:	01 96       	adiw	r24, 0x01	; 1
    8596:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    8598:	44 24       	eor	r4, r4
    859a:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    859c:	e1 2c       	mov	r14, r1
    859e:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    85a0:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    85a2:	c8 2e       	mov	r12, r24
    85a4:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    85a6:	e0 91 61 20 	lds	r30, 0x2061	; 0x802061 <pxCurrentTimerList>
    85aa:	f0 91 62 20 	lds	r31, 0x2062	; 0x802062 <pxCurrentTimerList+0x1>
    85ae:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    85b0:	88 23       	and	r24, r24
    85b2:	09 f4       	brne	.+2      	; 0x85b6 <prvTimerTask+0x30>
    85b4:	d1 c0       	rjmp	.+418    	; 0x8758 <prvTimerTask+0x1d2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    85b6:	05 80       	ldd	r0, Z+5	; 0x05
    85b8:	f6 81       	ldd	r31, Z+6	; 0x06
    85ba:	e0 2d       	mov	r30, r0
    85bc:	a0 80       	ld	r10, Z
    85be:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    85c0:	93 d8       	rcall	.-3802   	; 0x76e8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    85c2:	c4 01       	movw	r24, r8
    85c4:	72 df       	rcall	.-284    	; 0x84aa <prvSampleTimeNow>
    85c6:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    85c8:	89 81       	ldd	r24, Y+1	; 0x01
    85ca:	81 11       	cpse	r24, r1
    85cc:	47 c0       	rjmp	.+142    	; 0x865c <prvTimerTask+0xd6>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    85ce:	0a 15       	cp	r16, r10
    85d0:	1b 05       	cpc	r17, r11
			{
				( void ) xTaskResumeAll();
    85d2:	a0 f1       	brcs	.+104    	; 0x863c <prvTimerTask+0xb6>
    85d4:	46 d9       	rcall	.-3444   	; 0x7862 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    85d6:	e0 91 61 20 	lds	r30, 0x2061	; 0x802061 <pxCurrentTimerList>
    85da:	f0 91 62 20 	lds	r31, 0x2062	; 0x802062 <pxCurrentTimerList+0x1>
    85de:	05 80       	ldd	r0, Z+5	; 0x05
    85e0:	f6 81       	ldd	r31, Z+6	; 0x06
    85e2:	e0 2d       	mov	r30, r0
    85e4:	66 80       	ldd	r6, Z+6	; 0x06
    85e6:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    85e8:	c3 01       	movw	r24, r6
    85ea:	02 96       	adiw	r24, 0x02	; 2
    85ec:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    85f0:	d3 01       	movw	r26, r6
    85f2:	53 96       	adiw	r26, 0x13	; 19
    85f4:	8c 91       	ld	r24, X
    85f6:	53 97       	sbiw	r26, 0x13	; 19
    85f8:	82 ff       	sbrs	r24, 2
    85fa:	15 c0       	rjmp	.+42     	; 0x8626 <prvTimerTask+0xa0>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    85fc:	1c 96       	adiw	r26, 0x0c	; 12
    85fe:	6d 91       	ld	r22, X+
    8600:	7c 91       	ld	r23, X
    8602:	1d 97       	sbiw	r26, 0x0d	; 13
    8604:	6a 0d       	add	r22, r10
    8606:	7b 1d       	adc	r23, r11
    8608:	95 01       	movw	r18, r10
    860a:	a8 01       	movw	r20, r16
    860c:	c3 01       	movw	r24, r6
    860e:	8d de       	rcall	.-742    	; 0x832a <prvInsertTimerInActiveList>
    8610:	88 23       	and	r24, r24
    8612:	61 f0       	breq	.+24     	; 0x862c <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    8614:	0e 2d       	mov	r16, r14
    8616:	1f 2d       	mov	r17, r15
    8618:	2e 2d       	mov	r18, r14
    861a:	3f 2d       	mov	r19, r15
    861c:	a5 01       	movw	r20, r10
    861e:	65 2d       	mov	r22, r5
    8620:	c3 01       	movw	r24, r6
    8622:	fc de       	rcall	.-520    	; 0x841c <xTimerGenericCommand>
    8624:	03 c0       	rjmp	.+6      	; 0x862c <prvTimerTask+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8626:	8e 7f       	andi	r24, 0xFE	; 254
    8628:	f3 01       	movw	r30, r6
    862a:	83 8b       	std	Z+19, r24	; 0x13
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    862c:	d3 01       	movw	r26, r6
    862e:	50 96       	adiw	r26, 0x10	; 16
    8630:	ed 91       	ld	r30, X+
    8632:	fc 91       	ld	r31, X
    8634:	51 97       	sbiw	r26, 0x11	; 17
    8636:	c3 01       	movw	r24, r6
    8638:	19 95       	eicall
    863a:	81 c0       	rjmp	.+258    	; 0x873e <prvTimerTask+0x1b8>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    863c:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    863e:	b5 01       	movw	r22, r10
    8640:	60 1b       	sub	r22, r16
    8642:	71 0b       	sbc	r23, r17
    8644:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    8648:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    864c:	0e 94 4f 38 	call	0x709e	; 0x709e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    8650:	08 d9       	rcall	.-3568   	; 0x7862 <xTaskResumeAll>
    8652:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    8654:	74 c0       	rjmp	.+232    	; 0x873e <prvTimerTask+0x1b8>
    8656:	0e 94 e6 33 	call	0x67cc	; 0x67cc <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    865a:	71 c0       	rjmp	.+226    	; 0x873e <prvTimerTask+0x1b8>
    865c:	02 d9       	rcall	.-3580   	; 0x7862 <xTaskResumeAll>
    865e:	6f c0       	rjmp	.+222    	; 0x873e <prvTimerTask+0x1b8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    8660:	89 81       	ldd	r24, Y+1	; 0x01
    8662:	88 23       	and	r24, r24
    8664:	0c f4       	brge	.+2      	; 0x8668 <prvTimerTask+0xe2>
    8666:	6b c0       	rjmp	.+214    	; 0x873e <prvTimerTask+0x1b8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    8668:	ac 80       	ldd	r10, Y+4	; 0x04
    866a:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    866c:	f5 01       	movw	r30, r10
    866e:	82 85       	ldd	r24, Z+10	; 0x0a
    8670:	93 85       	ldd	r25, Z+11	; 0x0b
    8672:	89 2b       	or	r24, r25
    8674:	21 f0       	breq	.+8      	; 0x867e <prvTimerTask+0xf8>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    8676:	c5 01       	movw	r24, r10
    8678:	02 96       	adiw	r24, 0x02	; 2
    867a:	0e 94 0e 33 	call	0x661c	; 0x661c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    867e:	ce 01       	movw	r24, r28
    8680:	06 96       	adiw	r24, 0x06	; 6
    8682:	13 df       	rcall	.-474    	; 0x84aa <prvSampleTimeNow>
    8684:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    8686:	e9 81       	ldd	r30, Y+1	; 0x01
    8688:	0e 2e       	mov	r0, r30
    868a:	00 0c       	add	r0, r0
    868c:	ff 0b       	sbc	r31, r31
    868e:	ea 30       	cpi	r30, 0x0A	; 10
    8690:	f1 05       	cpc	r31, r1
    8692:	08 f0       	brcs	.+2      	; 0x8696 <prvTimerTask+0x110>
    8694:	54 c0       	rjmp	.+168    	; 0x873e <prvTimerTask+0x1b8>
    8696:	88 27       	eor	r24, r24
    8698:	eb 53       	subi	r30, 0x3B	; 59
    869a:	ff 4f       	sbci	r31, 0xFF	; 255
    869c:	8f 4f       	sbci	r24, 0xFF	; 255
    869e:	b1 c1       	rjmp	.+866    	; 0x8a02 <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    86a0:	d5 01       	movw	r26, r10
    86a2:	53 96       	adiw	r26, 0x13	; 19
    86a4:	8c 91       	ld	r24, X
    86a6:	53 97       	sbiw	r26, 0x13	; 19
    86a8:	81 60       	ori	r24, 0x01	; 1
    86aa:	53 96       	adiw	r26, 0x13	; 19
    86ac:	8c 93       	st	X, r24
    86ae:	53 97       	sbiw	r26, 0x13	; 19
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    86b0:	2a 81       	ldd	r18, Y+2	; 0x02
    86b2:	3b 81       	ldd	r19, Y+3	; 0x03
    86b4:	1c 96       	adiw	r26, 0x0c	; 12
    86b6:	6d 91       	ld	r22, X+
    86b8:	7c 91       	ld	r23, X
    86ba:	1d 97       	sbiw	r26, 0x0d	; 13
    86bc:	62 0f       	add	r22, r18
    86be:	73 1f       	adc	r23, r19
    86c0:	c5 01       	movw	r24, r10
    86c2:	33 de       	rcall	.-922    	; 0x832a <prvInsertTimerInActiveList>
    86c4:	88 23       	and	r24, r24
    86c6:	d9 f1       	breq	.+118    	; 0x873e <prvTimerTask+0x1b8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    86c8:	d5 01       	movw	r26, r10
    86ca:	50 96       	adiw	r26, 0x10	; 16
    86cc:	ed 91       	ld	r30, X+
    86ce:	fc 91       	ld	r31, X
    86d0:	51 97       	sbiw	r26, 0x11	; 17
    86d2:	c5 01       	movw	r24, r10
    86d4:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    86d6:	f5 01       	movw	r30, r10
    86d8:	83 89       	ldd	r24, Z+19	; 0x13
    86da:	82 ff       	sbrs	r24, 2
    86dc:	30 c0       	rjmp	.+96     	; 0x873e <prvTimerTask+0x1b8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    86de:	4a 81       	ldd	r20, Y+2	; 0x02
    86e0:	5b 81       	ldd	r21, Y+3	; 0x03
    86e2:	84 85       	ldd	r24, Z+12	; 0x0c
    86e4:	95 85       	ldd	r25, Z+13	; 0x0d
    86e6:	48 0f       	add	r20, r24
    86e8:	59 1f       	adc	r21, r25
    86ea:	0e 2d       	mov	r16, r14
    86ec:	1f 2d       	mov	r17, r15
    86ee:	2e 2d       	mov	r18, r14
    86f0:	3f 2d       	mov	r19, r15
    86f2:	65 2d       	mov	r22, r5
    86f4:	c5 01       	movw	r24, r10
    86f6:	92 de       	rcall	.-732    	; 0x841c <xTimerGenericCommand>
    86f8:	22 c0       	rjmp	.+68     	; 0x873e <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    86fa:	d5 01       	movw	r26, r10
    86fc:	53 96       	adiw	r26, 0x13	; 19
    86fe:	8c 91       	ld	r24, X
    8700:	53 97       	sbiw	r26, 0x13	; 19
    8702:	8e 7f       	andi	r24, 0xFE	; 254
    8704:	53 96       	adiw	r26, 0x13	; 19
    8706:	8c 93       	st	X, r24
    8708:	1a c0       	rjmp	.+52     	; 0x873e <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    870a:	f5 01       	movw	r30, r10
    870c:	83 89       	ldd	r24, Z+19	; 0x13
    870e:	81 60       	ori	r24, 0x01	; 1
    8710:	83 8b       	std	Z+19, r24	; 0x13
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    8712:	6a 81       	ldd	r22, Y+2	; 0x02
    8714:	7b 81       	ldd	r23, Y+3	; 0x03
    8716:	75 87       	std	Z+13, r23	; 0x0d
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    8718:	64 87       	std	Z+12, r22	; 0x0c
    871a:	64 0f       	add	r22, r20
    871c:	75 1f       	adc	r23, r21
    871e:	9a 01       	movw	r18, r20
    8720:	c5 01       	movw	r24, r10
    8722:	03 de       	rcall	.-1018   	; 0x832a <prvInsertTimerInActiveList>
    8724:	0c c0       	rjmp	.+24     	; 0x873e <prvTimerTask+0x1b8>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    8726:	d5 01       	movw	r26, r10
    8728:	53 96       	adiw	r26, 0x13	; 19
    872a:	8c 91       	ld	r24, X
    872c:	81 fd       	sbrc	r24, 1
    872e:	04 c0       	rjmp	.+8      	; 0x8738 <prvTimerTask+0x1b2>
						{
							vPortFree( pxTimer );
    8730:	c5 01       	movw	r24, r10
    8732:	0e 94 b5 31 	call	0x636a	; 0x636a <vPortFree>
    8736:	03 c0       	rjmp	.+6      	; 0x873e <prvTimerTask+0x1b8>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8738:	8e 7f       	andi	r24, 0xFE	; 254
    873a:	f5 01       	movw	r30, r10
    873c:	83 8b       	std	Z+19, r24	; 0x13
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    873e:	4e 2d       	mov	r20, r14
    8740:	5f 2d       	mov	r21, r15
    8742:	6c 2d       	mov	r22, r12
    8744:	7d 2d       	mov	r23, r13
    8746:	80 91 5d 20 	lds	r24, 0x205D	; 0x80205d <xTimerQueue>
    874a:	90 91 5e 20 	lds	r25, 0x205E	; 0x80205e <xTimerQueue+0x1>
    874e:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <xQueueReceive>
    8752:	81 11       	cpse	r24, r1
    8754:	85 cf       	rjmp	.-246    	; 0x8660 <prvTimerTask+0xda>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    8756:	27 cf       	rjmp	.-434    	; 0x85a6 <prvTimerTask+0x20>
    8758:	0e 94 74 3b 	call	0x76e8	; 0x76e8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    875c:	c4 01       	movw	r24, r8
    875e:	a5 de       	rcall	.-694    	; 0x84aa <prvSampleTimeNow>
    8760:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    8762:	89 81       	ldd	r24, Y+1	; 0x01
    8764:	81 11       	cpse	r24, r1
    8766:	7a cf       	rjmp	.-268    	; 0x865c <prvTimerTask+0xd6>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    8768:	e0 91 5f 20 	lds	r30, 0x205F	; 0x80205f <pxOverflowTimerList>
    876c:	f0 91 60 20 	lds	r31, 0x2060	; 0x802060 <pxOverflowTimerList+0x1>
    8770:	80 81       	ld	r24, Z
    8772:	44 2d       	mov	r20, r4
    8774:	81 11       	cpse	r24, r1
    8776:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    8778:	ae 2c       	mov	r10, r14
    877a:	bf 2c       	mov	r11, r15
    877c:	60 cf       	rjmp	.-320    	; 0x863e <prvTimerTask+0xb8>

0000877e <__floatunsisf>:
    877e:	e8 94       	clt
    8780:	09 c0       	rjmp	.+18     	; 0x8794 <__floatsisf+0x12>

00008782 <__floatsisf>:
    8782:	97 fb       	bst	r25, 7
    8784:	3e f4       	brtc	.+14     	; 0x8794 <__floatsisf+0x12>
    8786:	90 95       	com	r25
    8788:	80 95       	com	r24
    878a:	70 95       	com	r23
    878c:	61 95       	neg	r22
    878e:	7f 4f       	sbci	r23, 0xFF	; 255
    8790:	8f 4f       	sbci	r24, 0xFF	; 255
    8792:	9f 4f       	sbci	r25, 0xFF	; 255
    8794:	99 23       	and	r25, r25
    8796:	a9 f0       	breq	.+42     	; 0x87c2 <__floatsisf+0x40>
    8798:	f9 2f       	mov	r31, r25
    879a:	96 e9       	ldi	r25, 0x96	; 150
    879c:	bb 27       	eor	r27, r27
    879e:	93 95       	inc	r25
    87a0:	f6 95       	lsr	r31
    87a2:	87 95       	ror	r24
    87a4:	77 95       	ror	r23
    87a6:	67 95       	ror	r22
    87a8:	b7 95       	ror	r27
    87aa:	f1 11       	cpse	r31, r1
    87ac:	f8 cf       	rjmp	.-16     	; 0x879e <__floatsisf+0x1c>
    87ae:	fa f4       	brpl	.+62     	; 0x87ee <__floatsisf+0x6c>
    87b0:	bb 0f       	add	r27, r27
    87b2:	11 f4       	brne	.+4      	; 0x87b8 <__floatsisf+0x36>
    87b4:	60 ff       	sbrs	r22, 0
    87b6:	1b c0       	rjmp	.+54     	; 0x87ee <__floatsisf+0x6c>
    87b8:	6f 5f       	subi	r22, 0xFF	; 255
    87ba:	7f 4f       	sbci	r23, 0xFF	; 255
    87bc:	8f 4f       	sbci	r24, 0xFF	; 255
    87be:	9f 4f       	sbci	r25, 0xFF	; 255
    87c0:	16 c0       	rjmp	.+44     	; 0x87ee <__floatsisf+0x6c>
    87c2:	88 23       	and	r24, r24
    87c4:	11 f0       	breq	.+4      	; 0x87ca <__floatsisf+0x48>
    87c6:	96 e9       	ldi	r25, 0x96	; 150
    87c8:	11 c0       	rjmp	.+34     	; 0x87ec <__floatsisf+0x6a>
    87ca:	77 23       	and	r23, r23
    87cc:	21 f0       	breq	.+8      	; 0x87d6 <__floatsisf+0x54>
    87ce:	9e e8       	ldi	r25, 0x8E	; 142
    87d0:	87 2f       	mov	r24, r23
    87d2:	76 2f       	mov	r23, r22
    87d4:	05 c0       	rjmp	.+10     	; 0x87e0 <__floatsisf+0x5e>
    87d6:	66 23       	and	r22, r22
    87d8:	71 f0       	breq	.+28     	; 0x87f6 <__floatsisf+0x74>
    87da:	96 e8       	ldi	r25, 0x86	; 134
    87dc:	86 2f       	mov	r24, r22
    87de:	70 e0       	ldi	r23, 0x00	; 0
    87e0:	60 e0       	ldi	r22, 0x00	; 0
    87e2:	2a f0       	brmi	.+10     	; 0x87ee <__floatsisf+0x6c>
    87e4:	9a 95       	dec	r25
    87e6:	66 0f       	add	r22, r22
    87e8:	77 1f       	adc	r23, r23
    87ea:	88 1f       	adc	r24, r24
    87ec:	da f7       	brpl	.-10     	; 0x87e4 <__floatsisf+0x62>
    87ee:	88 0f       	add	r24, r24
    87f0:	96 95       	lsr	r25
    87f2:	87 95       	ror	r24
    87f4:	97 f9       	bld	r25, 7
    87f6:	08 95       	ret

000087f8 <__mulsf3>:
    87f8:	0b d0       	rcall	.+22     	; 0x8810 <__mulsf3x>
    87fa:	78 c0       	rjmp	.+240    	; 0x88ec <__fp_round>
    87fc:	69 d0       	rcall	.+210    	; 0x88d0 <__fp_pscA>
    87fe:	28 f0       	brcs	.+10     	; 0x880a <__mulsf3+0x12>
    8800:	6e d0       	rcall	.+220    	; 0x88de <__fp_pscB>
    8802:	18 f0       	brcs	.+6      	; 0x880a <__mulsf3+0x12>
    8804:	95 23       	and	r25, r21
    8806:	09 f0       	breq	.+2      	; 0x880a <__mulsf3+0x12>
    8808:	5a c0       	rjmp	.+180    	; 0x88be <__fp_inf>
    880a:	5f c0       	rjmp	.+190    	; 0x88ca <__fp_nan>
    880c:	11 24       	eor	r1, r1
    880e:	a2 c0       	rjmp	.+324    	; 0x8954 <__fp_szero>

00008810 <__mulsf3x>:
    8810:	7e d0       	rcall	.+252    	; 0x890e <__fp_split3>
    8812:	a0 f3       	brcs	.-24     	; 0x87fc <__mulsf3+0x4>

00008814 <__mulsf3_pse>:
    8814:	95 9f       	mul	r25, r21
    8816:	d1 f3       	breq	.-12     	; 0x880c <__mulsf3+0x14>
    8818:	95 0f       	add	r25, r21
    881a:	50 e0       	ldi	r21, 0x00	; 0
    881c:	55 1f       	adc	r21, r21
    881e:	62 9f       	mul	r22, r18
    8820:	f0 01       	movw	r30, r0
    8822:	72 9f       	mul	r23, r18
    8824:	bb 27       	eor	r27, r27
    8826:	f0 0d       	add	r31, r0
    8828:	b1 1d       	adc	r27, r1
    882a:	63 9f       	mul	r22, r19
    882c:	aa 27       	eor	r26, r26
    882e:	f0 0d       	add	r31, r0
    8830:	b1 1d       	adc	r27, r1
    8832:	aa 1f       	adc	r26, r26
    8834:	64 9f       	mul	r22, r20
    8836:	66 27       	eor	r22, r22
    8838:	b0 0d       	add	r27, r0
    883a:	a1 1d       	adc	r26, r1
    883c:	66 1f       	adc	r22, r22
    883e:	82 9f       	mul	r24, r18
    8840:	22 27       	eor	r18, r18
    8842:	b0 0d       	add	r27, r0
    8844:	a1 1d       	adc	r26, r1
    8846:	62 1f       	adc	r22, r18
    8848:	73 9f       	mul	r23, r19
    884a:	b0 0d       	add	r27, r0
    884c:	a1 1d       	adc	r26, r1
    884e:	62 1f       	adc	r22, r18
    8850:	83 9f       	mul	r24, r19
    8852:	a0 0d       	add	r26, r0
    8854:	61 1d       	adc	r22, r1
    8856:	22 1f       	adc	r18, r18
    8858:	74 9f       	mul	r23, r20
    885a:	33 27       	eor	r19, r19
    885c:	a0 0d       	add	r26, r0
    885e:	61 1d       	adc	r22, r1
    8860:	23 1f       	adc	r18, r19
    8862:	84 9f       	mul	r24, r20
    8864:	60 0d       	add	r22, r0
    8866:	21 1d       	adc	r18, r1
    8868:	82 2f       	mov	r24, r18
    886a:	76 2f       	mov	r23, r22
    886c:	6a 2f       	mov	r22, r26
    886e:	11 24       	eor	r1, r1
    8870:	9f 57       	subi	r25, 0x7F	; 127
    8872:	50 40       	sbci	r21, 0x00	; 0
    8874:	8a f0       	brmi	.+34     	; 0x8898 <__mulsf3_pse+0x84>
    8876:	e1 f0       	breq	.+56     	; 0x88b0 <__mulsf3_pse+0x9c>
    8878:	88 23       	and	r24, r24
    887a:	4a f0       	brmi	.+18     	; 0x888e <__mulsf3_pse+0x7a>
    887c:	ee 0f       	add	r30, r30
    887e:	ff 1f       	adc	r31, r31
    8880:	bb 1f       	adc	r27, r27
    8882:	66 1f       	adc	r22, r22
    8884:	77 1f       	adc	r23, r23
    8886:	88 1f       	adc	r24, r24
    8888:	91 50       	subi	r25, 0x01	; 1
    888a:	50 40       	sbci	r21, 0x00	; 0
    888c:	a9 f7       	brne	.-22     	; 0x8878 <__mulsf3_pse+0x64>
    888e:	9e 3f       	cpi	r25, 0xFE	; 254
    8890:	51 05       	cpc	r21, r1
    8892:	70 f0       	brcs	.+28     	; 0x88b0 <__mulsf3_pse+0x9c>
    8894:	14 c0       	rjmp	.+40     	; 0x88be <__fp_inf>
    8896:	5e c0       	rjmp	.+188    	; 0x8954 <__fp_szero>
    8898:	5f 3f       	cpi	r21, 0xFF	; 255
    889a:	ec f3       	brlt	.-6      	; 0x8896 <__mulsf3_pse+0x82>
    889c:	98 3e       	cpi	r25, 0xE8	; 232
    889e:	dc f3       	brlt	.-10     	; 0x8896 <__mulsf3_pse+0x82>
    88a0:	86 95       	lsr	r24
    88a2:	77 95       	ror	r23
    88a4:	67 95       	ror	r22
    88a6:	b7 95       	ror	r27
    88a8:	f7 95       	ror	r31
    88aa:	e7 95       	ror	r30
    88ac:	9f 5f       	subi	r25, 0xFF	; 255
    88ae:	c1 f7       	brne	.-16     	; 0x88a0 <__mulsf3_pse+0x8c>
    88b0:	fe 2b       	or	r31, r30
    88b2:	88 0f       	add	r24, r24
    88b4:	91 1d       	adc	r25, r1
    88b6:	96 95       	lsr	r25
    88b8:	87 95       	ror	r24
    88ba:	97 f9       	bld	r25, 7
    88bc:	08 95       	ret

000088be <__fp_inf>:
    88be:	97 f9       	bld	r25, 7
    88c0:	9f 67       	ori	r25, 0x7F	; 127
    88c2:	80 e8       	ldi	r24, 0x80	; 128
    88c4:	70 e0       	ldi	r23, 0x00	; 0
    88c6:	60 e0       	ldi	r22, 0x00	; 0
    88c8:	08 95       	ret

000088ca <__fp_nan>:
    88ca:	9f ef       	ldi	r25, 0xFF	; 255
    88cc:	80 ec       	ldi	r24, 0xC0	; 192
    88ce:	08 95       	ret

000088d0 <__fp_pscA>:
    88d0:	00 24       	eor	r0, r0
    88d2:	0a 94       	dec	r0
    88d4:	16 16       	cp	r1, r22
    88d6:	17 06       	cpc	r1, r23
    88d8:	18 06       	cpc	r1, r24
    88da:	09 06       	cpc	r0, r25
    88dc:	08 95       	ret

000088de <__fp_pscB>:
    88de:	00 24       	eor	r0, r0
    88e0:	0a 94       	dec	r0
    88e2:	12 16       	cp	r1, r18
    88e4:	13 06       	cpc	r1, r19
    88e6:	14 06       	cpc	r1, r20
    88e8:	05 06       	cpc	r0, r21
    88ea:	08 95       	ret

000088ec <__fp_round>:
    88ec:	09 2e       	mov	r0, r25
    88ee:	03 94       	inc	r0
    88f0:	00 0c       	add	r0, r0
    88f2:	11 f4       	brne	.+4      	; 0x88f8 <__fp_round+0xc>
    88f4:	88 23       	and	r24, r24
    88f6:	52 f0       	brmi	.+20     	; 0x890c <__fp_round+0x20>
    88f8:	bb 0f       	add	r27, r27
    88fa:	40 f4       	brcc	.+16     	; 0x890c <__fp_round+0x20>
    88fc:	bf 2b       	or	r27, r31
    88fe:	11 f4       	brne	.+4      	; 0x8904 <__fp_round+0x18>
    8900:	60 ff       	sbrs	r22, 0
    8902:	04 c0       	rjmp	.+8      	; 0x890c <__fp_round+0x20>
    8904:	6f 5f       	subi	r22, 0xFF	; 255
    8906:	7f 4f       	sbci	r23, 0xFF	; 255
    8908:	8f 4f       	sbci	r24, 0xFF	; 255
    890a:	9f 4f       	sbci	r25, 0xFF	; 255
    890c:	08 95       	ret

0000890e <__fp_split3>:
    890e:	57 fd       	sbrc	r21, 7
    8910:	90 58       	subi	r25, 0x80	; 128
    8912:	44 0f       	add	r20, r20
    8914:	55 1f       	adc	r21, r21
    8916:	59 f0       	breq	.+22     	; 0x892e <__fp_splitA+0x10>
    8918:	5f 3f       	cpi	r21, 0xFF	; 255
    891a:	71 f0       	breq	.+28     	; 0x8938 <__fp_splitA+0x1a>
    891c:	47 95       	ror	r20

0000891e <__fp_splitA>:
    891e:	88 0f       	add	r24, r24
    8920:	97 fb       	bst	r25, 7
    8922:	99 1f       	adc	r25, r25
    8924:	61 f0       	breq	.+24     	; 0x893e <__fp_splitA+0x20>
    8926:	9f 3f       	cpi	r25, 0xFF	; 255
    8928:	79 f0       	breq	.+30     	; 0x8948 <__fp_splitA+0x2a>
    892a:	87 95       	ror	r24
    892c:	08 95       	ret
    892e:	12 16       	cp	r1, r18
    8930:	13 06       	cpc	r1, r19
    8932:	14 06       	cpc	r1, r20
    8934:	55 1f       	adc	r21, r21
    8936:	f2 cf       	rjmp	.-28     	; 0x891c <__fp_split3+0xe>
    8938:	46 95       	lsr	r20
    893a:	f1 df       	rcall	.-30     	; 0x891e <__fp_splitA>
    893c:	08 c0       	rjmp	.+16     	; 0x894e <__fp_splitA+0x30>
    893e:	16 16       	cp	r1, r22
    8940:	17 06       	cpc	r1, r23
    8942:	18 06       	cpc	r1, r24
    8944:	99 1f       	adc	r25, r25
    8946:	f1 cf       	rjmp	.-30     	; 0x892a <__fp_splitA+0xc>
    8948:	86 95       	lsr	r24
    894a:	71 05       	cpc	r23, r1
    894c:	61 05       	cpc	r22, r1
    894e:	08 94       	sec
    8950:	08 95       	ret

00008952 <__fp_zero>:
    8952:	e8 94       	clt

00008954 <__fp_szero>:
    8954:	bb 27       	eor	r27, r27
    8956:	66 27       	eor	r22, r22
    8958:	77 27       	eor	r23, r23
    895a:	cb 01       	movw	r24, r22
    895c:	97 f9       	bld	r25, 7
    895e:	08 95       	ret

00008960 <__divmodhi4>:
    8960:	97 fb       	bst	r25, 7
    8962:	07 2e       	mov	r0, r23
    8964:	16 f4       	brtc	.+4      	; 0x896a <__divmodhi4+0xa>
    8966:	00 94       	com	r0
    8968:	06 d0       	rcall	.+12     	; 0x8976 <__divmodhi4_neg1>
    896a:	77 fd       	sbrc	r23, 7
    896c:	08 d0       	rcall	.+16     	; 0x897e <__divmodhi4_neg2>
    896e:	60 d0       	rcall	.+192    	; 0x8a30 <__udivmodhi4>
    8970:	07 fc       	sbrc	r0, 7
    8972:	05 d0       	rcall	.+10     	; 0x897e <__divmodhi4_neg2>
    8974:	3e f4       	brtc	.+14     	; 0x8984 <__divmodhi4_exit>

00008976 <__divmodhi4_neg1>:
    8976:	90 95       	com	r25
    8978:	81 95       	neg	r24
    897a:	9f 4f       	sbci	r25, 0xFF	; 255
    897c:	08 95       	ret

0000897e <__divmodhi4_neg2>:
    897e:	70 95       	com	r23
    8980:	61 95       	neg	r22
    8982:	7f 4f       	sbci	r23, 0xFF	; 255

00008984 <__divmodhi4_exit>:
    8984:	08 95       	ret

00008986 <__udivmodsi4>:
    8986:	a1 e2       	ldi	r26, 0x21	; 33
    8988:	1a 2e       	mov	r1, r26
    898a:	aa 1b       	sub	r26, r26
    898c:	bb 1b       	sub	r27, r27
    898e:	fd 01       	movw	r30, r26
    8990:	0d c0       	rjmp	.+26     	; 0x89ac <__udivmodsi4_ep>

00008992 <__udivmodsi4_loop>:
    8992:	aa 1f       	adc	r26, r26
    8994:	bb 1f       	adc	r27, r27
    8996:	ee 1f       	adc	r30, r30
    8998:	ff 1f       	adc	r31, r31
    899a:	a2 17       	cp	r26, r18
    899c:	b3 07       	cpc	r27, r19
    899e:	e4 07       	cpc	r30, r20
    89a0:	f5 07       	cpc	r31, r21
    89a2:	20 f0       	brcs	.+8      	; 0x89ac <__udivmodsi4_ep>
    89a4:	a2 1b       	sub	r26, r18
    89a6:	b3 0b       	sbc	r27, r19
    89a8:	e4 0b       	sbc	r30, r20
    89aa:	f5 0b       	sbc	r31, r21

000089ac <__udivmodsi4_ep>:
    89ac:	66 1f       	adc	r22, r22
    89ae:	77 1f       	adc	r23, r23
    89b0:	88 1f       	adc	r24, r24
    89b2:	99 1f       	adc	r25, r25
    89b4:	1a 94       	dec	r1
    89b6:	69 f7       	brne	.-38     	; 0x8992 <__udivmodsi4_loop>
    89b8:	60 95       	com	r22
    89ba:	70 95       	com	r23
    89bc:	80 95       	com	r24
    89be:	90 95       	com	r25
    89c0:	9b 01       	movw	r18, r22
    89c2:	ac 01       	movw	r20, r24
    89c4:	bd 01       	movw	r22, r26
    89c6:	cf 01       	movw	r24, r30
    89c8:	08 95       	ret

000089ca <__divmodsi4>:
    89ca:	05 2e       	mov	r0, r21
    89cc:	97 fb       	bst	r25, 7
    89ce:	16 f4       	brtc	.+4      	; 0x89d4 <__divmodsi4+0xa>
    89d0:	00 94       	com	r0
    89d2:	0f d0       	rcall	.+30     	; 0x89f2 <__negsi2>
    89d4:	57 fd       	sbrc	r21, 7
    89d6:	05 d0       	rcall	.+10     	; 0x89e2 <__divmodsi4_neg2>
    89d8:	d6 df       	rcall	.-84     	; 0x8986 <__udivmodsi4>
    89da:	07 fc       	sbrc	r0, 7
    89dc:	02 d0       	rcall	.+4      	; 0x89e2 <__divmodsi4_neg2>
    89de:	46 f4       	brtc	.+16     	; 0x89f0 <__divmodsi4_exit>
    89e0:	08 c0       	rjmp	.+16     	; 0x89f2 <__negsi2>

000089e2 <__divmodsi4_neg2>:
    89e2:	50 95       	com	r21
    89e4:	40 95       	com	r20
    89e6:	30 95       	com	r19
    89e8:	21 95       	neg	r18
    89ea:	3f 4f       	sbci	r19, 0xFF	; 255
    89ec:	4f 4f       	sbci	r20, 0xFF	; 255
    89ee:	5f 4f       	sbci	r21, 0xFF	; 255

000089f0 <__divmodsi4_exit>:
    89f0:	08 95       	ret

000089f2 <__negsi2>:
    89f2:	90 95       	com	r25
    89f4:	80 95       	com	r24
    89f6:	70 95       	com	r23
    89f8:	61 95       	neg	r22
    89fa:	7f 4f       	sbci	r23, 0xFF	; 255
    89fc:	8f 4f       	sbci	r24, 0xFF	; 255
    89fe:	9f 4f       	sbci	r25, 0xFF	; 255
    8a00:	08 95       	ret

00008a02 <__tablejump2__>:
    8a02:	ee 0f       	add	r30, r30
    8a04:	ff 1f       	adc	r31, r31
    8a06:	88 1f       	adc	r24, r24
    8a08:	8b bf       	out	0x3b, r24	; 59
    8a0a:	07 90       	elpm	r0, Z+
    8a0c:	f6 91       	elpm	r31, Z
    8a0e:	e0 2d       	mov	r30, r0
    8a10:	19 94       	eijmp

00008a12 <__umulhisi3>:
    8a12:	a2 9f       	mul	r26, r18
    8a14:	b0 01       	movw	r22, r0
    8a16:	b3 9f       	mul	r27, r19
    8a18:	c0 01       	movw	r24, r0
    8a1a:	a3 9f       	mul	r26, r19
    8a1c:	70 0d       	add	r23, r0
    8a1e:	81 1d       	adc	r24, r1
    8a20:	11 24       	eor	r1, r1
    8a22:	91 1d       	adc	r25, r1
    8a24:	b2 9f       	mul	r27, r18
    8a26:	70 0d       	add	r23, r0
    8a28:	81 1d       	adc	r24, r1
    8a2a:	11 24       	eor	r1, r1
    8a2c:	91 1d       	adc	r25, r1
    8a2e:	08 95       	ret

00008a30 <__udivmodhi4>:
    8a30:	aa 1b       	sub	r26, r26
    8a32:	bb 1b       	sub	r27, r27
    8a34:	51 e1       	ldi	r21, 0x11	; 17
    8a36:	07 c0       	rjmp	.+14     	; 0x8a46 <__udivmodhi4_ep>

00008a38 <__udivmodhi4_loop>:
    8a38:	aa 1f       	adc	r26, r26
    8a3a:	bb 1f       	adc	r27, r27
    8a3c:	a6 17       	cp	r26, r22
    8a3e:	b7 07       	cpc	r27, r23
    8a40:	10 f0       	brcs	.+4      	; 0x8a46 <__udivmodhi4_ep>
    8a42:	a6 1b       	sub	r26, r22
    8a44:	b7 0b       	sbc	r27, r23

00008a46 <__udivmodhi4_ep>:
    8a46:	88 1f       	adc	r24, r24
    8a48:	99 1f       	adc	r25, r25
    8a4a:	5a 95       	dec	r21
    8a4c:	a9 f7       	brne	.-22     	; 0x8a38 <__udivmodhi4_loop>
    8a4e:	80 95       	com	r24
    8a50:	90 95       	com	r25
    8a52:	bc 01       	movw	r22, r24
    8a54:	cd 01       	movw	r24, r26
    8a56:	08 95       	ret

00008a58 <do_rand>:
    8a58:	8f 92       	push	r8
    8a5a:	9f 92       	push	r9
    8a5c:	af 92       	push	r10
    8a5e:	bf 92       	push	r11
    8a60:	cf 92       	push	r12
    8a62:	df 92       	push	r13
    8a64:	ef 92       	push	r14
    8a66:	ff 92       	push	r15
    8a68:	cf 93       	push	r28
    8a6a:	df 93       	push	r29
    8a6c:	ec 01       	movw	r28, r24
    8a6e:	68 81       	ld	r22, Y
    8a70:	79 81       	ldd	r23, Y+1	; 0x01
    8a72:	8a 81       	ldd	r24, Y+2	; 0x02
    8a74:	9b 81       	ldd	r25, Y+3	; 0x03
    8a76:	61 15       	cp	r22, r1
    8a78:	71 05       	cpc	r23, r1
    8a7a:	81 05       	cpc	r24, r1
    8a7c:	91 05       	cpc	r25, r1
    8a7e:	21 f4       	brne	.+8      	; 0x8a88 <do_rand+0x30>
    8a80:	64 e2       	ldi	r22, 0x24	; 36
    8a82:	79 ed       	ldi	r23, 0xD9	; 217
    8a84:	8b e5       	ldi	r24, 0x5B	; 91
    8a86:	97 e0       	ldi	r25, 0x07	; 7
    8a88:	2d e1       	ldi	r18, 0x1D	; 29
    8a8a:	33 ef       	ldi	r19, 0xF3	; 243
    8a8c:	41 e0       	ldi	r20, 0x01	; 1
    8a8e:	50 e0       	ldi	r21, 0x00	; 0
    8a90:	9c df       	rcall	.-200    	; 0x89ca <__divmodsi4>
    8a92:	49 01       	movw	r8, r18
    8a94:	5a 01       	movw	r10, r20
    8a96:	9b 01       	movw	r18, r22
    8a98:	ac 01       	movw	r20, r24
    8a9a:	a7 ea       	ldi	r26, 0xA7	; 167
    8a9c:	b1 e4       	ldi	r27, 0x41	; 65
    8a9e:	86 d5       	rcall	.+2828   	; 0x95ac <__muluhisi3>
    8aa0:	6b 01       	movw	r12, r22
    8aa2:	7c 01       	movw	r14, r24
    8aa4:	ac ee       	ldi	r26, 0xEC	; 236
    8aa6:	b4 ef       	ldi	r27, 0xF4	; 244
    8aa8:	a5 01       	movw	r20, r10
    8aaa:	94 01       	movw	r18, r8
    8aac:	8b d5       	rcall	.+2838   	; 0x95c4 <__mulohisi3>
    8aae:	dc 01       	movw	r26, r24
    8ab0:	cb 01       	movw	r24, r22
    8ab2:	8c 0d       	add	r24, r12
    8ab4:	9d 1d       	adc	r25, r13
    8ab6:	ae 1d       	adc	r26, r14
    8ab8:	bf 1d       	adc	r27, r15
    8aba:	b7 ff       	sbrs	r27, 7
    8abc:	03 c0       	rjmp	.+6      	; 0x8ac4 <do_rand+0x6c>
    8abe:	01 97       	sbiw	r24, 0x01	; 1
    8ac0:	a1 09       	sbc	r26, r1
    8ac2:	b0 48       	sbci	r27, 0x80	; 128
    8ac4:	88 83       	st	Y, r24
    8ac6:	99 83       	std	Y+1, r25	; 0x01
    8ac8:	aa 83       	std	Y+2, r26	; 0x02
    8aca:	bb 83       	std	Y+3, r27	; 0x03
    8acc:	9f 77       	andi	r25, 0x7F	; 127
    8ace:	df 91       	pop	r29
    8ad0:	cf 91       	pop	r28
    8ad2:	ff 90       	pop	r15
    8ad4:	ef 90       	pop	r14
    8ad6:	df 90       	pop	r13
    8ad8:	cf 90       	pop	r12
    8ada:	bf 90       	pop	r11
    8adc:	af 90       	pop	r10
    8ade:	9f 90       	pop	r9
    8ae0:	8f 90       	pop	r8
    8ae2:	08 95       	ret

00008ae4 <rand_r>:
    8ae4:	b9 cf       	rjmp	.-142    	; 0x8a58 <do_rand>

00008ae6 <rand>:
    8ae6:	80 e0       	ldi	r24, 0x00	; 0
    8ae8:	92 e0       	ldi	r25, 0x02	; 2
    8aea:	b6 cf       	rjmp	.-148    	; 0x8a58 <do_rand>

00008aec <srand>:
    8aec:	a0 e0       	ldi	r26, 0x00	; 0
    8aee:	b0 e0       	ldi	r27, 0x00	; 0
    8af0:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    8af4:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    8af8:	a0 93 02 02 	sts	0x0202, r26	; 0x800202 <__DATA_REGION_ORIGIN__+0x2>
    8afc:	b0 93 03 02 	sts	0x0203, r27	; 0x800203 <__DATA_REGION_ORIGIN__+0x3>
    8b00:	08 95       	ret

00008b02 <memcmp>:
    8b02:	fb 01       	movw	r30, r22
    8b04:	dc 01       	movw	r26, r24
    8b06:	04 c0       	rjmp	.+8      	; 0x8b10 <memcmp+0xe>
    8b08:	8d 91       	ld	r24, X+
    8b0a:	01 90       	ld	r0, Z+
    8b0c:	80 19       	sub	r24, r0
    8b0e:	21 f4       	brne	.+8      	; 0x8b18 <memcmp+0x16>
    8b10:	41 50       	subi	r20, 0x01	; 1
    8b12:	50 40       	sbci	r21, 0x00	; 0
    8b14:	c8 f7       	brcc	.-14     	; 0x8b08 <memcmp+0x6>
    8b16:	88 1b       	sub	r24, r24
    8b18:	99 0b       	sbc	r25, r25
    8b1a:	08 95       	ret

00008b1c <memcpy>:
    8b1c:	fb 01       	movw	r30, r22
    8b1e:	dc 01       	movw	r26, r24
    8b20:	02 c0       	rjmp	.+4      	; 0x8b26 <memcpy+0xa>
    8b22:	01 90       	ld	r0, Z+
    8b24:	0d 92       	st	X+, r0
    8b26:	41 50       	subi	r20, 0x01	; 1
    8b28:	50 40       	sbci	r21, 0x00	; 0
    8b2a:	d8 f7       	brcc	.-10     	; 0x8b22 <memcpy+0x6>
    8b2c:	08 95       	ret

00008b2e <memset>:
    8b2e:	dc 01       	movw	r26, r24
    8b30:	01 c0       	rjmp	.+2      	; 0x8b34 <memset+0x6>
    8b32:	6d 93       	st	X+, r22
    8b34:	41 50       	subi	r20, 0x01	; 1
    8b36:	50 40       	sbci	r21, 0x00	; 0
    8b38:	e0 f7       	brcc	.-8      	; 0x8b32 <memset+0x4>
    8b3a:	08 95       	ret

00008b3c <strcpy>:
    8b3c:	fb 01       	movw	r30, r22
    8b3e:	dc 01       	movw	r26, r24
    8b40:	01 90       	ld	r0, Z+
    8b42:	0d 92       	st	X+, r0
    8b44:	00 20       	and	r0, r0
    8b46:	e1 f7       	brne	.-8      	; 0x8b40 <strcpy+0x4>
    8b48:	08 95       	ret

00008b4a <strncmp>:
    8b4a:	fb 01       	movw	r30, r22
    8b4c:	dc 01       	movw	r26, r24
    8b4e:	41 50       	subi	r20, 0x01	; 1
    8b50:	50 40       	sbci	r21, 0x00	; 0
    8b52:	30 f0       	brcs	.+12     	; 0x8b60 <strncmp+0x16>
    8b54:	8d 91       	ld	r24, X+
    8b56:	01 90       	ld	r0, Z+
    8b58:	80 19       	sub	r24, r0
    8b5a:	19 f4       	brne	.+6      	; 0x8b62 <strncmp+0x18>
    8b5c:	00 20       	and	r0, r0
    8b5e:	b9 f7       	brne	.-18     	; 0x8b4e <strncmp+0x4>
    8b60:	88 1b       	sub	r24, r24
    8b62:	99 0b       	sbc	r25, r25
    8b64:	08 95       	ret

00008b66 <strncpy>:
    8b66:	fb 01       	movw	r30, r22
    8b68:	dc 01       	movw	r26, r24
    8b6a:	41 50       	subi	r20, 0x01	; 1
    8b6c:	50 40       	sbci	r21, 0x00	; 0
    8b6e:	48 f0       	brcs	.+18     	; 0x8b82 <strncpy+0x1c>
    8b70:	01 90       	ld	r0, Z+
    8b72:	0d 92       	st	X+, r0
    8b74:	00 20       	and	r0, r0
    8b76:	c9 f7       	brne	.-14     	; 0x8b6a <strncpy+0x4>
    8b78:	01 c0       	rjmp	.+2      	; 0x8b7c <strncpy+0x16>
    8b7a:	1d 92       	st	X+, r1
    8b7c:	41 50       	subi	r20, 0x01	; 1
    8b7e:	50 40       	sbci	r21, 0x00	; 0
    8b80:	e0 f7       	brcc	.-8      	; 0x8b7a <strncpy+0x14>
    8b82:	08 95       	ret

00008b84 <strnlen>:
    8b84:	fc 01       	movw	r30, r24
    8b86:	61 50       	subi	r22, 0x01	; 1
    8b88:	70 40       	sbci	r23, 0x00	; 0
    8b8a:	01 90       	ld	r0, Z+
    8b8c:	01 10       	cpse	r0, r1
    8b8e:	d8 f7       	brcc	.-10     	; 0x8b86 <strnlen+0x2>
    8b90:	80 95       	com	r24
    8b92:	90 95       	com	r25
    8b94:	8e 0f       	add	r24, r30
    8b96:	9f 1f       	adc	r25, r31
    8b98:	08 95       	ret

00008b9a <fdevopen>:
    8b9a:	0f 93       	push	r16
    8b9c:	1f 93       	push	r17
    8b9e:	cf 93       	push	r28
    8ba0:	df 93       	push	r29
    8ba2:	00 97       	sbiw	r24, 0x00	; 0
    8ba4:	31 f4       	brne	.+12     	; 0x8bb2 <fdevopen+0x18>
    8ba6:	61 15       	cp	r22, r1
    8ba8:	71 05       	cpc	r23, r1
    8baa:	19 f4       	brne	.+6      	; 0x8bb2 <fdevopen+0x18>
    8bac:	80 e0       	ldi	r24, 0x00	; 0
    8bae:	90 e0       	ldi	r25, 0x00	; 0
    8bb0:	39 c0       	rjmp	.+114    	; 0x8c24 <fdevopen+0x8a>
    8bb2:	8b 01       	movw	r16, r22
    8bb4:	ec 01       	movw	r28, r24
    8bb6:	6e e0       	ldi	r22, 0x0E	; 14
    8bb8:	70 e0       	ldi	r23, 0x00	; 0
    8bba:	81 e0       	ldi	r24, 0x01	; 1
    8bbc:	90 e0       	ldi	r25, 0x00	; 0
    8bbe:	16 d3       	rcall	.+1580   	; 0x91ec <calloc>
    8bc0:	fc 01       	movw	r30, r24
    8bc2:	89 2b       	or	r24, r25
    8bc4:	99 f3       	breq	.-26     	; 0x8bac <fdevopen+0x12>
    8bc6:	80 e8       	ldi	r24, 0x80	; 128
    8bc8:	83 83       	std	Z+3, r24	; 0x03
    8bca:	01 15       	cp	r16, r1
    8bcc:	11 05       	cpc	r17, r1
    8bce:	71 f0       	breq	.+28     	; 0x8bec <fdevopen+0x52>
    8bd0:	13 87       	std	Z+11, r17	; 0x0b
    8bd2:	02 87       	std	Z+10, r16	; 0x0a
    8bd4:	81 e8       	ldi	r24, 0x81	; 129
    8bd6:	83 83       	std	Z+3, r24	; 0x03
    8bd8:	80 91 75 20 	lds	r24, 0x2075	; 0x802075 <__iob>
    8bdc:	90 91 76 20 	lds	r25, 0x2076	; 0x802076 <__iob+0x1>
    8be0:	89 2b       	or	r24, r25
    8be2:	21 f4       	brne	.+8      	; 0x8bec <fdevopen+0x52>
    8be4:	f0 93 76 20 	sts	0x2076, r31	; 0x802076 <__iob+0x1>
    8be8:	e0 93 75 20 	sts	0x2075, r30	; 0x802075 <__iob>
    8bec:	20 97       	sbiw	r28, 0x00	; 0
    8bee:	c9 f0       	breq	.+50     	; 0x8c22 <fdevopen+0x88>
    8bf0:	d1 87       	std	Z+9, r29	; 0x09
    8bf2:	c0 87       	std	Z+8, r28	; 0x08
    8bf4:	83 81       	ldd	r24, Z+3	; 0x03
    8bf6:	82 60       	ori	r24, 0x02	; 2
    8bf8:	83 83       	std	Z+3, r24	; 0x03
    8bfa:	80 91 77 20 	lds	r24, 0x2077	; 0x802077 <__iob+0x2>
    8bfe:	90 91 78 20 	lds	r25, 0x2078	; 0x802078 <__iob+0x3>
    8c02:	89 2b       	or	r24, r25
    8c04:	71 f4       	brne	.+28     	; 0x8c22 <fdevopen+0x88>
    8c06:	f0 93 78 20 	sts	0x2078, r31	; 0x802078 <__iob+0x3>
    8c0a:	e0 93 77 20 	sts	0x2077, r30	; 0x802077 <__iob+0x2>
    8c0e:	80 91 79 20 	lds	r24, 0x2079	; 0x802079 <__iob+0x4>
    8c12:	90 91 7a 20 	lds	r25, 0x207A	; 0x80207a <__iob+0x5>
    8c16:	89 2b       	or	r24, r25
    8c18:	21 f4       	brne	.+8      	; 0x8c22 <fdevopen+0x88>
    8c1a:	f0 93 7a 20 	sts	0x207A, r31	; 0x80207a <__iob+0x5>
    8c1e:	e0 93 79 20 	sts	0x2079, r30	; 0x802079 <__iob+0x4>
    8c22:	cf 01       	movw	r24, r30
    8c24:	df 91       	pop	r29
    8c26:	cf 91       	pop	r28
    8c28:	1f 91       	pop	r17
    8c2a:	0f 91       	pop	r16
    8c2c:	08 95       	ret

00008c2e <printf>:
    8c2e:	cf 93       	push	r28
    8c30:	df 93       	push	r29
    8c32:	cd b7       	in	r28, 0x3d	; 61
    8c34:	de b7       	in	r29, 0x3e	; 62
    8c36:	ae 01       	movw	r20, r28
    8c38:	4a 5f       	subi	r20, 0xFA	; 250
    8c3a:	5f 4f       	sbci	r21, 0xFF	; 255
    8c3c:	fa 01       	movw	r30, r20
    8c3e:	61 91       	ld	r22, Z+
    8c40:	71 91       	ld	r23, Z+
    8c42:	af 01       	movw	r20, r30
    8c44:	80 91 77 20 	lds	r24, 0x2077	; 0x802077 <__iob+0x2>
    8c48:	90 91 78 20 	lds	r25, 0x2078	; 0x802078 <__iob+0x3>
    8c4c:	d2 d0       	rcall	.+420    	; 0x8df2 <vfprintf>
    8c4e:	df 91       	pop	r29
    8c50:	cf 91       	pop	r28
    8c52:	08 95       	ret

00008c54 <printf_P>:
    8c54:	0f 93       	push	r16
    8c56:	1f 93       	push	r17
    8c58:	cf 93       	push	r28
    8c5a:	df 93       	push	r29
    8c5c:	cd b7       	in	r28, 0x3d	; 61
    8c5e:	de b7       	in	r29, 0x3e	; 62
    8c60:	ae 01       	movw	r20, r28
    8c62:	48 5f       	subi	r20, 0xF8	; 248
    8c64:	5f 4f       	sbci	r21, 0xFF	; 255
    8c66:	da 01       	movw	r26, r20
    8c68:	6d 91       	ld	r22, X+
    8c6a:	7d 91       	ld	r23, X+
    8c6c:	ad 01       	movw	r20, r26
    8c6e:	05 e7       	ldi	r16, 0x75	; 117
    8c70:	10 e2       	ldi	r17, 0x20	; 32
    8c72:	f8 01       	movw	r30, r16
    8c74:	82 81       	ldd	r24, Z+2	; 0x02
    8c76:	93 81       	ldd	r25, Z+3	; 0x03
    8c78:	dc 01       	movw	r26, r24
    8c7a:	13 96       	adiw	r26, 0x03	; 3
    8c7c:	2c 91       	ld	r18, X
    8c7e:	13 97       	sbiw	r26, 0x03	; 3
    8c80:	28 60       	ori	r18, 0x08	; 8
    8c82:	13 96       	adiw	r26, 0x03	; 3
    8c84:	2c 93       	st	X, r18
    8c86:	b5 d0       	rcall	.+362    	; 0x8df2 <vfprintf>
    8c88:	d8 01       	movw	r26, r16
    8c8a:	12 96       	adiw	r26, 0x02	; 2
    8c8c:	ed 91       	ld	r30, X+
    8c8e:	fc 91       	ld	r31, X
    8c90:	13 97       	sbiw	r26, 0x03	; 3
    8c92:	23 81       	ldd	r18, Z+3	; 0x03
    8c94:	27 7f       	andi	r18, 0xF7	; 247
    8c96:	23 83       	std	Z+3, r18	; 0x03
    8c98:	df 91       	pop	r29
    8c9a:	cf 91       	pop	r28
    8c9c:	1f 91       	pop	r17
    8c9e:	0f 91       	pop	r16
    8ca0:	08 95       	ret

00008ca2 <puts>:
    8ca2:	0f 93       	push	r16
    8ca4:	1f 93       	push	r17
    8ca6:	cf 93       	push	r28
    8ca8:	df 93       	push	r29
    8caa:	e0 91 77 20 	lds	r30, 0x2077	; 0x802077 <__iob+0x2>
    8cae:	f0 91 78 20 	lds	r31, 0x2078	; 0x802078 <__iob+0x3>
    8cb2:	23 81       	ldd	r18, Z+3	; 0x03
    8cb4:	21 ff       	sbrs	r18, 1
    8cb6:	1b c0       	rjmp	.+54     	; 0x8cee <puts+0x4c>
    8cb8:	8c 01       	movw	r16, r24
    8cba:	d0 e0       	ldi	r29, 0x00	; 0
    8cbc:	c0 e0       	ldi	r28, 0x00	; 0
    8cbe:	f8 01       	movw	r30, r16
    8cc0:	81 91       	ld	r24, Z+
    8cc2:	8f 01       	movw	r16, r30
    8cc4:	60 91 77 20 	lds	r22, 0x2077	; 0x802077 <__iob+0x2>
    8cc8:	70 91 78 20 	lds	r23, 0x2078	; 0x802078 <__iob+0x3>
    8ccc:	db 01       	movw	r26, r22
    8cce:	18 96       	adiw	r26, 0x08	; 8
    8cd0:	ed 91       	ld	r30, X+
    8cd2:	fc 91       	ld	r31, X
    8cd4:	19 97       	sbiw	r26, 0x09	; 9
    8cd6:	88 23       	and	r24, r24
    8cd8:	31 f0       	breq	.+12     	; 0x8ce6 <puts+0x44>
    8cda:	19 95       	eicall
    8cdc:	89 2b       	or	r24, r25
    8cde:	79 f3       	breq	.-34     	; 0x8cbe <puts+0x1c>
    8ce0:	df ef       	ldi	r29, 0xFF	; 255
    8ce2:	cf ef       	ldi	r28, 0xFF	; 255
    8ce4:	ec cf       	rjmp	.-40     	; 0x8cbe <puts+0x1c>
    8ce6:	8a e0       	ldi	r24, 0x0A	; 10
    8ce8:	19 95       	eicall
    8cea:	89 2b       	or	r24, r25
    8cec:	19 f0       	breq	.+6      	; 0x8cf4 <puts+0x52>
    8cee:	8f ef       	ldi	r24, 0xFF	; 255
    8cf0:	9f ef       	ldi	r25, 0xFF	; 255
    8cf2:	02 c0       	rjmp	.+4      	; 0x8cf8 <puts+0x56>
    8cf4:	8d 2f       	mov	r24, r29
    8cf6:	9c 2f       	mov	r25, r28
    8cf8:	df 91       	pop	r29
    8cfa:	cf 91       	pop	r28
    8cfc:	1f 91       	pop	r17
    8cfe:	0f 91       	pop	r16
    8d00:	08 95       	ret

00008d02 <snprintf_P>:
    8d02:	0f 93       	push	r16
    8d04:	1f 93       	push	r17
    8d06:	cf 93       	push	r28
    8d08:	df 93       	push	r29
    8d0a:	cd b7       	in	r28, 0x3d	; 61
    8d0c:	de b7       	in	r29, 0x3e	; 62
    8d0e:	2e 97       	sbiw	r28, 0x0e	; 14
    8d10:	0f b6       	in	r0, 0x3f	; 63
    8d12:	f8 94       	cli
    8d14:	de bf       	out	0x3e, r29	; 62
    8d16:	0f be       	out	0x3f, r0	; 63
    8d18:	cd bf       	out	0x3d, r28	; 61
    8d1a:	0e 89       	ldd	r16, Y+22	; 0x16
    8d1c:	1f 89       	ldd	r17, Y+23	; 0x17
    8d1e:	88 8d       	ldd	r24, Y+24	; 0x18
    8d20:	99 8d       	ldd	r25, Y+25	; 0x19
    8d22:	2e e0       	ldi	r18, 0x0E	; 14
    8d24:	2c 83       	std	Y+4, r18	; 0x04
    8d26:	1a 83       	std	Y+2, r17	; 0x02
    8d28:	09 83       	std	Y+1, r16	; 0x01
    8d2a:	97 ff       	sbrs	r25, 7
    8d2c:	02 c0       	rjmp	.+4      	; 0x8d32 <snprintf_P+0x30>
    8d2e:	80 e0       	ldi	r24, 0x00	; 0
    8d30:	90 e8       	ldi	r25, 0x80	; 128
    8d32:	01 97       	sbiw	r24, 0x01	; 1
    8d34:	9e 83       	std	Y+6, r25	; 0x06
    8d36:	8d 83       	std	Y+5, r24	; 0x05
    8d38:	ae 01       	movw	r20, r28
    8d3a:	44 5e       	subi	r20, 0xE4	; 228
    8d3c:	5f 4f       	sbci	r21, 0xFF	; 255
    8d3e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    8d40:	7b 8d       	ldd	r23, Y+27	; 0x1b
    8d42:	ce 01       	movw	r24, r28
    8d44:	01 96       	adiw	r24, 0x01	; 1
    8d46:	55 d0       	rcall	.+170    	; 0x8df2 <vfprintf>
    8d48:	4d 81       	ldd	r20, Y+5	; 0x05
    8d4a:	5e 81       	ldd	r21, Y+6	; 0x06
    8d4c:	57 fd       	sbrc	r21, 7
    8d4e:	0a c0       	rjmp	.+20     	; 0x8d64 <snprintf_P+0x62>
    8d50:	2f 81       	ldd	r18, Y+7	; 0x07
    8d52:	38 85       	ldd	r19, Y+8	; 0x08
    8d54:	42 17       	cp	r20, r18
    8d56:	53 07       	cpc	r21, r19
    8d58:	0c f4       	brge	.+2      	; 0x8d5c <snprintf_P+0x5a>
    8d5a:	9a 01       	movw	r18, r20
    8d5c:	f8 01       	movw	r30, r16
    8d5e:	e2 0f       	add	r30, r18
    8d60:	f3 1f       	adc	r31, r19
    8d62:	10 82       	st	Z, r1
    8d64:	2e 96       	adiw	r28, 0x0e	; 14
    8d66:	0f b6       	in	r0, 0x3f	; 63
    8d68:	f8 94       	cli
    8d6a:	de bf       	out	0x3e, r29	; 62
    8d6c:	0f be       	out	0x3f, r0	; 63
    8d6e:	cd bf       	out	0x3d, r28	; 61
    8d70:	df 91       	pop	r29
    8d72:	cf 91       	pop	r28
    8d74:	1f 91       	pop	r17
    8d76:	0f 91       	pop	r16
    8d78:	08 95       	ret

00008d7a <sprintf>:
    8d7a:	0f 93       	push	r16
    8d7c:	1f 93       	push	r17
    8d7e:	cf 93       	push	r28
    8d80:	df 93       	push	r29
    8d82:	cd b7       	in	r28, 0x3d	; 61
    8d84:	de b7       	in	r29, 0x3e	; 62
    8d86:	2e 97       	sbiw	r28, 0x0e	; 14
    8d88:	0f b6       	in	r0, 0x3f	; 63
    8d8a:	f8 94       	cli
    8d8c:	de bf       	out	0x3e, r29	; 62
    8d8e:	0f be       	out	0x3f, r0	; 63
    8d90:	cd bf       	out	0x3d, r28	; 61
    8d92:	0e 89       	ldd	r16, Y+22	; 0x16
    8d94:	1f 89       	ldd	r17, Y+23	; 0x17
    8d96:	86 e0       	ldi	r24, 0x06	; 6
    8d98:	8c 83       	std	Y+4, r24	; 0x04
    8d9a:	1a 83       	std	Y+2, r17	; 0x02
    8d9c:	09 83       	std	Y+1, r16	; 0x01
    8d9e:	8f ef       	ldi	r24, 0xFF	; 255
    8da0:	9f e7       	ldi	r25, 0x7F	; 127
    8da2:	9e 83       	std	Y+6, r25	; 0x06
    8da4:	8d 83       	std	Y+5, r24	; 0x05
    8da6:	ae 01       	movw	r20, r28
    8da8:	46 5e       	subi	r20, 0xE6	; 230
    8daa:	5f 4f       	sbci	r21, 0xFF	; 255
    8dac:	68 8d       	ldd	r22, Y+24	; 0x18
    8dae:	79 8d       	ldd	r23, Y+25	; 0x19
    8db0:	ce 01       	movw	r24, r28
    8db2:	01 96       	adiw	r24, 0x01	; 1
    8db4:	1e d0       	rcall	.+60     	; 0x8df2 <vfprintf>
    8db6:	ef 81       	ldd	r30, Y+7	; 0x07
    8db8:	f8 85       	ldd	r31, Y+8	; 0x08
    8dba:	e0 0f       	add	r30, r16
    8dbc:	f1 1f       	adc	r31, r17
    8dbe:	10 82       	st	Z, r1
    8dc0:	2e 96       	adiw	r28, 0x0e	; 14
    8dc2:	0f b6       	in	r0, 0x3f	; 63
    8dc4:	f8 94       	cli
    8dc6:	de bf       	out	0x3e, r29	; 62
    8dc8:	0f be       	out	0x3f, r0	; 63
    8dca:	cd bf       	out	0x3d, r28	; 61
    8dcc:	df 91       	pop	r29
    8dce:	cf 91       	pop	r28
    8dd0:	1f 91       	pop	r17
    8dd2:	0f 91       	pop	r16
    8dd4:	08 95       	ret

00008dd6 <vfprintf_P>:
    8dd6:	cf 93       	push	r28
    8dd8:	df 93       	push	r29
    8dda:	ec 01       	movw	r28, r24
    8ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    8dde:	88 60       	ori	r24, 0x08	; 8
    8de0:	8b 83       	std	Y+3, r24	; 0x03
    8de2:	ce 01       	movw	r24, r28
    8de4:	06 d0       	rcall	.+12     	; 0x8df2 <vfprintf>
    8de6:	2b 81       	ldd	r18, Y+3	; 0x03
    8de8:	27 7f       	andi	r18, 0xF7	; 247
    8dea:	2b 83       	std	Y+3, r18	; 0x03
    8dec:	df 91       	pop	r29
    8dee:	cf 91       	pop	r28
    8df0:	08 95       	ret

00008df2 <vfprintf>:
    8df2:	2f 92       	push	r2
    8df4:	3f 92       	push	r3
    8df6:	4f 92       	push	r4
    8df8:	5f 92       	push	r5
    8dfa:	6f 92       	push	r6
    8dfc:	7f 92       	push	r7
    8dfe:	8f 92       	push	r8
    8e00:	9f 92       	push	r9
    8e02:	af 92       	push	r10
    8e04:	bf 92       	push	r11
    8e06:	cf 92       	push	r12
    8e08:	df 92       	push	r13
    8e0a:	ef 92       	push	r14
    8e0c:	ff 92       	push	r15
    8e0e:	0f 93       	push	r16
    8e10:	1f 93       	push	r17
    8e12:	cf 93       	push	r28
    8e14:	df 93       	push	r29
    8e16:	cd b7       	in	r28, 0x3d	; 61
    8e18:	de b7       	in	r29, 0x3e	; 62
    8e1a:	2b 97       	sbiw	r28, 0x0b	; 11
    8e1c:	0f b6       	in	r0, 0x3f	; 63
    8e1e:	f8 94       	cli
    8e20:	de bf       	out	0x3e, r29	; 62
    8e22:	0f be       	out	0x3f, r0	; 63
    8e24:	cd bf       	out	0x3d, r28	; 61
    8e26:	6c 01       	movw	r12, r24
    8e28:	7b 01       	movw	r14, r22
    8e2a:	8a 01       	movw	r16, r20
    8e2c:	fc 01       	movw	r30, r24
    8e2e:	17 82       	std	Z+7, r1	; 0x07
    8e30:	16 82       	std	Z+6, r1	; 0x06
    8e32:	83 81       	ldd	r24, Z+3	; 0x03
    8e34:	81 ff       	sbrs	r24, 1
    8e36:	bf c1       	rjmp	.+894    	; 0x91b6 <vfprintf+0x3c4>
    8e38:	ce 01       	movw	r24, r28
    8e3a:	01 96       	adiw	r24, 0x01	; 1
    8e3c:	3c 01       	movw	r6, r24
    8e3e:	f6 01       	movw	r30, r12
    8e40:	93 81       	ldd	r25, Z+3	; 0x03
    8e42:	f7 01       	movw	r30, r14
    8e44:	93 fd       	sbrc	r25, 3
    8e46:	85 91       	lpm	r24, Z+
    8e48:	93 ff       	sbrs	r25, 3
    8e4a:	81 91       	ld	r24, Z+
    8e4c:	7f 01       	movw	r14, r30
    8e4e:	88 23       	and	r24, r24
    8e50:	09 f4       	brne	.+2      	; 0x8e54 <vfprintf+0x62>
    8e52:	ad c1       	rjmp	.+858    	; 0x91ae <vfprintf+0x3bc>
    8e54:	85 32       	cpi	r24, 0x25	; 37
    8e56:	39 f4       	brne	.+14     	; 0x8e66 <vfprintf+0x74>
    8e58:	93 fd       	sbrc	r25, 3
    8e5a:	85 91       	lpm	r24, Z+
    8e5c:	93 ff       	sbrs	r25, 3
    8e5e:	81 91       	ld	r24, Z+
    8e60:	7f 01       	movw	r14, r30
    8e62:	85 32       	cpi	r24, 0x25	; 37
    8e64:	21 f4       	brne	.+8      	; 0x8e6e <vfprintf+0x7c>
    8e66:	b6 01       	movw	r22, r12
    8e68:	90 e0       	ldi	r25, 0x00	; 0
    8e6a:	06 d3       	rcall	.+1548   	; 0x9478 <fputc>
    8e6c:	e8 cf       	rjmp	.-48     	; 0x8e3e <vfprintf+0x4c>
    8e6e:	91 2c       	mov	r9, r1
    8e70:	21 2c       	mov	r2, r1
    8e72:	31 2c       	mov	r3, r1
    8e74:	ff e1       	ldi	r31, 0x1F	; 31
    8e76:	f3 15       	cp	r31, r3
    8e78:	d8 f0       	brcs	.+54     	; 0x8eb0 <vfprintf+0xbe>
    8e7a:	8b 32       	cpi	r24, 0x2B	; 43
    8e7c:	79 f0       	breq	.+30     	; 0x8e9c <vfprintf+0xaa>
    8e7e:	38 f4       	brcc	.+14     	; 0x8e8e <vfprintf+0x9c>
    8e80:	80 32       	cpi	r24, 0x20	; 32
    8e82:	79 f0       	breq	.+30     	; 0x8ea2 <vfprintf+0xb0>
    8e84:	83 32       	cpi	r24, 0x23	; 35
    8e86:	a1 f4       	brne	.+40     	; 0x8eb0 <vfprintf+0xbe>
    8e88:	23 2d       	mov	r18, r3
    8e8a:	20 61       	ori	r18, 0x10	; 16
    8e8c:	1d c0       	rjmp	.+58     	; 0x8ec8 <vfprintf+0xd6>
    8e8e:	8d 32       	cpi	r24, 0x2D	; 45
    8e90:	61 f0       	breq	.+24     	; 0x8eaa <vfprintf+0xb8>
    8e92:	80 33       	cpi	r24, 0x30	; 48
    8e94:	69 f4       	brne	.+26     	; 0x8eb0 <vfprintf+0xbe>
    8e96:	23 2d       	mov	r18, r3
    8e98:	21 60       	ori	r18, 0x01	; 1
    8e9a:	16 c0       	rjmp	.+44     	; 0x8ec8 <vfprintf+0xd6>
    8e9c:	83 2d       	mov	r24, r3
    8e9e:	82 60       	ori	r24, 0x02	; 2
    8ea0:	38 2e       	mov	r3, r24
    8ea2:	e3 2d       	mov	r30, r3
    8ea4:	e4 60       	ori	r30, 0x04	; 4
    8ea6:	3e 2e       	mov	r3, r30
    8ea8:	2a c0       	rjmp	.+84     	; 0x8efe <vfprintf+0x10c>
    8eaa:	f3 2d       	mov	r31, r3
    8eac:	f8 60       	ori	r31, 0x08	; 8
    8eae:	1d c0       	rjmp	.+58     	; 0x8eea <vfprintf+0xf8>
    8eb0:	37 fc       	sbrc	r3, 7
    8eb2:	2d c0       	rjmp	.+90     	; 0x8f0e <vfprintf+0x11c>
    8eb4:	20 ed       	ldi	r18, 0xD0	; 208
    8eb6:	28 0f       	add	r18, r24
    8eb8:	2a 30       	cpi	r18, 0x0A	; 10
    8eba:	40 f0       	brcs	.+16     	; 0x8ecc <vfprintf+0xda>
    8ebc:	8e 32       	cpi	r24, 0x2E	; 46
    8ebe:	b9 f4       	brne	.+46     	; 0x8eee <vfprintf+0xfc>
    8ec0:	36 fc       	sbrc	r3, 6
    8ec2:	75 c1       	rjmp	.+746    	; 0x91ae <vfprintf+0x3bc>
    8ec4:	23 2d       	mov	r18, r3
    8ec6:	20 64       	ori	r18, 0x40	; 64
    8ec8:	32 2e       	mov	r3, r18
    8eca:	19 c0       	rjmp	.+50     	; 0x8efe <vfprintf+0x10c>
    8ecc:	36 fe       	sbrs	r3, 6
    8ece:	06 c0       	rjmp	.+12     	; 0x8edc <vfprintf+0xea>
    8ed0:	8a e0       	ldi	r24, 0x0A	; 10
    8ed2:	98 9e       	mul	r9, r24
    8ed4:	20 0d       	add	r18, r0
    8ed6:	11 24       	eor	r1, r1
    8ed8:	92 2e       	mov	r9, r18
    8eda:	11 c0       	rjmp	.+34     	; 0x8efe <vfprintf+0x10c>
    8edc:	ea e0       	ldi	r30, 0x0A	; 10
    8ede:	2e 9e       	mul	r2, r30
    8ee0:	20 0d       	add	r18, r0
    8ee2:	11 24       	eor	r1, r1
    8ee4:	22 2e       	mov	r2, r18
    8ee6:	f3 2d       	mov	r31, r3
    8ee8:	f0 62       	ori	r31, 0x20	; 32
    8eea:	3f 2e       	mov	r3, r31
    8eec:	08 c0       	rjmp	.+16     	; 0x8efe <vfprintf+0x10c>
    8eee:	8c 36       	cpi	r24, 0x6C	; 108
    8ef0:	21 f4       	brne	.+8      	; 0x8efa <vfprintf+0x108>
    8ef2:	83 2d       	mov	r24, r3
    8ef4:	80 68       	ori	r24, 0x80	; 128
    8ef6:	38 2e       	mov	r3, r24
    8ef8:	02 c0       	rjmp	.+4      	; 0x8efe <vfprintf+0x10c>
    8efa:	88 36       	cpi	r24, 0x68	; 104
    8efc:	41 f4       	brne	.+16     	; 0x8f0e <vfprintf+0x11c>
    8efe:	f7 01       	movw	r30, r14
    8f00:	93 fd       	sbrc	r25, 3
    8f02:	85 91       	lpm	r24, Z+
    8f04:	93 ff       	sbrs	r25, 3
    8f06:	81 91       	ld	r24, Z+
    8f08:	7f 01       	movw	r14, r30
    8f0a:	81 11       	cpse	r24, r1
    8f0c:	b3 cf       	rjmp	.-154    	; 0x8e74 <vfprintf+0x82>
    8f0e:	98 2f       	mov	r25, r24
    8f10:	9f 7d       	andi	r25, 0xDF	; 223
    8f12:	95 54       	subi	r25, 0x45	; 69
    8f14:	93 30       	cpi	r25, 0x03	; 3
    8f16:	28 f4       	brcc	.+10     	; 0x8f22 <vfprintf+0x130>
    8f18:	0c 5f       	subi	r16, 0xFC	; 252
    8f1a:	1f 4f       	sbci	r17, 0xFF	; 255
    8f1c:	9f e3       	ldi	r25, 0x3F	; 63
    8f1e:	99 83       	std	Y+1, r25	; 0x01
    8f20:	0d c0       	rjmp	.+26     	; 0x8f3c <vfprintf+0x14a>
    8f22:	83 36       	cpi	r24, 0x63	; 99
    8f24:	31 f0       	breq	.+12     	; 0x8f32 <vfprintf+0x140>
    8f26:	83 37       	cpi	r24, 0x73	; 115
    8f28:	71 f0       	breq	.+28     	; 0x8f46 <vfprintf+0x154>
    8f2a:	83 35       	cpi	r24, 0x53	; 83
    8f2c:	09 f0       	breq	.+2      	; 0x8f30 <vfprintf+0x13e>
    8f2e:	55 c0       	rjmp	.+170    	; 0x8fda <vfprintf+0x1e8>
    8f30:	20 c0       	rjmp	.+64     	; 0x8f72 <vfprintf+0x180>
    8f32:	f8 01       	movw	r30, r16
    8f34:	80 81       	ld	r24, Z
    8f36:	89 83       	std	Y+1, r24	; 0x01
    8f38:	0e 5f       	subi	r16, 0xFE	; 254
    8f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    8f3c:	88 24       	eor	r8, r8
    8f3e:	83 94       	inc	r8
    8f40:	91 2c       	mov	r9, r1
    8f42:	53 01       	movw	r10, r6
    8f44:	12 c0       	rjmp	.+36     	; 0x8f6a <vfprintf+0x178>
    8f46:	28 01       	movw	r4, r16
    8f48:	f2 e0       	ldi	r31, 0x02	; 2
    8f4a:	4f 0e       	add	r4, r31
    8f4c:	51 1c       	adc	r5, r1
    8f4e:	f8 01       	movw	r30, r16
    8f50:	a0 80       	ld	r10, Z
    8f52:	b1 80       	ldd	r11, Z+1	; 0x01
    8f54:	36 fe       	sbrs	r3, 6
    8f56:	03 c0       	rjmp	.+6      	; 0x8f5e <vfprintf+0x16c>
    8f58:	69 2d       	mov	r22, r9
    8f5a:	70 e0       	ldi	r23, 0x00	; 0
    8f5c:	02 c0       	rjmp	.+4      	; 0x8f62 <vfprintf+0x170>
    8f5e:	6f ef       	ldi	r22, 0xFF	; 255
    8f60:	7f ef       	ldi	r23, 0xFF	; 255
    8f62:	c5 01       	movw	r24, r10
    8f64:	0f de       	rcall	.-994    	; 0x8b84 <strnlen>
    8f66:	4c 01       	movw	r8, r24
    8f68:	82 01       	movw	r16, r4
    8f6a:	f3 2d       	mov	r31, r3
    8f6c:	ff 77       	andi	r31, 0x7F	; 127
    8f6e:	3f 2e       	mov	r3, r31
    8f70:	15 c0       	rjmp	.+42     	; 0x8f9c <vfprintf+0x1aa>
    8f72:	28 01       	movw	r4, r16
    8f74:	22 e0       	ldi	r18, 0x02	; 2
    8f76:	42 0e       	add	r4, r18
    8f78:	51 1c       	adc	r5, r1
    8f7a:	f8 01       	movw	r30, r16
    8f7c:	a0 80       	ld	r10, Z
    8f7e:	b1 80       	ldd	r11, Z+1	; 0x01
    8f80:	36 fe       	sbrs	r3, 6
    8f82:	03 c0       	rjmp	.+6      	; 0x8f8a <vfprintf+0x198>
    8f84:	69 2d       	mov	r22, r9
    8f86:	70 e0       	ldi	r23, 0x00	; 0
    8f88:	02 c0       	rjmp	.+4      	; 0x8f8e <vfprintf+0x19c>
    8f8a:	6f ef       	ldi	r22, 0xFF	; 255
    8f8c:	7f ef       	ldi	r23, 0xFF	; 255
    8f8e:	c5 01       	movw	r24, r10
    8f90:	68 d2       	rcall	.+1232   	; 0x9462 <strnlen_P>
    8f92:	4c 01       	movw	r8, r24
    8f94:	f3 2d       	mov	r31, r3
    8f96:	f0 68       	ori	r31, 0x80	; 128
    8f98:	3f 2e       	mov	r3, r31
    8f9a:	82 01       	movw	r16, r4
    8f9c:	33 fc       	sbrc	r3, 3
    8f9e:	19 c0       	rjmp	.+50     	; 0x8fd2 <vfprintf+0x1e0>
    8fa0:	82 2d       	mov	r24, r2
    8fa2:	90 e0       	ldi	r25, 0x00	; 0
    8fa4:	88 16       	cp	r8, r24
    8fa6:	99 06       	cpc	r9, r25
    8fa8:	a0 f4       	brcc	.+40     	; 0x8fd2 <vfprintf+0x1e0>
    8faa:	b6 01       	movw	r22, r12
    8fac:	80 e2       	ldi	r24, 0x20	; 32
    8fae:	90 e0       	ldi	r25, 0x00	; 0
    8fb0:	63 d2       	rcall	.+1222   	; 0x9478 <fputc>
    8fb2:	2a 94       	dec	r2
    8fb4:	f5 cf       	rjmp	.-22     	; 0x8fa0 <vfprintf+0x1ae>
    8fb6:	f5 01       	movw	r30, r10
    8fb8:	37 fc       	sbrc	r3, 7
    8fba:	85 91       	lpm	r24, Z+
    8fbc:	37 fe       	sbrs	r3, 7
    8fbe:	81 91       	ld	r24, Z+
    8fc0:	5f 01       	movw	r10, r30
    8fc2:	b6 01       	movw	r22, r12
    8fc4:	90 e0       	ldi	r25, 0x00	; 0
    8fc6:	58 d2       	rcall	.+1200   	; 0x9478 <fputc>
    8fc8:	21 10       	cpse	r2, r1
    8fca:	2a 94       	dec	r2
    8fcc:	21 e0       	ldi	r18, 0x01	; 1
    8fce:	82 1a       	sub	r8, r18
    8fd0:	91 08       	sbc	r9, r1
    8fd2:	81 14       	cp	r8, r1
    8fd4:	91 04       	cpc	r9, r1
    8fd6:	79 f7       	brne	.-34     	; 0x8fb6 <vfprintf+0x1c4>
    8fd8:	e1 c0       	rjmp	.+450    	; 0x919c <vfprintf+0x3aa>
    8fda:	84 36       	cpi	r24, 0x64	; 100
    8fdc:	11 f0       	breq	.+4      	; 0x8fe2 <vfprintf+0x1f0>
    8fde:	89 36       	cpi	r24, 0x69	; 105
    8fe0:	39 f5       	brne	.+78     	; 0x9030 <vfprintf+0x23e>
    8fe2:	f8 01       	movw	r30, r16
    8fe4:	37 fe       	sbrs	r3, 7
    8fe6:	07 c0       	rjmp	.+14     	; 0x8ff6 <vfprintf+0x204>
    8fe8:	60 81       	ld	r22, Z
    8fea:	71 81       	ldd	r23, Z+1	; 0x01
    8fec:	82 81       	ldd	r24, Z+2	; 0x02
    8fee:	93 81       	ldd	r25, Z+3	; 0x03
    8ff0:	0c 5f       	subi	r16, 0xFC	; 252
    8ff2:	1f 4f       	sbci	r17, 0xFF	; 255
    8ff4:	08 c0       	rjmp	.+16     	; 0x9006 <vfprintf+0x214>
    8ff6:	60 81       	ld	r22, Z
    8ff8:	71 81       	ldd	r23, Z+1	; 0x01
    8ffa:	07 2e       	mov	r0, r23
    8ffc:	00 0c       	add	r0, r0
    8ffe:	88 0b       	sbc	r24, r24
    9000:	99 0b       	sbc	r25, r25
    9002:	0e 5f       	subi	r16, 0xFE	; 254
    9004:	1f 4f       	sbci	r17, 0xFF	; 255
    9006:	f3 2d       	mov	r31, r3
    9008:	ff 76       	andi	r31, 0x6F	; 111
    900a:	3f 2e       	mov	r3, r31
    900c:	97 ff       	sbrs	r25, 7
    900e:	09 c0       	rjmp	.+18     	; 0x9022 <vfprintf+0x230>
    9010:	90 95       	com	r25
    9012:	80 95       	com	r24
    9014:	70 95       	com	r23
    9016:	61 95       	neg	r22
    9018:	7f 4f       	sbci	r23, 0xFF	; 255
    901a:	8f 4f       	sbci	r24, 0xFF	; 255
    901c:	9f 4f       	sbci	r25, 0xFF	; 255
    901e:	f0 68       	ori	r31, 0x80	; 128
    9020:	3f 2e       	mov	r3, r31
    9022:	2a e0       	ldi	r18, 0x0A	; 10
    9024:	30 e0       	ldi	r19, 0x00	; 0
    9026:	a3 01       	movw	r20, r6
    9028:	63 d2       	rcall	.+1222   	; 0x94f0 <__ultoa_invert>
    902a:	88 2e       	mov	r8, r24
    902c:	86 18       	sub	r8, r6
    902e:	44 c0       	rjmp	.+136    	; 0x90b8 <vfprintf+0x2c6>
    9030:	85 37       	cpi	r24, 0x75	; 117
    9032:	31 f4       	brne	.+12     	; 0x9040 <vfprintf+0x24e>
    9034:	23 2d       	mov	r18, r3
    9036:	2f 7e       	andi	r18, 0xEF	; 239
    9038:	b2 2e       	mov	r11, r18
    903a:	2a e0       	ldi	r18, 0x0A	; 10
    903c:	30 e0       	ldi	r19, 0x00	; 0
    903e:	25 c0       	rjmp	.+74     	; 0x908a <vfprintf+0x298>
    9040:	93 2d       	mov	r25, r3
    9042:	99 7f       	andi	r25, 0xF9	; 249
    9044:	b9 2e       	mov	r11, r25
    9046:	8f 36       	cpi	r24, 0x6F	; 111
    9048:	c1 f0       	breq	.+48     	; 0x907a <vfprintf+0x288>
    904a:	18 f4       	brcc	.+6      	; 0x9052 <vfprintf+0x260>
    904c:	88 35       	cpi	r24, 0x58	; 88
    904e:	79 f0       	breq	.+30     	; 0x906e <vfprintf+0x27c>
    9050:	ae c0       	rjmp	.+348    	; 0x91ae <vfprintf+0x3bc>
    9052:	80 37       	cpi	r24, 0x70	; 112
    9054:	19 f0       	breq	.+6      	; 0x905c <vfprintf+0x26a>
    9056:	88 37       	cpi	r24, 0x78	; 120
    9058:	21 f0       	breq	.+8      	; 0x9062 <vfprintf+0x270>
    905a:	a9 c0       	rjmp	.+338    	; 0x91ae <vfprintf+0x3bc>
    905c:	e9 2f       	mov	r30, r25
    905e:	e0 61       	ori	r30, 0x10	; 16
    9060:	be 2e       	mov	r11, r30
    9062:	b4 fe       	sbrs	r11, 4
    9064:	0d c0       	rjmp	.+26     	; 0x9080 <vfprintf+0x28e>
    9066:	fb 2d       	mov	r31, r11
    9068:	f4 60       	ori	r31, 0x04	; 4
    906a:	bf 2e       	mov	r11, r31
    906c:	09 c0       	rjmp	.+18     	; 0x9080 <vfprintf+0x28e>
    906e:	34 fe       	sbrs	r3, 4
    9070:	0a c0       	rjmp	.+20     	; 0x9086 <vfprintf+0x294>
    9072:	29 2f       	mov	r18, r25
    9074:	26 60       	ori	r18, 0x06	; 6
    9076:	b2 2e       	mov	r11, r18
    9078:	06 c0       	rjmp	.+12     	; 0x9086 <vfprintf+0x294>
    907a:	28 e0       	ldi	r18, 0x08	; 8
    907c:	30 e0       	ldi	r19, 0x00	; 0
    907e:	05 c0       	rjmp	.+10     	; 0x908a <vfprintf+0x298>
    9080:	20 e1       	ldi	r18, 0x10	; 16
    9082:	30 e0       	ldi	r19, 0x00	; 0
    9084:	02 c0       	rjmp	.+4      	; 0x908a <vfprintf+0x298>
    9086:	20 e1       	ldi	r18, 0x10	; 16
    9088:	32 e0       	ldi	r19, 0x02	; 2
    908a:	f8 01       	movw	r30, r16
    908c:	b7 fe       	sbrs	r11, 7
    908e:	07 c0       	rjmp	.+14     	; 0x909e <vfprintf+0x2ac>
    9090:	60 81       	ld	r22, Z
    9092:	71 81       	ldd	r23, Z+1	; 0x01
    9094:	82 81       	ldd	r24, Z+2	; 0x02
    9096:	93 81       	ldd	r25, Z+3	; 0x03
    9098:	0c 5f       	subi	r16, 0xFC	; 252
    909a:	1f 4f       	sbci	r17, 0xFF	; 255
    909c:	06 c0       	rjmp	.+12     	; 0x90aa <vfprintf+0x2b8>
    909e:	60 81       	ld	r22, Z
    90a0:	71 81       	ldd	r23, Z+1	; 0x01
    90a2:	80 e0       	ldi	r24, 0x00	; 0
    90a4:	90 e0       	ldi	r25, 0x00	; 0
    90a6:	0e 5f       	subi	r16, 0xFE	; 254
    90a8:	1f 4f       	sbci	r17, 0xFF	; 255
    90aa:	a3 01       	movw	r20, r6
    90ac:	21 d2       	rcall	.+1090   	; 0x94f0 <__ultoa_invert>
    90ae:	88 2e       	mov	r8, r24
    90b0:	86 18       	sub	r8, r6
    90b2:	fb 2d       	mov	r31, r11
    90b4:	ff 77       	andi	r31, 0x7F	; 127
    90b6:	3f 2e       	mov	r3, r31
    90b8:	36 fe       	sbrs	r3, 6
    90ba:	0d c0       	rjmp	.+26     	; 0x90d6 <vfprintf+0x2e4>
    90bc:	23 2d       	mov	r18, r3
    90be:	2e 7f       	andi	r18, 0xFE	; 254
    90c0:	a2 2e       	mov	r10, r18
    90c2:	89 14       	cp	r8, r9
    90c4:	58 f4       	brcc	.+22     	; 0x90dc <vfprintf+0x2ea>
    90c6:	34 fe       	sbrs	r3, 4
    90c8:	0b c0       	rjmp	.+22     	; 0x90e0 <vfprintf+0x2ee>
    90ca:	32 fc       	sbrc	r3, 2
    90cc:	09 c0       	rjmp	.+18     	; 0x90e0 <vfprintf+0x2ee>
    90ce:	83 2d       	mov	r24, r3
    90d0:	8e 7e       	andi	r24, 0xEE	; 238
    90d2:	a8 2e       	mov	r10, r24
    90d4:	05 c0       	rjmp	.+10     	; 0x90e0 <vfprintf+0x2ee>
    90d6:	b8 2c       	mov	r11, r8
    90d8:	a3 2c       	mov	r10, r3
    90da:	03 c0       	rjmp	.+6      	; 0x90e2 <vfprintf+0x2f0>
    90dc:	b8 2c       	mov	r11, r8
    90de:	01 c0       	rjmp	.+2      	; 0x90e2 <vfprintf+0x2f0>
    90e0:	b9 2c       	mov	r11, r9
    90e2:	a4 fe       	sbrs	r10, 4
    90e4:	0f c0       	rjmp	.+30     	; 0x9104 <vfprintf+0x312>
    90e6:	fe 01       	movw	r30, r28
    90e8:	e8 0d       	add	r30, r8
    90ea:	f1 1d       	adc	r31, r1
    90ec:	80 81       	ld	r24, Z
    90ee:	80 33       	cpi	r24, 0x30	; 48
    90f0:	21 f4       	brne	.+8      	; 0x90fa <vfprintf+0x308>
    90f2:	9a 2d       	mov	r25, r10
    90f4:	99 7e       	andi	r25, 0xE9	; 233
    90f6:	a9 2e       	mov	r10, r25
    90f8:	09 c0       	rjmp	.+18     	; 0x910c <vfprintf+0x31a>
    90fa:	a2 fe       	sbrs	r10, 2
    90fc:	06 c0       	rjmp	.+12     	; 0x910a <vfprintf+0x318>
    90fe:	b3 94       	inc	r11
    9100:	b3 94       	inc	r11
    9102:	04 c0       	rjmp	.+8      	; 0x910c <vfprintf+0x31a>
    9104:	8a 2d       	mov	r24, r10
    9106:	86 78       	andi	r24, 0x86	; 134
    9108:	09 f0       	breq	.+2      	; 0x910c <vfprintf+0x31a>
    910a:	b3 94       	inc	r11
    910c:	a3 fc       	sbrc	r10, 3
    910e:	10 c0       	rjmp	.+32     	; 0x9130 <vfprintf+0x33e>
    9110:	a0 fe       	sbrs	r10, 0
    9112:	06 c0       	rjmp	.+12     	; 0x9120 <vfprintf+0x32e>
    9114:	b2 14       	cp	r11, r2
    9116:	80 f4       	brcc	.+32     	; 0x9138 <vfprintf+0x346>
    9118:	28 0c       	add	r2, r8
    911a:	92 2c       	mov	r9, r2
    911c:	9b 18       	sub	r9, r11
    911e:	0d c0       	rjmp	.+26     	; 0x913a <vfprintf+0x348>
    9120:	b2 14       	cp	r11, r2
    9122:	58 f4       	brcc	.+22     	; 0x913a <vfprintf+0x348>
    9124:	b6 01       	movw	r22, r12
    9126:	80 e2       	ldi	r24, 0x20	; 32
    9128:	90 e0       	ldi	r25, 0x00	; 0
    912a:	a6 d1       	rcall	.+844    	; 0x9478 <fputc>
    912c:	b3 94       	inc	r11
    912e:	f8 cf       	rjmp	.-16     	; 0x9120 <vfprintf+0x32e>
    9130:	b2 14       	cp	r11, r2
    9132:	18 f4       	brcc	.+6      	; 0x913a <vfprintf+0x348>
    9134:	2b 18       	sub	r2, r11
    9136:	02 c0       	rjmp	.+4      	; 0x913c <vfprintf+0x34a>
    9138:	98 2c       	mov	r9, r8
    913a:	21 2c       	mov	r2, r1
    913c:	a4 fe       	sbrs	r10, 4
    913e:	0f c0       	rjmp	.+30     	; 0x915e <vfprintf+0x36c>
    9140:	b6 01       	movw	r22, r12
    9142:	80 e3       	ldi	r24, 0x30	; 48
    9144:	90 e0       	ldi	r25, 0x00	; 0
    9146:	98 d1       	rcall	.+816    	; 0x9478 <fputc>
    9148:	a2 fe       	sbrs	r10, 2
    914a:	16 c0       	rjmp	.+44     	; 0x9178 <vfprintf+0x386>
    914c:	a1 fc       	sbrc	r10, 1
    914e:	03 c0       	rjmp	.+6      	; 0x9156 <vfprintf+0x364>
    9150:	88 e7       	ldi	r24, 0x78	; 120
    9152:	90 e0       	ldi	r25, 0x00	; 0
    9154:	02 c0       	rjmp	.+4      	; 0x915a <vfprintf+0x368>
    9156:	88 e5       	ldi	r24, 0x58	; 88
    9158:	90 e0       	ldi	r25, 0x00	; 0
    915a:	b6 01       	movw	r22, r12
    915c:	0c c0       	rjmp	.+24     	; 0x9176 <vfprintf+0x384>
    915e:	8a 2d       	mov	r24, r10
    9160:	86 78       	andi	r24, 0x86	; 134
    9162:	51 f0       	breq	.+20     	; 0x9178 <vfprintf+0x386>
    9164:	a1 fe       	sbrs	r10, 1
    9166:	02 c0       	rjmp	.+4      	; 0x916c <vfprintf+0x37a>
    9168:	8b e2       	ldi	r24, 0x2B	; 43
    916a:	01 c0       	rjmp	.+2      	; 0x916e <vfprintf+0x37c>
    916c:	80 e2       	ldi	r24, 0x20	; 32
    916e:	a7 fc       	sbrc	r10, 7
    9170:	8d e2       	ldi	r24, 0x2D	; 45
    9172:	b6 01       	movw	r22, r12
    9174:	90 e0       	ldi	r25, 0x00	; 0
    9176:	80 d1       	rcall	.+768    	; 0x9478 <fputc>
    9178:	89 14       	cp	r8, r9
    917a:	30 f4       	brcc	.+12     	; 0x9188 <vfprintf+0x396>
    917c:	b6 01       	movw	r22, r12
    917e:	80 e3       	ldi	r24, 0x30	; 48
    9180:	90 e0       	ldi	r25, 0x00	; 0
    9182:	7a d1       	rcall	.+756    	; 0x9478 <fputc>
    9184:	9a 94       	dec	r9
    9186:	f8 cf       	rjmp	.-16     	; 0x9178 <vfprintf+0x386>
    9188:	8a 94       	dec	r8
    918a:	f3 01       	movw	r30, r6
    918c:	e8 0d       	add	r30, r8
    918e:	f1 1d       	adc	r31, r1
    9190:	80 81       	ld	r24, Z
    9192:	b6 01       	movw	r22, r12
    9194:	90 e0       	ldi	r25, 0x00	; 0
    9196:	70 d1       	rcall	.+736    	; 0x9478 <fputc>
    9198:	81 10       	cpse	r8, r1
    919a:	f6 cf       	rjmp	.-20     	; 0x9188 <vfprintf+0x396>
    919c:	22 20       	and	r2, r2
    919e:	09 f4       	brne	.+2      	; 0x91a2 <vfprintf+0x3b0>
    91a0:	4e ce       	rjmp	.-868    	; 0x8e3e <vfprintf+0x4c>
    91a2:	b6 01       	movw	r22, r12
    91a4:	80 e2       	ldi	r24, 0x20	; 32
    91a6:	90 e0       	ldi	r25, 0x00	; 0
    91a8:	67 d1       	rcall	.+718    	; 0x9478 <fputc>
    91aa:	2a 94       	dec	r2
    91ac:	f7 cf       	rjmp	.-18     	; 0x919c <vfprintf+0x3aa>
    91ae:	f6 01       	movw	r30, r12
    91b0:	86 81       	ldd	r24, Z+6	; 0x06
    91b2:	97 81       	ldd	r25, Z+7	; 0x07
    91b4:	02 c0       	rjmp	.+4      	; 0x91ba <vfprintf+0x3c8>
    91b6:	8f ef       	ldi	r24, 0xFF	; 255
    91b8:	9f ef       	ldi	r25, 0xFF	; 255
    91ba:	2b 96       	adiw	r28, 0x0b	; 11
    91bc:	0f b6       	in	r0, 0x3f	; 63
    91be:	f8 94       	cli
    91c0:	de bf       	out	0x3e, r29	; 62
    91c2:	0f be       	out	0x3f, r0	; 63
    91c4:	cd bf       	out	0x3d, r28	; 61
    91c6:	df 91       	pop	r29
    91c8:	cf 91       	pop	r28
    91ca:	1f 91       	pop	r17
    91cc:	0f 91       	pop	r16
    91ce:	ff 90       	pop	r15
    91d0:	ef 90       	pop	r14
    91d2:	df 90       	pop	r13
    91d4:	cf 90       	pop	r12
    91d6:	bf 90       	pop	r11
    91d8:	af 90       	pop	r10
    91da:	9f 90       	pop	r9
    91dc:	8f 90       	pop	r8
    91de:	7f 90       	pop	r7
    91e0:	6f 90       	pop	r6
    91e2:	5f 90       	pop	r5
    91e4:	4f 90       	pop	r4
    91e6:	3f 90       	pop	r3
    91e8:	2f 90       	pop	r2
    91ea:	08 95       	ret

000091ec <calloc>:
    91ec:	0f 93       	push	r16
    91ee:	1f 93       	push	r17
    91f0:	cf 93       	push	r28
    91f2:	df 93       	push	r29
    91f4:	86 9f       	mul	r24, r22
    91f6:	80 01       	movw	r16, r0
    91f8:	87 9f       	mul	r24, r23
    91fa:	10 0d       	add	r17, r0
    91fc:	96 9f       	mul	r25, r22
    91fe:	10 0d       	add	r17, r0
    9200:	11 24       	eor	r1, r1
    9202:	c8 01       	movw	r24, r16
    9204:	0d d0       	rcall	.+26     	; 0x9220 <malloc>
    9206:	ec 01       	movw	r28, r24
    9208:	00 97       	sbiw	r24, 0x00	; 0
    920a:	21 f0       	breq	.+8      	; 0x9214 <calloc+0x28>
    920c:	a8 01       	movw	r20, r16
    920e:	60 e0       	ldi	r22, 0x00	; 0
    9210:	70 e0       	ldi	r23, 0x00	; 0
    9212:	8d dc       	rcall	.-1766   	; 0x8b2e <memset>
    9214:	ce 01       	movw	r24, r28
    9216:	df 91       	pop	r29
    9218:	cf 91       	pop	r28
    921a:	1f 91       	pop	r17
    921c:	0f 91       	pop	r16
    921e:	08 95       	ret

00009220 <malloc>:
    9220:	0f 93       	push	r16
    9222:	1f 93       	push	r17
    9224:	cf 93       	push	r28
    9226:	df 93       	push	r29
    9228:	82 30       	cpi	r24, 0x02	; 2
    922a:	91 05       	cpc	r25, r1
    922c:	10 f4       	brcc	.+4      	; 0x9232 <malloc+0x12>
    922e:	82 e0       	ldi	r24, 0x02	; 2
    9230:	90 e0       	ldi	r25, 0x00	; 0
    9232:	e0 91 7d 20 	lds	r30, 0x207D	; 0x80207d <__flp>
    9236:	f0 91 7e 20 	lds	r31, 0x207E	; 0x80207e <__flp+0x1>
    923a:	20 e0       	ldi	r18, 0x00	; 0
    923c:	30 e0       	ldi	r19, 0x00	; 0
    923e:	a0 e0       	ldi	r26, 0x00	; 0
    9240:	b0 e0       	ldi	r27, 0x00	; 0
    9242:	30 97       	sbiw	r30, 0x00	; 0
    9244:	19 f1       	breq	.+70     	; 0x928c <malloc+0x6c>
    9246:	40 81       	ld	r20, Z
    9248:	51 81       	ldd	r21, Z+1	; 0x01
    924a:	02 81       	ldd	r16, Z+2	; 0x02
    924c:	13 81       	ldd	r17, Z+3	; 0x03
    924e:	48 17       	cp	r20, r24
    9250:	59 07       	cpc	r21, r25
    9252:	c8 f0       	brcs	.+50     	; 0x9286 <malloc+0x66>
    9254:	84 17       	cp	r24, r20
    9256:	95 07       	cpc	r25, r21
    9258:	69 f4       	brne	.+26     	; 0x9274 <malloc+0x54>
    925a:	10 97       	sbiw	r26, 0x00	; 0
    925c:	31 f0       	breq	.+12     	; 0x926a <malloc+0x4a>
    925e:	12 96       	adiw	r26, 0x02	; 2
    9260:	0c 93       	st	X, r16
    9262:	12 97       	sbiw	r26, 0x02	; 2
    9264:	13 96       	adiw	r26, 0x03	; 3
    9266:	1c 93       	st	X, r17
    9268:	27 c0       	rjmp	.+78     	; 0x92b8 <malloc+0x98>
    926a:	00 93 7d 20 	sts	0x207D, r16	; 0x80207d <__flp>
    926e:	10 93 7e 20 	sts	0x207E, r17	; 0x80207e <__flp+0x1>
    9272:	22 c0       	rjmp	.+68     	; 0x92b8 <malloc+0x98>
    9274:	21 15       	cp	r18, r1
    9276:	31 05       	cpc	r19, r1
    9278:	19 f0       	breq	.+6      	; 0x9280 <malloc+0x60>
    927a:	42 17       	cp	r20, r18
    927c:	53 07       	cpc	r21, r19
    927e:	18 f4       	brcc	.+6      	; 0x9286 <malloc+0x66>
    9280:	9a 01       	movw	r18, r20
    9282:	bd 01       	movw	r22, r26
    9284:	ef 01       	movw	r28, r30
    9286:	df 01       	movw	r26, r30
    9288:	f8 01       	movw	r30, r16
    928a:	db cf       	rjmp	.-74     	; 0x9242 <malloc+0x22>
    928c:	21 15       	cp	r18, r1
    928e:	31 05       	cpc	r19, r1
    9290:	f9 f0       	breq	.+62     	; 0x92d0 <malloc+0xb0>
    9292:	28 1b       	sub	r18, r24
    9294:	39 0b       	sbc	r19, r25
    9296:	24 30       	cpi	r18, 0x04	; 4
    9298:	31 05       	cpc	r19, r1
    929a:	80 f4       	brcc	.+32     	; 0x92bc <malloc+0x9c>
    929c:	8a 81       	ldd	r24, Y+2	; 0x02
    929e:	9b 81       	ldd	r25, Y+3	; 0x03
    92a0:	61 15       	cp	r22, r1
    92a2:	71 05       	cpc	r23, r1
    92a4:	21 f0       	breq	.+8      	; 0x92ae <malloc+0x8e>
    92a6:	fb 01       	movw	r30, r22
    92a8:	93 83       	std	Z+3, r25	; 0x03
    92aa:	82 83       	std	Z+2, r24	; 0x02
    92ac:	04 c0       	rjmp	.+8      	; 0x92b6 <malloc+0x96>
    92ae:	90 93 7e 20 	sts	0x207E, r25	; 0x80207e <__flp+0x1>
    92b2:	80 93 7d 20 	sts	0x207D, r24	; 0x80207d <__flp>
    92b6:	fe 01       	movw	r30, r28
    92b8:	32 96       	adiw	r30, 0x02	; 2
    92ba:	44 c0       	rjmp	.+136    	; 0x9344 <malloc+0x124>
    92bc:	fe 01       	movw	r30, r28
    92be:	e2 0f       	add	r30, r18
    92c0:	f3 1f       	adc	r31, r19
    92c2:	81 93       	st	Z+, r24
    92c4:	91 93       	st	Z+, r25
    92c6:	22 50       	subi	r18, 0x02	; 2
    92c8:	31 09       	sbc	r19, r1
    92ca:	39 83       	std	Y+1, r19	; 0x01
    92cc:	28 83       	st	Y, r18
    92ce:	3a c0       	rjmp	.+116    	; 0x9344 <malloc+0x124>
    92d0:	20 91 7b 20 	lds	r18, 0x207B	; 0x80207b <__brkval>
    92d4:	30 91 7c 20 	lds	r19, 0x207C	; 0x80207c <__brkval+0x1>
    92d8:	23 2b       	or	r18, r19
    92da:	41 f4       	brne	.+16     	; 0x92ec <malloc+0xcc>
    92dc:	20 91 06 02 	lds	r18, 0x0206	; 0x800206 <__malloc_heap_start>
    92e0:	30 91 07 02 	lds	r19, 0x0207	; 0x800207 <__malloc_heap_start+0x1>
    92e4:	30 93 7c 20 	sts	0x207C, r19	; 0x80207c <__brkval+0x1>
    92e8:	20 93 7b 20 	sts	0x207B, r18	; 0x80207b <__brkval>
    92ec:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <__malloc_heap_end>
    92f0:	30 91 05 02 	lds	r19, 0x0205	; 0x800205 <__malloc_heap_end+0x1>
    92f4:	21 15       	cp	r18, r1
    92f6:	31 05       	cpc	r19, r1
    92f8:	41 f4       	brne	.+16     	; 0x930a <malloc+0xea>
    92fa:	2d b7       	in	r18, 0x3d	; 61
    92fc:	3e b7       	in	r19, 0x3e	; 62
    92fe:	40 91 08 02 	lds	r20, 0x0208	; 0x800208 <__malloc_margin>
    9302:	50 91 09 02 	lds	r21, 0x0209	; 0x800209 <__malloc_margin+0x1>
    9306:	24 1b       	sub	r18, r20
    9308:	35 0b       	sbc	r19, r21
    930a:	e0 91 7b 20 	lds	r30, 0x207B	; 0x80207b <__brkval>
    930e:	f0 91 7c 20 	lds	r31, 0x207C	; 0x80207c <__brkval+0x1>
    9312:	e2 17       	cp	r30, r18
    9314:	f3 07       	cpc	r31, r19
    9316:	a0 f4       	brcc	.+40     	; 0x9340 <malloc+0x120>
    9318:	2e 1b       	sub	r18, r30
    931a:	3f 0b       	sbc	r19, r31
    931c:	28 17       	cp	r18, r24
    931e:	39 07       	cpc	r19, r25
    9320:	78 f0       	brcs	.+30     	; 0x9340 <malloc+0x120>
    9322:	ac 01       	movw	r20, r24
    9324:	4e 5f       	subi	r20, 0xFE	; 254
    9326:	5f 4f       	sbci	r21, 0xFF	; 255
    9328:	24 17       	cp	r18, r20
    932a:	35 07       	cpc	r19, r21
    932c:	48 f0       	brcs	.+18     	; 0x9340 <malloc+0x120>
    932e:	4e 0f       	add	r20, r30
    9330:	5f 1f       	adc	r21, r31
    9332:	50 93 7c 20 	sts	0x207C, r21	; 0x80207c <__brkval+0x1>
    9336:	40 93 7b 20 	sts	0x207B, r20	; 0x80207b <__brkval>
    933a:	81 93       	st	Z+, r24
    933c:	91 93       	st	Z+, r25
    933e:	02 c0       	rjmp	.+4      	; 0x9344 <malloc+0x124>
    9340:	e0 e0       	ldi	r30, 0x00	; 0
    9342:	f0 e0       	ldi	r31, 0x00	; 0
    9344:	cf 01       	movw	r24, r30
    9346:	df 91       	pop	r29
    9348:	cf 91       	pop	r28
    934a:	1f 91       	pop	r17
    934c:	0f 91       	pop	r16
    934e:	08 95       	ret

00009350 <free>:
    9350:	cf 93       	push	r28
    9352:	df 93       	push	r29
    9354:	00 97       	sbiw	r24, 0x00	; 0
    9356:	09 f4       	brne	.+2      	; 0x935a <free+0xa>
    9358:	81 c0       	rjmp	.+258    	; 0x945c <free+0x10c>
    935a:	fc 01       	movw	r30, r24
    935c:	32 97       	sbiw	r30, 0x02	; 2
    935e:	13 82       	std	Z+3, r1	; 0x03
    9360:	12 82       	std	Z+2, r1	; 0x02
    9362:	a0 91 7d 20 	lds	r26, 0x207D	; 0x80207d <__flp>
    9366:	b0 91 7e 20 	lds	r27, 0x207E	; 0x80207e <__flp+0x1>
    936a:	10 97       	sbiw	r26, 0x00	; 0
    936c:	81 f4       	brne	.+32     	; 0x938e <free+0x3e>
    936e:	20 81       	ld	r18, Z
    9370:	31 81       	ldd	r19, Z+1	; 0x01
    9372:	82 0f       	add	r24, r18
    9374:	93 1f       	adc	r25, r19
    9376:	20 91 7b 20 	lds	r18, 0x207B	; 0x80207b <__brkval>
    937a:	30 91 7c 20 	lds	r19, 0x207C	; 0x80207c <__brkval+0x1>
    937e:	28 17       	cp	r18, r24
    9380:	39 07       	cpc	r19, r25
    9382:	51 f5       	brne	.+84     	; 0x93d8 <free+0x88>
    9384:	f0 93 7c 20 	sts	0x207C, r31	; 0x80207c <__brkval+0x1>
    9388:	e0 93 7b 20 	sts	0x207B, r30	; 0x80207b <__brkval>
    938c:	67 c0       	rjmp	.+206    	; 0x945c <free+0x10c>
    938e:	ed 01       	movw	r28, r26
    9390:	20 e0       	ldi	r18, 0x00	; 0
    9392:	30 e0       	ldi	r19, 0x00	; 0
    9394:	ce 17       	cp	r28, r30
    9396:	df 07       	cpc	r29, r31
    9398:	40 f4       	brcc	.+16     	; 0x93aa <free+0x5a>
    939a:	4a 81       	ldd	r20, Y+2	; 0x02
    939c:	5b 81       	ldd	r21, Y+3	; 0x03
    939e:	9e 01       	movw	r18, r28
    93a0:	41 15       	cp	r20, r1
    93a2:	51 05       	cpc	r21, r1
    93a4:	f1 f0       	breq	.+60     	; 0x93e2 <free+0x92>
    93a6:	ea 01       	movw	r28, r20
    93a8:	f5 cf       	rjmp	.-22     	; 0x9394 <free+0x44>
    93aa:	d3 83       	std	Z+3, r29	; 0x03
    93ac:	c2 83       	std	Z+2, r28	; 0x02
    93ae:	40 81       	ld	r20, Z
    93b0:	51 81       	ldd	r21, Z+1	; 0x01
    93b2:	84 0f       	add	r24, r20
    93b4:	95 1f       	adc	r25, r21
    93b6:	c8 17       	cp	r28, r24
    93b8:	d9 07       	cpc	r29, r25
    93ba:	59 f4       	brne	.+22     	; 0x93d2 <free+0x82>
    93bc:	88 81       	ld	r24, Y
    93be:	99 81       	ldd	r25, Y+1	; 0x01
    93c0:	84 0f       	add	r24, r20
    93c2:	95 1f       	adc	r25, r21
    93c4:	02 96       	adiw	r24, 0x02	; 2
    93c6:	91 83       	std	Z+1, r25	; 0x01
    93c8:	80 83       	st	Z, r24
    93ca:	8a 81       	ldd	r24, Y+2	; 0x02
    93cc:	9b 81       	ldd	r25, Y+3	; 0x03
    93ce:	93 83       	std	Z+3, r25	; 0x03
    93d0:	82 83       	std	Z+2, r24	; 0x02
    93d2:	21 15       	cp	r18, r1
    93d4:	31 05       	cpc	r19, r1
    93d6:	29 f4       	brne	.+10     	; 0x93e2 <free+0x92>
    93d8:	f0 93 7e 20 	sts	0x207E, r31	; 0x80207e <__flp+0x1>
    93dc:	e0 93 7d 20 	sts	0x207D, r30	; 0x80207d <__flp>
    93e0:	3d c0       	rjmp	.+122    	; 0x945c <free+0x10c>
    93e2:	e9 01       	movw	r28, r18
    93e4:	fb 83       	std	Y+3, r31	; 0x03
    93e6:	ea 83       	std	Y+2, r30	; 0x02
    93e8:	49 91       	ld	r20, Y+
    93ea:	59 91       	ld	r21, Y+
    93ec:	c4 0f       	add	r28, r20
    93ee:	d5 1f       	adc	r29, r21
    93f0:	ec 17       	cp	r30, r28
    93f2:	fd 07       	cpc	r31, r29
    93f4:	61 f4       	brne	.+24     	; 0x940e <free+0xbe>
    93f6:	80 81       	ld	r24, Z
    93f8:	91 81       	ldd	r25, Z+1	; 0x01
    93fa:	84 0f       	add	r24, r20
    93fc:	95 1f       	adc	r25, r21
    93fe:	02 96       	adiw	r24, 0x02	; 2
    9400:	e9 01       	movw	r28, r18
    9402:	99 83       	std	Y+1, r25	; 0x01
    9404:	88 83       	st	Y, r24
    9406:	82 81       	ldd	r24, Z+2	; 0x02
    9408:	93 81       	ldd	r25, Z+3	; 0x03
    940a:	9b 83       	std	Y+3, r25	; 0x03
    940c:	8a 83       	std	Y+2, r24	; 0x02
    940e:	e0 e0       	ldi	r30, 0x00	; 0
    9410:	f0 e0       	ldi	r31, 0x00	; 0
    9412:	12 96       	adiw	r26, 0x02	; 2
    9414:	8d 91       	ld	r24, X+
    9416:	9c 91       	ld	r25, X
    9418:	13 97       	sbiw	r26, 0x03	; 3
    941a:	00 97       	sbiw	r24, 0x00	; 0
    941c:	19 f0       	breq	.+6      	; 0x9424 <free+0xd4>
    941e:	fd 01       	movw	r30, r26
    9420:	dc 01       	movw	r26, r24
    9422:	f7 cf       	rjmp	.-18     	; 0x9412 <free+0xc2>
    9424:	8d 91       	ld	r24, X+
    9426:	9c 91       	ld	r25, X
    9428:	11 97       	sbiw	r26, 0x01	; 1
    942a:	9d 01       	movw	r18, r26
    942c:	2e 5f       	subi	r18, 0xFE	; 254
    942e:	3f 4f       	sbci	r19, 0xFF	; 255
    9430:	82 0f       	add	r24, r18
    9432:	93 1f       	adc	r25, r19
    9434:	20 91 7b 20 	lds	r18, 0x207B	; 0x80207b <__brkval>
    9438:	30 91 7c 20 	lds	r19, 0x207C	; 0x80207c <__brkval+0x1>
    943c:	28 17       	cp	r18, r24
    943e:	39 07       	cpc	r19, r25
    9440:	69 f4       	brne	.+26     	; 0x945c <free+0x10c>
    9442:	30 97       	sbiw	r30, 0x00	; 0
    9444:	29 f4       	brne	.+10     	; 0x9450 <free+0x100>
    9446:	10 92 7e 20 	sts	0x207E, r1	; 0x80207e <__flp+0x1>
    944a:	10 92 7d 20 	sts	0x207D, r1	; 0x80207d <__flp>
    944e:	02 c0       	rjmp	.+4      	; 0x9454 <free+0x104>
    9450:	13 82       	std	Z+3, r1	; 0x03
    9452:	12 82       	std	Z+2, r1	; 0x02
    9454:	b0 93 7c 20 	sts	0x207C, r27	; 0x80207c <__brkval+0x1>
    9458:	a0 93 7b 20 	sts	0x207B, r26	; 0x80207b <__brkval>
    945c:	df 91       	pop	r29
    945e:	cf 91       	pop	r28
    9460:	08 95       	ret

00009462 <strnlen_P>:
    9462:	fc 01       	movw	r30, r24
    9464:	05 90       	lpm	r0, Z+
    9466:	61 50       	subi	r22, 0x01	; 1
    9468:	70 40       	sbci	r23, 0x00	; 0
    946a:	01 10       	cpse	r0, r1
    946c:	d8 f7       	brcc	.-10     	; 0x9464 <strnlen_P+0x2>
    946e:	80 95       	com	r24
    9470:	90 95       	com	r25
    9472:	8e 0f       	add	r24, r30
    9474:	9f 1f       	adc	r25, r31
    9476:	08 95       	ret

00009478 <fputc>:
    9478:	0f 93       	push	r16
    947a:	1f 93       	push	r17
    947c:	cf 93       	push	r28
    947e:	df 93       	push	r29
    9480:	fb 01       	movw	r30, r22
    9482:	23 81       	ldd	r18, Z+3	; 0x03
    9484:	21 fd       	sbrc	r18, 1
    9486:	03 c0       	rjmp	.+6      	; 0x948e <fputc+0x16>
    9488:	8f ef       	ldi	r24, 0xFF	; 255
    948a:	9f ef       	ldi	r25, 0xFF	; 255
    948c:	2c c0       	rjmp	.+88     	; 0x94e6 <fputc+0x6e>
    948e:	22 ff       	sbrs	r18, 2
    9490:	16 c0       	rjmp	.+44     	; 0x94be <fputc+0x46>
    9492:	46 81       	ldd	r20, Z+6	; 0x06
    9494:	57 81       	ldd	r21, Z+7	; 0x07
    9496:	24 81       	ldd	r18, Z+4	; 0x04
    9498:	35 81       	ldd	r19, Z+5	; 0x05
    949a:	42 17       	cp	r20, r18
    949c:	53 07       	cpc	r21, r19
    949e:	44 f4       	brge	.+16     	; 0x94b0 <fputc+0x38>
    94a0:	a0 81       	ld	r26, Z
    94a2:	b1 81       	ldd	r27, Z+1	; 0x01
    94a4:	9d 01       	movw	r18, r26
    94a6:	2f 5f       	subi	r18, 0xFF	; 255
    94a8:	3f 4f       	sbci	r19, 0xFF	; 255
    94aa:	31 83       	std	Z+1, r19	; 0x01
    94ac:	20 83       	st	Z, r18
    94ae:	8c 93       	st	X, r24
    94b0:	26 81       	ldd	r18, Z+6	; 0x06
    94b2:	37 81       	ldd	r19, Z+7	; 0x07
    94b4:	2f 5f       	subi	r18, 0xFF	; 255
    94b6:	3f 4f       	sbci	r19, 0xFF	; 255
    94b8:	37 83       	std	Z+7, r19	; 0x07
    94ba:	26 83       	std	Z+6, r18	; 0x06
    94bc:	14 c0       	rjmp	.+40     	; 0x94e6 <fputc+0x6e>
    94be:	8b 01       	movw	r16, r22
    94c0:	ec 01       	movw	r28, r24
    94c2:	fb 01       	movw	r30, r22
    94c4:	00 84       	ldd	r0, Z+8	; 0x08
    94c6:	f1 85       	ldd	r31, Z+9	; 0x09
    94c8:	e0 2d       	mov	r30, r0
    94ca:	19 95       	eicall
    94cc:	89 2b       	or	r24, r25
    94ce:	e1 f6       	brne	.-72     	; 0x9488 <fputc+0x10>
    94d0:	d8 01       	movw	r26, r16
    94d2:	16 96       	adiw	r26, 0x06	; 6
    94d4:	8d 91       	ld	r24, X+
    94d6:	9c 91       	ld	r25, X
    94d8:	17 97       	sbiw	r26, 0x07	; 7
    94da:	01 96       	adiw	r24, 0x01	; 1
    94dc:	17 96       	adiw	r26, 0x07	; 7
    94de:	9c 93       	st	X, r25
    94e0:	8e 93       	st	-X, r24
    94e2:	16 97       	sbiw	r26, 0x06	; 6
    94e4:	ce 01       	movw	r24, r28
    94e6:	df 91       	pop	r29
    94e8:	cf 91       	pop	r28
    94ea:	1f 91       	pop	r17
    94ec:	0f 91       	pop	r16
    94ee:	08 95       	ret

000094f0 <__ultoa_invert>:
    94f0:	fa 01       	movw	r30, r20
    94f2:	aa 27       	eor	r26, r26
    94f4:	28 30       	cpi	r18, 0x08	; 8
    94f6:	51 f1       	breq	.+84     	; 0x954c <__ultoa_invert+0x5c>
    94f8:	20 31       	cpi	r18, 0x10	; 16
    94fa:	81 f1       	breq	.+96     	; 0x955c <__ultoa_invert+0x6c>
    94fc:	e8 94       	clt
    94fe:	6f 93       	push	r22
    9500:	6e 7f       	andi	r22, 0xFE	; 254
    9502:	6e 5f       	subi	r22, 0xFE	; 254
    9504:	7f 4f       	sbci	r23, 0xFF	; 255
    9506:	8f 4f       	sbci	r24, 0xFF	; 255
    9508:	9f 4f       	sbci	r25, 0xFF	; 255
    950a:	af 4f       	sbci	r26, 0xFF	; 255
    950c:	b1 e0       	ldi	r27, 0x01	; 1
    950e:	3e d0       	rcall	.+124    	; 0x958c <__ultoa_invert+0x9c>
    9510:	b4 e0       	ldi	r27, 0x04	; 4
    9512:	3c d0       	rcall	.+120    	; 0x958c <__ultoa_invert+0x9c>
    9514:	67 0f       	add	r22, r23
    9516:	78 1f       	adc	r23, r24
    9518:	89 1f       	adc	r24, r25
    951a:	9a 1f       	adc	r25, r26
    951c:	a1 1d       	adc	r26, r1
    951e:	68 0f       	add	r22, r24
    9520:	79 1f       	adc	r23, r25
    9522:	8a 1f       	adc	r24, r26
    9524:	91 1d       	adc	r25, r1
    9526:	a1 1d       	adc	r26, r1
    9528:	6a 0f       	add	r22, r26
    952a:	71 1d       	adc	r23, r1
    952c:	81 1d       	adc	r24, r1
    952e:	91 1d       	adc	r25, r1
    9530:	a1 1d       	adc	r26, r1
    9532:	20 d0       	rcall	.+64     	; 0x9574 <__ultoa_invert+0x84>
    9534:	09 f4       	brne	.+2      	; 0x9538 <__ultoa_invert+0x48>
    9536:	68 94       	set
    9538:	3f 91       	pop	r19
    953a:	2a e0       	ldi	r18, 0x0A	; 10
    953c:	26 9f       	mul	r18, r22
    953e:	11 24       	eor	r1, r1
    9540:	30 19       	sub	r19, r0
    9542:	30 5d       	subi	r19, 0xD0	; 208
    9544:	31 93       	st	Z+, r19
    9546:	de f6       	brtc	.-74     	; 0x94fe <__ultoa_invert+0xe>
    9548:	cf 01       	movw	r24, r30
    954a:	08 95       	ret
    954c:	46 2f       	mov	r20, r22
    954e:	47 70       	andi	r20, 0x07	; 7
    9550:	40 5d       	subi	r20, 0xD0	; 208
    9552:	41 93       	st	Z+, r20
    9554:	b3 e0       	ldi	r27, 0x03	; 3
    9556:	0f d0       	rcall	.+30     	; 0x9576 <__ultoa_invert+0x86>
    9558:	c9 f7       	brne	.-14     	; 0x954c <__ultoa_invert+0x5c>
    955a:	f6 cf       	rjmp	.-20     	; 0x9548 <__ultoa_invert+0x58>
    955c:	46 2f       	mov	r20, r22
    955e:	4f 70       	andi	r20, 0x0F	; 15
    9560:	40 5d       	subi	r20, 0xD0	; 208
    9562:	4a 33       	cpi	r20, 0x3A	; 58
    9564:	18 f0       	brcs	.+6      	; 0x956c <__ultoa_invert+0x7c>
    9566:	49 5d       	subi	r20, 0xD9	; 217
    9568:	31 fd       	sbrc	r19, 1
    956a:	40 52       	subi	r20, 0x20	; 32
    956c:	41 93       	st	Z+, r20
    956e:	02 d0       	rcall	.+4      	; 0x9574 <__ultoa_invert+0x84>
    9570:	a9 f7       	brne	.-22     	; 0x955c <__ultoa_invert+0x6c>
    9572:	ea cf       	rjmp	.-44     	; 0x9548 <__ultoa_invert+0x58>
    9574:	b4 e0       	ldi	r27, 0x04	; 4
    9576:	a6 95       	lsr	r26
    9578:	97 95       	ror	r25
    957a:	87 95       	ror	r24
    957c:	77 95       	ror	r23
    957e:	67 95       	ror	r22
    9580:	ba 95       	dec	r27
    9582:	c9 f7       	brne	.-14     	; 0x9576 <__ultoa_invert+0x86>
    9584:	00 97       	sbiw	r24, 0x00	; 0
    9586:	61 05       	cpc	r22, r1
    9588:	71 05       	cpc	r23, r1
    958a:	08 95       	ret
    958c:	9b 01       	movw	r18, r22
    958e:	ac 01       	movw	r20, r24
    9590:	0a 2e       	mov	r0, r26
    9592:	06 94       	lsr	r0
    9594:	57 95       	ror	r21
    9596:	47 95       	ror	r20
    9598:	37 95       	ror	r19
    959a:	27 95       	ror	r18
    959c:	ba 95       	dec	r27
    959e:	c9 f7       	brne	.-14     	; 0x9592 <__ultoa_invert+0xa2>
    95a0:	62 0f       	add	r22, r18
    95a2:	73 1f       	adc	r23, r19
    95a4:	84 1f       	adc	r24, r20
    95a6:	95 1f       	adc	r25, r21
    95a8:	a0 1d       	adc	r26, r0
    95aa:	08 95       	ret

000095ac <__muluhisi3>:
    95ac:	32 da       	rcall	.-2972   	; 0x8a12 <__umulhisi3>
    95ae:	a5 9f       	mul	r26, r21
    95b0:	90 0d       	add	r25, r0
    95b2:	b4 9f       	mul	r27, r20
    95b4:	90 0d       	add	r25, r0
    95b6:	a4 9f       	mul	r26, r20
    95b8:	80 0d       	add	r24, r0
    95ba:	91 1d       	adc	r25, r1
    95bc:	11 24       	eor	r1, r1
    95be:	08 95       	ret

000095c0 <__mulshisi3>:
    95c0:	b7 ff       	sbrs	r27, 7
    95c2:	f4 cf       	rjmp	.-24     	; 0x95ac <__muluhisi3>

000095c4 <__mulohisi3>:
    95c4:	f3 df       	rcall	.-26     	; 0x95ac <__muluhisi3>
    95c6:	82 1b       	sub	r24, r18
    95c8:	93 0b       	sbc	r25, r19
    95ca:	08 95       	ret

000095cc <_exit>:
    95cc:	f8 94       	cli

000095ce <__stop_program>:
    95ce:	ff cf       	rjmp	.-2      	; 0x95ce <__stop_program>
