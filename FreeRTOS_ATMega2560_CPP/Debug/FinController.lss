
FinController.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000011e  00800200  0000941a  000094ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000941a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001d56  0080031e  0080031e  000095ee  2**3
                  ALLOC
  3 .fuse         00000003  00820000  00820000  000095ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  000095ef  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000964c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000c00  00000000  00000000  0000968c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00016071  00000000  00000000  0000a28c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000059e1  00000000  00000000  000202fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00008fb3  00000000  00000000  00025cde  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003354  00000000  00000000  0002ec94  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00005989  00000000  00000000  00031fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001112f  00000000  00000000  00037971  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000cc0  00000000  00000000  00048aa0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c5 09 	jmp	0x138a	; 0x138a <__ctors_end>
       4:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
       8:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
       c:	0c 94 fb 16 	jmp	0x2df6	; 0x2df6 <__vector_3>
      10:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      14:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      18:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      1c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      20:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      24:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      28:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      2c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      30:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      34:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      38:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      3c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      40:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      44:	0c 94 94 34 	jmp	0x6928	; 0x6928 <__vector_17>
      48:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      4c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      50:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      54:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      58:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      5c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      60:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      64:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      68:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      6c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      70:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      74:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      78:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      7c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      80:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      84:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      88:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      8c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      90:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      94:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      98:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      9c:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      a0:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      a4:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      a8:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      ac:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      b0:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      b4:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      b8:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      bc:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      c0:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      c4:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      c8:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      cc:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      d0:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      d4:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      d8:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      dc:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      e0:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <__bad_interrupt>
      e4:	00 0d       	add	r16, r0
      e6:	32 0d       	add	r19, r2
      e8:	d3 0b       	sbc	r29, r19
      ea:	3c 0d       	add	r19, r12
      ec:	dd 0b       	sbc	r29, r29
      ee:	e7 0b       	sbc	r30, r23
      f0:	f1 0b       	sbc	r31, r17
      f2:	fb 0b       	sbc	r31, r27
      f4:	2a 0d       	add	r18, r10
      f6:	2a 0d       	add	r18, r10
      f8:	03 0c       	add	r0, r3
      fa:	0b 0c       	add	r0, r11
      fc:	13 0c       	add	r1, r3
      fe:	1a 0c       	add	r1, r10
     100:	21 0c       	add	r2, r1
     102:	28 0c       	add	r2, r8
     104:	0a 0d       	add	r16, r10
     106:	46 0d       	add	r20, r6
     108:	3b 0c       	add	r3, r11
     10a:	2c 0d       	add	r18, r12
     10c:	43 0c       	add	r4, r3
     10e:	4d 0c       	add	r4, r13
     110:	55 0c       	add	r5, r5
     112:	5f 0c       	add	r5, r15
     114:	67 0c       	add	r6, r7
     116:	2c 0d       	add	r18, r12
     118:	71 0c       	add	r7, r1
     11a:	7b 0c       	add	r7, r11
     11c:	85 0c       	add	r8, r5
     11e:	8d 0c       	add	r8, r13
     120:	97 0c       	add	r9, r7
     122:	9e 0c       	add	r9, r14
     124:	12 0d       	add	r17, r2
     126:	4e 0d       	add	r20, r14
     128:	b3 0c       	add	r11, r3
     12a:	bd 0c       	add	r11, r13
     12c:	c4 0c       	add	r12, r4
     12e:	2e 0d       	add	r18, r14
     130:	cd 0c       	add	r12, r13
     132:	d6 0c       	add	r13, r6
     134:	e0 0c       	add	r14, r0
     136:	e6 0c       	add	r14, r6
     138:	f0 0c       	add	r15, r0
     13a:	f7 0c       	add	r15, r7
     13c:	0d 19       	sub	r16, r13
     13e:	f5 18       	sub	r15, r5
     140:	f8 18       	sub	r15, r8
     142:	fb 18       	sub	r15, r11
     144:	fe 18       	sub	r15, r14
     146:	01 19       	sub	r16, r1
     148:	04 19       	sub	r16, r4
     14a:	07 19       	sub	r16, r7
     14c:	66 1f       	adc	r22, r22
     14e:	68 1f       	adc	r22, r24
     150:	72 1f       	adc	r23, r18
     152:	6a 1f       	adc	r22, r26
     154:	6c 1f       	adc	r22, r28
     156:	6e 1f       	adc	r22, r30
     158:	66 1f       	adc	r22, r22
     15a:	70 1f       	adc	r23, r16
     15c:	b4 28       	or	r11, r4
     15e:	2c 2a       	or	r2, r28
     160:	38 2a       	or	r3, r24
     162:	a0 2a       	or	r10, r16
     164:	ad 2a       	or	r10, r29
     166:	c9 2a       	or	r12, r25
     168:	da 2a       	or	r13, r26
     16a:	75 42       	sbci	r23, 0x25	; 37
     16c:	75 42       	sbci	r23, 0x25	; 37
     16e:	75 42       	sbci	r23, 0x25	; 37
     170:	a2 42       	sbci	r26, 0x22	; 34
     172:	aa 42       	sbci	r26, 0x2A	; 42
     174:	b8 42       	sbci	r27, 0x28	; 40
     176:	75 42       	sbci	r23, 0x25	; 37
     178:	75 42       	sbci	r23, 0x25	; 37
     17a:	a2 42       	sbci	r26, 0x22	; 34
     17c:	aa 42       	sbci	r26, 0x2A	; 42
     17e:	7b 15       	cp	r23, r11
     180:	68 15       	cp	r22, r8
     182:	6a 15       	cp	r22, r10
     184:	6c 15       	cp	r22, r12
     186:	6e 15       	cp	r22, r14
     188:	70 15       	cp	r23, r0
     18a:	72 15       	cp	r23, r2
     18c:	74 15       	cp	r23, r4
     18e:	9b 15       	cp	r25, r11
     190:	9d 15       	cp	r25, r13
     192:	9f 15       	cp	r25, r15
     194:	a1 15       	cp	r26, r1
     196:	a3 15       	cp	r26, r3
     198:	a5 15       	cp	r26, r5
     19a:	a7 15       	cp	r26, r7
     19c:	a9 15       	cp	r26, r9

0000019e <__trampolines_end>:
     19e:	50 6f       	ori	r21, 0xF0	; 240
     1a0:	73 74       	andi	r23, 0x43	; 67
     1a2:	3a 20       	and	r3, r10
     1a4:	25 70       	andi	r18, 0x05	; 5
	...

000001a7 <__c.3112>:
     1a7:	57 61 69 74 3a 20 25 70 00                          Wait: %p.

000001b0 <__c.2850>:
     1b0:	1b 5b 25 75 3b 25 75 6d 00                          .[%u;%um.

000001b9 <__c.2824>:
     1b9:	46 61 69 6c 65 64 20 74 6f 20 73 68 75 74 64 6f     Failed to shutdo
     1c9:	77 6e 00                                            wn.

000001cc <__c.2814>:
     1cc:	46 61 69 6c 65 64 20 74 6f 20 72 65 62 6f 6f 74     Failed to reboot
	...

000001dd <__c.3148>:
     1dd:	46 52 45 45 3a 20 25 70 00                          FREE: %p.

000001e6 <__c.3146>:
     1e6:	46 52 45 45 3a 20 42 75 66 66 65 72 20 25 70 20     FREE: Buffer %p 
     1f6:	69 6e 20 75 73 65 20 62 79 20 25 75 20 75 73 65     in use by %u use
     206:	72 73 00                                            rs.

00000209 <__c.3144>:
     209:	46 52 45 45 3a 20 42 75 66 66 65 72 20 61 6c 72     FREE: Buffer alr
     219:	65 61 64 79 20 66 72 65 65 20 25 70 00              eady free %p.

00000226 <__c.3142>:
     226:	46 52 45 45 3a 20 49 6e 76 61 6c 69 64 20 43 53     FREE: Invalid CS
     236:	50 20 62 75 66 66 65 72 20 70 6f 69 6e 74 65 72     P buffer pointer
     246:	20 25 70 00                                          %p.

0000024a <__c.3137>:
     24a:	41 74 74 65 6d 70 74 20 74 6f 20 66 72 65 65 20     Attempt to free 
     25a:	6e 75 6c 6c 20 70 6f 69 6e 74 65 72 00              null pointer.

00000267 <__c.3127>:
     267:	43 6f 72 72 75 70 74 20 43 53 50 20 62 75 66 66     Corrupt CSP buff
     277:	65 72 00                                            er.

0000027a <__c.3125>:
     27a:	47 45 54 3a 20 25 70 20 25 70 00                    GET: %p %p.

00000285 <__c.3123>:
     285:	4f 75 74 20 6f 66 20 62 75 66 66 65 72 73 00        Out of buffers.

00000294 <__c.3121>:
     294:	41 74 74 65 6d 70 74 20 74 6f 20 61 6c 6c 6f 63     Attempt to alloc
     2a4:	61 74 65 20 74 6f 6f 20 6c 61 72 67 65 20 62 6c     ate too large bl
     2b4:	6f 63 6b 20 25 75 00                                ock %u.

000002bb <__c.3326>:
     2bb:	5b 25 30 32 75 20 25 70 5d 20 53 3a 25 75 2c 20     [%02u %p] S:%u, 
     2cb:	25 75 20 2d 3e 20 25 75 2c 20 25 75 20 2d 3e 20     %u -> %u, %u -> 
     2db:	25 75 2c 20 73 6f 63 6b 3a 20 25 70 0a 00           %u, sock: %p..

000002e9 <__c.3299>:
     2e9:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     2f9:	65 20 58 54 45 41 20 65 6e 63 72 79 70 74 65 64     e XTEA encrypted
     309:	20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74      connection, but
     319:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     329:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     339:	75 70 70 6f 72 74 00                                upport.

00000340 <__c.3297>:
     340:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     350:	65 20 48 4d 41 43 20 61 75 74 68 65 6e 74 69 63     e HMAC authentic
     360:	61 74 65 64 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c     ated connection,
     370:	20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d      but CSP was com
     380:	70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48 4d     piled without HM
     390:	41 43 20 73 75 70 70 6f 72 74 00                    AC support.

0000039b <__c.3295>:
     39b:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     3ab:	65 20 52 44 50 20 63 6f 6e 6e 65 63 74 69 6f 6e     e RDP connection
     3bb:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     3cb:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 52     mpiled without R
     3db:	44 50 20 73 75 70 70 6f 72 74 00                    DP support.

000003e6 <__c.3284>:
     3e6:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     3f6:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

00000400 <__c.3282>:
     400:	43 6f 6e 6e 20 61 6c 72 65 61 64 79 20 63 6c 6f     Conn already clo
     410:	73 65 64 00                                         sed.

00000414 <__c.3280>:
     414:	4e 55 4c 4c 20 50 6f 69 6e 74 65 72 20 67 69 76     NULL Pointer giv
     424:	65 6e 20 74 6f 20 63 73 70 5f 63 6c 6f 73 65 00     en to csp_close.

00000434 <__c.3270>:
     434:	4e 6f 20 6d 6f 72 65 20 66 72 65 65 20 63 6f 6e     No more free con
     444:	6e 65 63 74 69 6f 6e 73 00                          nections.

0000044d <__c.3265>:
     44d:	46 61 69 6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63     Failed to lock c
     45d:	6f 6e 6e 20 61 72 72 61 79 00                       onn array.

00000467 <__c.3236>:
     467:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     477:	6f 72 20 63 6f 6e 6e 20 73 65 6d 61 70 68 6f 72     or conn semaphor
     487:	65 00                                               e.

00000489 <__c.3231>:
     489:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
     499:	20 63 6f 6e 6e 65 63 74 69 6f 6e 20 6c 6f 63 6b      connection lock
	...

000004aa <__c.3224>:
     4aa:	4e 6f 20 6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66     No more memory f
     4ba:	6f 72 20 73 70 6f 72 74 20 73 65 6d 61 70 68 6f     or sport semapho
     4ca:	72 65 00                                            re.

000004cd <__c.3219>:
     4cd:	52 58 20 71 75 65 75 65 20 25 70 20 66 75 6c 6c     RX queue %p full
     4dd:	20 77 69 74 68 20 25 75 20 69 74 65 6d 73 00         with %u items.

000004ec <crc_tab>:
     4ec:	00 00 00 00 03 83 6b f2 f7 70 3b e1 f4 f3 50 13     ......k..p;...P.
     4fc:	1f 97 9a c7 1c 14 f1 35 e8 e7 a1 26 eb 64 ca d4     .......5...&.d..
     50c:	cf 58 d9 8a cc db b2 78 38 28 e2 6b 3b ab 89 99     .X.....x8(.k;...
     51c:	d0 cf 43 4d d3 4c 28 bf 27 bf 78 ac 24 3c 13 5e     ..CM.L(.'.x.$<.^
     52c:	6f c7 5e 10 6c 44 35 e2 98 b7 65 f1 9b 34 0e 03     o.^.lD5...e..4..
     53c:	70 50 c4 d7 73 d3 af 25 87 20 ff 36 84 a3 94 c4     pP..s..%. .6....
     54c:	a0 9f 87 9a a3 1c ec 68 57 ef bc 7b 54 6c d7 89     .......hW..{Tl..
     55c:	bf 08 1d 5d bc 8b 76 af 48 78 26 bc 4b fb 4d 4e     ...]..v.Hx&.K.MN
     56c:	de 8e bd 20 dd 0d d6 d2 29 fe 86 c1 2a 7d ed 33     ... ....)...*}.3
     57c:	c1 19 27 e7 c2 9a 4c 15 36 69 1c 06 35 ea 77 f4     ..'...L.6i..5.w.
     58c:	11 d6 64 aa 12 55 0f 58 e6 a6 5f 4b e5 25 34 b9     ..d..U.X.._K.%4.
     59c:	0e 41 fe 6d 0d c2 95 9f f9 31 c5 8c fa b2 ae 7e     .A.m.....1.....~
     5ac:	b1 49 e3 30 b2 ca 88 c2 46 39 d8 d1 45 ba b3 23     .I.0....F9..E..#
     5bc:	ae de 79 f7 ad 5d 12 05 59 ae 42 16 5a 2d 29 e4     ..y..]..Y.B.Z-).
     5cc:	7e 11 3a ba 7d 92 51 48 89 61 01 5b 8a e2 6a a9     ~.:.}.QH.a.[..j.
     5dc:	61 86 a0 7d 62 05 cb 8f 96 f6 9b 9c 95 75 f0 6e     a..}b........u.n
     5ec:	bc 1d 7b 41 bf 9e 10 b3 4b 6d 40 a0 48 ee 2b 52     ..{A....Km@.H.+R
     5fc:	a3 8a e1 86 a0 09 8a 74 54 fa da 67 57 79 b1 95     .......tT..gWy..
     60c:	73 45 a2 cb 70 c6 c9 39 84 35 99 2a 87 b6 f2 d8     sE..p..9.5.*....
     61c:	6c d2 38 0c 6f 51 53 fe 9b a2 03 ed 98 21 68 1f     l.8.oQS......!h.
     62c:	d3 da 25 51 d0 59 4e a3 24 aa 1e b0 27 29 75 42     ..%Q.YN.$...')uB
     63c:	cc 4d bf 96 cf ce d4 64 3b 3d 84 77 38 be ef 85     .M.....d;=.w8...
     64c:	1c 82 fc db 1f 01 97 29 eb f2 c7 3a e8 71 ac c8     .......)...:.q..
     65c:	03 15 66 1c 00 96 0d ee f4 65 5d fd f7 e6 36 0f     ..f......e]...6.
     66c:	62 93 c6 61 61 10 ad 93 95 e3 fd 80 96 60 96 72     b..aa........`.r
     67c:	7d 04 5c a6 7e 87 37 54 8a 74 67 47 89 f7 0c b5     }.\.~.7T.tgG....
     68c:	ad cb 1f eb ae 48 74 19 5a bb 24 0a 59 38 4f f8     .....Ht.Z.$.Y8O.
     69c:	b2 5c 85 2c b1 df ee de 45 2c be cd 46 af d5 3f     .\.,....E,..F..?
     6ac:	0d 54 98 71 0e d7 f3 83 fa 24 a3 90 f9 a7 c8 62     .T.q.....$.....b
     6bc:	12 c3 02 b6 11 40 69 44 e5 b3 39 57 e6 30 52 a5     .....@iD..9W.0R.
     6cc:	c2 0c 41 fb c1 8f 2a 09 35 7c 7a 1a 36 ff 11 e8     ..A...*.5|z.6...
     6dc:	dd 9b db 3c de 18 b0 ce 2a eb e0 dd 29 68 8b 2f     ...<....*...)h./
     6ec:	78 3b f6 82 7b b8 9d 70 8f 4b cd 63 8c c8 a6 91     x;..{..p.K.c....
     6fc:	67 ac 6c 45 64 2f 07 b7 90 dc 57 a4 93 5f 3c 56     g.lEd/....W.._<V
     70c:	b7 63 2f 08 b4 e0 44 fa 40 13 14 e9 43 90 7f 1b     .c/...D.@...C...
     71c:	a8 f4 b5 cf ab 77 de 3d 5f 84 8e 2e 5c 07 e5 dc     .....w.=_...\...
     72c:	17 fc a8 92 14 7f c3 60 e0 8c 93 73 e3 0f f8 81     .......`...s....
     73c:	08 6b 32 55 0b e8 59 a7 ff 1b 09 b4 fc 98 62 46     .k2U..Y.......bF
     74c:	d8 a4 71 18 db 27 1a ea 2f d4 4a f9 2c 57 21 0b     ..q..'../.J.,W!.
     75c:	c7 33 eb df c4 b0 80 2d 30 43 d0 3e 33 c0 bb cc     .3.....-0C.>3...
     76c:	a6 b5 4b a2 a5 36 20 50 51 c5 70 43 52 46 1b b1     ..K..6 PQ.pCRF..
     77c:	b9 22 d1 65 ba a1 ba 97 4e 52 ea 84 4d d1 81 76     .".e....NR..M..v
     78c:	69 ed 92 28 6a 6e f9 da 9e 9d a9 c9 9d 1e c2 3b     i..(jn.........;
     79c:	76 7a 08 ef 75 f9 63 1d 81 0a 33 0e 82 89 58 fc     vz..u.c...3...X.
     7ac:	c9 72 15 b2 ca f1 7e 40 3e 02 2e 53 3d 81 45 a1     .r....~@>..S=.E.
     7bc:	d6 e5 8f 75 d5 66 e4 87 21 95 b4 94 22 16 df 66     ...u.f..!..."..f
     7cc:	06 2a cc 38 05 a9 a7 ca f1 5a f7 d9 f2 d9 9c 2b     .*.8.....Z.....+
     7dc:	19 bd 56 ff 1a 3e 3d 0d ee cd 6d 1e ed 4e 06 ec     ..V..>=...m..N..
     7ec:	c4 26 8d c3 c7 a5 e6 31 33 56 b6 22 30 d5 dd d0     .&.....13V."0...
     7fc:	db b1 17 04 d8 32 7c f6 2c c1 2c e5 2f 42 47 17     .....2|.,.,./BG.
     80c:	0b 7e 54 49 08 fd 3f bb fc 0e 6f a8 ff 8d 04 5a     .~TI..?...o....Z
     81c:	14 e9 ce 8e 17 6a a5 7c e3 99 f5 6f e0 1a 9e 9d     .....j.|...o....
     82c:	ab e1 d3 d3 a8 62 b8 21 5c 91 e8 32 5f 12 83 c0     .....b.!\..2_...
     83c:	b4 76 49 14 b7 f5 22 e6 43 06 72 f5 40 85 19 07     .vI...".C.r.@...
     84c:	64 b9 0a 59 67 3a 61 ab 93 c9 31 b8 90 4a 5a 4a     d..Yg:a...1..JZJ
     85c:	7b 2e 90 9e 78 ad fb 6c 8c 5e ab 7f 8f dd c0 8d     {...x..l.^......
     86c:	1a a8 30 e3 19 2b 5b 11 ed d8 0b 02 ee 5b 60 f0     ..0..+[......[`.
     87c:	05 3f aa 24 06 bc c1 d6 f2 4f 91 c5 f1 cc fa 37     .?.$.....O.....7
     88c:	d5 f0 e9 69 d6 73 82 9b 22 80 d2 88 21 03 b9 7a     ...i.s.."...!..z
     89c:	ca 67 73 ae c9 e4 18 5c 3d 17 48 4f 3e 94 23 bd     .gs....\=.HO>.#.
     8ac:	75 6f 6e f3 76 ec 05 01 82 1f 55 12 81 9c 3e e0     uon.v.....U...>.
     8bc:	6a f8 f4 34 69 7b 9f c6 9d 88 cf d5 9e 0b a4 27     j..4i{.........'
     8cc:	ba 37 b7 79 b9 b4 dc 8b 4d 47 8c 98 4e c4 e7 6a     .7.y....MG..N..j
     8dc:	a5 a0 2d be a6 23 46 4c 52 d0 16 5f 51 53 7d ad     ..-..#FLR.._QS}.

000008ec <__c.2576>:
     8ec:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

000008f9 <__c.2572>:
     8f9:	43 53 50 20 52 45 53 45 54 20 25 73 00              CSP RESET %s.

00000906 <__c.2570>:
     906:	0d 0a 00                                            ...

00000909 <__c.2543>:
     909:	25 2e 31 66 25 63 00                                %.1f%c.

00000910 <__c.2551>:
     910:	25 2d 35 73 20 20 20 74 78 3a 20 25 30 35 6c 75     %-5s   tx: %05lu
     920:	20 72 78 3a 20 25 30 35 6c 75 20 74 78 65 3a 20      rx: %05lu txe: 
     930:	25 30 35 6c 75 20 72 78 65 3a 20 25 30 35 6c 75     %05lu rxe: %05lu
     940:	0d 0a 20 20 20 20 20 20 20 20 64 72 6f 70 3a 20     ..        drop: 
     950:	25 30 35 6c 75 20 61 75 74 68 65 72 72 3a 20 25     %05lu autherr: %
     960:	30 35 6c 75 20 66 72 61 6d 65 3a 20 25 30 35 6c     05lu frame: %05l
     970:	75 0d 0a 20 20 20 20 20 20 20 20 74 78 62 3a 20     u..        txb: 
     980:	25 6c 75 20 28 25 73 29 20 72 78 62 3a 20 25 6c     %lu (%s) rxb: %l
     990:	75 20 28 25 73 29 0d 0a 0d 0a 00                    u (%s).....

0000099b <__c.3384>:
     99b:	49 6e 76 61 6c 69 64 20 63 61 6c 6c 20 74 6f 20     Invalid call to 
     9ab:	63 73 70 5f 73 65 6e 64 00                          csp_send.

000009b4 <__c.3374>:
     9b4:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     9c4:	58 54 45 41 20 65 6e 63 72 79 70 74 65 64 20 70     XTEA encrypted p
     9d4:	61 63 6b 65 74 2c 20 62 75 74 20 43 53 50 20 77     acket, but CSP w
     9e4:	61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68     as compiled with
     9f4:	6f 75 74 20 58 54 45 41 20 73 75 70 70 6f 72 74     out XTEA support
     a04:	2e 20 44 69 73 63 61 72 64 69 6e 67 20 70 61 63     . Discarding pac
     a14:	6b 65 74 00                                         ket.

00000a18 <__c.3372>:
     a18:	43 52 43 33 32 20 61 70 70 65 6e 64 20 66 61 69     CRC32 append fai
     a28:	6c 65 64 21 00                                      led!.

00000a2d <__c.3369>:
     a2d:	41 74 74 65 6d 70 74 20 74 6f 20 73 65 6e 64 20     Attempt to send 
     a3d:	70 61 63 6b 65 74 20 77 69 74 68 20 48 4d 41 43     packet with HMAC
     a4d:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     a5d:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 48     mpiled without H
     a6d:	4d 41 43 20 73 75 70 70 6f 72 74 2e 20 44 69 73     MAC support. Dis
     a7d:	63 61 72 64 69 6e 67 20 70 61 63 6b 65 74 00        carding packet.

00000a8c <__c.3367>:
     a8c:	4f 55 54 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     OUT: S %u, D %u,
     a9c:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
     aac:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
     abc:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

00000acb <__c.3365>:
     acb:	4e 6f 20 72 6f 75 74 65 20 74 6f 20 68 6f 73 74     No route to host
     adb:	3a 20 25 23 30 38 78 00                             : %#08x.

00000ae3 <__c.3362>:
     ae3:	63 73 70 5f 73 65 6e 64 5f 64 69 72 65 63 74 20     csp_send_direct 
     af3:	63 61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c     called with NULL
     b03:	20 70 61 63 6b 65 74 00                              packet.

00000b0b <__c.3343>:
     b0b:	49 6e 76 61 6c 69 64 20 73 6f 63 6b 65 74 20 6f     Invalid socket o
     b1b:	70 74 69 6f 6e 00                                   ption.

00000b21 <__c.3341>:
     b21:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     b31:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     b41:	71 75 69 72 65 73 20 48 4d 41 43 2c 20 62 75 74     quires HMAC, but
     b51:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     b61:	64 20 77 69 74 68 6f 75 74 20 48 4d 41 43 20 73     d without HMAC s
     b71:	75 70 70 6f 72 74 00                                upport.

00000b78 <__c.3339>:
     b78:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     b88:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     b98:	71 75 69 72 65 73 20 58 54 45 41 2c 20 62 75 74     quires XTEA, but
     ba8:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     bb8:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     bc8:	75 70 70 6f 72 74 00                                upport.

00000bcf <__c.3337>:
     bcf:	41 74 74 65 6d 70 74 20 74 6f 20 63 72 65 61 74     Attempt to creat
     bdf:	65 20 73 6f 63 6b 65 74 20 74 68 61 74 20 72 65     e socket that re
     bef:	71 75 69 72 65 73 20 52 44 50 2c 20 62 75 74 20     quires RDP, but 
     bff:	43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64     CSP was compiled
     c0f:	20 77 69 74 68 6f 75 74 20 52 44 50 20 73 75 70      without RDP sup
     c1f:	70 6f 72 74 00                                      port.

00000c24 <__c.3192>:
     c24:	42 69 6e 64 69 6e 67 20 73 6f 63 6b 65 74 20 25     Binding socket %
     c34:	70 20 74 6f 20 70 6f 72 74 20 25 75 00              p to port %u.

00000c41 <__c.3190>:
     c41:	50 6f 72 74 20 25 64 20 69 73 20 61 6c 72 65 61     Port %d is alrea
     c51:	64 79 20 69 6e 20 75 73 65 00                       dy in use.

00000c5b <__c.3188>:
     c5b:	4f 6e 6c 79 20 70 6f 72 74 73 20 66 72 6f 6d 20     Only ports from 
     c6b:	30 2d 25 75 20 28 61 6e 64 20 43 53 50 5f 41 4e     0-%u (and CSP_AN
     c7b:	59 20 66 6f 72 20 64 65 66 61 75 6c 74 29 20 61     Y for default) a
     c8b:	72 65 20 61 76 61 69 6c 61 62 6c 65 20 66 6f 72     re available for
     c9b:	20 69 6e 63 6f 6d 69 6e 67 20 70 6f 72 74 73 00      incoming ports.

00000cab <__c.2386>:
     cab:	45 52 52 4f 52 3a 20 52 6f 75 74 69 6e 67 20 69     ERROR: Routing i
     cbb:	6e 70 75 74 20 46 49 46 4f 20 69 73 20 46 55 4c     nput FIFO is FUL
     ccb:	4c 2e 20 44 72 6f 70 70 69 6e 67 20 70 61 63 6b     L. Dropping pack
     cdb:	65 74 2e 00                                         et..

00000cdf <__c.2382>:
     cdf:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     cef:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     cff:	69 6e 74 65 72 66 61 63 65 00                       interface.

00000d09 <__c.2380>:
     d09:	63 73 70 5f 6e 65 77 20 70 61 63 6b 65 74 20 63     csp_new packet c
     d19:	61 6c 6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20     alled with NULL 
     d29:	70 61 63 6b 65 74 00                                packet.

00000d30 <__c.3124>:
     d30:	25 73 20 25 64 0a 00                                %s %d..

00000d37 <__c.3133>:
     d37:	46 61 69 6c 65 64 20 74 6f 20 73 74 61 72 74 20     Failed to start 
     d47:	72 6f 75 74 65 72 20 74 61 73 6b 00                 router task.

00000d53 <__c.3102>:
     d53:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
     d63:	77 69 74 68 6f 75 74 20 43 52 43 33 32 2e 20 41     without CRC32. A
     d73:	63 63 65 70 74 69 6e 67 20 70 61 63 6b 65 74 00     ccepting packet.

00000d83 <__c.3100>:
     d83:	43 52 43 33 32 20 76 65 72 69 66 69 63 61 74 69     CRC32 verificati
     d93:	6f 6e 20 65 72 72 6f 72 21 20 44 69 73 63 61 72     on error! Discar
     da3:	64 69 6e 67 20 70 61 63 6b 65 74 00                 ding packet.

00000daf <__c.3098>:
     daf:	54 6f 6f 20 73 68 6f 72 74 20 70 61 63 6b 65 74     Too short packet
     dbf:	20 66 6f 72 20 43 52 43 33 32 2c 20 25 75 00         for CRC32, %u.

00000dce <__c.3091>:
     dce:	52 65 63 65 69 76 65 64 20 52 44 50 20 70 61 63     Received RDP pac
     dde:	6b 65 74 2c 20 62 75 74 20 43 53 50 20 77 61 73     ket, but CSP was
     dee:	20 63 6f 6d 70 69 6c 65 64 20 77 69 74 68 6f 75      compiled withou
     dfe:	74 20 52 44 50 20 73 75 70 70 6f 72 74 2e 20 44     t RDP support. D
     e0e:	69 73 63 61 72 64 69 6e 67 20 70 61 63 6b 65 74     iscarding packet
	...

00000e1f <__c.3089>:
     e1f:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
     e2f:	77 69 74 68 20 48 4d 41 43 2c 20 62 75 74 20 43     with HMAC, but C
     e3f:	53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20     SP was compiled 
     e4f:	77 69 74 68 6f 75 74 20 48 4d 41 43 20 73 75 70     without HMAC sup
     e5f:	70 6f 72 74 2e 20 44 69 73 63 61 72 64 69 6e 67     port. Discarding
     e6f:	20 70 61 63 6b 65 74 00                              packet.

00000e77 <__c.3087>:
     e77:	52 65 63 65 69 76 65 64 20 58 54 45 41 20 65 6e     Received XTEA en
     e87:	63 72 79 70 74 65 64 20 70 61 63 6b 65 74 2c 20     crypted packet, 
     e97:	62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70     but CSP was comp
     ea7:	69 6c 65 64 20 77 69 74 68 6f 75 74 20 58 54 45     iled without XTE
     eb7:	41 20 73 75 70 70 6f 72 74 2e 20 44 69 73 63 61     A support. Disca
     ec7:	72 64 69 6e 67 20 70 61 63 6b 65 74 00              rding packet.

00000ed4 <__c.3119>:
     ed4:	4e 6f 20 6d 6f 72 65 20 63 6f 6e 6e 65 63 74 69     No more connecti
     ee4:	6f 6e 73 20 61 76 61 69 6c 61 62 6c 65 00           ons available.

00000ef2 <__c.3116>:
     ef2:	43 6f 6e 6e 2d 6c 65 73 73 20 73 6f 63 6b 65 74     Conn-less socket
     f02:	20 71 75 65 75 65 20 66 75 6c 6c 00                  queue full.

00000f0e <__c.3114>:
     f0e:	52 6f 75 74 65 72 20 66 61 69 6c 65 64 20 74 6f     Router failed to
     f1e:	20 73 65 6e 64 00                                    send.

00000f24 <__c.3111>:
     f24:	49 4e 50 3a 20 53 20 25 75 2c 20 44 20 25 75 2c     INP: S %u, D %u,
     f34:	20 44 70 20 25 75 2c 20 53 70 20 25 75 2c 20 50      Dp %u, Sp %u, P
     f44:	72 20 25 75 2c 20 46 6c 20 30 78 25 30 32 58 2c     r %u, Fl 0x%02X,
     f54:	20 53 7a 20 25 75 20 56 49 41 3a 20 25 73 00         Sz %u VIA: %s.

00000f63 <__c.3139>:
     f63:	53 45 52 56 49 43 45 3a 20 50 69 6e 67 20 72 65     SERVICE: Ping re
     f73:	63 65 69 76 65 64 00                                ceived.

00000f7a <_ZZ9CanRxFuncE3__c_7>:
     f7a:	71 75 65 75 65 20 66 61 69 6c 00                    queue fail.

00000f85 <_ZZ9CanRxFuncE3__c_6>:
     f85:	71 75 65 75 65 20 66 61 69 6c 00                    queue fail.

00000f90 <_ZZ9CanRxFuncE3__c_5>:
     f90:	44 61 74 61 20 25 64 20 3d 20 25 78 00              Data %d = %x.

00000f9d <_ZZ9CanRxFuncE3__c_4>:
     f9d:	44 4c 43 20 3d 20 25 75 78 0d 0a 00                 DLC = %ux...

00000fa9 <_ZZ9CanRxFuncE3__c_3>:
     fa9:	49 64 20 3d 20 25 75 78 0d 0a 00                    Id = %ux...

00000fb4 <_ZZ9CanRxFuncE3__c_2>:
     fb4:	69 6d 70 6f 73 73 69 62 6c 65 20 70 6f 73 20 25     impossible pos %
     fc4:	64 09 63 6f 75 6e 74 20 3d 20 25 64 0d 0a 00        d.count = %d...

00000fd3 <_ZZ9CanRxFuncE3__c_1>:
     fd3:	43 41 4e 20 52 65 63 20 3d 20 25 64 00              CAN Rec = %d.

00000fe0 <_ZZ9CanRxFuncE3__c_0>:
     fe0:	54 6f 6f 20 4d 61 6e 79 20 46 72 61 6d 65 73 20     Too Many Frames 
     ff0:	6f 72 20 77 72 6f 6e 67 20 6f 72 64 65 72 00        or wrong order.

00000fff <_ZZ9CanRxFuncE3__c>:
     fff:	25 73 20 25 64 0a 00                                %s %d..

00001006 <_ZZ8can_sendE3__c>:
    1006:	63 61 6e 20 74 78 20 65 72 72 6f 72 00              can tx error.

00001013 <__c.3321>:
    1013:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
    1023:	41 4e 20 66 72 61 6d 65 20 69 6e 20 54 78 20 63     AN frame in Tx c
    1033:	61 6c 6c 62 61 63 6b 00                             allback.

0000103b <__c.3318>:
    103b:	46 61 69 6c 65 64 20 74 6f 20 73 65 6e 64 20 43     Failed to send C
    104b:	41 4e 20 66 72 61 6d 65 20 69 6e 20 63 73 70 5f     AN frame in csp_
    105b:	74 78 5f 63 61 6e 00                                tx_can.

00001062 <__c.3313>:
    1062:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 43 46     Failed to get CF
    1072:	50 20 69 64 65 6e 74 69 66 69 63 61 74 69 6f 6e     P identification
    1082:	20 6e 75 6d 62 65 72 00                              number.

0000108a <__c.3200>:
    108a:	43 6f 75 6c 64 20 6e 6f 74 20 69 6e 69 74 69 61     Could not initia
    109a:	6c 69 7a 65 20 43 46 50 20 69 64 20 73 65 6d 61     lize CFP id sema
    10aa:	70 68 6f 72 65 00                                   phore.

000010b0 <__c.3288>:
    10b0:	52 65 63 65 69 76 65 64 20 75 6e 6b 6e 6f 77 6e     Received unknown
    10c0:	20 43 46 50 20 6d 65 73 73 61 67 65 20 74 79 70      CFP message typ
    10d0:	65 00                                               e.

000010d2 <__c.3285>:
    10d2:	52 58 20 62 75 66 66 65 72 20 6f 76 65 72 66 6c     RX buffer overfl
    10e2:	6f 77 00                                            ow.

000010e5 <__c.3283>:
    10e5:	43 41 4e 20 66 72 61 6d 65 20 6c 6f 73 74 20 69     CAN frame lost i
    10f5:	6e 20 43 53 50 20 70 61 63 6b 65 74 00              n CSP packet.

00001102 <__c.3280>:
    1102:	46 61 69 6c 65 64 20 74 6f 20 67 65 74 20 62 75     Failed to get bu
    1112:	66 66 65 72 20 66 6f 72 20 43 53 50 5f 42 45 47     ffer for CSP_BEG
    1122:	49 4e 20 70 61 63 6b 65 74 00                       IN packet.

0000112c <__c.3278>:
    112c:	49 6e 63 6f 6d 70 6c 65 74 65 20 66 72 61 6d 65     Incomplete frame
	...

0000113d <__c.3275>:
    113d:	53 68 6f 72 74 20 42 45 47 49 4e 20 66 72 61 6d     Short BEGIN fram
    114d:	65 20 72 65 63 65 69 76 65 64 00                    e received.

00001158 <__c.3272>:
    1158:	4f 75 74 20 6f 66 20 6f 72 64 65 72 20 4d 4f 52     Out of order MOR
    1168:	45 20 66 72 61 6d 65 20 72 65 63 65 69 76 65 64     E frame received
	...

00001179 <__c.3270>:
    1179:	4e 6f 20 61 76 61 69 6c 61 62 6c 65 20 70 61 63     No available pac
    1189:	6b 65 74 20 62 75 66 66 65 72 20 66 6f 72 20 43     ket buffer for C
    1199:	41 4e 00                                            AN.

0000119c <__c.3259>:
    119c:	43 41 4e 20 42 75 66 66 65 72 20 65 6c 65 6d 65     CAN Buffer eleme
    11ac:	6e 74 20 74 69 6d 65 64 20 6f 75 74 00              nt timed out.

000011b9 <__c.3343>:
    11b9:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
    11c9:	6c 69 7a 65 20 43 41 4e 20 64 72 69 76 65 72 00     lize CAN driver.

000011d9 <__c.3340>:
    11d9:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 20 43     Failed to init C
    11e9:	41 4e 20 52 58 20 74 61 73 6b 00                    AN RX task.

000011f4 <__c.3338>:
    11f4:	46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 65     Failed to create
    1204:	20 43 41 4e 20 52 58 20 71 75 65 75 65 00            CAN RX queue.

00001212 <__c.3336>:
    1212:	55 6e 6b 6e 6f 77 6e 20 43 41 4e 20 6d 6f 64 65     Unknown CAN mode
	...

00001223 <__c.3334>:
    1223:	46 61 69 6c 65 64 20 74 6f 20 69 6e 69 74 69 61     Failed to initia
    1233:	6c 69 7a 65 20 43 41 4e 20 69 64 65 6e 74 69 66     lize CAN identif
    1243:	69 63 61 74 69 6f 6e 20 6e 75 6d 62 65 72 00        ication number.

00001252 <__c.2565>:
    1252:	20 20 20 2a 20 20 25 2d 39 73 20 20 25 75 0d 0a        *  %-9s  %u..
	...

00001263 <__c.2560>:
    1263:	25 34 75 20 20 25 2d 39 73 20 20 25 75 0d 0a 00     %4u  %-9s  %u...

00001273 <__c.2558>:
    1273:	4e 6f 64 65 20 20 49 6e 74 65 72 66 61 63 65 20     Node  Interface 
    1283:	20 41 64 64 72 65 73 73 0d 0a 00                     Address...

0000128e <__c.2552>:
    128e:	46 61 69 6c 65 64 20 74 6f 20 73 65 74 20 72 6f     Failed to set ro
    129e:	75 74 65 3a 20 69 6e 76 61 6c 69 64 20 6e 6f 64     ute: invalid nod
    12ae:	65 20 69 64 20 25 75 00                             e id %u.

000012b6 <__c.2836>:
    12b6:	57 61 72 6e 69 6e 67 20 73 6f 63 6b 65 74 20 63     Warning socket c
    12c6:	6f 6e 6e 65 63 74 69 6f 6e 20 71 75 65 75 65 20     onnection queue 
    12d6:	66 75 6c 6c 00                                      full.

000012db <__c.2834>:
    12db:	43 6f 6e 6e 65 63 74 69 6f 6e 20 62 75 66 66 65     Connection buffe
    12eb:	72 20 71 75 65 75 65 20 66 75 6c 6c 21 00           r queue full!.

000012f9 <_ZZ11task_serverPvE3__c>:
    12f9:	25 73 20 25 64 0a 00                                %s %d..

00001300 <_ZZ16__vector_defaultE3__c_0>:
    1300:	45 72 72 6f 72 20 52 65 73 65 74 0a 00              Error Reset..

0000130d <_ZZ16__vector_defaultE3__c>:
    130d:	55 6e 65 78 20 56 65 63 74 6f 72 00                 Unex Vector.

00001319 <_ZZ11task_clientPvE3__c_2>:
    1319:	50 69 6e 67 20 72 65 73 75 6c 74 20 25 64 20 5b     Ping result %d [
    1329:	6d 73 5d 0d 0a 00                                   ms]...

0000132f <_ZZ11task_clientPvE3__c_1>:
    132f:	50 69 6e 67 20 46 61 69 6c 65 64 0a 00              Ping Failed..

0000133c <_ZZ11task_clientPvE3__c_0>:
    133c:	53 50 20 3d 20 30 78 25 30 34 78 0a 00              SP = 0x%04x..

00001349 <_ZZ11task_clientPvE3__c>:
    1349:	25 73 20 25 64 0a 00                                %s %d..

00001350 <_ZZ4mainE3__c_3>:
    1350:	49 6e 74 65 72 66 61 63 65 73 0d 0a 00              Interfaces...

0000135d <_ZZ4mainE3__c_2>:
    135d:	52 6f 75 74 65 20 74 61 62 6c 65 0d 0a 00           Route table...

0000136b <_ZZ4mainE3__c_1>:
    136b:	43 6f 6e 6e 20 74 61 62 6c 65 0d 0a 00              Conn table...

00001378 <_ZZ4mainE3__c_0>:
    1378:	53 65 74 75 70 20 45 72 72 6f 72 00                 Setup Error.

00001384 <_ZZ4mainE3__c>:
    1384:	25 64 00 00                                         %d..

00001388 <__ctors_start>:
    1388:	ee 12       	cpse	r14, r30

0000138a <__ctors_end>:
    138a:	11 24       	eor	r1, r1
    138c:	1f be       	out	0x3f, r1	; 63
    138e:	cf ef       	ldi	r28, 0xFF	; 255
    1390:	d1 e2       	ldi	r29, 0x21	; 33
    1392:	de bf       	out	0x3e, r29	; 62
    1394:	cd bf       	out	0x3d, r28	; 61
    1396:	00 e0       	ldi	r16, 0x00	; 0
    1398:	0c bf       	out	0x3c, r16	; 60

0000139a <__do_copy_data>:
    139a:	13 e0       	ldi	r17, 0x03	; 3
    139c:	a0 e0       	ldi	r26, 0x00	; 0
    139e:	b2 e0       	ldi	r27, 0x02	; 2
    13a0:	ea e1       	ldi	r30, 0x1A	; 26
    13a2:	f4 e9       	ldi	r31, 0x94	; 148
    13a4:	00 e0       	ldi	r16, 0x00	; 0
    13a6:	0b bf       	out	0x3b, r16	; 59
    13a8:	02 c0       	rjmp	.+4      	; 0x13ae <__do_copy_data+0x14>
    13aa:	07 90       	elpm	r0, Z+
    13ac:	0d 92       	st	X+, r0
    13ae:	ae 31       	cpi	r26, 0x1E	; 30
    13b0:	b1 07       	cpc	r27, r17
    13b2:	d9 f7       	brne	.-10     	; 0x13aa <__do_copy_data+0x10>

000013b4 <__do_clear_bss>:
    13b4:	20 e2       	ldi	r18, 0x20	; 32
    13b6:	ae e1       	ldi	r26, 0x1E	; 30
    13b8:	b3 e0       	ldi	r27, 0x03	; 3
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <.do_clear_bss_start>

000013bc <.do_clear_bss_loop>:
    13bc:	1d 92       	st	X+, r1

000013be <.do_clear_bss_start>:
    13be:	a4 37       	cpi	r26, 0x74	; 116
    13c0:	b2 07       	cpc	r27, r18
    13c2:	e1 f7       	brne	.-8      	; 0x13bc <.do_clear_bss_loop>

000013c4 <__do_global_ctors>:
    13c4:	19 e0       	ldi	r17, 0x09	; 9
    13c6:	c5 ec       	ldi	r28, 0xC5	; 197
    13c8:	d9 e0       	ldi	r29, 0x09	; 9
    13ca:	00 e0       	ldi	r16, 0x00	; 0
    13cc:	06 c0       	rjmp	.+12     	; 0x13da <__do_global_ctors+0x16>
    13ce:	21 97       	sbiw	r28, 0x01	; 1
    13d0:	01 09       	sbc	r16, r1
    13d2:	80 2f       	mov	r24, r16
    13d4:	fe 01       	movw	r30, r28
    13d6:	0e 94 1e 44 	call	0x883c	; 0x883c <__tablejump2__>
    13da:	c4 3c       	cpi	r28, 0xC4	; 196
    13dc:	d1 07       	cpc	r29, r17
    13de:	80 e0       	ldi	r24, 0x00	; 0
    13e0:	08 07       	cpc	r16, r24
    13e2:	a9 f7       	brne	.-22     	; 0x13ce <__do_global_ctors+0xa>
    13e4:	0e 94 39 16 	call	0x2c72	; 0x2c72 <main>
    13e8:	0c 94 0b 4a 	jmp	0x9416	; 0x9416 <_exit>

000013ec <__bad_interrupt>:
    13ec:	0c 94 36 17 	jmp	0x2e6c	; 0x2e6c <__vector_default>

000013f0 <_ZN7MCP25158startSPIEv>:
    // Compensate for the duplicate fosc/64
    if (clockDiv == 6)
    clockDiv = 7;

    // Invert the SPI2X bit
    clockDiv ^= 0x1;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>

  // Before using SPI.transfer() or asserting chip select pins,
  // this function is used to gain exclusive access to the SPI bus
  // and configure the correct settings.
  inline static void beginTransaction(SPISettings settings) {
    if (interruptMode > 0) {
    13f6:	80 91 66 20 	lds	r24, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    13fa:	88 23       	and	r24, r24
    13fc:	99 f0       	breq	.+38     	; 0x1424 <_ZN7MCP25158startSPIEv+0x34>
      uint8_t sreg = SREG;
    13fe:	8f b7       	in	r24, 0x3f	; 63
      cli();
    1400:	f8 94       	cli

      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    1402:	90 91 66 20 	lds	r25, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    1406:	91 30       	cpi	r25, 0x01	; 1
    1408:	59 f4       	brne	.+22     	; 0x1420 <_ZN7MCP25158startSPIEv+0x30>
        interruptSave = SPI_AVR_EIMSK;
    140a:	9d b3       	in	r25, 0x1d	; 29
    140c:	90 93 64 20 	sts	0x2064, r25	; 0x802064 <_ZN8SPIClass13interruptSaveE>
        SPI_AVR_EIMSK &= ~interruptMask;
    1410:	2d b3       	in	r18, 0x1d	; 29
    1412:	90 91 65 20 	lds	r25, 0x2065	; 0x802065 <_ZN8SPIClass13interruptMaskE>
    1416:	90 95       	com	r25
    1418:	92 23       	and	r25, r18
    141a:	9d bb       	out	0x1d, r25	; 29
        SREG = sreg;
    141c:	8f bf       	out	0x3f, r24	; 63
    141e:	02 c0       	rjmp	.+4      	; 0x1424 <_ZN7MCP25158startSPIEv+0x34>
      } else
      #endif
      {
        interruptSave = sreg;
    1420:	80 93 64 20 	sts	0x2064, r24	; 0x802064 <_ZN8SPIClass13interruptSaveE>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
    1424:	80 e5       	ldi	r24, 0x50	; 80
    1426:	8c bd       	out	0x2c, r24	; 44
    SPSR = settings.spsr;
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	8d bd       	out	0x2d, r24	; 45
}

void MCP2515::startSPI(void) {
    SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0));
   // digitalWrite(SPICS, LOW);
   PORTB&=~(1<<PB4);
    142c:	2c 98       	cbi	0x05, 4	; 5
    142e:	08 95       	ret

00001430 <_ZN7MCP25156endSPIEv>:
}

void MCP2515::endSPI() {
     PORTB|=(1<<PB4);
    1430:	2c 9a       	sbi	0x05, 4	; 5
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
    1432:	80 91 66 20 	lds	r24, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    1436:	88 23       	and	r24, r24
    1438:	71 f0       	breq	.+28     	; 0x1456 <_ZN7MCP25156endSPIEv+0x26>
      #ifdef SPI_AVR_EIMSK
      uint8_t sreg = SREG;
    143a:	9f b7       	in	r25, 0x3f	; 63
      #endif
      cli();
    143c:	f8 94       	cli
      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    143e:	80 91 66 20 	lds	r24, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    1442:	81 30       	cpi	r24, 0x01	; 1
    1444:	29 f4       	brne	.+10     	; 0x1450 <_ZN7MCP25156endSPIEv+0x20>
        SPI_AVR_EIMSK = interruptSave;
    1446:	80 91 64 20 	lds	r24, 0x2064	; 0x802064 <_ZN8SPIClass13interruptSaveE>
    144a:	8d bb       	out	0x1d, r24	; 29
        SREG = sreg;
    144c:	9f bf       	out	0x3f, r25	; 63
    144e:	08 95       	ret
      } else
      #endif
      {
        SREG = interruptSave;
    1450:	80 91 64 20 	lds	r24, 0x2064	; 0x802064 <_ZN8SPIClass13interruptSaveE>
    1454:	8f bf       	out	0x3f, r24	; 63
    1456:	08 95       	ret

00001458 <_ZN7MCP2515C1Ev>:
const struct MCP2515::RXBn_REGS MCP2515::RXB[N_RXBUFFERS] = {
    {MCP_RXB0CTRL, MCP_RXB0SIDH, MCP_RXB0DATA, CANINTF_RX0IF},
    {MCP_RXB1CTRL, MCP_RXB1SIDH, MCP_RXB1DATA, CANINTF_RX1IF}
};

MCP2515::MCP2515(void)
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
{
    SPI.begin();
    145e:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8SPIClass5beginEv>

   //SPICS = _CS;
    //pinMode(SPICS, OUTPUT);
	DDRB|=(1<<PB4);
    1462:	24 9a       	sbi	0x04, 4	; 4
    endSPI();
    1464:	ce 01       	movw	r24, r28
    1466:	e4 df       	rcall	.-56     	; 0x1430 <_ZN7MCP25156endSPIEv>
}
    1468:	df 91       	pop	r29
    146a:	cf 91       	pop	r28
    146c:	08 95       	ret

0000146e <_ZN7MCP251512readRegisterENS_8REGISTERE>:

    return ERROR_OK;
}

uint8_t MCP2515::readRegister(const REGISTER reg)
{
    146e:	1f 93       	push	r17
    1470:	cf 93       	push	r28
    1472:	df 93       	push	r29
    1474:	ec 01       	movw	r28, r24
    startSPI();
    1476:	16 2f       	mov	r17, r22
    1478:	bb df       	rcall	.-138    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    147a:	83 e0       	ldi	r24, 0x03	; 3
    147c:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    147e:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1480:	0d b4       	in	r0, 0x2d	; 45
    1482:	07 fe       	sbrs	r0, 7
    1484:	fd cf       	rjmp	.-6      	; 0x1480 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x12>
    return SPDR;
    1486:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1488:	1e bd       	out	0x2e, r17	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    148a:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    148c:	0d b4       	in	r0, 0x2d	; 45
    148e:	07 fe       	sbrs	r0, 7
    1490:	fd cf       	rjmp	.-6      	; 0x148c <_ZN7MCP251512readRegisterENS_8REGISTERE+0x1e>
    return SPDR;
    1492:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1494:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1496:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1498:	0d b4       	in	r0, 0x2d	; 45
    149a:	07 fe       	sbrs	r0, 7
    149c:	fd cf       	rjmp	.-6      	; 0x1498 <_ZN7MCP251512readRegisterENS_8REGISTERE+0x2a>
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    uint8_t ret = SPI.transfer(0x00);
    endSPI();
    149e:	1e b5       	in	r17, 0x2e	; 46
    14a0:	ce 01       	movw	r24, r28
    14a2:	c6 df       	rcall	.-116    	; 0x1430 <_ZN7MCP25156endSPIEv>

    return ret;
}
    14a4:	81 2f       	mov	r24, r17
    14a6:	df 91       	pop	r29
    14a8:	cf 91       	pop	r28
    14aa:	1f 91       	pop	r17
    14ac:	08 95       	ret

000014ae <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>:

void MCP2515::readRegisters(const REGISTER reg, uint8_t values[], const uint8_t n)
{
    14ae:	ef 92       	push	r14
    14b0:	ff 92       	push	r15
    14b2:	0f 93       	push	r16
    14b4:	1f 93       	push	r17
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
    14ba:	ec 01       	movw	r28, r24
    14bc:	06 2f       	mov	r16, r22
    14be:	7a 01       	movw	r14, r20
    startSPI();
    14c0:	12 2f       	mov	r17, r18
    14c2:	96 df       	rcall	.-212    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    14c4:	83 e0       	ldi	r24, 0x03	; 3
    14c6:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    14c8:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    14ca:	0d b4       	in	r0, 0x2d	; 45
    14cc:	07 fe       	sbrs	r0, 7
    14ce:	fd cf       	rjmp	.-6      	; 0x14ca <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x1c>
    return SPDR;
    14d0:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    14d2:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    14d4:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    14d6:	0d b4       	in	r0, 0x2d	; 45
    14d8:	07 fe       	sbrs	r0, 7
    14da:	fd cf       	rjmp	.-6      	; 0x14d6 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x28>
    return SPDR;
    14dc:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    // mcp2515 has auto-increment of address-pointer
    for (uint8_t i=0; i<n; i++) {
    14de:	11 23       	and	r17, r17
    14e0:	91 f0       	breq	.+36     	; 0x1506 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x58>
    14e2:	f7 01       	movw	r30, r14
    14e4:	11 50       	subi	r17, 0x01	; 1
    14e6:	41 2f       	mov	r20, r17
    14e8:	50 e0       	ldi	r21, 0x00	; 0
    14ea:	4f 5f       	subi	r20, 0xFF	; 255
    14ec:	5f 4f       	sbci	r21, 0xFF	; 255
    14ee:	4e 0d       	add	r20, r14
    14f0:	5f 1d       	adc	r21, r15
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    14f2:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    14f4:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    14f6:	0d b4       	in	r0, 0x2d	; 45
    14f8:	07 fe       	sbrs	r0, 7
    14fa:	fd cf       	rjmp	.-6      	; 0x14f6 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x48>
    return SPDR;
    14fc:	8e b5       	in	r24, 0x2e	; 46
        values[i] = SPI.transfer(0x00);
    14fe:	81 93       	st	Z+, r24
{
    startSPI();
    SPI.transfer(INSTRUCTION_READ);
    SPI.transfer(reg);
    // mcp2515 has auto-increment of address-pointer
    for (uint8_t i=0; i<n; i++) {
    1500:	e4 17       	cp	r30, r20
    1502:	f5 07       	cpc	r31, r21
        values[i] = SPI.transfer(0x00);
    }
    endSPI();
    1504:	b1 f7       	brne	.-20     	; 0x14f2 <_ZN7MCP251513readRegistersENS_8REGISTEREPhh+0x44>
    1506:	ce 01       	movw	r24, r28
    1508:	93 df       	rcall	.-218    	; 0x1430 <_ZN7MCP25156endSPIEv>
}
    150a:	df 91       	pop	r29
    150c:	cf 91       	pop	r28
    150e:	1f 91       	pop	r17
    1510:	0f 91       	pop	r16
    1512:	ff 90       	pop	r15
    1514:	ef 90       	pop	r14
    1516:	08 95       	ret

00001518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>:

void MCP2515::setRegister(const REGISTER reg, const uint8_t value)
{
    1518:	0f 93       	push	r16
    151a:	1f 93       	push	r17
    151c:	cf 93       	push	r28
    151e:	df 93       	push	r29
    1520:	ec 01       	movw	r28, r24
    1522:	06 2f       	mov	r16, r22
    startSPI();
    1524:	14 2f       	mov	r17, r20
    1526:	64 df       	rcall	.-312    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1528:	82 e0       	ldi	r24, 0x02	; 2
    152a:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    152c:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    152e:	0d b4       	in	r0, 0x2d	; 45
    1530:	07 fe       	sbrs	r0, 7
    1532:	fd cf       	rjmp	.-6      	; 0x152e <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x16>
    return SPDR;
    1534:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1536:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1538:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    153a:	0d b4       	in	r0, 0x2d	; 45
    153c:	07 fe       	sbrs	r0, 7
    153e:	fd cf       	rjmp	.-6      	; 0x153a <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x22>
    return SPDR;
    1540:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1542:	1e bd       	out	0x2e, r17	; 46
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1544:	00 00       	nop
    1546:	0d b4       	in	r0, 0x2d	; 45
    1548:	07 fe       	sbrs	r0, 7
    return SPDR;
    154a:	fd cf       	rjmp	.-6      	; 0x1546 <_ZN7MCP251511setRegisterENS_8REGISTEREh+0x2e>
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    SPI.transfer(value);
    endSPI();
    154c:	8e b5       	in	r24, 0x2e	; 46
    154e:	ce 01       	movw	r24, r28
    1550:	6f df       	rcall	.-290    	; 0x1430 <_ZN7MCP25156endSPIEv>
}
    1552:	df 91       	pop	r29
    1554:	cf 91       	pop	r28
    1556:	1f 91       	pop	r17
    1558:	0f 91       	pop	r16
    155a:	08 95       	ret

0000155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>:

void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    155c:	ef 92       	push	r14
    155e:	ff 92       	push	r15
    1560:	0f 93       	push	r16
    1562:	1f 93       	push	r17
    1564:	cf 93       	push	r28
    1566:	df 93       	push	r29
    1568:	ec 01       	movw	r28, r24
    156a:	06 2f       	mov	r16, r22
    156c:	7a 01       	movw	r14, r20
    startSPI();
    156e:	12 2f       	mov	r17, r18
    1570:	3f df       	rcall	.-386    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1572:	82 e0       	ldi	r24, 0x02	; 2
    1574:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1576:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1578:	0d b4       	in	r0, 0x2d	; 45
    157a:	07 fe       	sbrs	r0, 7
    157c:	fd cf       	rjmp	.-6      	; 0x1578 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x1c>
    return SPDR;
    157e:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1580:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1582:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1584:	0d b4       	in	r0, 0x2d	; 45
    1586:	07 fe       	sbrs	r0, 7
    1588:	fd cf       	rjmp	.-6      	; 0x1584 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x28>
    return SPDR;
    158a:	8e b5       	in	r24, 0x2e	; 46
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    158c:	11 23       	and	r17, r17
    158e:	91 f0       	breq	.+36     	; 0x15b4 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x58>
    1590:	f7 01       	movw	r30, r14
    1592:	11 50       	subi	r17, 0x01	; 1
    1594:	41 2f       	mov	r20, r17
    1596:	50 e0       	ldi	r21, 0x00	; 0
    1598:	4f 5f       	subi	r20, 0xFF	; 255
    159a:	5f 4f       	sbci	r21, 0xFF	; 255
    159c:	4e 0d       	add	r20, r14
    159e:	5f 1d       	adc	r21, r15
        SPI.transfer(values[i]);
    15a0:	81 91       	ld	r24, Z+
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    15a2:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    15a4:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    15a6:	0d b4       	in	r0, 0x2d	; 45
    15a8:	07 fe       	sbrs	r0, 7
    return SPDR;
    15aa:	fd cf       	rjmp	.-6      	; 0x15a6 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x4a>
void MCP2515::setRegisters(const REGISTER reg, const uint8_t values[], const uint8_t n)
{
    startSPI();
    SPI.transfer(INSTRUCTION_WRITE);
    SPI.transfer(reg);
    for (uint8_t i=0; i<n; i++) {
    15ac:	8e b5       	in	r24, 0x2e	; 46
    15ae:	e4 17       	cp	r30, r20
    15b0:	f5 07       	cpc	r31, r21
        SPI.transfer(values[i]);
    }
    endSPI();
    15b2:	b1 f7       	brne	.-20     	; 0x15a0 <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh+0x44>
    15b4:	ce 01       	movw	r24, r28
    15b6:	3c df       	rcall	.-392    	; 0x1430 <_ZN7MCP25156endSPIEv>
}
    15b8:	df 91       	pop	r29
    15ba:	cf 91       	pop	r28
    15bc:	1f 91       	pop	r17
    15be:	0f 91       	pop	r16
    15c0:	ff 90       	pop	r15
    15c2:	ef 90       	pop	r14
    15c4:	08 95       	ret

000015c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>:

void MCP2515::modifyRegister(const REGISTER reg, const uint8_t mask, const uint8_t data)
{
    15c6:	ff 92       	push	r15
    15c8:	0f 93       	push	r16
    15ca:	1f 93       	push	r17
    15cc:	cf 93       	push	r28
    15ce:	df 93       	push	r29
    15d0:	ec 01       	movw	r28, r24
    15d2:	f6 2e       	mov	r15, r22
    15d4:	04 2f       	mov	r16, r20
    startSPI();
    15d6:	12 2f       	mov	r17, r18
    15d8:	0b df       	rcall	.-490    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    15da:	85 e0       	ldi	r24, 0x05	; 5
    15dc:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    15de:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    15e0:	0d b4       	in	r0, 0x2d	; 45
    15e2:	07 fe       	sbrs	r0, 7
    15e4:	fd cf       	rjmp	.-6      	; 0x15e0 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x1a>
    return SPDR;
    15e6:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    15e8:	fe bc       	out	0x2e, r15	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    15ea:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    15ec:	0d b4       	in	r0, 0x2d	; 45
    15ee:	07 fe       	sbrs	r0, 7
    15f0:	fd cf       	rjmp	.-6      	; 0x15ec <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x26>
    return SPDR;
    15f2:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    15f4:	0e bd       	out	0x2e, r16	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    15f6:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    15f8:	0d b4       	in	r0, 0x2d	; 45
    15fa:	07 fe       	sbrs	r0, 7
    return SPDR;
    15fc:	fd cf       	rjmp	.-6      	; 0x15f8 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x32>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    15fe:	8e b5       	in	r24, 0x2e	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1600:	1e bd       	out	0x2e, r17	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1602:	00 00       	nop
    1604:	0d b4       	in	r0, 0x2d	; 45
    1606:	07 fe       	sbrs	r0, 7
    return SPDR;
    1608:	fd cf       	rjmp	.-6      	; 0x1604 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh+0x3e>
    SPI.transfer(INSTRUCTION_BITMOD);
    SPI.transfer(reg);
    SPI.transfer(mask);
    SPI.transfer(data);
    endSPI();
    160a:	8e b5       	in	r24, 0x2e	; 46
    160c:	ce 01       	movw	r24, r28
    160e:	10 df       	rcall	.-480    	; 0x1430 <_ZN7MCP25156endSPIEv>
}
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	1f 91       	pop	r17
    1616:	0f 91       	pop	r16
    1618:	ff 90       	pop	r15
    161a:	08 95       	ret

0000161c <_ZN7MCP25155resetEv>:
     PORTB|=(1<<PB4);
    SPI.endTransaction();
}

MCP2515::ERROR MCP2515::reset(void)
{
    161c:	ef 92       	push	r14
    161e:	ff 92       	push	r15
    1620:	0f 93       	push	r16
    1622:	1f 93       	push	r17
    1624:	cf 93       	push	r28
    1626:	df 93       	push	r29
    1628:	cd b7       	in	r28, 0x3d	; 61
    162a:	de b7       	in	r29, 0x3e	; 62
    162c:	2e 97       	sbiw	r28, 0x0e	; 14
    162e:	0f b6       	in	r0, 0x3f	; 63
    1630:	f8 94       	cli
    1632:	de bf       	out	0x3e, r29	; 62
    1634:	0f be       	out	0x3f, r0	; 63
    startSPI();
    1636:	cd bf       	out	0x3d, r28	; 61
    1638:	8c 01       	movw	r16, r24
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    163a:	da de       	rcall	.-588    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    163c:	80 ec       	ldi	r24, 0xC0	; 192
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    163e:	8e bd       	out	0x2e, r24	; 46
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    1640:	00 00       	nop
    1642:	0d b4       	in	r0, 0x2d	; 45
    1644:	07 fe       	sbrs	r0, 7
    return SPDR;
    1646:	fd cf       	rjmp	.-6      	; 0x1642 <_ZN7MCP25155resetEv+0x26>
    SPI.transfer(INSTRUCTION_RESET);
    endSPI();
    1648:	8e b5       	in	r24, 0x2e	; 46
    164a:	c8 01       	movw	r24, r16
    164c:	f1 de       	rcall	.-542    	; 0x1430 <_ZN7MCP25156endSPIEv>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    164e:	8f e3       	ldi	r24, 0x3F	; 63
    1650:	9c e9       	ldi	r25, 0x9C	; 156
    1652:	01 97       	sbiw	r24, 0x01	; 1
    1654:	f1 f7       	brne	.-4      	; 0x1652 <_ZN7MCP25155resetEv+0x36>
    1656:	00 c0       	rjmp	.+0      	; 0x1658 <_ZN7MCP25155resetEv+0x3c>

    _delay_ms(10);

    uint8_t zeros[14];
    memset(zeros, 0, sizeof(zeros));
    1658:	00 00       	nop
    165a:	fe 01       	movw	r30, r28
    165c:	31 96       	adiw	r30, 0x01	; 1
    165e:	7f 01       	movw	r14, r30
    1660:	8e e0       	ldi	r24, 0x0E	; 14
    1662:	11 92       	st	Z+, r1
    setRegisters(MCP_TXB0CTRL, zeros, 14);
    1664:	8a 95       	dec	r24
    1666:	e9 f7       	brne	.-6      	; 0x1662 <_ZN7MCP25155resetEv+0x46>
    1668:	2e e0       	ldi	r18, 0x0E	; 14
    166a:	a7 01       	movw	r20, r14
    166c:	60 e3       	ldi	r22, 0x30	; 48
    setRegisters(MCP_TXB1CTRL, zeros, 14);
    166e:	c8 01       	movw	r24, r16
    1670:	75 df       	rcall	.-278    	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1672:	2e e0       	ldi	r18, 0x0E	; 14
    1674:	a7 01       	movw	r20, r14
    1676:	60 e4       	ldi	r22, 0x40	; 64
    setRegisters(MCP_TXB2CTRL, zeros, 14);
    1678:	c8 01       	movw	r24, r16
    167a:	70 df       	rcall	.-288    	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    167c:	2e e0       	ldi	r18, 0x0E	; 14
    167e:	a7 01       	movw	r20, r14
    1680:	60 e5       	ldi	r22, 0x50	; 80

    setRegister(MCP_RXB0CTRL, 0);
    1682:	c8 01       	movw	r24, r16
    1684:	6b df       	rcall	.-298    	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1686:	40 e0       	ldi	r20, 0x00	; 0
    1688:	60 e6       	ldi	r22, 0x60	; 96
    setRegister(MCP_RXB1CTRL, 0);
    168a:	c8 01       	movw	r24, r16
    168c:	45 df       	rcall	.-374    	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    168e:	40 e0       	ldi	r20, 0x00	; 0
    1690:	60 e7       	ldi	r22, 0x70	; 112

    setRegister(MCP_CANINTE, CANINTF_RX0IF | CANINTF_RX1IF); // | CANINTF_ERRIF | CANINTF_MERRF
    1692:	c8 01       	movw	r24, r16
    1694:	41 df       	rcall	.-382    	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1696:	43 e0       	ldi	r20, 0x03	; 3
    1698:	6b e2       	ldi	r22, 0x2B	; 43
    169a:	c8 01       	movw	r24, r16

    modifyRegister(MCP_RXB0CTRL,
                   RXBnCTRL_RXM_MASK | RXB0CTRL_BUKT,
                   RXBnCTRL_RXM_STDEXT | RXB0CTRL_BUKT);
    169c:	3d df       	rcall	.-390    	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    169e:	24 e0       	ldi	r18, 0x04	; 4
    16a0:	44 e6       	ldi	r20, 0x64	; 100
    16a2:	60 e6       	ldi	r22, 0x60	; 96
    16a4:	c8 01       	movw	r24, r16
    16a6:	8f df       	rcall	.-226    	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    modifyRegister(MCP_RXB1CTRL, RXBnCTRL_RXM_MASK, RXBnCTRL_RXM_STDEXT);
    16a8:	20 e0       	ldi	r18, 0x00	; 0
    16aa:	40 e6       	ldi	r20, 0x60	; 96
    16ac:	60 e7       	ldi	r22, 0x70	; 112
    16ae:	c8 01       	movw	r24, r16
    16b0:	8a df       	rcall	.-236    	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
            return result;
        }
    }*/

    return ERROR_OK;
}
    16b2:	80 e0       	ldi	r24, 0x00	; 0
    16b4:	2e 96       	adiw	r28, 0x0e	; 14
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	de bf       	out	0x3e, r29	; 62
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	cd bf       	out	0x3d, r28	; 61
    16c0:	df 91       	pop	r29
    16c2:	cf 91       	pop	r28
    16c4:	1f 91       	pop	r17
    16c6:	0f 91       	pop	r16
    16c8:	ff 90       	pop	r15
    16ca:	ef 90       	pop	r14
    SPI.transfer(data);
    endSPI();
}

uint8_t MCP2515::getStatus(void)
{
    16cc:	08 95       	ret

000016ce <_ZN7MCP25159getStatusEv>:
    16ce:	1f 93       	push	r17
    16d0:	cf 93       	push	r28
    16d2:	df 93       	push	r29
    startSPI();
    16d4:	ec 01       	movw	r28, r24
    16d6:	8c de       	rcall	.-744    	; 0x13f0 <_ZN7MCP25158startSPIEv>
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    16d8:	80 ea       	ldi	r24, 0xA0	; 160
    16da:	8e bd       	out	0x2e, r24	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    16dc:	00 00       	nop
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    16de:	0d b4       	in	r0, 0x2d	; 45
    16e0:	07 fe       	sbrs	r0, 7
    16e2:	fd cf       	rjmp	.-6      	; 0x16de <_ZN7MCP25159getStatusEv+0x10>
    return SPDR;
    16e4:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    16e6:	1e bc       	out	0x2e, r1	; 46
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    while (!(SPSR & (1<<(SPIF)))) ; // wait
    16e8:	00 00       	nop
    16ea:	0d b4       	in	r0, 0x2d	; 45
    16ec:	07 fe       	sbrs	r0, 7
    SPI.transfer(INSTRUCTION_READ_STATUS);
    uint8_t i = SPI.transfer(0x00);
    endSPI();
    16ee:	fd cf       	rjmp	.-6      	; 0x16ea <_ZN7MCP25159getStatusEv+0x1c>
    16f0:	1e b5       	in	r17, 0x2e	; 46

    return i;
}
    16f2:	ce 01       	movw	r24, r28
    16f4:	9d de       	rcall	.-710    	; 0x1430 <_ZN7MCP25156endSPIEv>
    16f6:	81 2f       	mov	r24, r17
    16f8:	df 91       	pop	r29
{
    return setMode(CANCTRL_REQOP_NORMAL);
}

MCP2515::ERROR MCP2515::setMode(const CANCTRL_REQOP_MODE mode)
{
    16fa:	cf 91       	pop	r28
    16fc:	1f 91       	pop	r17
    16fe:	08 95       	ret

00001700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>:
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	cf 93       	push	r28
	uint8_t sreg = SREG;
    1706:	df 93       	push	r29
    modifyRegister(MCP_CANCTRL, CANCTRL_REQOP, mode);
    1708:	ec 01       	movw	r28, r24
    170a:	16 2f       	mov	r17, r22
    170c:	0f b7       	in	r16, 0x3f	; 63
    170e:	26 2f       	mov	r18, r22
    1710:	40 ee       	ldi	r20, 0xE0	; 224
	sei();
    1712:	6f e0       	ldi	r22, 0x0F	; 15
    timeoutstart(624);
    1714:	58 df       	rcall	.-336    	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1716:	78 94       	sei
    1718:	80 e7       	ldi	r24, 0x70	; 112
    bool modeMatch = false;
    while (~timeoutcheck()) {
    171a:	92 e0       	ldi	r25, 0x02	; 2
    171c:	b8 d7       	rcall	.+3952   	; 0x268e <_Z12timeoutstarti>
    171e:	d9 d7       	rcall	.+4018   	; 0x26d2 <_Z12timeoutcheckv>
        uint8_t newmode = readRegister(MCP_CANSTAT);
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	41 f0       	breq	.+16     	; 0x1734 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x34>
    1724:	6e e0       	ldi	r22, 0x0E	; 14
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;

        if (modeMatch) {
    1726:	ce 01       	movw	r24, r28
    1728:	a2 de       	rcall	.-700    	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
    bool modeMatch = false;
    while (~timeoutcheck()) {
        uint8_t newmode = readRegister(MCP_CANSTAT);
        newmode &= CANSTAT_OPMOD;

        modeMatch = newmode == mode;
    172a:	80 7e       	andi	r24, 0xE0	; 224
    172c:	18 13       	cpse	r17, r24
    172e:	f7 cf       	rjmp	.-18     	; 0x171e <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x1e>

        if (modeMatch) {
            break;
        }
    }
	SREG = sreg;
    1730:	91 e0       	ldi	r25, 0x01	; 1

    return modeMatch ? ERROR_OK : ERROR_FAIL;

}
    1732:	01 c0       	rjmp	.+2      	; 0x1736 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE+0x36>
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	0f bf       	out	0x3f, r16	; 63
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	89 27       	eor	r24, r25
    173c:	df 91       	pop	r29
    return i;
}

MCP2515::ERROR MCP2515::setConfigMode()
{
    return setMode(CANCTRL_REQOP_CONFIG);
    173e:	cf 91       	pop	r28
    1740:	1f 91       	pop	r17
    1742:	0f 91       	pop	r16
}
    1744:	08 95       	ret

00001746 <_ZN7MCP251513setConfigModeEv>:

MCP2515::ERROR MCP2515::setListenOnlyMode()
{
    return setMode(CANCTRL_REQOP_LISTENONLY);
    1746:	60 e8       	ldi	r22, 0x80	; 128
    1748:	db cf       	rjmp	.-74     	; 0x1700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    174a:	08 95       	ret

0000174c <_ZN7MCP251517setListenOnlyModeEv>:
}
    174c:	60 e6       	ldi	r22, 0x60	; 96

MCP2515::ERROR MCP2515::setSleepMode()
{
    return setMode(CANCTRL_REQOP_SLEEP);
    174e:	d8 cf       	rjmp	.-80     	; 0x1700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    1750:	08 95       	ret

00001752 <_ZN7MCP251512setSleepModeEv>:
    1752:	60 e2       	ldi	r22, 0x20	; 32
}
    1754:	d5 cf       	rjmp	.-86     	; 0x1700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>

MCP2515::ERROR MCP2515::setLoopbackMode()
{
    return setMode(CANCTRL_REQOP_LOOPBACK);
    1756:	08 95       	ret

00001758 <_ZN7MCP251515setLoopbackModeEv>:
    1758:	60 e4       	ldi	r22, 0x40	; 64
    175a:	d2 cf       	rjmp	.-92     	; 0x1700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
}
    175c:	08 95       	ret

0000175e <_ZN7MCP251513setNormalModeEv>:

MCP2515::ERROR MCP2515::setNormalMode()
{
    return setMode(CANCTRL_REQOP_NORMAL);
    175e:	60 e0       	ldi	r22, 0x00	; 0
    1760:	cf cf       	rjmp	.-98     	; 0x1700 <_ZN7MCP25157setModeENS_18CANCTRL_REQOP_MODEE>
    1762:	08 95       	ret

00001764 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>:
}
    1764:	ef 92       	push	r14
{
    return setBitrate(canSpeed, MCP_16MHZ);
}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed, CAN_CLOCK canClock)
{
    1766:	ff 92       	push	r15
    1768:	0f 93       	push	r16
    176a:	1f 93       	push	r17
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	ec 01       	movw	r28, r24
    1772:	16 2f       	mov	r17, r22
    1774:	04 2f       	mov	r16, r20
    1776:	e7 df       	rcall	.-50     	; 0x1746 <_ZN7MCP251513setConfigModeEv>
    ERROR error = setConfigMode();
    1778:	81 11       	cpse	r24, r1
    177a:	98 c1       	rjmp	.+816    	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    if (error != ERROR_OK) {
    177c:	01 30       	cpi	r16, 0x01	; 1
    177e:	09 f4       	brne	.+2      	; 0x1782 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1e>
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    switch (canClock)
    1780:	6d c0       	rjmp	.+218    	; 0x185c <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0xf8>
    1782:	08 f4       	brcc	.+2      	; 0x1786 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x22>
    1784:	e2 c0       	rjmp	.+452    	; 0x194a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1e6>
    1786:	02 30       	cpi	r16, 0x02	; 2
    1788:	09 f0       	breq	.+2      	; 0x178c <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x28>
    178a:	38 c1       	rjmp	.+624    	; 0x19fc <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x298>
    178c:	81 2f       	mov	r24, r17
    178e:	90 e0       	ldi	r25, 0x00	; 0
    {
        case (MCP_8MHZ):
        switch (canSpeed)
    1790:	80 31       	cpi	r24, 0x10	; 16
    1792:	91 05       	cpc	r25, r1
    1794:	08 f0       	brcs	.+2      	; 0x1798 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x34>
    1796:	5e c1       	rjmp	.+700    	; 0x1a54 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f0>
    1798:	fc 01       	movw	r30, r24
    179a:	88 27       	eor	r24, r24
    179c:	ee 58       	subi	r30, 0x8E	; 142
    179e:	ff 4f       	sbci	r31, 0xFF	; 255
    17a0:	8f 4f       	sbci	r24, 0xFF	; 255
    17a2:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
    17a6:	17 e8       	ldi	r17, 0x87	; 135
    17a8:	0f 2e       	mov	r0, r31
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
    17aa:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
            cfg2 = MCP_8MHz_20kBPS_CFG2;
    17ac:	ef 2e       	mov	r14, r31
    17ae:	f0 2d       	mov	r31, r0
    17b0:	0f 2e       	mov	r0, r31
    17b2:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20KBPS
            cfg1 = MCP_8MHz_20kBPS_CFG1;
    17b4:	ff 2e       	mov	r15, r31
    17b6:	f0 2d       	mov	r31, r0
    17b8:	3f c1       	rjmp	.+638    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    17ba:	15 e8       	ldi	r17, 0x85	; 133
    17bc:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
    17be:	f2 ee       	ldi	r31, 0xE2	; 226
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
    17c0:	ef 2e       	mov	r14, r31
    17c2:	f0 2d       	mov	r31, r0
    17c4:	0f 2e       	mov	r0, r31
    17c6:	f7 e4       	ldi	r31, 0x47	; 71
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
            cfg3 = MCP_8MHz_31k25BPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333KBPS
            cfg1 = MCP_8MHz_33k3BPS_CFG1;
    17c8:	ff 2e       	mov	r15, r31
    17ca:	f0 2d       	mov	r31, r0
    17cc:	35 c1       	rjmp	.+618    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    17ce:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;
    17d0:	0f 2e       	mov	r0, r31

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
    17d2:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
            cfg2 = MCP_8MHz_40kBPS_CFG2;
    17d4:	ef 2e       	mov	r14, r31
    17d6:	f0 2d       	mov	r31, r0
    17d8:	0f 2e       	mov	r0, r31
    17da:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_33k3BPS_CFG2;
            cfg3 = MCP_8MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_8MHz_40kBPS_CFG1;
    17dc:	ff 2e       	mov	r15, r31
    17de:	f0 2d       	mov	r31, r0
    17e0:	2b c1       	rjmp	.+598    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    17e2:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;
    17e4:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
    17e6:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
            cfg2 = MCP_8MHz_50kBPS_CFG2;
    17e8:	ef 2e       	mov	r14, r31
    17ea:	f0 2d       	mov	r31, r0
    17ec:	0f 2e       	mov	r0, r31
    17ee:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_8MHz_40kBPS_CFG2;
            cfg3 = MCP_8MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_8MHz_50kBPS_CFG1;
    17f0:	ff 2e       	mov	r15, r31
    17f2:	f0 2d       	mov	r31, r0
    17f4:	21 c1       	rjmp	.+578    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    17f6:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;
    17f8:	0f 2e       	mov	r0, r31

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
    17fa:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
            cfg2 = MCP_8MHz_80kBPS_CFG2;
    17fc:	ef 2e       	mov	r14, r31
    17fe:	f0 2d       	mov	r31, r0
    1800:	ff 24       	eor	r15, r15
    1802:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_50kBPS_CFG2;
            cfg3 = MCP_8MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_8MHz_80kBPS_CFG1;
    1804:	19 c1       	rjmp	.+562    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1806:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;
    1808:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
    180a:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
            cfg2 = MCP_8MHz_100kBPS_CFG2;
    180c:	ef 2e       	mov	r14, r31
    180e:	f0 2d       	mov	r31, r0
    1810:	ff 24       	eor	r15, r15
    1812:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_80kBPS_CFG2;
            cfg3 = MCP_8MHz_80kBPS_CFG3;
            break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_8MHz_100kBPS_CFG1;
    1814:	11 c1       	rjmp	.+546    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1816:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;
    1818:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
    181a:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
            cfg2 = MCP_8MHz_125kBPS_CFG2;
    181c:	ef 2e       	mov	r14, r31
    181e:	f0 2d       	mov	r31, r0
    1820:	ff 24       	eor	r15, r15
    1822:	f3 94       	inc	r15
            cfg2 = MCP_8MHz_100kBPS_CFG2;
            cfg3 = MCP_8MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_8MHz_125kBPS_CFG1;
    1824:	09 c1       	rjmp	.+530    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1826:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;
    1828:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
    182a:	f4 eb       	ldi	r31, 0xB4	; 180
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
            cfg2 = MCP_8MHz_200kBPS_CFG2;
    182c:	ef 2e       	mov	r14, r31
    182e:	f0 2d       	mov	r31, r0
    1830:	f1 2c       	mov	r15, r1
    1832:	02 c1       	rjmp	.+516    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_125kBPS_CFG2;
            cfg3 = MCP_8MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_8MHz_200kBPS_CFG1;
    1834:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;
    1836:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
    1838:	f1 eb       	ldi	r31, 0xB1	; 177
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
            cfg2 = MCP_8MHz_250kBPS_CFG2;
    183a:	ef 2e       	mov	r14, r31
    183c:	f0 2d       	mov	r31, r0
    183e:	f1 2c       	mov	r15, r1
    1840:	fb c0       	rjmp	.+502    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_200kBPS_CFG2;
            cfg3 = MCP_8MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_8MHz_250kBPS_CFG1;
    1842:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;
    1844:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
    1846:	f0 e9       	ldi	r31, 0x90	; 144
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
            cfg2 = MCP_8MHz_500kBPS_CFG2;
    1848:	ef 2e       	mov	r14, r31
    184a:	f0 2d       	mov	r31, r0
    184c:	f1 2c       	mov	r15, r1
    184e:	f4 c0       	rjmp	.+488    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_250kBPS_CFG2;
            cfg3 = MCP_8MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_8MHz_500kBPS_CFG1;
    1850:	10 e8       	ldi	r17, 0x80	; 128
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;
    1852:	68 94       	set

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
    1854:	ee 24       	eor	r14, r14
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
    1856:	e7 f8       	bld	r14, 7
    1858:	f1 2c       	mov	r15, r1
    185a:	ee c0       	rjmp	.+476    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_8MHz_500kBPS_CFG2;
            cfg3 = MCP_8MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_8MHz_1000kBPS_CFG1;
    185c:	81 2f       	mov	r24, r17
            cfg2 = MCP_8MHz_1000kBPS_CFG2;
            cfg3 = MCP_8MHz_1000kBPS_CFG3;
            break;
    185e:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_16MHZ):
        switch (canSpeed)
    1860:	80 31       	cpi	r24, 0x10	; 16
    1862:	91 05       	cpc	r25, r1
    1864:	08 f0       	brcs	.+2      	; 0x1868 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x104>
    1866:	f8 c0       	rjmp	.+496    	; 0x1a58 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f4>
    1868:	fc 01       	movw	r30, r24
    186a:	88 27       	eor	r24, r24
    186c:	ee 57       	subi	r30, 0x7E	; 126
    186e:	ff 4f       	sbci	r31, 0xFF	; 255
    1870:	8f 4f       	sbci	r24, 0xFF	; 255
    1872:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
    1876:	17 e8       	ldi	r17, 0x87	; 135
    1878:	ee 24       	eor	r14, r14
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
    187a:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
            cfg2 = MCP_16MHz_20kBPS_CFG2;
    187c:	0f 2e       	mov	r0, r31
    187e:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_16MHz_10kBPS_CFG2;
            cfg3 = MCP_16MHz_10kBPS_CFG3;
            break;

            case (CAN_20KBPS):                                              //  20Kbps
            cfg1 = MCP_16MHz_20kBPS_CFG1;
    1880:	ff 2e       	mov	r15, r31
    1882:	f0 2d       	mov	r31, r0
    1884:	d9 c0       	rjmp	.+434    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1886:	15 e8       	ldi	r17, 0x85	; 133
    1888:	0f 2e       	mov	r0, r31
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
    188a:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
    188c:	ef 2e       	mov	r14, r31
    188e:	f0 2d       	mov	r31, r0
    1890:	0f 2e       	mov	r0, r31
    1892:	fe e4       	ldi	r31, 0x4E	; 78
            cfg2 = MCP_16MHz_20kBPS_CFG2;
            cfg3 = MCP_16MHz_20kBPS_CFG3;
            break;

            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_16MHz_33k3BPS_CFG1;
    1894:	ff 2e       	mov	r15, r31
    1896:	f0 2d       	mov	r31, r0
    1898:	cf c0       	rjmp	.+414    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    189a:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;
    189c:	ee 24       	eor	r14, r14

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
    189e:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
            cfg2 = MCP_16MHz_40kBPS_CFG2;
    18a0:	0f 2e       	mov	r0, r31
    18a2:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_33k3BPS_CFG2;
            cfg3 = MCP_16MHz_33k3BPS_CFG3;
            break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_16MHz_40kBPS_CFG1;
    18a4:	ff 2e       	mov	r15, r31
    18a6:	f0 2d       	mov	r31, r0
    18a8:	c7 c0       	rjmp	.+398    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    18aa:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;
    18ac:	0f 2e       	mov	r0, r31

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
    18ae:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
            cfg2 = MCP_16MHz_50kBPS_CFG2;
    18b0:	ef 2e       	mov	r14, r31
    18b2:	f0 2d       	mov	r31, r0
    18b4:	0f 2e       	mov	r0, r31
    18b6:	f7 e0       	ldi	r31, 0x07	; 7
            cfg2 = MCP_16MHz_40kBPS_CFG2;
            cfg3 = MCP_16MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_16MHz_50kBPS_CFG1;
    18b8:	ff 2e       	mov	r15, r31
    18ba:	f0 2d       	mov	r31, r0
    18bc:	bd c0       	rjmp	.+378    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    18be:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;
    18c0:	ee 24       	eor	r14, r14

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
    18c2:	ea 94       	dec	r14
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
            cfg2 = MCP_16MHz_80kBPS_CFG2;
    18c4:	0f 2e       	mov	r0, r31
    18c6:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_50kBPS_CFG2;
            cfg3 = MCP_16MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_16MHz_80kBPS_CFG1;
    18c8:	ff 2e       	mov	r15, r31
    18ca:	f0 2d       	mov	r31, r0
    18cc:	b5 c0       	rjmp	.+362    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    18ce:	17 e0       	ldi	r17, 0x07	; 7
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;
    18d0:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
    18d2:	fe eb       	ldi	r31, 0xBE	; 190
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
    18d4:	ef 2e       	mov	r14, r31
    18d6:	f0 2d       	mov	r31, r0
    18d8:	0f 2e       	mov	r0, r31
    18da:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_80kBPS_CFG2;
            cfg3 = MCP_16MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_16MHz_83k3BPS_CFG1;
    18dc:	ff 2e       	mov	r15, r31
    18de:	f0 2d       	mov	r31, r0
    18e0:	ab c0       	rjmp	.+342    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    18e2:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 
    18e4:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
    18e6:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
            cfg2 = MCP_16MHz_100kBPS_CFG2;
    18e8:	ef 2e       	mov	r14, r31
    18ea:	f0 2d       	mov	r31, r0
    18ec:	0f 2e       	mov	r0, r31
    18ee:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_83k3BPS_CFG2;
            cfg3 = MCP_16MHz_83k3BPS_CFG3;
            break; 

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_16MHz_100kBPS_CFG1;
    18f0:	ff 2e       	mov	r15, r31
    18f2:	f0 2d       	mov	r31, r0
    18f4:	a1 c0       	rjmp	.+322    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    18f6:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;
    18f8:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
    18fa:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
            cfg2 = MCP_16MHz_125kBPS_CFG2;
    18fc:	ef 2e       	mov	r14, r31
    18fe:	f0 2d       	mov	r31, r0
    1900:	0f 2e       	mov	r0, r31
    1902:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_16MHz_100kBPS_CFG2;
            cfg3 = MCP_16MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_16MHz_125kBPS_CFG1;
    1904:	ff 2e       	mov	r15, r31
    1906:	f0 2d       	mov	r31, r0
    1908:	97 c0       	rjmp	.+302    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    190a:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;
    190c:	0f 2e       	mov	r0, r31

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
    190e:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
            cfg2 = MCP_16MHz_200kBPS_CFG2;
    1910:	ef 2e       	mov	r14, r31
    1912:	f0 2d       	mov	r31, r0
    1914:	ff 24       	eor	r15, r15
    1916:	f3 94       	inc	r15
            cfg2 = MCP_16MHz_125kBPS_CFG2;
            cfg3 = MCP_16MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_16MHz_200kBPS_CFG1;
    1918:	8f c0       	rjmp	.+286    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    191a:	15 e8       	ldi	r17, 0x85	; 133
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;
    191c:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
    191e:	f1 ef       	ldi	r31, 0xF1	; 241
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
            cfg2 = MCP_16MHz_250kBPS_CFG2;
    1920:	ef 2e       	mov	r14, r31
    1922:	f0 2d       	mov	r31, r0
    1924:	0f 2e       	mov	r0, r31
    1926:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_16MHz_200kBPS_CFG2;
            cfg3 = MCP_16MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_16MHz_250kBPS_CFG1;
    1928:	ff 2e       	mov	r15, r31
    192a:	f0 2d       	mov	r31, r0
    192c:	85 c0       	rjmp	.+266    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    192e:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;
    1930:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
    1932:	f0 ef       	ldi	r31, 0xF0	; 240
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
            cfg2 = MCP_16MHz_500kBPS_CFG2;
    1934:	ef 2e       	mov	r14, r31
    1936:	f0 2d       	mov	r31, r0
    1938:	f1 2c       	mov	r15, r1
    193a:	7e c0       	rjmp	.+252    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_16MHz_250kBPS_CFG2;
            cfg3 = MCP_16MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_16MHz_500kBPS_CFG1;
    193c:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;
    193e:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
    1940:	f0 ed       	ldi	r31, 0xD0	; 208
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
    1942:	ef 2e       	mov	r14, r31
    1944:	f0 2d       	mov	r31, r0
    1946:	f1 2c       	mov	r15, r1
    1948:	77 c0       	rjmp	.+238    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_16MHz_500kBPS_CFG2;
            cfg3 = MCP_16MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_16MHz_1000kBPS_CFG1;
    194a:	81 2f       	mov	r24, r17
            cfg2 = MCP_16MHz_1000kBPS_CFG2;
            cfg3 = MCP_16MHz_1000kBPS_CFG3;
            break;
    194c:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        break;

        case (MCP_20MHZ):
        switch (canSpeed)
    194e:	fc 01       	movw	r30, r24
    1950:	34 97       	sbiw	r30, 0x04	; 4
    1952:	ec 30       	cpi	r30, 0x0C	; 12
    1954:	f1 05       	cpc	r31, r1
    1956:	08 f0       	brcs	.+2      	; 0x195a <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x1f6>
    1958:	81 c0       	rjmp	.+258    	; 0x1a5c <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2f8>
    195a:	88 27       	eor	r24, r24
    195c:	ee 56       	subi	r30, 0x6E	; 110
    195e:	ff 4f       	sbci	r31, 0xFF	; 255
    1960:	8f 4f       	sbci	r24, 0xFF	; 255
    1962:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
    1966:	17 e8       	ldi	r17, 0x87	; 135
    1968:	0f 2e       	mov	r0, r31
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
    196a:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
            cfg2 = MCP_20MHz_50kBPS_CFG2;
    196c:	ef 2e       	mov	r14, r31
    196e:	f0 2d       	mov	r31, r0
    1970:	0f 2e       	mov	r0, r31
    1972:	f9 e0       	ldi	r31, 0x09	; 9
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
            break;

            case (CAN_50KBPS):                                              //  50Kbps
            cfg1 = MCP_20MHz_50kBPS_CFG1;
    1974:	ff 2e       	mov	r15, r31
    1976:	f0 2d       	mov	r31, r0
    1978:	5f c0       	rjmp	.+190    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    197a:	17 e8       	ldi	r17, 0x87	; 135
    197c:	ee 24       	eor	r14, r14
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
    197e:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
            cfg2 = MCP_20MHz_80kBPS_CFG2;
    1980:	68 94       	set
    1982:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_50kBPS_CFG2;
            cfg3 = MCP_20MHz_50kBPS_CFG3;
            break;

            case (CAN_80KBPS):                                              //  80Kbps
            cfg1 = MCP_20MHz_80kBPS_CFG1;
    1984:	f2 f8       	bld	r15, 2
    1986:	58 c0       	rjmp	.+176    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1988:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;
    198a:	0f 2e       	mov	r0, r31

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
    198c:	fe ef       	ldi	r31, 0xFE	; 254
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
    198e:	ef 2e       	mov	r14, r31
    1990:	f0 2d       	mov	r31, r0
    1992:	68 94       	set
    1994:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_80kBPS_CFG2;
            cfg3 = MCP_20MHz_80kBPS_CFG3;
            break;

            case (CAN_83K3BPS):                                             //  83.333Kbps
            cfg1 = MCP_20MHz_83k3BPS_CFG1;
    1996:	f2 f8       	bld	r15, 2
    1998:	4f c0       	rjmp	.+158    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    199a:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;
    199c:	0f 2e       	mov	r0, r31

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
    199e:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
            cfg2 = MCP_20MHz_100kBPS_CFG2;
    19a0:	ef 2e       	mov	r14, r31
    19a2:	f0 2d       	mov	r31, r0
    19a4:	68 94       	set
    19a6:	ff 24       	eor	r15, r15
            cfg2 = MCP_20MHz_83k3BPS_CFG2;
            cfg3 = MCP_20MHz_83k3BPS_CFG3;
	    break;

            case (CAN_100KBPS):                                             // 100Kbps
            cfg1 = MCP_20MHz_100kBPS_CFG1;
    19a8:	f2 f8       	bld	r15, 2
    19aa:	46 c0       	rjmp	.+140    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    19ac:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;
    19ae:	0f 2e       	mov	r0, r31

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
    19b0:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
            cfg2 = MCP_20MHz_125kBPS_CFG2;
    19b2:	ef 2e       	mov	r14, r31
    19b4:	f0 2d       	mov	r31, r0
    19b6:	0f 2e       	mov	r0, r31
    19b8:	f3 e0       	ldi	r31, 0x03	; 3
            cfg2 = MCP_20MHz_100kBPS_CFG2;
            cfg3 = MCP_20MHz_100kBPS_CFG3;
            break;

            case (CAN_125KBPS):                                             // 125Kbps
            cfg1 = MCP_20MHz_125kBPS_CFG1;
    19ba:	ff 2e       	mov	r15, r31
    19bc:	f0 2d       	mov	r31, r0
    19be:	3c c0       	rjmp	.+120    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    19c0:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;
    19c2:	ee 24       	eor	r14, r14

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
    19c4:	ea 94       	dec	r14
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
            cfg2 = MCP_20MHz_200kBPS_CFG2;
    19c6:	ff 24       	eor	r15, r15
    19c8:	f3 94       	inc	r15
            cfg2 = MCP_20MHz_125kBPS_CFG2;
            cfg3 = MCP_20MHz_125kBPS_CFG3;
            break;

            case (CAN_200KBPS):                                             // 200Kbps
            cfg1 = MCP_20MHz_200kBPS_CFG1;
    19ca:	36 c0       	rjmp	.+108    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    19cc:	16 e8       	ldi	r17, 0x86	; 134
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;
    19ce:	0f 2e       	mov	r0, r31

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
    19d0:	fb ef       	ldi	r31, 0xFB	; 251
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
            cfg2 = MCP_20MHz_250kBPS_CFG2;
    19d2:	ef 2e       	mov	r14, r31
    19d4:	f0 2d       	mov	r31, r0
    19d6:	0f 2e       	mov	r0, r31
    19d8:	f1 e4       	ldi	r31, 0x41	; 65
            cfg2 = MCP_20MHz_200kBPS_CFG2;
            cfg3 = MCP_20MHz_200kBPS_CFG3;
            break;

            case (CAN_250KBPS):                                             // 250Kbps
            cfg1 = MCP_20MHz_250kBPS_CFG1;
    19da:	ff 2e       	mov	r15, r31
    19dc:	f0 2d       	mov	r31, r0
    19de:	2c c0       	rjmp	.+88     	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    19e0:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;
    19e2:	0f 2e       	mov	r0, r31

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
    19e4:	fa ef       	ldi	r31, 0xFA	; 250
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
            cfg2 = MCP_20MHz_500kBPS_CFG2;
    19e6:	ef 2e       	mov	r14, r31
    19e8:	f0 2d       	mov	r31, r0
    19ea:	f1 2c       	mov	r15, r1
    19ec:	25 c0       	rjmp	.+74     	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_20MHz_250kBPS_CFG2;
            cfg3 = MCP_20MHz_250kBPS_CFG3;
            break;

            case (CAN_500KBPS):                                             // 500Kbps
            cfg1 = MCP_20MHz_500kBPS_CFG1;
    19ee:	12 e8       	ldi	r17, 0x82	; 130
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;
    19f0:	0f 2e       	mov	r0, r31

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
            cfg3 = MCP_20MHz_1000kBPS_CFG3;
    19f2:	f9 ed       	ldi	r31, 0xD9	; 217
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
    19f4:	ef 2e       	mov	r14, r31
    19f6:	f0 2d       	mov	r31, r0
    19f8:	f1 2c       	mov	r15, r1
    19fa:	1e c0       	rjmp	.+60     	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg2 = MCP_20MHz_500kBPS_CFG2;
            cfg3 = MCP_20MHz_500kBPS_CFG3;
            break;

            case (CAN_1000KBPS):                                            //   1Mbps
            cfg1 = MCP_20MHz_1000kBPS_CFG1;
    19fc:	80 e0       	ldi	r24, 0x00	; 0
            cfg2 = MCP_20MHz_1000kBPS_CFG2;
            cfg3 = MCP_20MHz_1000kBPS_CFG3;
            break;
    19fe:	19 c0       	rjmp	.+50     	; 0x1a32 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
            break;
        }
        break;

        default:
        set = 0;
    1a00:	0f 2e       	mov	r0, r31
    1a02:	ff eb       	ldi	r31, 0xBF	; 191
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
            cfg2 = MCP_8MHz_5kBPS_CFG2;
    1a04:	ef 2e       	mov	r14, r31
    1a06:	f0 2d       	mov	r31, r0
    1a08:	0f 2e       	mov	r0, r31
    {
        case (MCP_8MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5KBPS
            cfg1 = MCP_8MHz_5kBPS_CFG1;
    1a0a:	ff e1       	ldi	r31, 0x1F	; 31
    1a0c:	ff 2e       	mov	r15, r31
    1a0e:	f0 2d       	mov	r31, r0
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    1a10:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
            cfg2 = MCP_16MHz_5kBPS_CFG2;
    1a12:	0f c0       	rjmp	.+30     	; 0x1a32 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
    1a14:	ee 24       	eor	r14, r14

        case (MCP_16MHZ):
        switch (canSpeed)
        {
            case (CAN_5KBPS):                                               //   5Kbps
            cfg1 = MCP_16MHz_5kBPS_CFG1;
    1a16:	ea 94       	dec	r14
    1a18:	0f 2e       	mov	r0, r31
    1a1a:	ff e3       	ldi	r31, 0x3F	; 63
    1a1c:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    1a1e:	f0 2d       	mov	r31, r0
    1a20:	81 e0       	ldi	r24, 0x01	; 1
        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
    1a22:	07 c0       	rjmp	.+14     	; 0x1a32 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2ce>
    1a24:	ee 24       	eor	r14, r14

        case (MCP_20MHZ):
        switch (canSpeed)
        {
            case (CAN_33KBPS):                                              //  33.333Kbps
            cfg1 = MCP_20MHz_33k3BPS_CFG1;
    1a26:	ea 94       	dec	r14
    1a28:	0f 2e       	mov	r0, r31
    1a2a:	fb e0       	ldi	r31, 0x0B	; 11
    1a2c:	ff 2e       	mov	r15, r31
    if (error != ERROR_OK) {
        return error;
    }

    uint8_t set, cfg1, cfg2, cfg3;
    set = 1;
    1a2e:	f0 2d       	mov	r31, r0
        default:
        set = 0;
        break;
    }

    if (set) {
    1a30:	81 e0       	ldi	r24, 0x01	; 1
    1a32:	88 23       	and	r24, r24
    1a34:	a9 f0       	breq	.+42     	; 0x1a60 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2fc>
        setRegister(MCP_CNF1, cfg1);
    1a36:	17 e8       	ldi	r17, 0x87	; 135
    1a38:	4f 2d       	mov	r20, r15
    1a3a:	6a e2       	ldi	r22, 0x2A	; 42
    1a3c:	ce 01       	movw	r24, r28
    1a3e:	6c dd       	rcall	.-1320   	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
        setRegister(MCP_CNF2, cfg2);
    1a40:	4e 2d       	mov	r20, r14
    1a42:	69 e2       	ldi	r22, 0x29	; 41
    1a44:	ce 01       	movw	r24, r28
    1a46:	68 dd       	rcall	.-1328   	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1a48:	41 2f       	mov	r20, r17
        setRegister(MCP_CNF3, cfg3);
    1a4a:	68 e2       	ldi	r22, 0x28	; 40
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	64 dd       	rcall	.-1336   	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>
    1a50:	80 e0       	ldi	r24, 0x00	; 0
    1a52:	2c c0       	rjmp	.+88     	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
        return ERROR_OK;
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	2a c0       	rjmp	.+84     	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    }
    else {
        return ERROR_FAIL;
    1a58:	81 e0       	ldi	r24, 0x01	; 1
    1a5a:	28 c0       	rjmp	.+80     	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	26 c0       	rjmp	.+76     	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	24 c0       	rjmp	.+72     	; 0x1aac <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x348>
    1a64:	17 e8       	ldi	r17, 0x87	; 135
    1a66:	0f 2e       	mov	r0, r31
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
            cfg3 = MCP_8MHz_10kBPS_CFG3;
    1a68:	ff eb       	ldi	r31, 0xBF	; 191
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
            cfg2 = MCP_8MHz_10kBPS_CFG2;
    1a6a:	ef 2e       	mov	r14, r31
    1a6c:	f0 2d       	mov	r31, r0
    1a6e:	0f 2e       	mov	r0, r31
    1a70:	ff e0       	ldi	r31, 0x0F	; 15
            cfg2 = MCP_8MHz_5kBPS_CFG2;
            cfg3 = MCP_8MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10KBPS
            cfg1 = MCP_8MHz_10kBPS_CFG1;
    1a72:	ff 2e       	mov	r15, r31
    1a74:	f0 2d       	mov	r31, r0
    1a76:	e0 cf       	rjmp	.-64     	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1a78:	14 e8       	ldi	r17, 0x84	; 132
    1a7a:	0f 2e       	mov	r0, r31
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
            cfg2 = MCP_8MHz_31k25BPS_CFG2;
    1a7c:	f4 ea       	ldi	r31, 0xA4	; 164
    1a7e:	ef 2e       	mov	r14, r31
    1a80:	f0 2d       	mov	r31, r0
    1a82:	0f 2e       	mov	r0, r31
            cfg2 = MCP_8MHz_20kBPS_CFG2;
            cfg3 = MCP_8MHz_20kBPS_CFG3;
            break;

            case (CAN_31K25BPS):                                            //  31.25KBPS
            cfg1 = MCP_8MHz_31k25BPS_CFG1;
    1a84:	f7 e0       	ldi	r31, 0x07	; 7
    1a86:	ff 2e       	mov	r15, r31
    1a88:	f0 2d       	mov	r31, r0
    1a8a:	d6 cf       	rjmp	.-84     	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1a8c:	17 e8       	ldi	r17, 0x87	; 135
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
            cfg2 = MCP_16MHz_10kBPS_CFG2;
    1a8e:	ee 24       	eor	r14, r14
    1a90:	ea 94       	dec	r14
            cfg2 = MCP_16MHz_5kBPS_CFG2;
            cfg3 = MCP_16MHz_5kBPS_CFG3;
            break;

            case (CAN_10KBPS):                                              //  10Kbps
            cfg1 = MCP_16MHz_10kBPS_CFG1;
    1a92:	0f 2e       	mov	r0, r31
    1a94:	ff e1       	ldi	r31, 0x1F	; 31
    1a96:	ff 2e       	mov	r15, r31
    1a98:	f0 2d       	mov	r31, r0
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
            cfg3 = MCP_20MHz_40kBPS_CFG3;
    1a9a:	ce cf       	rjmp	.-100    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
            cfg2 = MCP_20MHz_40kBPS_CFG2;
    1a9c:	17 e8       	ldi	r17, 0x87	; 135
            cfg2 = MCP_20MHz_33k3BPS_CFG2;
            cfg3 = MCP_20MHz_33k3BPS_CFG3;
	    break;

            case (CAN_40KBPS):                                              //  40Kbps
            cfg1 = MCP_20MHz_40kBPS_CFG1;
    1a9e:	ee 24       	eor	r14, r14
    1aa0:	ea 94       	dec	r14
    1aa2:	0f 2e       	mov	r0, r31
    1aa4:	f9 e0       	ldi	r31, 0x09	; 9
        return ERROR_OK;
    }
    else {
        return ERROR_FAIL;
    }
}
    1aa6:	ff 2e       	mov	r15, r31
    1aa8:	f0 2d       	mov	r31, r0
    1aaa:	c6 cf       	rjmp	.-116    	; 0x1a38 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK+0x2d4>
    1aac:	df 91       	pop	r29
    1aae:	cf 91       	pop	r28
    1ab0:	1f 91       	pop	r17

}

MCP2515::ERROR MCP2515::setBitrate(const CAN_SPEED canSpeed)
{
    return setBitrate(canSpeed, MCP_16MHZ);
    1ab2:	0f 91       	pop	r16
    1ab4:	ff 90       	pop	r15
    1ab6:	ef 90       	pop	r14
}
    1ab8:	08 95       	ret

00001aba <_ZN7MCP251510setBitrateE9CAN_SPEED>:
        return ERROR_FAIL;
    }
}

MCP2515::ERROR MCP2515::setClkOut(const CAN_CLKOUT divisor)
{
    1aba:	41 e0       	ldi	r20, 0x01	; 1
    1abc:	53 ce       	rjmp	.-858    	; 0x1764 <_ZN7MCP251510setBitrateE9CAN_SPEED9CAN_CLOCK>
    1abe:	08 95       	ret

00001ac0 <_ZN7MCP25159setClkOutE10CAN_CLKOUT>:
    ERROR res;
    uint8_t cfg3;

    if (divisor == CLKOUT_DISABLE) {
    1ac0:	cf 93       	push	r28
    1ac2:	df 93       	push	r29
	/* Turn off CLKEN */
	modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, 0x00);
    1ac4:	ec 01       	movw	r28, r24
    1ac6:	6f 3f       	cpi	r22, 0xFF	; 255
    1ac8:	51 f4       	brne	.+20     	; 0x1ade <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x1e>
    1aca:	20 e0       	ldi	r18, 0x00	; 0
    1acc:	44 e0       	ldi	r20, 0x04	; 4

	/* Turn on CLKOUT for SOF */
	modifyRegister(MCP_CNF3, CNF3_SOF, CNF3_SOF);
    1ace:	6f e0       	ldi	r22, 0x0F	; 15
    1ad0:	7a dd       	rcall	.-1292   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1ad2:	20 e8       	ldi	r18, 0x80	; 128
    1ad4:	40 e8       	ldi	r20, 0x80	; 128
    1ad6:	68 e2       	ldi	r22, 0x28	; 40
    1ad8:	ce 01       	movw	r24, r28
        return ERROR_OK;
    1ada:	75 dd       	rcall	.-1302   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    }

    /* Set the prescaler (CLKPRE) */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKPRE, divisor);
    1adc:	0e c0       	rjmp	.+28     	; 0x1afa <_ZN7MCP25159setClkOutE10CAN_CLKOUT+0x3a>
    1ade:	26 2f       	mov	r18, r22
    1ae0:	43 e0       	ldi	r20, 0x03	; 3
    1ae2:	6f e0       	ldi	r22, 0x0F	; 15
    1ae4:	70 dd       	rcall	.-1312   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>

    /* Turn on CLKEN */
    modifyRegister(MCP_CANCTRL, CANCTRL_CLKEN, CANCTRL_CLKEN);
    1ae6:	24 e0       	ldi	r18, 0x04	; 4
    1ae8:	44 e0       	ldi	r20, 0x04	; 4
    1aea:	6f e0       	ldi	r22, 0x0F	; 15
    1aec:	ce 01       	movw	r24, r28
    1aee:	6b dd       	rcall	.-1322   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1af0:	20 e0       	ldi	r18, 0x00	; 0

    /* Turn off CLKOUT for SOF */
    modifyRegister(MCP_CNF3, CNF3_SOF, 0x00);
    1af2:	40 e8       	ldi	r20, 0x80	; 128
    1af4:	68 e2       	ldi	r22, 0x28	; 40
    1af6:	ce 01       	movw	r24, r28
    1af8:	66 dd       	rcall	.-1332   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1afa:	80 e0       	ldi	r24, 0x00	; 0
    1afc:	df 91       	pop	r29
    return ERROR_OK;
}
    1afe:	cf 91       	pop	r28
    1b00:	08 95       	ret

00001b02 <_ZN7MCP25159prepareIdEPhbm>:
    1b02:	0f 93       	push	r16
    1b04:	1f 93       	push	r17

void MCP2515::prepareId(uint8_t *buffer, const bool ext, const uint32_t id)
{
    1b06:	fb 01       	movw	r30, r22
    1b08:	44 23       	and	r20, r20
    1b0a:	c9 f0       	breq	.+50     	; 0x1b3e <_ZN7MCP25159prepareIdEPhbm+0x3c>
    uint16_t canid = (uint16_t)(id & 0x0FFFF);

    if (ext) {
    1b0c:	03 83       	std	Z+3, r16	; 0x03
    1b0e:	12 83       	std	Z+2, r17	; 0x02
        buffer[MCP_EID0] = (uint8_t) (canid & 0xFF);
    1b10:	89 01       	movw	r16, r18
        buffer[MCP_EID8] = (uint8_t) (canid >> 8);
    1b12:	22 27       	eor	r18, r18
        canid = (uint16_t)(id >> 16);
    1b14:	33 27       	eor	r19, r19
    1b16:	80 2f       	mov	r24, r16
    1b18:	8c 71       	andi	r24, 0x1C	; 28
        buffer[MCP_SIDL] = (uint8_t) (canid & 0x03);
        buffer[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
        buffer[MCP_SIDL] |= TXB_EXIDE_MASK;
    1b1a:	88 0f       	add	r24, r24
    1b1c:	88 0f       	add	r24, r24
    1b1e:	88 0f       	add	r24, r24
    1b20:	90 2f       	mov	r25, r16
    1b22:	93 70       	andi	r25, 0x03	; 3
    1b24:	89 0f       	add	r24, r25
    1b26:	88 60       	ori	r24, 0x08	; 8
    1b28:	81 83       	std	Z+1, r24	; 0x01
    1b2a:	16 95       	lsr	r17
    1b2c:	07 95       	ror	r16
        buffer[MCP_SIDH] = (uint8_t) (canid >> 5);
    1b2e:	12 95       	swap	r17
    1b30:	02 95       	swap	r16
    1b32:	0f 70       	andi	r16, 0x0F	; 15
    1b34:	01 27       	eor	r16, r17
    1b36:	1f 70       	andi	r17, 0x0F	; 15
    1b38:	01 27       	eor	r16, r17
    1b3a:	00 83       	st	Z, r16
    1b3c:	0e c0       	rjmp	.+28     	; 0x1b5a <_ZN7MCP25159prepareIdEPhbm+0x58>
    1b3e:	c8 01       	movw	r24, r16
    } else {
        buffer[MCP_SIDH] = (uint8_t) (canid >> 3);
    1b40:	96 95       	lsr	r25
    1b42:	87 95       	ror	r24
    1b44:	96 95       	lsr	r25
    1b46:	87 95       	ror	r24
    1b48:	96 95       	lsr	r25
    1b4a:	87 95       	ror	r24
    1b4c:	80 83       	st	Z, r24
    1b4e:	02 95       	swap	r16
        buffer[MCP_SIDL] = (uint8_t) ((canid & 0x07 ) << 5);
    1b50:	00 0f       	add	r16, r16
    1b52:	00 7e       	andi	r16, 0xE0	; 224
    1b54:	01 83       	std	Z+1, r16	; 0x01
        buffer[MCP_EID0] = 0;
    1b56:	13 82       	std	Z+3, r1	; 0x03
        buffer[MCP_EID8] = 0;
    1b58:	12 82       	std	Z+2, r1	; 0x02
    }
}
    1b5a:	1f 91       	pop	r17
    1b5c:	0f 91       	pop	r16
    1b5e:	08 95       	ret

00001b60 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>:

MCP2515::ERROR MCP2515::setFilterMask(const MASK mask, const bool ext, const uint32_t ulData)
{
    1b60:	8f 92       	push	r8
    1b62:	9f 92       	push	r9
    1b64:	af 92       	push	r10
    1b66:	bf 92       	push	r11
    1b68:	cf 92       	push	r12
    1b6a:	df 92       	push	r13
    1b6c:	ef 92       	push	r14
    1b6e:	ff 92       	push	r15
    1b70:	0f 93       	push	r16
    1b72:	1f 93       	push	r17
    1b74:	cf 93       	push	r28
    1b76:	df 93       	push	r29
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x1a>
    1b7a:	1f 92       	push	r1
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	7c 01       	movw	r14, r24
    1b82:	d6 2e       	mov	r13, r22
    1b84:	c4 2e       	mov	r12, r20
    1b86:	48 01       	movw	r8, r16
    ERROR res = setConfigMode();
    1b88:	59 01       	movw	r10, r18
    1b8a:	dd dd       	rcall	.-1094   	; 0x1746 <_ZN7MCP251513setConfigModeEv>
    if (res != ERROR_OK) {
    1b8c:	81 11       	cpse	r24, r1
    1b8e:	19 c0       	rjmp	.+50     	; 0x1bc2 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
        return res;
    }
    
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    1b90:	95 01       	movw	r18, r10
    1b92:	84 01       	movw	r16, r8
    1b94:	4c 2d       	mov	r20, r12
    1b96:	be 01       	movw	r22, r28
    1b98:	6f 5f       	subi	r22, 0xFF	; 255
    1b9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b9c:	c7 01       	movw	r24, r14
    1b9e:	b1 df       	rcall	.-158    	; 0x1b02 <_ZN7MCP25159prepareIdEPhbm>
    1ba0:	dd 20       	and	r13, r13

    REGISTER reg;
    switch (mask) {
    1ba2:	29 f0       	breq	.+10     	; 0x1bae <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x4e>
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	d8 12       	cpse	r13, r24
    1ba8:	0b c0       	rjmp	.+22     	; 0x1bc0 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x60>
    1baa:	64 e2       	ldi	r22, 0x24	; 36
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
    1bac:	01 c0       	rjmp	.+2      	; 0x1bb0 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x50>
    1bae:	60 e2       	ldi	r22, 0x20	; 32
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);

    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
    1bb0:	24 e0       	ldi	r18, 0x04	; 4
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    }

    setRegisters(reg, tbufdata, 4);
    1bb2:	ae 01       	movw	r20, r28
    1bb4:	4f 5f       	subi	r20, 0xFF	; 255
    1bb6:	5f 4f       	sbci	r21, 0xFF	; 255
    1bb8:	c7 01       	movw	r24, r14
    1bba:	d0 dc       	rcall	.-1632   	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    
    return ERROR_OK;
    1bbe:	01 c0       	rjmp	.+2      	; 0x1bc2 <_ZN7MCP251513setFilterMaskENS_4MASKEbm+0x62>
    1bc0:	81 e0       	ldi	r24, 0x01	; 1
    REGISTER reg;
    switch (mask) {
        case MASK0: reg = MCP_RXM0SIDH; break;
        case MASK1: reg = MCP_RXM1SIDH; break;
        default:
            return ERROR_FAIL;
    1bc2:	0f 90       	pop	r0
    }

    setRegisters(reg, tbufdata, 4);
    
    return ERROR_OK;
}
    1bc4:	0f 90       	pop	r0
    1bc6:	0f 90       	pop	r0
    1bc8:	0f 90       	pop	r0
    1bca:	df 91       	pop	r29
    1bcc:	cf 91       	pop	r28
    1bce:	1f 91       	pop	r17
    1bd0:	0f 91       	pop	r16
    1bd2:	ff 90       	pop	r15
    1bd4:	ef 90       	pop	r14
    1bd6:	df 90       	pop	r13
    1bd8:	cf 90       	pop	r12
    1bda:	bf 90       	pop	r11
    1bdc:	af 90       	pop	r10
    1bde:	9f 90       	pop	r9
    1be0:	8f 90       	pop	r8
    1be2:	08 95       	ret

00001be4 <_ZN7MCP25159setFilterENS_3RXFEbm>:
    1be4:	8f 92       	push	r8

MCP2515::ERROR MCP2515::setFilter(const RXF num, const bool ext, const uint32_t ulData)
{
    1be6:	9f 92       	push	r9
    1be8:	af 92       	push	r10
    1bea:	bf 92       	push	r11
    1bec:	cf 92       	push	r12
    1bee:	df 92       	push	r13
    1bf0:	ef 92       	push	r14
    1bf2:	ff 92       	push	r15
    1bf4:	0f 93       	push	r16
    1bf6:	1f 93       	push	r17
    1bf8:	cf 93       	push	r28
    1bfa:	df 93       	push	r29
    1bfc:	00 d0       	rcall	.+0      	; 0x1bfe <_ZN7MCP25159setFilterENS_3RXFEbm+0x1a>
    1bfe:	1f 92       	push	r1
    1c00:	cd b7       	in	r28, 0x3d	; 61
    1c02:	de b7       	in	r29, 0x3e	; 62
    1c04:	6c 01       	movw	r12, r24
    1c06:	f6 2e       	mov	r15, r22
    1c08:	e4 2e       	mov	r14, r20
    1c0a:	48 01       	movw	r8, r16
    1c0c:	59 01       	movw	r10, r18
    1c0e:	9b dd       	rcall	.-1226   	; 0x1746 <_ZN7MCP251513setConfigModeEv>
    ERROR res = setConfigMode();
    1c10:	81 11       	cpse	r24, r1
    1c12:	3d c0       	rjmp	.+122    	; 0x1c8e <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>
    if (res != ERROR_OK) {
    1c14:	82 e0       	ldi	r24, 0x02	; 2
    1c16:	f8 16       	cp	r15, r24
        return res;
    }

    REGISTER reg;

    switch (num) {
    1c18:	a9 f0       	breq	.+42     	; 0x1c44 <_ZN7MCP25159setFilterENS_3RXFEbm+0x60>
    1c1a:	8f 15       	cp	r24, r15
    1c1c:	30 f0       	brcs	.+12     	; 0x1c2a <_ZN7MCP25159setFilterENS_3RXFEbm+0x46>
    1c1e:	ff 20       	and	r15, r15
    1c20:	19 f1       	breq	.+70     	; 0x1c68 <_ZN7MCP25159setFilterENS_3RXFEbm+0x84>
    1c22:	81 e0       	ldi	r24, 0x01	; 1
    1c24:	f8 16       	cp	r15, r24
    1c26:	51 f0       	breq	.+20     	; 0x1c3c <_ZN7MCP25159setFilterENS_3RXFEbm+0x58>
    1c28:	31 c0       	rjmp	.+98     	; 0x1c8c <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
    1c2a:	84 e0       	ldi	r24, 0x04	; 4
    1c2c:	f8 16       	cp	r15, r24
    1c2e:	91 f0       	breq	.+36     	; 0x1c54 <_ZN7MCP25159setFilterENS_3RXFEbm+0x70>
    1c30:	f8 16       	cp	r15, r24
    1c32:	60 f0       	brcs	.+24     	; 0x1c4c <_ZN7MCP25159setFilterENS_3RXFEbm+0x68>
    1c34:	85 e0       	ldi	r24, 0x05	; 5
    1c36:	f8 16       	cp	r15, r24
    1c38:	91 f0       	breq	.+36     	; 0x1c5e <_ZN7MCP25159setFilterENS_3RXFEbm+0x7a>
    1c3a:	28 c0       	rjmp	.+80     	; 0x1c8c <_ZN7MCP25159setFilterENS_3RXFEbm+0xa8>
        case RXF0: reg = MCP_RXF0SIDH; break;
        case RXF1: reg = MCP_RXF1SIDH; break;
    1c3c:	68 94       	set
    1c3e:	ff 24       	eor	r15, r15
    1c40:	f2 f8       	bld	r15, 2
    1c42:	13 c0       	rjmp	.+38     	; 0x1c6a <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF2: reg = MCP_RXF2SIDH; break;
    1c44:	68 94       	set
    1c46:	ff 24       	eor	r15, r15
    1c48:	f3 f8       	bld	r15, 3
    1c4a:	0f c0       	rjmp	.+30     	; 0x1c6a <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF3: reg = MCP_RXF3SIDH; break;
    1c4c:	68 94       	set
    1c4e:	ff 24       	eor	r15, r15
    1c50:	f4 f8       	bld	r15, 4
    1c52:	0b c0       	rjmp	.+22     	; 0x1c6a <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF4: reg = MCP_RXF4SIDH; break;
    1c54:	0f 2e       	mov	r0, r31
    1c56:	f4 e1       	ldi	r31, 0x14	; 20
    1c58:	ff 2e       	mov	r15, r31
    1c5a:	f0 2d       	mov	r31, r0
    1c5c:	06 c0       	rjmp	.+12     	; 0x1c6a <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
        case RXF5: reg = MCP_RXF5SIDH; break;
    1c5e:	0f 2e       	mov	r0, r31
    1c60:	f8 e1       	ldi	r31, 0x18	; 24
    1c62:	ff 2e       	mov	r15, r31
    1c64:	f0 2d       	mov	r31, r0
    1c66:	01 c0       	rjmp	.+2      	; 0x1c6a <_ZN7MCP25159setFilterENS_3RXFEbm+0x86>
    }

    REGISTER reg;

    switch (num) {
        case RXF0: reg = MCP_RXF0SIDH; break;
    1c68:	f1 2c       	mov	r15, r1
        default:
            return ERROR_FAIL;
    }

    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    1c6a:	95 01       	movw	r18, r10
    1c6c:	84 01       	movw	r16, r8
    1c6e:	4e 2d       	mov	r20, r14
    1c70:	be 01       	movw	r22, r28
    1c72:	6f 5f       	subi	r22, 0xFF	; 255
    1c74:	7f 4f       	sbci	r23, 0xFF	; 255
    1c76:	c6 01       	movw	r24, r12
    1c78:	44 df       	rcall	.-376    	; 0x1b02 <_ZN7MCP25159prepareIdEPhbm>
    1c7a:	24 e0       	ldi	r18, 0x04	; 4
    setRegisters(reg, tbufdata, 4);
    1c7c:	ae 01       	movw	r20, r28
    1c7e:	4f 5f       	subi	r20, 0xFF	; 255
    1c80:	5f 4f       	sbci	r21, 0xFF	; 255
    1c82:	6f 2d       	mov	r22, r15
    1c84:	c6 01       	movw	r24, r12
    1c86:	6a dc       	rcall	.-1836   	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1c88:	80 e0       	ldi	r24, 0x00	; 0
    1c8a:	01 c0       	rjmp	.+2      	; 0x1c8e <_ZN7MCP25159setFilterENS_3RXFEbm+0xaa>

    return ERROR_OK;
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	0f 90       	pop	r0
        case RXF2: reg = MCP_RXF2SIDH; break;
        case RXF3: reg = MCP_RXF3SIDH; break;
        case RXF4: reg = MCP_RXF4SIDH; break;
        case RXF5: reg = MCP_RXF5SIDH; break;
        default:
            return ERROR_FAIL;
    1c90:	0f 90       	pop	r0
    uint8_t tbufdata[4];
    prepareId(tbufdata, ext, ulData);
    setRegisters(reg, tbufdata, 4);

    return ERROR_OK;
}
    1c92:	0f 90       	pop	r0
    1c94:	0f 90       	pop	r0
    1c96:	df 91       	pop	r29
    1c98:	cf 91       	pop	r28
    1c9a:	1f 91       	pop	r17
    1c9c:	0f 91       	pop	r16
    1c9e:	ff 90       	pop	r15
    1ca0:	ef 90       	pop	r14
    1ca2:	df 90       	pop	r13
    1ca4:	cf 90       	pop	r12
    1ca6:	bf 90       	pop	r11
    1ca8:	af 90       	pop	r10
    1caa:	9f 90       	pop	r9
    1cac:	8f 90       	pop	r8
    1cae:	08 95       	ret

00001cb0 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>:
    1cb0:	4f 92       	push	r4
    1cb2:	5f 92       	push	r5

MCP2515::ERROR MCP2515::sendMessage(const TXBn txbn, const struct can_frame *frame)
{
    1cb4:	6f 92       	push	r6
    1cb6:	7f 92       	push	r7
    1cb8:	af 92       	push	r10
    1cba:	bf 92       	push	r11
    1cbc:	cf 92       	push	r12
    1cbe:	df 92       	push	r13
    1cc0:	ef 92       	push	r14
    1cc2:	ff 92       	push	r15
    1cc4:	0f 93       	push	r16
    1cc6:	1f 93       	push	r17
    1cc8:	cf 93       	push	r28
    1cca:	df 93       	push	r29
    1ccc:	cd b7       	in	r28, 0x3d	; 61
    1cce:	de b7       	in	r29, 0x3e	; 62
    1cd0:	2d 97       	sbiw	r28, 0x0d	; 13
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	de bf       	out	0x3e, r29	; 62
    1cd8:	0f be       	out	0x3f, r0	; 63
    1cda:	cd bf       	out	0x3d, r28	; 61
    1cdc:	5c 01       	movw	r10, r24
    1cde:	6a 01       	movw	r12, r20
    1ce0:	e6 2e       	mov	r14, r22
    const struct TXBn_REGS *txbuf = &TXB[txbn];
    1ce2:	f1 2c       	mov	r15, r1
    1ce4:	fa 01       	movw	r30, r20

    uint8_t data[13];

    bool ext = (frame->can_id & CAN_EFF_FLAG);
    1ce6:	00 81       	ld	r16, Z
    1ce8:	11 81       	ldd	r17, Z+1	; 0x01
    1cea:	22 81       	ldd	r18, Z+2	; 0x02
    1cec:	33 81       	ldd	r19, Z+3	; 0x03
    1cee:	b9 01       	movw	r22, r18
    1cf0:	a8 01       	movw	r20, r16
    1cf2:	44 27       	eor	r20, r20
    1cf4:	77 fd       	sbrc	r23, 7
    1cf6:	43 95       	inc	r20
    1cf8:	55 27       	eor	r21, r21
    1cfa:	66 27       	eor	r22, r22
    1cfc:	77 27       	eor	r23, r23
    1cfe:	28 01       	movw	r4, r16
    bool rtr = (frame->can_id & CAN_RTR_FLAG);
    1d00:	39 01       	movw	r6, r18
    1d02:	44 24       	eor	r4, r4
    1d04:	55 24       	eor	r5, r5
    1d06:	66 24       	eor	r6, r6
    1d08:	f0 e4       	ldi	r31, 0x40	; 64
    1d0a:	7f 22       	and	r7, r31
    1d0c:	33 23       	and	r19, r19
    uint32_t id = (frame->can_id & (ext ? CAN_EFF_MASK : CAN_SFF_MASK));
    1d0e:	2c f0       	brlt	.+10     	; 0x1d1a <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x6a>
    1d10:	8f ef       	ldi	r24, 0xFF	; 255
    1d12:	97 e0       	ldi	r25, 0x07	; 7
    1d14:	a0 e0       	ldi	r26, 0x00	; 0
    1d16:	b0 e0       	ldi	r27, 0x00	; 0
    1d18:	04 c0       	rjmp	.+8      	; 0x1d22 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x72>
    1d1a:	8f ef       	ldi	r24, 0xFF	; 255
    1d1c:	9f ef       	ldi	r25, 0xFF	; 255
    1d1e:	af ef       	ldi	r26, 0xFF	; 255
    1d20:	bf e1       	ldi	r27, 0x1F	; 31
    1d22:	08 23       	and	r16, r24

    prepareId(data, ext, id);
    1d24:	19 23       	and	r17, r25
    1d26:	2a 23       	and	r18, r26
    1d28:	3b 23       	and	r19, r27
    1d2a:	be 01       	movw	r22, r28
    1d2c:	6f 5f       	subi	r22, 0xFF	; 255
    1d2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d30:	c5 01       	movw	r24, r10
    1d32:	e7 de       	rcall	.-562    	; 0x1b02 <_ZN7MCP25159prepareIdEPhbm>

    data[MCP_DLC] = rtr ? (frame->can_dlc | RTR_MASK) : frame->can_dlc;
    1d34:	45 28       	or	r4, r5
    1d36:	46 28       	or	r4, r6
    1d38:	47 28       	or	r4, r7
    1d3a:	21 f0       	breq	.+8      	; 0x1d44 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x94>
    1d3c:	f6 01       	movw	r30, r12
    1d3e:	84 81       	ldd	r24, Z+4	; 0x04
    1d40:	80 64       	ori	r24, 0x40	; 64
    1d42:	02 c0       	rjmp	.+4      	; 0x1d48 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame+0x98>
    1d44:	f6 01       	movw	r30, r12
    1d46:	84 81       	ldd	r24, Z+4	; 0x04
    1d48:	8d 83       	std	Y+5, r24	; 0x05

    memcpy(&data[MCP_DATA], frame->data, frame->can_dlc);
    1d4a:	f6 01       	movw	r30, r12
    1d4c:	14 81       	ldd	r17, Z+4	; 0x04
    1d4e:	41 2f       	mov	r20, r17
    1d50:	50 e0       	ldi	r21, 0x00	; 0
    1d52:	b6 01       	movw	r22, r12
    1d54:	68 5f       	subi	r22, 0xF8	; 248
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	ce 01       	movw	r24, r28
    1d5a:	06 96       	adiw	r24, 0x06	; 6
    1d5c:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>

    setRegisters(txbuf->SIDH, data, 5 + frame->can_dlc);
    1d60:	25 e0       	ldi	r18, 0x05	; 5
    1d62:	21 0f       	add	r18, r17
    1d64:	87 01       	movw	r16, r14
    1d66:	00 0f       	add	r16, r16
    1d68:	11 1f       	adc	r17, r17
    1d6a:	0e 0d       	add	r16, r14
    1d6c:	1f 1d       	adc	r17, r15
    1d6e:	02 57       	subi	r16, 0x72	; 114
    1d70:	1d 4f       	sbci	r17, 0xFD	; 253
    1d72:	ae 01       	movw	r20, r28
    1d74:	4f 5f       	subi	r20, 0xFF	; 255
    1d76:	5f 4f       	sbci	r21, 0xFF	; 255
    1d78:	f8 01       	movw	r30, r16
    1d7a:	61 81       	ldd	r22, Z+1	; 0x01
    1d7c:	c5 01       	movw	r24, r10
    1d7e:	ee db       	rcall	.-2084   	; 0x155c <_ZN7MCP251512setRegistersENS_8REGISTEREPKhh>
    1d80:	28 e0       	ldi	r18, 0x08	; 8

    modifyRegister(txbuf->CTRL, TXB_TXREQ, TXB_TXREQ);
    1d82:	48 e0       	ldi	r20, 0x08	; 8
    1d84:	f8 01       	movw	r30, r16
    1d86:	60 81       	ld	r22, Z
    1d88:	c5 01       	movw	r24, r10
    1d8a:	1d dc       	rcall	.-1990   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1d8c:	80 e0       	ldi	r24, 0x00	; 0
    1d8e:	2d 96       	adiw	r28, 0x0d	; 13

    return ERROR_OK;
}
    1d90:	0f b6       	in	r0, 0x3f	; 63
    1d92:	f8 94       	cli
    1d94:	de bf       	out	0x3e, r29	; 62
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	cd bf       	out	0x3d, r28	; 61
    1d9a:	df 91       	pop	r29
    1d9c:	cf 91       	pop	r28
    1d9e:	1f 91       	pop	r17
    1da0:	0f 91       	pop	r16
    1da2:	ff 90       	pop	r15
    1da4:	ef 90       	pop	r14
    1da6:	df 90       	pop	r13
    1da8:	cf 90       	pop	r12
    1daa:	bf 90       	pop	r11
    1dac:	af 90       	pop	r10
    1dae:	7f 90       	pop	r7
    1db0:	6f 90       	pop	r6
    1db2:	5f 90       	pop	r5
    1db4:	4f 90       	pop	r4
    1db6:	08 95       	ret

00001db8 <_ZN7MCP251511sendMessageEPK9can_frame>:
    1db8:	9f 92       	push	r9

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    1dba:	af 92       	push	r10
    1dbc:	bf 92       	push	r11
    1dbe:	cf 92       	push	r12
    1dc0:	df 92       	push	r13
    1dc2:	ef 92       	push	r14
    1dc4:	ff 92       	push	r15
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	00 d0       	rcall	.+0      	; 0x1dd0 <_ZN7MCP251511sendMessageEPK9can_frame+0x18>
    1dd0:	cd b7       	in	r28, 0x3d	; 61
    1dd2:	de b7       	in	r29, 0x3e	; 62
    1dd4:	6c 01       	movw	r12, r24
    if (frame->can_dlc > CAN_MAX_DLEN) {
    1dd6:	fb 01       	movw	r30, r22
    1dd8:	94 81       	ldd	r25, Z+4	; 0x04
    1dda:	99 30       	cpi	r25, 0x09	; 9
    1ddc:	48 f5       	brcc	.+82     	; 0x1e30 <_ZN7MCP251511sendMessageEPK9can_frame+0x78>
    1dde:	7b 01       	movw	r14, r22
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};
    1de0:	19 82       	std	Y+1, r1	; 0x01
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	8a 83       	std	Y+2, r24	; 0x02
    1de6:	82 e0       	ldi	r24, 0x02	; 2
    1de8:	8b 83       	std	Y+3, r24	; 0x03
    1dea:	8e 01       	movw	r16, r28
    1dec:	0f 5f       	subi	r16, 0xFF	; 255
    1dee:	1f 4f       	sbci	r17, 0xFF	; 255
    1df0:	5e 01       	movw	r10, r28
    1df2:	f4 e0       	ldi	r31, 0x04	; 4
    1df4:	af 0e       	add	r10, r31
    1df6:	b1 1c       	adc	r11, r1

    for (int i=0; i<N_TXBUFFERS; i++) {
        const struct TXBn_REGS *txbuf = &TXB[txBuffers[i]];
    1df8:	f8 01       	movw	r30, r16
    1dfa:	91 90       	ld	r9, Z+
    1dfc:	8f 01       	movw	r16, r30
        uint8_t ctrlval = readRegister(txbuf->CTRL);
    1dfe:	29 2d       	mov	r18, r9
    1e00:	30 e0       	ldi	r19, 0x00	; 0
    1e02:	f9 01       	movw	r30, r18
    1e04:	ee 0f       	add	r30, r30
    1e06:	ff 1f       	adc	r31, r31
    1e08:	2e 0f       	add	r18, r30
    1e0a:	3f 1f       	adc	r19, r31
    1e0c:	f9 01       	movw	r30, r18
    1e0e:	e2 57       	subi	r30, 0x72	; 114
    1e10:	fd 4f       	sbci	r31, 0xFD	; 253
    1e12:	60 81       	ld	r22, Z
    1e14:	c6 01       	movw	r24, r12
    1e16:	2b db       	rcall	.-2474   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
    1e18:	83 fd       	sbrc	r24, 3
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
    1e1a:	05 c0       	rjmp	.+10     	; 0x1e26 <_ZN7MCP251511sendMessageEPK9can_frame+0x6e>
    1e1c:	a7 01       	movw	r20, r14
            return sendMessage(txBuffers[i], frame);
    1e1e:	69 2d       	mov	r22, r9
    1e20:	c6 01       	movw	r24, r12
    1e22:	46 df       	rcall	.-372    	; 0x1cb0 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    1e24:	06 c0       	rjmp	.+12     	; 0x1e32 <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
    1e26:	0a 15       	cp	r16, r10
    1e28:	1b 05       	cpc	r17, r11
        return ERROR_FAILTX;
    }

    TXBn txBuffers[N_TXBUFFERS] = {TXB0, TXB1, TXB2};

    for (int i=0; i<N_TXBUFFERS; i++) {
    1e2a:	31 f7       	brne	.-52     	; 0x1df8 <_ZN7MCP251511sendMessageEPK9can_frame+0x40>
    1e2c:	84 e0       	ldi	r24, 0x04	; 4
    1e2e:	01 c0       	rjmp	.+2      	; 0x1e32 <_ZN7MCP251511sendMessageEPK9can_frame+0x7a>
        if ( (ctrlval & TXB_TXREQ) == 0 ) {
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
    1e30:	84 e0       	ldi	r24, 0x04	; 4
}

MCP2515::ERROR MCP2515::sendMessage(const struct can_frame *frame)
{
    if (frame->can_dlc > CAN_MAX_DLEN) {
        return ERROR_FAILTX;
    1e32:	0f 90       	pop	r0
            return sendMessage(txBuffers[i], frame);
        }
    }

    return ERROR_FAILTX;
}
    1e34:	0f 90       	pop	r0
    1e36:	0f 90       	pop	r0
    1e38:	df 91       	pop	r29
    1e3a:	cf 91       	pop	r28
    1e3c:	1f 91       	pop	r17
    1e3e:	0f 91       	pop	r16
    1e40:	ff 90       	pop	r15
    1e42:	ef 90       	pop	r14
    1e44:	df 90       	pop	r13
    1e46:	cf 90       	pop	r12
    1e48:	bf 90       	pop	r11
    1e4a:	af 90       	pop	r10
    1e4c:	9f 90       	pop	r9
    1e4e:	08 95       	ret

00001e50 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>:
    1e50:	7f 92       	push	r7

MCP2515::ERROR MCP2515::readMessage(const RXBn rxbn, struct can_frame *frame)
{
    1e52:	8f 92       	push	r8
    1e54:	9f 92       	push	r9
    1e56:	af 92       	push	r10
    1e58:	bf 92       	push	r11
    1e5a:	cf 92       	push	r12
    1e5c:	df 92       	push	r13
    1e5e:	ef 92       	push	r14
    1e60:	ff 92       	push	r15
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	00 d0       	rcall	.+0      	; 0x1e6c <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x1c>
    1e6c:	1f 92       	push	r1
    1e6e:	1f 92       	push	r1
    1e70:	cd b7       	in	r28, 0x3d	; 61
    1e72:	de b7       	in	r29, 0x3e	; 62
    1e74:	5c 01       	movw	r10, r24
    1e76:	4a 01       	movw	r8, r20
    1e78:	06 2f       	mov	r16, r22
    const struct RXBn_REGS *rxb = &RXB[rxbn];
    1e7a:	10 e0       	ldi	r17, 0x00	; 0
    1e7c:	f8 01       	movw	r30, r16

    uint8_t tbufdata[5];

    readRegisters(rxb->SIDH, tbufdata, 5);
    1e7e:	ee 0f       	add	r30, r30
    1e80:	ff 1f       	adc	r31, r31
    1e82:	ee 0f       	add	r30, r30
    1e84:	ff 1f       	adc	r31, r31
    1e86:	ea 57       	subi	r30, 0x7A	; 122
    1e88:	fd 4f       	sbci	r31, 0xFD	; 253
    1e8a:	25 e0       	ldi	r18, 0x05	; 5
    1e8c:	ae 01       	movw	r20, r28
    1e8e:	4f 5f       	subi	r20, 0xFF	; 255
    1e90:	5f 4f       	sbci	r21, 0xFF	; 255
    1e92:	61 81       	ldd	r22, Z+1	; 0x01
    1e94:	0c db       	rcall	.-2536   	; 0x14ae <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    1e96:	8a 81       	ldd	r24, Y+2	; 0x02
    1e98:	99 81       	ldd	r25, Y+1	; 0x01

    uint32_t id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    1e9a:	c8 2e       	mov	r12, r24
    1e9c:	d1 2c       	mov	r13, r1
    1e9e:	d5 94       	asr	r13
    1ea0:	c7 94       	ror	r12
    1ea2:	d5 94       	asr	r13
    1ea4:	c7 94       	ror	r12
    1ea6:	d5 94       	asr	r13
    1ea8:	c7 94       	ror	r12
    1eaa:	d5 94       	asr	r13
    1eac:	c7 94       	ror	r12
    1eae:	d5 94       	asr	r13
    1eb0:	c7 94       	ror	r12
    1eb2:	28 e0       	ldi	r18, 0x08	; 8
    1eb4:	92 9f       	mul	r25, r18
    1eb6:	c0 0c       	add	r12, r0
    1eb8:	d1 1c       	adc	r13, r1
    1eba:	11 24       	eor	r1, r1
    1ebc:	0d 2c       	mov	r0, r13
    1ebe:	00 0c       	add	r0, r0
    1ec0:	ee 08       	sbc	r14, r14
    1ec2:	ff 08       	sbc	r15, r15
    1ec4:	83 ff       	sbrs	r24, 3
	//printf("%lx	",id);
    if ( (tbufdata[MCP_SIDL] & TXB_EXIDE_MASK) ==  TXB_EXIDE_MASK ) {
    1ec6:	21 c0       	rjmp	.+66     	; 0x1f0a <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xba>
    1ec8:	cc 0c       	add	r12, r12
        id = (id<<2) + (tbufdata[MCP_SIDL] & 0x03);
    1eca:	dd 1c       	adc	r13, r13
    1ecc:	ee 1c       	adc	r14, r14
    1ece:	ff 1c       	adc	r15, r15
    1ed0:	cc 0c       	add	r12, r12
    1ed2:	dd 1c       	adc	r13, r13
    1ed4:	ee 1c       	adc	r14, r14
    1ed6:	ff 1c       	adc	r15, r15
    1ed8:	83 70       	andi	r24, 0x03	; 3
        id = (id<<8) + tbufdata[MCP_EID8];
    1eda:	c8 0e       	add	r12, r24
    1edc:	d1 1c       	adc	r13, r1
    1ede:	e1 1c       	adc	r14, r1
    1ee0:	f1 1c       	adc	r15, r1
    1ee2:	fe 2c       	mov	r15, r14
    1ee4:	ed 2c       	mov	r14, r13
    1ee6:	dc 2c       	mov	r13, r12
    1ee8:	cc 24       	eor	r12, r12
    1eea:	8b 81       	ldd	r24, Y+3	; 0x03
        id = (id<<8) + tbufdata[MCP_EID0];
    1eec:	c8 0e       	add	r12, r24
    1eee:	d1 1c       	adc	r13, r1
    1ef0:	e1 1c       	adc	r14, r1
    1ef2:	f1 1c       	adc	r15, r1
    1ef4:	fe 2c       	mov	r15, r14
    1ef6:	ed 2c       	mov	r14, r13
    1ef8:	dc 2c       	mov	r13, r12
    1efa:	cc 24       	eor	r12, r12
    1efc:	8c 81       	ldd	r24, Y+4	; 0x04
    1efe:	c8 0e       	add	r12, r24
    1f00:	d1 1c       	adc	r13, r1
    1f02:	e1 1c       	adc	r14, r1
        id |= CAN_EFF_FLAG;
    1f04:	f1 1c       	adc	r15, r1
    1f06:	68 94       	set
    }

    uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
    1f08:	f7 f8       	bld	r15, 7
    1f0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f0c:	8f 70       	andi	r24, 0x0F	; 15
    if (dlc > CAN_MAX_DLEN) {
    1f0e:	78 2e       	mov	r7, r24
    1f10:	88 e0       	ldi	r24, 0x08	; 8
    1f12:	87 15       	cp	r24, r7
        return ERROR_FAIL;
    }

    uint8_t ctrl = readRegister(rxb->CTRL);
    1f14:	50 f1       	brcs	.+84     	; 0x1f6a <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11a>
    1f16:	f8 01       	movw	r30, r16
    1f18:	ee 0f       	add	r30, r30
    1f1a:	ff 1f       	adc	r31, r31
    1f1c:	ee 0f       	add	r30, r30
    1f1e:	ff 1f       	adc	r31, r31
    1f20:	ea 57       	subi	r30, 0x7A	; 122
    1f22:	fd 4f       	sbci	r31, 0xFD	; 253
    1f24:	60 81       	ld	r22, Z
    1f26:	c5 01       	movw	r24, r10
    1f28:	a2 da       	rcall	.-2748   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
    if (ctrl & RXBnCTRL_RTR) {
    1f2a:	83 ff       	sbrs	r24, 3
    1f2c:	02 c0       	rjmp	.+4      	; 0x1f32 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0xe2>
        id |= CAN_RTR_FLAG;
    1f2e:	68 94       	set
    1f30:	f6 f8       	bld	r15, 6
    }

    frame->can_id = id;
    1f32:	f4 01       	movw	r30, r8
    1f34:	c0 82       	st	Z, r12
    1f36:	d1 82       	std	Z+1, r13	; 0x01
    1f38:	e2 82       	std	Z+2, r14	; 0x02
    frame->can_dlc = dlc;
    1f3a:	f3 82       	std	Z+3, r15	; 0x03


    readRegisters(rxb->DATA, frame->data, dlc);
    1f3c:	74 82       	std	Z+4, r7	; 0x04
    1f3e:	a4 01       	movw	r20, r8
    1f40:	48 5f       	subi	r20, 0xF8	; 248
    1f42:	5f 4f       	sbci	r21, 0xFF	; 255
    1f44:	00 0f       	add	r16, r16
    1f46:	11 1f       	adc	r17, r17
    1f48:	00 0f       	add	r16, r16
    1f4a:	11 1f       	adc	r17, r17
    1f4c:	0a 57       	subi	r16, 0x7A	; 122
    1f4e:	1d 4f       	sbci	r17, 0xFD	; 253
    1f50:	27 2d       	mov	r18, r7
    1f52:	f8 01       	movw	r30, r16
    1f54:	62 81       	ldd	r22, Z+2	; 0x02

    modifyRegister(MCP_CANINTF, rxb->CANINTF_RXnIF, 0);
    1f56:	c5 01       	movw	r24, r10
    1f58:	aa da       	rcall	.-2732   	; 0x14ae <_ZN7MCP251513readRegistersENS_8REGISTEREPhh>
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	43 81       	ldd	r20, Z+3	; 0x03
    1f60:	6c e2       	ldi	r22, 0x2C	; 44

    return ERROR_OK;
    1f62:	c5 01       	movw	r24, r10
    1f64:	30 db       	rcall	.-2464   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
}
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	01 c0       	rjmp	.+2      	; 0x1f6c <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame+0x11c>
    1f6a:	81 e0       	ldi	r24, 0x01	; 1
    1f6c:	0f 90       	pop	r0
    1f6e:	0f 90       	pop	r0
    1f70:	0f 90       	pop	r0
    1f72:	0f 90       	pop	r0
    1f74:	0f 90       	pop	r0
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	1f 91       	pop	r17
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	df 90       	pop	r13
    1f84:	cf 90       	pop	r12

MCP2515::ERROR MCP2515::readMessage(struct can_frame *frame)
{
    1f86:	bf 90       	pop	r11
    1f88:	af 90       	pop	r10
    1f8a:	9f 90       	pop	r9
    1f8c:	8f 90       	pop	r8
    1f8e:	7f 90       	pop	r7
    ERROR rc;
    uint8_t stat = getStatus();
    1f90:	08 95       	ret

00001f92 <_ZN7MCP251511readMessageEP9can_frame>:

    if ( stat & STAT_RX0IF ) {
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
        rc = readMessage(RXB0, frame);
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	ec 01       	movw	r28, r24
    1f9c:	8b 01       	movw	r16, r22
    1f9e:	97 db       	rcall	.-2258   	; 0x16ce <_ZN7MCP25159getStatusEv>
    } else if ( stat & STAT_RX1IF ) {
    1fa0:	80 ff       	sbrs	r24, 0
        rc = readMessage(RXB1, frame);
    1fa2:	05 c0       	rjmp	.+10     	; 0x1fae <_ZN7MCP251511readMessageEP9can_frame+0x1c>
    1fa4:	a8 01       	movw	r20, r16
    1fa6:	60 e0       	ldi	r22, 0x00	; 0
    1fa8:	ce 01       	movw	r24, r28
    1faa:	52 df       	rcall	.-348    	; 0x1e50 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    } else {
        rc = ERROR_NOMSG;
    1fac:	08 c0       	rjmp	.+16     	; 0x1fbe <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    }

    return rc;
}
    1fae:	81 ff       	sbrs	r24, 1
    1fb0:	05 c0       	rjmp	.+10     	; 0x1fbc <_ZN7MCP251511readMessageEP9can_frame+0x2a>
    1fb2:	a8 01       	movw	r20, r16
    1fb4:	61 e0       	ldi	r22, 0x01	; 1

bool MCP2515::checkReceive(void)
{
    uint8_t res = getStatus();
    1fb6:	ce 01       	movw	r24, r28
    1fb8:	4b df       	rcall	.-362    	; 0x1e50 <_ZN7MCP251511readMessageENS_4RXBnEP9can_frame>
    1fba:	01 c0       	rjmp	.+2      	; 0x1fbe <_ZN7MCP251511readMessageEP9can_frame+0x2c>
    1fbc:	85 e0       	ldi	r24, 0x05	; 5
    1fbe:	df 91       	pop	r29
    if ( res & STAT_RXIF_MASK ) {
        return true;
    } else {
        return false;
    }
}
    1fc0:	cf 91       	pop	r28
    }
}

uint8_t MCP2515::getErrorFlags(void)
{
    return readRegister(MCP_EFLG);
    1fc2:	1f 91       	pop	r17
    1fc4:	0f 91       	pop	r16
    1fc6:	08 95       	ret

00001fc8 <_ZN7MCP251512checkReceiveEv>:
}
    1fc8:	82 db       	rcall	.-2300   	; 0x16ce <_ZN7MCP25159getStatusEv>
    }
}

bool MCP2515::checkError(void)
{
    uint8_t eflg = getErrorFlags();
    1fca:	98 2f       	mov	r25, r24
    1fcc:	93 70       	andi	r25, 0x03	; 3
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	09 f4       	brne	.+2      	; 0x1fd4 <_ZN7MCP251512checkReceiveEv+0xc>
    1fd2:	80 e0       	ldi	r24, 0x00	; 0
    1fd4:	08 95       	ret

00001fd6 <_ZN7MCP251513getErrorFlagsEv>:
    1fd6:	6d e2       	ldi	r22, 0x2D	; 45
    if ( eflg & EFLG_ERRORMASK ) {
        return true;
    } else {
        return false;
    }
}
    1fd8:	4a ca       	rjmp	.-2924   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
    return readRegister(MCP_EFLG);
}

void MCP2515::clearRXnOVRFlags(void)
{
	modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    1fda:	08 95       	ret

00001fdc <_ZN7MCP251510checkErrorEv>:
    1fdc:	fc df       	rcall	.-8      	; 0x1fd6 <_ZN7MCP251513getErrorFlagsEv>
    1fde:	98 2f       	mov	r25, r24
    1fe0:	98 7f       	andi	r25, 0xF8	; 248
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	09 f4       	brne	.+2      	; 0x1fe8 <_ZN7MCP251510checkErrorEv+0xc>
}

uint8_t MCP2515::getInterrupts(void)
{
    return readRegister(MCP_CANINTF);
    1fe6:	80 e0       	ldi	r24, 0x00	; 0
    1fe8:	08 95       	ret

00001fea <_ZN7MCP251516clearRXnOVRFlagsEv>:
    1fea:	20 e0       	ldi	r18, 0x00	; 0
}
    1fec:	40 ec       	ldi	r20, 0xC0	; 192

void MCP2515::clearInterrupts(void)
{
    setRegister(MCP_CANINTF, 0);
    1fee:	6d e2       	ldi	r22, 0x2D	; 45
    1ff0:	ea ca       	rjmp	.-2604   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    1ff2:	08 95       	ret

00001ff4 <_ZN7MCP251513getInterruptsEv>:
    1ff4:	6c e2       	ldi	r22, 0x2C	; 44
    1ff6:	3b ca       	rjmp	.-2954   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
}

uint8_t MCP2515::getInterruptMask(void)
{
    return readRegister(MCP_CANINTE);
    1ff8:	08 95       	ret

00001ffa <_ZN7MCP251515clearInterruptsEv>:
    1ffa:	40 e0       	ldi	r20, 0x00	; 0
    1ffc:	6c e2       	ldi	r22, 0x2C	; 44
}
    1ffe:	8c ca       	rjmp	.-2792   	; 0x1518 <_ZN7MCP251511setRegisterENS_8REGISTEREh>

void MCP2515::clearTXInterrupts(void)
{
    modifyRegister(MCP_CANINTF, (CANINTF_TX0IF | CANINTF_TX1IF | CANINTF_TX2IF), 0);
    2000:	08 95       	ret

00002002 <_ZN7MCP251516getInterruptMaskEv>:
    2002:	6b e2       	ldi	r22, 0x2B	; 43
    2004:	34 ca       	rjmp	.-2968   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
    2006:	08 95       	ret

00002008 <_ZN7MCP251517clearTXInterruptsEv>:
    2008:	20 e0       	ldi	r18, 0x00	; 0
    200a:	4c e1       	ldi	r20, 0x1C	; 28
}

void MCP2515::clearRXnOVR(void)
{
    200c:	6c e2       	ldi	r22, 0x2C	; 44
    200e:	db ca       	rjmp	.-2634   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2010:	08 95       	ret

00002012 <_ZN7MCP251511clearRXnOVREv>:
	uint8_t eflg = getErrorFlags();
    2012:	cf 93       	push	r28
    2014:	df 93       	push	r29
	if (eflg != 0) {
    2016:	ec 01       	movw	r28, r24
    2018:	de df       	rcall	.-68     	; 0x1fd6 <_ZN7MCP251513getErrorFlagsEv>
		clearRXnOVRFlags();
    201a:	88 23       	and	r24, r24
    201c:	21 f0       	breq	.+8      	; 0x2026 <_ZN7MCP251511clearRXnOVREv+0x14>
    201e:	ce 01       	movw	r24, r28
		clearInterrupts();
    2020:	e4 df       	rcall	.-56     	; 0x1fea <_ZN7MCP251516clearRXnOVRFlagsEv>
    2022:	ce 01       	movw	r24, r28
    2024:	ea df       	rcall	.-44     	; 0x1ffa <_ZN7MCP251515clearInterruptsEv>
		//modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
	}
	
}
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	08 95       	ret

0000202c <_ZN7MCP25159clearMERREv>:

void MCP2515::clearMERR()
{
	//modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
	//clearInterrupts();
	modifyRegister(MCP_CANINTF, CANINTF_MERRF, 0);
    202c:	20 e0       	ldi	r18, 0x00	; 0
    202e:	40 e8       	ldi	r20, 0x80	; 128
    2030:	6c e2       	ldi	r22, 0x2C	; 44
    2032:	c9 ca       	rjmp	.-2670   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    2034:	08 95       	ret

00002036 <_ZN7MCP251510clearERRIFEv>:
    2036:	20 e0       	ldi	r18, 0x00	; 0

void MCP2515::clearERRIF()
{
    //modifyRegister(MCP_EFLG, EFLG_RX0OVR | EFLG_RX1OVR, 0);
    //clearInterrupts();
    modifyRegister(MCP_CANINTF, CANINTF_ERRIF, 0);
    2038:	40 e2       	ldi	r20, 0x20	; 32
    203a:	6c e2       	ldi	r22, 0x2C	; 44
    203c:	c4 ca       	rjmp	.-2680   	; 0x15c6 <_ZN7MCP251514modifyRegisterENS_8REGISTEREhh>
    203e:	08 95       	ret

00002040 <_ZN7MCP251510checktxavaEv>:
    2040:	60 e3       	ldi	r22, 0x30	; 48
    2042:	15 da       	rcall	.-3030   	; 0x146e <_ZN7MCP251512readRegisterENS_8REGISTERE>
}

MCP2515::ERROR MCP2515::checktxava(void) {
	if(((readRegister(MCP_TXB0CTRL)&TXB_TXREQ)>>TXB_TXREQ)==0) {
    2044:	80 e0       	ldi	r24, 0x00	; 0
    2046:	08 95       	ret

00002048 <can_init>:
	
#define RETRY_NO 8



int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
    2048:	8f 92       	push	r8
    204a:	9f 92       	push	r9
    204c:	af 92       	push	r10
    204e:	bf 92       	push	r11
    2050:	cf 92       	push	r12
    2052:	df 92       	push	r13
    2054:	ef 92       	push	r14
    2056:	ff 92       	push	r15
    2058:	0f 93       	push	r16
    205a:	1f 93       	push	r17
    205c:	cf 93       	push	r28
    205e:	df 93       	push	r29
    2060:	6b 01       	movw	r12, r22
    2062:	7c 01       	movw	r14, r24
    2064:	49 01       	movw	r8, r18
    2066:	5a 01       	movw	r10, r20
	int error = 0;
	portENTER_CRITICAL();
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	0f 92       	push	r0
		SPI.begin();
    206e:	f5 d4       	rcall	.+2538   	; 0x2a5a <_ZN8SPIClass5beginEv>
			errorfunc(mcp2515.reset(),error);
    2070:	88 e5       	ldi	r24, 0x58	; 88
    2072:	95 e0       	ldi	r25, 0x05	; 5
    2074:	d3 da       	rcall	.-2650   	; 0x161c <_ZN7MCP25155resetEv>
    2076:	d8 2f       	mov	r29, r24
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    2078:	6f e0       	ldi	r22, 0x0F	; 15
    207a:	88 e5       	ldi	r24, 0x58	; 88
    207c:	95 e0       	ldi	r25, 0x05	; 5
    207e:	1d dd       	rcall	.-1478   	; 0x1aba <_ZN7MCP251510setBitrateE9CAN_SPEED>
    2080:	81 11       	cpse	r24, r1
    2082:	0b c0       	rjmp	.+22     	; 0x209a <can_init+0x52>

int can_init(uint32_t id, uint32_t mask, struct csp_can_config *conf) {
	int error = 0;
	portENTER_CRITICAL();
		SPI.begin();
			errorfunc(mcp2515.reset(),error);
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	d1 11       	cpse	r29, r1
    208a:	02 c0       	rjmp	.+4      	; 0x2090 <can_init+0x48>
    208c:	80 e0       	ldi	r24, 0x00	; 0
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	cc 27       	eor	r28, r28
    2092:	dd 27       	eor	r29, r29
    2094:	c8 1b       	sub	r28, r24
    2096:	d9 0b       	sbc	r29, r25
    2098:	02 c0       	rjmp	.+4      	; 0x209e <can_init+0x56>
			errorfunc(mcp2515.setBitrate(CAN_1000KBPS),error);
    209a:	cf ef       	ldi	r28, 0xFF	; 255
    209c:	df ef       	ldi	r29, 0xFF	; 255
			//printf(" mask = %lx",mask);
			//while(1);
			errorfunc(mcp2515.setFilterMask(MCP2515::MASK0,1,mask),error);
    209e:	95 01       	movw	r18, r10
    20a0:	84 01       	movw	r16, r8
    20a2:	41 e0       	ldi	r20, 0x01	; 1
    20a4:	60 e0       	ldi	r22, 0x00	; 0
    20a6:	88 e5       	ldi	r24, 0x58	; 88
    20a8:	95 e0       	ldi	r25, 0x05	; 5
    20aa:	5a dd       	rcall	.-1356   	; 0x1b60 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    20ac:	88 23       	and	r24, r24
    20ae:	11 f0       	breq	.+4      	; 0x20b4 <can_init+0x6c>
    20b0:	cf ef       	ldi	r28, 0xFF	; 255
    20b2:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilterMask(MCP2515::MASK1,1,mask),error);
    20b4:	95 01       	movw	r18, r10
    20b6:	84 01       	movw	r16, r8
    20b8:	41 e0       	ldi	r20, 0x01	; 1
    20ba:	61 e0       	ldi	r22, 0x01	; 1
    20bc:	88 e5       	ldi	r24, 0x58	; 88
    20be:	95 e0       	ldi	r25, 0x05	; 5
    20c0:	4f dd       	rcall	.-1378   	; 0x1b60 <_ZN7MCP251513setFilterMaskENS_4MASKEbm>
    20c2:	88 23       	and	r24, r24
    20c4:	11 f0       	breq	.+4      	; 0x20ca <can_init+0x82>
    20c6:	cf ef       	ldi	r28, 0xFF	; 255
    20c8:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF0,1,id),error);
    20ca:	97 01       	movw	r18, r14
    20cc:	86 01       	movw	r16, r12
    20ce:	41 e0       	ldi	r20, 0x01	; 1
    20d0:	60 e0       	ldi	r22, 0x00	; 0
    20d2:	88 e5       	ldi	r24, 0x58	; 88
    20d4:	95 e0       	ldi	r25, 0x05	; 5
    20d6:	86 dd       	rcall	.-1268   	; 0x1be4 <_ZN7MCP25159setFilterENS_3RXFEbm>
    20d8:	88 23       	and	r24, r24
    20da:	11 f0       	breq	.+4      	; 0x20e0 <can_init+0x98>
    20dc:	cf ef       	ldi	r28, 0xFF	; 255
    20de:	df ef       	ldi	r29, 0xFF	; 255
 			errorfunc(mcp2515.setFilter(MCP2515::RXF2,1,id),error);
    20e0:	97 01       	movw	r18, r14
    20e2:	86 01       	movw	r16, r12
    20e4:	41 e0       	ldi	r20, 0x01	; 1
    20e6:	62 e0       	ldi	r22, 0x02	; 2
    20e8:	88 e5       	ldi	r24, 0x58	; 88
    20ea:	95 e0       	ldi	r25, 0x05	; 5
    20ec:	7b dd       	rcall	.-1290   	; 0x1be4 <_ZN7MCP25159setFilterENS_3RXFEbm>
    20ee:	88 23       	and	r24, r24
    20f0:	11 f0       	breq	.+4      	; 0x20f6 <can_init+0xae>
    20f2:	cf ef       	ldi	r28, 0xFF	; 255
			errorfunc(mcp2515.setNormalMode(),error);
    20f4:	df ef       	ldi	r29, 0xFF	; 255
    20f6:	88 e5       	ldi	r24, 0x58	; 88
    20f8:	95 e0       	ldi	r25, 0x05	; 5
    20fa:	31 db       	rcall	.-2462   	; 0x175e <_ZN7MCP251513setNormalModeEv>
    20fc:	88 23       	and	r24, r24
    20fe:	11 f0       	breq	.+4      	; 0x2104 <can_init+0xbc>
    2100:	cf ef       	ldi	r28, 0xFF	; 255
    2102:	df ef       	ldi	r29, 0xFF	; 255
			
	portEXIT_CRITICAL();
    2104:	0f 90       	pop	r0
    2106:	0f be       	out	0x3f, r0	; 63
			


			
	return error;
}
    2108:	ce 01       	movw	r24, r28
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	1f 91       	pop	r17
    2110:	0f 91       	pop	r16
    2112:	ff 90       	pop	r15
    2114:	ef 90       	pop	r14
    2116:	df 90       	pop	r13
    2118:	cf 90       	pop	r12
    211a:	bf 90       	pop	r11
    211c:	af 90       	pop	r10
    211e:	9f 90       	pop	r9
    2120:	8f 90       	pop	r8
    2122:	08 95       	ret

00002124 <can_send>:


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    2124:	cf 92       	push	r12
    2126:	df 92       	push	r13
    2128:	ef 92       	push	r14
    212a:	ff 92       	push	r15
    212c:	0f 93       	push	r16
    212e:	1f 93       	push	r17
    2130:	cf 93       	push	r28
    2132:	df 93       	push	r29
    2134:	cd b7       	in	r28, 0x3d	; 61
    2136:	de b7       	in	r29, 0x3e	; 62
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    2138:	cd b6       	in	r12, 0x3d	; 61
    213a:	de b6       	in	r13, 0x3e	; 62
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    213c:	ed b7       	in	r30, 0x3d	; 61
    213e:	fe b7       	in	r31, 0x3e	; 62
    2140:	77 97       	sbiw	r30, 0x17	; 23
    2142:	0f b6       	in	r0, 0x3f	; 63
    2144:	f8 94       	cli
    2146:	fe bf       	out	0x3e, r31	; 62
    2148:	0f be       	out	0x3f, r0	; 63
    214a:	ed bf       	out	0x3d, r30	; 61
    214c:	ed b6       	in	r14, 0x3d	; 61
    214e:	fe b6       	in	r15, 0x3e	; 62
    2150:	f8 e0       	ldi	r31, 0x08	; 8
    2152:	ef 0e       	add	r14, r31
    2154:	f1 1c       	adc	r15, r1
    2156:	38 ef       	ldi	r19, 0xF8	; 248
    2158:	e3 22       	and	r14, r19
	int error=0;
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
    215a:	0f b6       	in	r0, 0x3f	; 63
    215c:	f8 94       	cli
    215e:	0f 92       	push	r0
	canMsg.can_id=id | CAN_EFF_FLAG;
    2160:	dc 01       	movw	r26, r24
    2162:	cb 01       	movw	r24, r22
    2164:	b0 68       	ori	r27, 0x80	; 128
    2166:	f7 01       	movw	r30, r14
    2168:	80 83       	st	Z, r24
    216a:	91 83       	std	Z+1, r25	; 0x01
    216c:	a2 83       	std	Z+2, r26	; 0x02
    216e:	b3 83       	std	Z+3, r27	; 0x03
	canMsg.can_dlc=dlc;
    2170:	24 83       	std	Z+4, r18	; 0x04
	for (int i=0;i<dlc;i++) {
    2172:	22 23       	and	r18, r18
    2174:	09 f4       	brne	.+2      	; 0x2178 <can_send+0x54>
    2176:	3d c0       	rjmp	.+122    	; 0x21f2 <can_send+0xce>
    2178:	a4 2f       	mov	r26, r20
    217a:	b5 2f       	mov	r27, r21
    217c:	38 96       	adiw	r30, 0x08	; 8
    217e:	30 e0       	ldi	r19, 0x00	; 0
    2180:	28 5f       	subi	r18, 0xF8	; 248
    2182:	3f 4f       	sbci	r19, 0xFF	; 255
    2184:	2e 0d       	add	r18, r14
    2186:	3f 1d       	adc	r19, r15
	
		canMsg.data[i]=*(data+i);
    2188:	8d 91       	ld	r24, X+
	const MCP2515::TXBn tx0 =MCP2515::TXB0;
	struct can_frame canMsg;
	portENTER_CRITICAL();
	canMsg.can_id=id | CAN_EFF_FLAG;
	canMsg.can_dlc=dlc;
	for (int i=0;i<dlc;i++) {
    218a:	81 93       	st	Z+, r24
    218c:	e2 17       	cp	r30, r18
    218e:	f3 07       	cpc	r31, r19
    2190:	d9 f7       	brne	.-10     	; 0x2188 <can_send+0x64>
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
	if(mcp2515.checktxava()==MCP2515::ERROR_OK){
    2192:	2f c0       	rjmp	.+94     	; 0x21f2 <can_send+0xce>
    2194:	88 e5       	ldi	r24, 0x58	; 88
    2196:	95 e0       	ldi	r25, 0x05	; 5
    2198:	53 df       	rcall	.-346    	; 0x2040 <_ZN7MCP251510checktxavaEv>
    219a:	81 11       	cpse	r24, r1
    219c:	15 c0       	rjmp	.+42     	; 0x21c8 <can_send+0xa4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    219e:	8f e8       	ldi	r24, 0x8F	; 143
    21a0:	91 e0       	ldi	r25, 0x01	; 1
    21a2:	01 97       	sbiw	r24, 0x01	; 1
    21a4:	f1 f7       	brne	.-4      	; 0x21a2 <can_send+0x7e>
    21a6:	00 c0       	rjmp	.+0      	; 0x21a8 <can_send+0x84>
		_delay_us(100); //magic number because even if the MCP2515 reports complete tx it can ignore if data written too quickly
			errorfunc(mcp2515.sendMessage(tx0,&canMsg),error);
    21a8:	00 00       	nop
    21aa:	a7 01       	movw	r20, r14
    21ac:	60 e0       	ldi	r22, 0x00	; 0
    21ae:	88 e5       	ldi	r24, 0x58	; 88
    21b0:	95 e0       	ldi	r25, 0x05	; 5
    21b2:	7e dd       	rcall	.-1284   	; 0x1cb0 <_ZN7MCP251511sendMessageENS_4TXBnEPK9can_frame>
    21b4:	01 e0       	ldi	r16, 0x01	; 1
    21b6:	10 e0       	ldi	r17, 0x00	; 0
    21b8:	81 11       	cpse	r24, r1
    21ba:	02 c0       	rjmp	.+4      	; 0x21c0 <can_send+0x9c>
    21bc:	00 e0       	ldi	r16, 0x00	; 0
    21be:	10 e0       	ldi	r17, 0x00	; 0
    21c0:	11 95       	neg	r17
    21c2:	01 95       	neg	r16
    21c4:	11 09       	sbc	r17, r1
    21c6:	05 c0       	rjmp	.+10     	; 0x21d2 <can_send+0xae>
    21c8:	01 50       	subi	r16, 0x01	; 1
    21ca:	11 09       	sbc	r17, r1
	for (int i=0;i<dlc;i++) {
	
		canMsg.data[i]=*(data+i);
	}
	
	for(int i =0;i<RETRY_NO;i++) {
    21cc:	19 f7       	brne	.-58     	; 0x2194 <can_send+0x70>
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
	int error=0;
    21ce:	00 e0       	ldi	r16, 0x00	; 0
    21d0:	10 e0       	ldi	r17, 0x00	; 0
		break;
		}
	}*/
	
	
	portEXIT_CRITICAL();
    21d2:	0f 90       	pop	r0
    21d4:	0f be       	out	0x3f, r0	; 63
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
    21d6:	01 15       	cp	r16, r1
    21d8:	11 05       	cpc	r17, r1
    21da:	71 f0       	breq	.+28     	; 0x21f8 <can_send+0xd4>
    21dc:	86 e0       	ldi	r24, 0x06	; 6
    21de:	90 e1       	ldi	r25, 0x10	; 16
    21e0:	9f 93       	push	r25
    21e2:	8f 93       	push	r24
    21e4:	1f 92       	push	r1
    21e6:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    21ea:	0f 90       	pop	r0
    21ec:	0f 90       	pop	r0
    21ee:	0f 90       	pop	r0
	return error;
    21f0:	03 c0       	rjmp	.+6      	; 0x21f8 <can_send+0xd4>
			
	return error;
}


int can_send(can_id_t id, uint8_t * data, uint8_t dlc){
    21f2:	08 e0       	ldi	r16, 0x08	; 8
    21f4:	10 e0       	ldi	r17, 0x00	; 0
    21f6:	ce cf       	rjmp	.-100    	; 0x2194 <can_send+0x70>
	portEXIT_CRITICAL();
	//csp_log_info("%d\n",ctr);
	if(error!=0) {csp_log_error("can tx error");}
	return error;
	
}
    21f8:	c8 01       	movw	r24, r16
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	de be       	out	0x3e, r13	; 62
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	cd be       	out	0x3d, r12	; 61
    2204:	df 91       	pop	r29
    2206:	cf 91       	pop	r28
    2208:	1f 91       	pop	r17
    220a:	0f 91       	pop	r16
    220c:	ff 90       	pop	r15
    220e:	ef 90       	pop	r14
    2210:	df 90       	pop	r13
    2212:	cf 90       	pop	r12
    2214:	08 95       	ret

00002216 <CanRxFunc>:



void CanRxFunc(void* pvParameters) {
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	00 d0       	rcall	.+0      	; 0x221c <CanRxFunc+0x6>
    221c:	1f 92       	push	r1
    221e:	1f 92       	push	r1
    2220:	cd b7       	in	r28, 0x3d	; 61
	

	DDRD&=~(1<<PD2);
    2222:	de b7       	in	r29, 0x3e	; 62
	EICRA|=(2<<ISC20);
    2224:	52 98       	cbi	0x0a, 2	; 10
    2226:	e9 e6       	ldi	r30, 0x69	; 105
    2228:	f0 e0       	ldi	r31, 0x00	; 0
    222a:	80 81       	ld	r24, Z
    222c:	80 62       	ori	r24, 0x20	; 32
	EIMSK|=(1<<INT2);
    222e:	80 83       	st	Z, r24
	
	mcp2515.clearInterrupts();
    2230:	ea 9a       	sbi	0x1d, 2	; 29
    2232:	88 e5       	ldi	r24, 0x58	; 88
    2234:	95 e0       	ldi	r25, 0x05	; 5
    2236:	e1 de       	rcall	.-574    	; 0x1ffa <_ZN7MCP251515clearInterruptsEv>
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
    2238:	21 e0       	ldi	r18, 0x01	; 1
    223a:	29 83       	std	Y+1, r18	; 0x01
				if(pos>=count) {
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
					for (int a=0;a<frame[i].can_dlc;a++) {
						csp_log_error("Data %d = %x",a,frame[i].data[a]);
    223c:	1a 82       	std	Y+2, r1	; 0x02
    223e:	0f 2e       	mov	r0, r31
    2240:	f0 e9       	ldi	r31, 0x90	; 144
    2242:	2f 2e       	mov	r2, r31
    2244:	ff e0       	ldi	r31, 0x0F	; 15
    2246:	3f 2e       	mov	r3, r31
	

	for(;;){
		

		mcp2515.clearInterrupts();
    2248:	f0 2d       	mov	r31, r0
    224a:	88 e5       	ldi	r24, 0x58	; 88
    224c:	95 e0       	ldi	r25, 0x05	; 5
    224e:	d5 de       	rcall	.-598    	; 0x1ffa <_ZN7MCP251515clearInterruptsEv>
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    2250:	80 e0       	ldi	r24, 0x00	; 0
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	0e 94 c6 3d 	call	0x7b8c	; 0x7b8c <uxTaskGetStackHighWaterMark2>
    2258:	8b 83       	std	Y+3, r24	; 0x03
    225a:	9d 83       	std	Y+5, r25	; 0x05
    225c:	80 e0       	ldi	r24, 0x00	; 0
    225e:	90 e0       	ldi	r25, 0x00	; 0
    2260:	0e 94 ad 3a 	call	0x755a	; 0x755a <pcTaskGetName>
    2264:	3d 81       	ldd	r19, Y+5	; 0x05
    2266:	3f 93       	push	r19
    2268:	4b 81       	ldd	r20, Y+3	; 0x03
    226a:	4f 93       	push	r20
    226c:	9f 93       	push	r25
    226e:	8f 93       	push	r24
    2270:	8f ef       	ldi	r24, 0xFF	; 255
    2272:	9f e0       	ldi	r25, 0x0F	; 15
    2274:	9f 93       	push	r25
    2276:	8f 93       	push	r24
    2278:	82 e0       	ldi	r24, 0x02	; 2
    227a:	8f 93       	push	r24
    227c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		vTaskSuspend(NULL);
    2280:	80 e0       	ldi	r24, 0x00	; 0
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	0e 94 69 40 	call	0x80d2	; 0x80d2 <vTaskSuspend>
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int errorb=0;
			int dlcsum=0;
			portENTER_CRITICAL();
    2288:	0f b6       	in	r0, 0x3f	; 63
    228a:	f8 94       	cli
			timeoutstart(MAX_DELAY); // 256*n/16M for time
    228c:	0f 92       	push	r0
    228e:	86 e0       	ldi	r24, 0x06	; 6
    2290:	91 e0       	ldi	r25, 0x01	; 1
    2292:	fd d1       	rcall	.+1018   	; 0x268e <_Z12timeoutstarti>
    2294:	0f b6       	in	r0, 0x3f	; 63
    2296:	f8 94       	cli
    2298:	de bf       	out	0x3e, r29	; 62
    229a:	0f be       	out	0x3f, r0	; 63
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
    229c:	cd bf       	out	0x3d, r28	; 61
    229e:	00 e0       	ldi	r16, 0x00	; 0
		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
    22a0:	10 e0       	ldi	r17, 0x00	; 0
    22a2:	0f 2e       	mov	r0, r31
    22a4:	f6 e0       	ldi	r31, 0x06	; 6
    22a6:	ff 2e       	mov	r15, r31

		mcp2515.clearInterrupts();
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		vTaskSuspend(NULL);
		
			uint8_t count=0;
    22a8:	f0 2d       	mov	r31, r0
			int error=0;
			int errorb=0;
			int dlcsum=0;
			portENTER_CRITICAL();
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
    22aa:	51 2c       	mov	r5, r1
    22ac:	12 d2       	rcall	.+1060   	; 0x26d2 <_Z12timeoutcheckv>
    22ae:	89 2b       	or	r24, r25
    22b0:	a9 f5       	brne	.+106    	; 0x231c <CanRxFunc+0x106>
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
    22b2:	45 2d       	mov	r20, r5
    22b4:	50 e0       	ldi	r21, 0x00	; 0
    22b6:	5c 83       	std	Y+4, r21	; 0x04
    22b8:	4b 83       	std	Y+3, r20	; 0x03
    22ba:	ba 01       	movw	r22, r20
    22bc:	62 95       	swap	r22
    22be:	72 95       	swap	r23
    22c0:	70 7f       	andi	r23, 0xF0	; 240
    22c2:	76 27       	eor	r23, r22
    22c4:	60 7f       	andi	r22, 0xF0	; 240
    22c6:	76 27       	eor	r23, r22
    22c8:	68 51       	subi	r22, 0x18	; 24
    22ca:	7b 4f       	sbci	r23, 0xFB	; 251
    22cc:	88 e5       	ldi	r24, 0x58	; 88
    22ce:	95 e0       	ldi	r25, 0x05	; 5
    22d0:	60 de       	rcall	.-832    	; 0x1f92 <_ZN7MCP251511readMessageEP9can_frame>
    22d2:	81 11       	cpse	r24, r1
    22d4:	1e c0       	rjmp	.+60     	; 0x2312 <CanRxFunc+0xfc>
    22d6:	01 15       	cp	r16, r1
    22d8:	11 05       	cpc	r17, r1
    22da:	09 f4       	brne	.+2      	; 0x22de <CanRxFunc+0xc8>
    22dc:	62 c1       	rjmp	.+708    	; 0x25a2 <CanRxFunc+0x38c>
    22de:	19 c0       	rjmp	.+50     	; 0x2312 <CanRxFunc+0xfc>
					//dlcsum+=frame[count].can_dlc;
					 uint8_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
    22e0:	51 10       	cpse	r5, r1
    22e2:	15 c0       	rjmp	.+42     	; 0x230e <CanRxFunc+0xf8>
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
    22e4:	07 2e       	mov	r0, r23
    22e6:	7a e0       	ldi	r23, 0x0A	; 10
    22e8:	b6 95       	lsr	r27
    22ea:	a7 95       	ror	r26
    22ec:	97 95       	ror	r25
    22ee:	87 95       	ror	r24
    22f0:	7a 95       	dec	r23
    22f2:	d1 f7       	brne	.-12     	; 0x22e8 <CanRxFunc+0xd2>
    22f4:	70 2d       	mov	r23, r0
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
    22f6:	f8 2e       	mov	r15, r24
    22f8:	56 e0       	ldi	r21, 0x06	; 6
    22fa:	58 17       	cp	r21, r24
    22fc:	20 f0       	brcs	.+8      	; 0x2306 <CanRxFunc+0xf0>
								error=1;
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
    22fe:	07 c0       	rjmp	.+14     	; 0x230e <CanRxFunc+0xf8>
    2300:	51 10       	cpse	r5, r1
    2302:	05 c0       	rjmp	.+10     	; 0x230e <CanRxFunc+0xf8>
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
							remain = ((uint8_t)((frame[count].can_id >> 10) & 0xFF)); //get the remain from it
							// printf("h%d",remain);
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
    2304:	0e c0       	rjmp	.+28     	; 0x2322 <CanRxFunc+0x10c>
    2306:	09 81       	ldd	r16, Y+1	; 0x01
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
						if (error==1) {count=1;}
    2308:	1a 81       	ldd	r17, Y+2	; 0x02
    230a:	55 24       	eor	r5, r5

						count++; // increment number of messages received
    230c:	53 94       	inc	r5
						timeoutreset(); //if there is a new message, reset the timer
    230e:	53 94       	inc	r5
    2310:	db d1       	rcall	.+950    	; 0x26c8 <_Z12timeoutresetv>
					}		
					if (count>remain){break;} // this is used to break out of the timeout if we've received all frames or if there's too many
    2312:	f5 14       	cp	r15, r5
    2314:	58 f6       	brcc	.-106    	; 0x22ac <CanRxFunc+0x96>
		vTaskSuspend(NULL);
		
			uint8_t count=0;
			uint8_t remain =MAX_CONC_FRAME-1;
			int error=0;
			int errorb=0;
    2316:	80 e0       	ldi	r24, 0x00	; 0
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	05 c0       	rjmp	.+10     	; 0x2326 <CanRxFunc+0x110>
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	90 e0       	ldi	r25, 0x00	; 0
    2320:	02 c0       	rjmp	.+4      	; 0x2326 <CanRxFunc+0x110>
							if(remain>(MAX_CONC_FRAME-1)) { //if the frames coming in are too big they will be ignored
								error=1;
							}

					
						} else if (count==0) {errorb=1; break;} // if its the first frame received and not a begin frame, break
    2322:	81 e0       	ldi	r24, 0x01	; 1
    2324:	90 e0       	ldi	r25, 0x00	; 0
						count++; // increment number of messages received
						timeoutreset(); //if there is a new message, reset the timer
					}		
					if (count>remain){break;} // this is used to break out of the timeout if we've received all frames or if there's too many
			}
			portEXIT_CRITICAL();
    2326:	0f 90       	pop	r0
    2328:	0f be       	out	0x3f, r0	; 63
			//csp_log_info("DLC = %d",dlcsum);
			if(error!=0||errorb!=0) { // if too many frames come it, it wont process them. saves time handling these useless requests
    232a:	01 2b       	or	r16, r17
    232c:	11 f4       	brne	.+4      	; 0x2332 <CanRxFunc+0x11c>
    232e:	89 2b       	or	r24, r25
    2330:	59 f0       	breq	.+22     	; 0x2348 <CanRxFunc+0x132>
 				csp_log_error("Too Many Frames or wrong order");
    2332:	80 ee       	ldi	r24, 0xE0	; 224
    2334:	9f e0       	ldi	r25, 0x0F	; 15
    2336:	9f 93       	push	r25
    2338:	8f 93       	push	r24
    233a:	1f 92       	push	r1
    233c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    2340:	0f 90       	pop	r0
    2342:	0f 90       	pop	r0
    2344:	0f 90       	pop	r0
    2346:	81 cf       	rjmp	.-254    	; 0x224a <CanRxFunc+0x34>
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
    2348:	c5 2c       	mov	r12, r5
    234a:	d1 2c       	mov	r13, r1
    234c:	1f 92       	push	r1
    234e:	5f 92       	push	r5
    2350:	83 ed       	ldi	r24, 0xD3	; 211
    2352:	9f e0       	ldi	r25, 0x0F	; 15
    2354:	9f 93       	push	r25
    2356:	8f 93       	push	r24
    2358:	82 e0       	ldi	r24, 0x02	; 2
    235a:	8f 93       	push	r24
    235c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			for (int i=0;i<count;i++){
    2360:	0f 90       	pop	r0
    2362:	0f 90       	pop	r0
    2364:	0f 90       	pop	r0
    2366:	0f 90       	pop	r0
    2368:	0f 90       	pop	r0
    236a:	1c 14       	cp	r1, r12
    236c:	1d 04       	cpc	r1, r13
    236e:	0c f0       	brlt	.+2      	; 0x2372 <CanRxFunc+0x15c>
    2370:	a5 c0       	rjmp	.+330    	; 0x24bc <CanRxFunc+0x2a6>
    2372:	88 ee       	ldi	r24, 0xE8	; 232
    2374:	94 e0       	ldi	r25, 0x04	; 4
    2376:	0f 2e       	mov	r0, r31
    2378:	f0 ef       	ldi	r31, 0xF0	; 240
    237a:	8f 2e       	mov	r8, r31
    237c:	f4 e0       	ldi	r31, 0x04	; 4
    237e:	9f 2e       	mov	r9, r31
    2380:	f0 2d       	mov	r31, r0
    2382:	a1 2c       	mov	r10, r1
    2384:	b1 2c       	mov	r11, r1
				
				//csp_log_info("pos = %d	count=%d",pos,count);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    2386:	9c 83       	std	Y+4, r25	; 0x04
    2388:	8b 83       	std	Y+3, r24	; 0x03
    238a:	0b 81       	ldd	r16, Y+3	; 0x03
    238c:	1c 81       	ldd	r17, Y+4	; 0x04
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
				uint8_t pos = count-((uint8_t)((frame[i].can_id >> 10) & 0xFF))-1;
    238e:	f8 01       	movw	r30, r16
    2390:	80 81       	ld	r24, Z
    2392:	91 81       	ldd	r25, Z+1	; 0x01
    2394:	a2 81       	ldd	r26, Z+2	; 0x02
    2396:	b3 81       	ldd	r27, Z+3	; 0x03
    2398:	07 2e       	mov	r0, r23
    239a:	7a e0       	ldi	r23, 0x0A	; 10
    239c:	b6 95       	lsr	r27
    239e:	a7 95       	ror	r26
    23a0:	97 95       	ror	r25
    23a2:	87 95       	ror	r24
    23a4:	7a 95       	dec	r23
    23a6:	d1 f7       	brne	.-12     	; 0x239c <CanRxFunc+0x186>
    23a8:	70 2d       	mov	r23, r0
    23aa:	e8 2f       	mov	r30, r24
    23ac:	e0 95       	com	r30
    23ae:	4e 2e       	mov	r4, r30
    23b0:	45 0c       	add	r4, r5
				if(pos>=count) {
    23b2:	45 14       	cp	r4, r5
    23b4:	08 f4       	brcc	.+2      	; 0x23b8 <CanRxFunc+0x1a2>
    23b6:	4f c0       	rjmp	.+158    	; 0x2456 <CanRxFunc+0x240>
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
    23b8:	df 92       	push	r13
    23ba:	cf 92       	push	r12
    23bc:	1f 92       	push	r1
    23be:	4f 92       	push	r4
    23c0:	24 eb       	ldi	r18, 0xB4	; 180
    23c2:	3f e0       	ldi	r19, 0x0F	; 15
    23c4:	3f 93       	push	r19
    23c6:	2f 93       	push	r18
    23c8:	1f 92       	push	r1
    23ca:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
    23ce:	eb 81       	ldd	r30, Y+3	; 0x03
    23d0:	fc 81       	ldd	r31, Y+4	; 0x04
    23d2:	83 81       	ldd	r24, Z+3	; 0x03
    23d4:	8f 93       	push	r24
    23d6:	82 81       	ldd	r24, Z+2	; 0x02
    23d8:	8f 93       	push	r24
    23da:	81 81       	ldd	r24, Z+1	; 0x01
    23dc:	8f 93       	push	r24
    23de:	80 81       	ld	r24, Z
    23e0:	8f 93       	push	r24
    23e2:	29 ea       	ldi	r18, 0xA9	; 169
    23e4:	3f e0       	ldi	r19, 0x0F	; 15
    23e6:	3f 93       	push	r19
    23e8:	2f 93       	push	r18
    23ea:	1f 92       	push	r1
    23ec:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
    23f0:	eb 81       	ldd	r30, Y+3	; 0x03
    23f2:	fc 81       	ldd	r31, Y+4	; 0x04
    23f4:	84 81       	ldd	r24, Z+4	; 0x04
    23f6:	1f 92       	push	r1
    23f8:	8f 93       	push	r24
    23fa:	2d e9       	ldi	r18, 0x9D	; 157
    23fc:	3f e0       	ldi	r19, 0x0F	; 15
    23fe:	3f 93       	push	r19
    2400:	2f 93       	push	r18
    2402:	1f 92       	push	r1
    2404:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
					for (int a=0;a<frame[i].can_dlc;a++) {
    2408:	eb 81       	ldd	r30, Y+3	; 0x03
    240a:	fc 81       	ldd	r31, Y+4	; 0x04
    240c:	84 81       	ldd	r24, Z+4	; 0x04
    240e:	0f b6       	in	r0, 0x3f	; 63
    2410:	f8 94       	cli
    2412:	de bf       	out	0x3e, r29	; 62
    2414:	0f be       	out	0x3f, r0	; 63
    2416:	cd bf       	out	0x3d, r28	; 61
    2418:	88 23       	and	r24, r24
    241a:	e9 f0       	breq	.+58     	; 0x2456 <CanRxFunc+0x240>
    241c:	74 01       	movw	r14, r8
    241e:	61 2c       	mov	r6, r1
    2420:	71 2c       	mov	r7, r1
						csp_log_error("Data %d = %x",a,frame[i].data[a]);
    2422:	f7 01       	movw	r30, r14
    2424:	81 91       	ld	r24, Z+
    2426:	7f 01       	movw	r14, r30
    2428:	1f 92       	push	r1
    242a:	8f 93       	push	r24
    242c:	7f 92       	push	r7
    242e:	6f 92       	push	r6
    2430:	3f 92       	push	r3
    2432:	2f 92       	push	r2
    2434:	1f 92       	push	r1
    2436:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
				uint8_t pos = count-((uint8_t)((frame[i].can_id >> 10) & 0xFF))-1;
				if(pos>=count) {
					csp_log_error("impossible pos %d	count = %d\r\n",pos,count);
					csp_log_error("Id = %ux\r\n",frame[i].can_id);
					csp_log_error("DLC = %ux\r\n",frame[i].can_dlc);
					for (int a=0;a<frame[i].can_dlc;a++) {
    243a:	ff ef       	ldi	r31, 0xFF	; 255
    243c:	6f 1a       	sub	r6, r31
    243e:	7f 0a       	sbc	r7, r31
    2440:	f8 01       	movw	r30, r16
    2442:	84 81       	ldd	r24, Z+4	; 0x04
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	0f b6       	in	r0, 0x3f	; 63
    2448:	f8 94       	cli
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	cd bf       	out	0x3d, r28	; 61
    2450:	68 16       	cp	r6, r24
    2452:	79 06       	cpc	r7, r25
    2454:	34 f3       	brlt	.-52     	; 0x2422 <CanRxFunc+0x20c>
				
				//csp_log_info("pos = %d	count=%d",pos,count);
				
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
    2456:	5d e0       	ldi	r21, 0x0D	; 13
    2458:	54 9d       	mul	r21, r4
    245a:	f0 01       	movw	r30, r0
    245c:	11 24       	eor	r1, r1
    245e:	af 01       	movw	r20, r30
    2460:	43 57       	subi	r20, 0x73	; 115
    2462:	5b 4f       	sbci	r21, 0xFB	; 251
    2464:	f8 01       	movw	r30, r16
    2466:	80 81       	ld	r24, Z
    2468:	91 81       	ldd	r25, Z+1	; 0x01
    246a:	a2 81       	ldd	r26, Z+2	; 0x02
    246c:	b3 81       	ldd	r27, Z+3	; 0x03
    246e:	fa 01       	movw	r30, r20
    2470:	80 83       	st	Z, r24
    2472:	91 83       	std	Z+1, r25	; 0x01
    2474:	a2 83       	std	Z+2, r26	; 0x02
    2476:	b3 83       	std	Z+3, r27	; 0x03
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
    2478:	f8 01       	movw	r30, r16
    247a:	24 81       	ldd	r18, Z+4	; 0x04
    247c:	fa 01       	movw	r30, r20
    247e:	24 83       	std	Z+4, r18	; 0x04
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    2480:	22 23       	and	r18, r18
    2482:	69 f0       	breq	.+26     	; 0x249e <CanRxFunc+0x288>
    2484:	3d e0       	ldi	r19, 0x0D	; 13
    2486:	34 9d       	mul	r19, r4
    2488:	f0 01       	movw	r30, r0
    248a:	11 24       	eor	r1, r1
    248c:	ee 56       	subi	r30, 0x6E	; 110
    248e:	fb 4f       	sbci	r31, 0xFB	; 251
    2490:	d4 01       	movw	r26, r8
    2492:	80 e0       	ldi	r24, 0x00	; 0
						frameo[pos].data[a]=frame[i].data[a];
    2494:	9d 91       	ld	r25, X+
    2496:	91 93       	st	Z+, r25
				
				// next part translates from libraries can frame to libcsp's
							frameo[pos].id=frame[i].can_id;
							//frameo.id&=~(0xE0000000); //this was here ebcause for some reason first 3 bits were 1's of id
					frameo[pos].dlc=frame[i].can_dlc;
					for (uint8_t a=0;a<frame[i].can_dlc;a++) {
    2498:	8f 5f       	subi	r24, 0xFF	; 255
    249a:	28 13       	cpse	r18, r24
    249c:	fb cf       	rjmp	.-10     	; 0x2494 <CanRxFunc+0x27e>
 				csp_log_error("Too Many Frames or wrong order");
			
			} else {
			
			csp_log_info("CAN Rec = %d",count); 
			for (int i=0;i<count;i++){
    249e:	9f ef       	ldi	r25, 0xFF	; 255
    24a0:	a9 1a       	sub	r10, r25
    24a2:	b9 0a       	sbc	r11, r25
    24a4:	eb 81       	ldd	r30, Y+3	; 0x03
    24a6:	fc 81       	ldd	r31, Y+4	; 0x04
    24a8:	70 96       	adiw	r30, 0x10	; 16
    24aa:	fc 83       	std	Y+4, r31	; 0x04
    24ac:	eb 83       	std	Y+3, r30	; 0x03
    24ae:	f0 e1       	ldi	r31, 0x10	; 16
    24b0:	8f 0e       	add	r8, r31
    24b2:	91 1c       	adc	r9, r1
    24b4:	ca 14       	cp	r12, r10
    24b6:	db 04       	cpc	r13, r11
    24b8:	09 f0       	breq	.+2      	; 0x24bc <CanRxFunc+0x2a6>
    24ba:	67 cf       	rjmp	.-306    	; 0x238a <CanRxFunc+0x174>
						csp_log_info(" %x",frameo[count].data[a]);
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
    24bc:	0f b6       	in	r0, 0x3f	; 63
    24be:	f8 94       	cli
    24c0:	0f 92       	push	r0
			for (int i=0;i<count;i++){ //send of the frames to be processed
    24c2:	1c 14       	cp	r1, r12
    24c4:	1d 04       	cpc	r1, r13
    24c6:	f4 f5       	brge	.+124    	; 0x2544 <CanRxFunc+0x32e>
    24c8:	0d e8       	ldi	r16, 0x8D	; 141
    24ca:	14 e0       	ldi	r17, 0x04	; 4
    24cc:	1c 82       	std	Y+4, r1	; 0x04
    24ce:	1b 82       	std	Y+3, r1	; 0x03
				if(i==count-1){
    24d0:	76 01       	movw	r14, r12
    24d2:	21 e0       	ldi	r18, 0x01	; 1
    24d4:	e2 1a       	sub	r14, r18
    24d6:	f1 08       	sbc	r15, r1
					
					if(csp_can_rx_frame(&frameo[i],"CAN")!=0) {csp_log_reset("queue fail");}
					
					} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
    24d8:	0f 2e       	mov	r0, r31
    24da:	f6 e0       	ldi	r31, 0x06	; 6
    24dc:	bf 2e       	mov	r11, r31
    24de:	f0 2d       	mov	r31, r0
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
			for (int i=0;i<count;i++){ //send of the frames to be processed
				if(i==count-1){
    24e0:	8b 81       	ldd	r24, Y+3	; 0x03
    24e2:	9c 81       	ldd	r25, Y+4	; 0x04
    24e4:	e8 16       	cp	r14, r24
    24e6:	f9 06       	cpc	r15, r25
    24e8:	91 f4       	brne	.+36     	; 0x250e <CanRxFunc+0x2f8>
					
					if(csp_can_rx_frame(&frameo[i],"CAN")!=0) {csp_log_reset("queue fail");}
    24ea:	62 ec       	ldi	r22, 0xC2	; 194
    24ec:	72 e0       	ldi	r23, 0x02	; 2
    24ee:	c8 01       	movw	r24, r16
    24f0:	0e 94 1d 2f 	call	0x5e3a	; 0x5e3a <csp_can_rx_frame>
    24f4:	89 2b       	or	r24, r25
    24f6:	e1 f0       	breq	.+56     	; 0x2530 <CanRxFunc+0x31a>
    24f8:	e5 e8       	ldi	r30, 0x85	; 133
    24fa:	ff e0       	ldi	r31, 0x0F	; 15
    24fc:	ff 93       	push	r31
    24fe:	ef 93       	push	r30
    2500:	bf 92       	push	r11
    2502:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    2506:	0f 90       	pop	r0
    2508:	0f 90       	pop	r0
    250a:	0f 90       	pop	r0
    250c:	11 c0       	rjmp	.+34     	; 0x2530 <CanRxFunc+0x31a>
					
					} else {
					if(csp_can_rx_frame(&frameo[i],NULL)!=0) {csp_log_reset("queue fail");}
    250e:	60 e0       	ldi	r22, 0x00	; 0
    2510:	70 e0       	ldi	r23, 0x00	; 0
    2512:	c8 01       	movw	r24, r16
    2514:	0e 94 1d 2f 	call	0x5e3a	; 0x5e3a <csp_can_rx_frame>
    2518:	89 2b       	or	r24, r25
    251a:	51 f0       	breq	.+20     	; 0x2530 <CanRxFunc+0x31a>
    251c:	4a e7       	ldi	r20, 0x7A	; 122
    251e:	5f e0       	ldi	r21, 0x0F	; 15
    2520:	5f 93       	push	r21
    2522:	4f 93       	push	r20
    2524:	bf 92       	push	r11
    2526:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    252a:	0f 90       	pop	r0
    252c:	0f 90       	pop	r0
    252e:	0f 90       	pop	r0
					}
					csp_log_info("\n");
				
			}*/
			portENTER_CRITICAL();
			for (int i=0;i<count;i++){ //send of the frames to be processed
    2530:	eb 81       	ldd	r30, Y+3	; 0x03
    2532:	fc 81       	ldd	r31, Y+4	; 0x04
    2534:	31 96       	adiw	r30, 0x01	; 1
    2536:	fc 83       	std	Y+4, r31	; 0x04
    2538:	eb 83       	std	Y+3, r30	; 0x03
    253a:	03 5f       	subi	r16, 0xF3	; 243
    253c:	1f 4f       	sbci	r17, 0xFF	; 255
    253e:	ce 16       	cp	r12, r30
    2540:	df 06       	cpc	r13, r31
    2542:	71 f6       	brne	.-100    	; 0x24e0 <CanRxFunc+0x2ca>
					}
					
					
				
			}
			portEXIT_CRITICAL();
    2544:	0f 90       	pop	r0
    2546:	0f be       	out	0x3f, r0	; 63
    2548:	8d e8       	ldi	r24, 0x8D	; 141
    254a:	94 e0       	ldi	r25, 0x04	; 4
    254c:	28 ee       	ldi	r18, 0xE8	; 232
    254e:	34 e0       	ldi	r19, 0x04	; 4
    2550:	3c 83       	std	Y+4, r19	; 0x04
    2552:	2b 83       	std	Y+3, r18	; 0x03
    2554:	28 ee       	ldi	r18, 0xE8	; 232
    2556:	34 e0       	ldi	r19, 0x04	; 4
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
    2558:	fc 01       	movw	r30, r24
    255a:	10 82       	st	Z, r1
    255c:	11 82       	std	Z+1, r1	; 0x01
    255e:	12 82       	std	Z+2, r1	; 0x02
    2560:	13 82       	std	Z+3, r1	; 0x03
				frame[i].can_id=0;
    2562:	eb 81       	ldd	r30, Y+3	; 0x03
    2564:	fc 81       	ldd	r31, Y+4	; 0x04
    2566:	10 82       	st	Z, r1
    2568:	11 82       	std	Z+1, r1	; 0x01
    256a:	12 82       	std	Z+2, r1	; 0x02
    256c:	13 82       	std	Z+3, r1	; 0x03
				frameo[i].dlc=0;
    256e:	fc 01       	movw	r30, r24
    2570:	14 82       	std	Z+4, r1	; 0x04
				frame[i].can_dlc=0;
    2572:	eb 81       	ldd	r30, Y+3	; 0x03
    2574:	fc 81       	ldd	r31, Y+4	; 0x04
    2576:	14 82       	std	Z+4, r1	; 0x04
    2578:	dc 01       	movw	r26, r24
    257a:	15 96       	adiw	r26, 0x05	; 5
    257c:	38 96       	adiw	r30, 0x08	; 8
    257e:	4b 81       	ldd	r20, Y+3	; 0x03
    2580:	5c 81       	ldd	r21, Y+4	; 0x04
    2582:	40 5f       	subi	r20, 0xF0	; 240
    2584:	5f 4f       	sbci	r21, 0xFF	; 255
    2586:	5c 83       	std	Y+4, r21	; 0x04
    2588:	4b 83       	std	Y+3, r20	; 0x03
				for (int a=0;a<8;a++) {
					frameo[i].data[a]=0;
    258a:	1d 92       	st	X+, r1
					frame[i].data[a]=0;
    258c:	11 92       	st	Z+, r1
			for(int i=0;i<MAX_CONC_FRAME;i++){
				frameo[i].id=0;
				frame[i].can_id=0;
				frameo[i].dlc=0;
				frame[i].can_dlc=0;
				for (int a=0;a<8;a++) {
    258e:	4b 81       	ldd	r20, Y+3	; 0x03
    2590:	5c 81       	ldd	r21, Y+4	; 0x04
    2592:	e4 17       	cp	r30, r20
    2594:	f5 07       	cpc	r31, r21
    2596:	c9 f7       	brne	.-14     	; 0x258a <CanRxFunc+0x374>
    2598:	0d 96       	adiw	r24, 0x0d	; 13
					
				
			}
			portEXIT_CRITICAL();
			
			for(int i=0;i<MAX_CONC_FRAME;i++){
    259a:	82 17       	cp	r24, r18
    259c:	93 07       	cpc	r25, r19
    259e:	e1 f6       	brne	.-72     	; 0x2558 <CanRxFunc+0x342>
    25a0:	54 ce       	rjmp	.-856    	; 0x224a <CanRxFunc+0x34>
			timeoutstart(MAX_DELAY); // 256*n/16M for time
			while(!(timeoutcheck())){ //while the time hasn't elapsed
			
				if(mcp2515.readMessage(&frame[count]) == MCP2515::ERROR_OK&&error==0) { //check for a new message and store in &frame
					//dlcsum+=frame[count].can_dlc;
					 uint8_t begin = (((frame[count].can_id)>>18)&0x01); //get the begin flag
    25a2:	8b 81       	ldd	r24, Y+3	; 0x03
    25a4:	9c 81       	ldd	r25, Y+4	; 0x04
    25a6:	82 95       	swap	r24
    25a8:	92 95       	swap	r25
    25aa:	90 7f       	andi	r25, 0xF0	; 240
    25ac:	98 27       	eor	r25, r24
    25ae:	80 7f       	andi	r24, 0xF0	; 240
    25b0:	98 27       	eor	r25, r24
    25b2:	88 51       	subi	r24, 0x18	; 24
    25b4:	9b 4f       	sbci	r25, 0xFB	; 251
    25b6:	fc 01       	movw	r30, r24
    25b8:	80 81       	ld	r24, Z
    25ba:	91 81       	ldd	r25, Z+1	; 0x01
    25bc:	a2 81       	ldd	r26, Z+2	; 0x02
    25be:	b3 81       	ldd	r27, Z+3	; 0x03
						//csp_log_info("t= %lx\n",test);
						if (begin!=1&&count==0) { //if it is a begin frame
    25c0:	ac 01       	movw	r20, r24
    25c2:	bd 01       	movw	r22, r26
    25c4:	03 2e       	mov	r0, r19
    25c6:	32 e1       	ldi	r19, 0x12	; 18
    25c8:	76 95       	lsr	r23
    25ca:	67 95       	ror	r22
    25cc:	57 95       	ror	r21
    25ce:	47 95       	ror	r20
    25d0:	3a 95       	dec	r19
    25d2:	d1 f7       	brne	.-12     	; 0x25c8 <CanRxFunc+0x3b2>
    25d4:	30 2d       	mov	r19, r0
    25d6:	40 ff       	sbrs	r20, 0
    25d8:	83 ce       	rjmp	.-762    	; 0x22e0 <CanRxFunc+0xca>
    25da:	92 ce       	rjmp	.-732    	; 0x2300 <CanRxFunc+0xea>

000025dc <_GLOBAL__sub_I_mcp2515>:

//static csp_queue_handle_t csp_can_rx_queue;



MCP2515 mcp2515;
    25dc:	88 e5       	ldi	r24, 0x58	; 88
    25de:	95 e0       	ldi	r25, 0x05	; 5
    25e0:	0c 94 2c 0a 	jmp	0x1458	; 0x1458 <_ZN7MCP2515C1Ev>
    25e4:	08 95       	ret

000025e6 <_Z10enableledsv>:
#include <avr/interrupt.h>

int leden=0;

void enableleds(void) {
	DDRD|= (1<<PD5) | (1<<PD6) | (1<<PD7);
    25e6:	8a b1       	in	r24, 0x0a	; 10
    25e8:	80 6e       	ori	r24, 0xE0	; 224
    25ea:	8a b9       	out	0x0a, r24	; 10
	leden=1;
    25ec:	81 e0       	ldi	r24, 0x01	; 1
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	90 93 6f 06 	sts	0x066F, r25	; 0x80066f <leden+0x1>
    25f4:	80 93 6e 06 	sts	0x066E, r24	; 0x80066e <leden>
    25f8:	08 95       	ret

000025fa <_Z7contledii>:
}

void contled(int con, int led) {
	if (leden==0) {return;}
    25fa:	20 91 6e 06 	lds	r18, 0x066E	; 0x80066e <leden>
    25fe:	30 91 6f 06 	lds	r19, 0x066F	; 0x80066f <leden+0x1>
    2602:	23 2b       	or	r18, r19
    2604:	c1 f1       	breq	.+112    	; 0x2676 <_Z7contledii+0x7c>
	char tarled = 0;
	switch (led)
    2606:	61 30       	cpi	r22, 0x01	; 1
    2608:	71 05       	cpc	r23, r1
    260a:	39 f0       	breq	.+14     	; 0x261a <_Z7contledii+0x20>
    260c:	62 30       	cpi	r22, 0x02	; 2
    260e:	71 05       	cpc	r23, r1
    2610:	31 f0       	breq	.+12     	; 0x261e <_Z7contledii+0x24>
    2612:	67 2b       	or	r22, r23
    2614:	31 f4       	brne	.+12     	; 0x2622 <_Z7contledii+0x28>
	{
	case 0 : tarled = PD5;
    2616:	25 e0       	ldi	r18, 0x05	; 5
    2618:	05 c0       	rjmp	.+10     	; 0x2624 <_Z7contledii+0x2a>
		break;
	case 1 : tarled = PD6;
    261a:	26 e0       	ldi	r18, 0x06	; 6
		break;
    261c:	03 c0       	rjmp	.+6      	; 0x2624 <_Z7contledii+0x2a>
	case 2 : tarled = PD7;
    261e:	27 e0       	ldi	r18, 0x07	; 7
		break;
    2620:	01 c0       	rjmp	.+2      	; 0x2624 <_Z7contledii+0x2a>
	leden=1;
}

void contled(int con, int led) {
	if (leden==0) {return;}
	char tarled = 0;
    2622:	20 e0       	ldi	r18, 0x00	; 0
	case 1 : tarled = PD6;
		break;
	case 2 : tarled = PD7;
		break;
	}
		switch (con)
    2624:	81 30       	cpi	r24, 0x01	; 1
    2626:	91 05       	cpc	r25, r1
    2628:	81 f0       	breq	.+32     	; 0x264a <_Z7contledii+0x50>
    262a:	82 30       	cpi	r24, 0x02	; 2
    262c:	91 05       	cpc	r25, r1
    262e:	c1 f0       	breq	.+48     	; 0x2660 <_Z7contledii+0x66>
    2630:	89 2b       	or	r24, r25
    2632:	09 f5       	brne	.+66     	; 0x2676 <_Z7contledii+0x7c>
		{
	case 0 : PORTD ^= (1<<tarled);
    2634:	3b b1       	in	r19, 0x0b	; 11
    2636:	81 e0       	ldi	r24, 0x01	; 1
    2638:	90 e0       	ldi	r25, 0x00	; 0
    263a:	02 c0       	rjmp	.+4      	; 0x2640 <_Z7contledii+0x46>
    263c:	88 0f       	add	r24, r24
    263e:	99 1f       	adc	r25, r25
    2640:	2a 95       	dec	r18
    2642:	e2 f7       	brpl	.-8      	; 0x263c <_Z7contledii+0x42>
    2644:	83 27       	eor	r24, r19
    2646:	8b b9       	out	0x0b, r24	; 11
		break;
    2648:	08 95       	ret
	case 1 : PORTD |= (1<<tarled);
    264a:	3b b1       	in	r19, 0x0b	; 11
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	90 e0       	ldi	r25, 0x00	; 0
    2650:	02 c0       	rjmp	.+4      	; 0x2656 <_Z7contledii+0x5c>
    2652:	88 0f       	add	r24, r24
    2654:	99 1f       	adc	r25, r25
    2656:	2a 95       	dec	r18
    2658:	e2 f7       	brpl	.-8      	; 0x2652 <_Z7contledii+0x58>
    265a:	83 2b       	or	r24, r19
    265c:	8b b9       	out	0x0b, r24	; 11
		break;
    265e:	08 95       	ret
	case 2 : PORTD &= ~(1<<tarled);
    2660:	3b b1       	in	r19, 0x0b	; 11
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	02 c0       	rjmp	.+4      	; 0x266c <_Z7contledii+0x72>
    2668:	88 0f       	add	r24, r24
    266a:	99 1f       	adc	r25, r25
    266c:	2a 95       	dec	r18
    266e:	e2 f7       	brpl	.-8      	; 0x2668 <_Z7contledii+0x6e>
    2670:	80 95       	com	r24
    2672:	83 23       	and	r24, r19
    2674:	8b b9       	out	0x0b, r24	; 11
    2676:	08 95       	ret

00002678 <_Z10pwrredinitv>:
	}
	
}

void pwrredinit(void) {
	PRR0|=0b01100000; //shuts down TIM0 and 2
    2678:	e4 e6       	ldi	r30, 0x64	; 100
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	80 81       	ld	r24, Z
    267e:	80 66       	ori	r24, 0x60	; 96
    2680:	80 83       	st	Z, r24
	PRR1|=0b00111111; //shuts down TIM3-5 and USART1-3
    2682:	e5 e6       	ldi	r30, 0x65	; 101
    2684:	f0 e0       	ldi	r31, 0x00	; 0
    2686:	80 81       	ld	r24, Z
    2688:	8f 63       	ori	r24, 0x3F	; 63
    268a:	80 83       	st	Z, r24
    268c:	08 95       	ret

0000268e <_Z12timeoutstarti>:
	
}

void timeoutstart(int tim) {
    268e:	9c 01       	movw	r18, r24
	// remember power save
	cli();
    2690:	f8 94       	cli
	PRR1&=~(1<<PRTIM3);
    2692:	e5 e6       	ldi	r30, 0x65	; 101
    2694:	f0 e0       	ldi	r31, 0x00	; 0
    2696:	90 81       	ld	r25, Z
    2698:	97 7f       	andi	r25, 0xF7	; 247
    269a:	90 83       	st	Z, r25
	
	TCCR3A = 0;
    269c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
	TCCR3B = 0;
    26a0:	e1 e9       	ldi	r30, 0x91	; 145
    26a2:	f0 e0       	ldi	r31, 0x00	; 0
    26a4:	10 82       	st	Z, r1
	TCNT3 = 0;
    26a6:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    26aa:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
	
	OCR3A=tim;
    26ae:	30 93 99 00 	sts	0x0099, r19	; 0x800099 <__TEXT_REGION_LENGTH__+0x7c0099>
    26b2:	20 93 98 00 	sts	0x0098, r18	; 0x800098 <__TEXT_REGION_LENGTH__+0x7c0098>
	
	TCCR3B|=(1<<WGM32);	
    26b6:	80 81       	ld	r24, Z
    26b8:	88 60       	ori	r24, 0x08	; 8
    26ba:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS32);
    26bc:	80 81       	ld	r24, Z
    26be:	84 60       	ori	r24, 0x04	; 4
    26c0:	80 83       	st	Z, r24
	TIFR3|=(1<<OCF3A);
    26c2:	c1 9a       	sbi	0x18, 1	; 24
	sei();
    26c4:	78 94       	sei
    26c6:	08 95       	ret

000026c8 <_Z12timeoutresetv>:
	
}

void timeoutreset(void) {
		TCNT3 = 0;
    26c8:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    26cc:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
    26d0:	08 95       	ret

000026d2 <_Z12timeoutcheckv>:
}

int timeoutcheck(void) {
	
	if((TIFR3&2)>>OCF3A) {
    26d2:	28 b3       	in	r18, 0x18	; 24
    26d4:	21 fb       	bst	r18, 1
    26d6:	88 27       	eor	r24, r24
    26d8:	80 f9       	bld	r24, 0
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	21 ff       	sbrs	r18, 1
    26de:	11 c0       	rjmp	.+34     	; 0x2702 <_Z12timeoutcheckv+0x30>
		cli();
    26e0:	f8 94       	cli
			TCCR3A = 0;
    26e2:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7c0090>
			TCCR3B = 0;
    26e6:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x7c0091>
			TCNT3 = 0;
    26ea:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x7c0095>
    26ee:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x7c0094>
			TIFR3&=~(1<<OCF3A);
    26f2:	c1 98       	cbi	0x18, 1	; 24
			PRR1|=(1<<PRTIM3);
    26f4:	e5 e6       	ldi	r30, 0x65	; 101
    26f6:	f0 e0       	ldi	r31, 0x00	; 0
    26f8:	80 81       	ld	r24, Z
    26fa:	88 60       	ori	r24, 0x08	; 8
    26fc:	80 83       	st	Z, r24
			sei();
    26fe:	78 94       	sei
		return 1;
    2700:	81 e0       	ldi	r24, 0x01	; 1
	} else {
		return 0;
		}
return 0;
}
    2702:	08 95       	ret

00002704 <_Z11task_serverPv>:

   Handles generic CSP cmds and fin controller cmds.
   CSP must be enabled prior to creation of this task.
 */
CSP_DEFINE_TASK(task_server)
{
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	cd b7       	in	r28, 0x3d	; 61
    270a:	de b7       	in	r29, 0x3e	; 62
    270c:	a8 97       	sbiw	r28, 0x28	; 40
    270e:	0f b6       	in	r0, 0x3f	; 63
    2710:	f8 94       	cli
    2712:	de bf       	out	0x3e, r29	; 62
    2714:	0f be       	out	0x3f, r0	; 63
    2716:	cd bf       	out	0x3d, r28	; 61
    /* Create socket without any socket options */
    csp_socket_t *sock = csp_socket(CSP_SO_NONE);
    2718:	60 e0       	ldi	r22, 0x00	; 0
    271a:	70 e0       	ldi	r23, 0x00	; 0
    271c:	cb 01       	movw	r24, r22
    271e:	0e 94 a8 21 	call	0x4350	; 0x4350 <csp_socket>
    2722:	5c 01       	movw	r10, r24

    /* Bind all ports to socket */
    csp_bind(sock, CSP_ANY);
    2724:	60 e2       	ldi	r22, 0x20	; 32
    2726:	0e 94 03 24 	call	0x4806	; 0x4806 <csp_bind>

    /* Create 10 connections backlog queue */
    csp_listen(sock, 10);
    272a:	6a e0       	ldi	r22, 0x0A	; 10
    272c:	70 e0       	ldi	r23, 0x00	; 0
    272e:	c5 01       	movw	r24, r10
    2730:	0e 94 e6 23 	call	0x47cc	; 0x47cc <csp_listen>
    csp_conn_t * conn;
    csp_packet_t * packet;

    /* Process incoming connections */
    while (1) {
csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    2734:	0f 2e       	mov	r0, r31
    2736:	f9 ef       	ldi	r31, 0xF9	; 249
    2738:	cf 2e       	mov	r12, r31
    273a:	f2 e1       	ldi	r31, 0x12	; 18
    273c:	df 2e       	mov	r13, r31
    273e:	f0 2d       	mov	r31, r0
    2740:	68 94       	set
    2742:	55 24       	eor	r5, r5
    2744:	51 f8       	bld	r5, 1

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    2746:	ce 01       	movw	r24, r28
    2748:	01 96       	adiw	r24, 0x01	; 1
    274a:	9c a3       	std	Y+36, r25	; 0x24
    274c:	8b a3       	std	Y+35, r24	; 0x23
    274e:	3e 01       	movw	r6, r28
    2750:	99 e0       	ldi	r25, 0x09	; 9
    2752:	69 0e       	add	r6, r25
    2754:	71 1c       	adc	r7, r1
            break;
        }

        default: {
            /* Set error code in response to no command found */
            packet->data[0] = FIN_CMD_NOT_FOUND;
    2756:	0f 2e       	mov	r0, r31
    2758:	fe ef       	ldi	r31, 0xFE	; 254
    275a:	2f 2e       	mov	r2, r31
    275c:	f0 2d       	mov	r31, r0

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    275e:	eb a1       	ldd	r30, Y+35	; 0x23
    2760:	ed a3       	std	Y+37, r30	; 0x25
    2762:	fc a1       	ldd	r31, Y+36	; 0x24
    2764:	fe a3       	std	Y+38, r31	; 0x26
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    2766:	33 24       	eor	r3, r3
    2768:	33 94       	inc	r3
    276a:	41 2c       	mov	r4, r1
    276c:	83 e2       	ldi	r24, 0x23	; 35
    276e:	8f a3       	std	Y+39, r24	; 0x27
    2770:	18 a6       	std	Y+40, r1	; 0x28
    csp_conn_t * conn;
    csp_packet_t * packet;

    /* Process incoming connections */
    while (1) {
csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	0e 94 c6 3d 	call	0x7b8c	; 0x7b8c <uxTaskGetStackHighWaterMark2>
    277a:	18 2f       	mov	r17, r24
    277c:	09 2f       	mov	r16, r25
    277e:	80 e0       	ldi	r24, 0x00	; 0
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	0e 94 ad 3a 	call	0x755a	; 0x755a <pcTaskGetName>
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    278a:	9f 93       	push	r25
    278c:	8f 93       	push	r24
    278e:	df 92       	push	r13
    2790:	cf 92       	push	r12
    2792:	5f 92       	push	r5
    2794:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
        /* Wait for connection, 10000 ms timeout */
        if ((conn = csp_accept(sock, 10000)) == NULL) {
    2798:	40 e1       	ldi	r20, 0x10	; 16
    279a:	57 e2       	ldi	r21, 0x27	; 39
    279c:	60 e0       	ldi	r22, 0x00	; 0
    279e:	70 e0       	ldi	r23, 0x00	; 0
    27a0:	c5 01       	movw	r24, r10
    27a2:	0e 94 15 22 	call	0x442a	; 0x442a <csp_accept>
    27a6:	8c 01       	movw	r16, r24
    27a8:	0f b6       	in	r0, 0x3f	; 63
    27aa:	f8 94       	cli
    27ac:	de bf       	out	0x3e, r29	; 62
    27ae:	0f be       	out	0x3f, r0	; 63
    27b0:	cd bf       	out	0x3d, r28	; 61
    27b2:	89 2b       	or	r24, r25
    27b4:	f1 f2       	breq	.-68     	; 0x2772 <_Z11task_serverPv+0x6e>
            continue;
        }

        /* Read packets */
        while ((packet = csp_read(conn, 0)) != NULL) { //was 100 in my code
    27b6:	40 e0       	ldi	r20, 0x00	; 0
    27b8:	50 e0       	ldi	r21, 0x00	; 0
    27ba:	ba 01       	movw	r22, r20
    27bc:	c8 01       	movw	r24, r16
    27be:	0e 94 3b 22 	call	0x4476	; 0x4476 <csp_read>
    27c2:	7c 01       	movw	r14, r24
    27c4:	89 2b       	or	r24, r25
    27c6:	09 f4       	brne	.+2      	; 0x27ca <_Z11task_serverPv+0xc6>
    27c8:	61 c0       	rjmp	.+194    	; 0x288c <_Z11task_serverPv+0x188>
            switch (csp_conn_dport(conn)) {
    27ca:	c8 01       	movw	r24, r16
    27cc:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <csp_conn_dport>
    27d0:	4f 97       	sbiw	r24, 0x1f	; 31
    27d2:	09 f0       	breq	.+2      	; 0x27d6 <_Z11task_serverPv+0xd2>
    27d4:	56 c0       	rjmp	.+172    	; 0x2882 <_Z11task_serverPv+0x17e>
static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    uint8_t cmd_id = packet->data[0]; // First byte is command ID

    switch(cmd_id) {
    27d6:	f7 01       	movw	r30, r14
    27d8:	86 85       	ldd	r24, Z+14	; 0x0e
    27da:	81 30       	cpi	r24, 0x01	; 1
    27dc:	b9 f0       	breq	.+46     	; 0x280c <_Z11task_serverPv+0x108>
    27de:	28 f0       	brcs	.+10     	; 0x27ea <_Z11task_serverPv+0xe6>
    27e0:	82 30       	cpi	r24, 0x02	; 2
    27e2:	89 f1       	breq	.+98     	; 0x2846 <_Z11task_serverPv+0x142>
    27e4:	83 30       	cpi	r24, 0x03	; 3
    27e6:	a1 f1       	breq	.+104    	; 0x2850 <_Z11task_serverPv+0x14c>
    27e8:	38 c0       	rjmp	.+112    	; 0x285a <_Z11task_serverPv+0x156>

            /* Get status internally */
            int8_t error = get_fin_status(&status);

            /* Set error code in response */
            packet->data[0] = error;
    27ea:	80 e0       	ldi	r24, 0x00	; 0
    27ec:	f7 01       	movw	r30, r14
    27ee:	86 87       	std	Z+14, r24	; 0x0e

            if (error == FIN_CMD_OK) {
    27f0:	81 11       	cpse	r24, r1
    27f2:	09 c0       	rjmp	.+18     	; 0x2806 <_Z11task_serverPv+0x102>
                /* Copy status to response buffer */
                memcpy(&packet->data[1], &status, sizeof(status));
    27f4:	82 e2       	ldi	r24, 0x22	; 34
    27f6:	ed a1       	ldd	r30, Y+37	; 0x25
    27f8:	fe a1       	ldd	r31, Y+38	; 0x26
    27fa:	d7 01       	movw	r26, r14
    27fc:	1f 96       	adiw	r26, 0x0f	; 15
    27fe:	01 90       	ld	r0, Z+
    2800:	0d 92       	st	X+, r0
    2802:	8a 95       	dec	r24
    2804:	e1 f7       	brne	.-8      	; 0x27fe <_Z11task_serverPv+0xfa>
    2806:	9f a1       	ldd	r25, Y+39	; 0x27
    2808:	88 a5       	ldd	r24, Y+40	; 0x28
    280a:	2b c0       	rjmp	.+86     	; 0x2862 <_Z11task_serverPv+0x15e>

        case GS_FIN_CMD_SET_CUSTOM_POSITION: {
            gs_fin_positions_t pos;

            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));
    280c:	88 e0       	ldi	r24, 0x08	; 8
    280e:	f7 01       	movw	r30, r14
    2810:	3f 96       	adiw	r30, 0x0f	; 15
    2812:	ad a1       	ldd	r26, Y+37	; 0x25
    2814:	be a1       	ldd	r27, Y+38	; 0x26
    2816:	01 90       	ld	r0, Z+
    2818:	0d 92       	st	X+, r0
    281a:	8a 95       	dec	r24
    281c:	e1 f7       	brne	.-8      	; 0x2816 <_Z11task_serverPv+0x112>
    281e:	ce 01       	movw	r24, r28
    2820:	01 96       	adiw	r24, 0x01	; 1
    2822:	4c 01       	movw	r8, r24

            /* Ensure correct endianness */
            uint16_t * pos_array = (uint16_t *) &pos; //(void *)
            for (int i = 0; i < 4; i++) {
                pos_array[i] = csp_ntoh16(pos_array[i]);
    2824:	f4 01       	movw	r30, r8
    2826:	80 81       	ld	r24, Z
    2828:	91 81       	ldd	r25, Z+1	; 0x01
    282a:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <csp_ntoh16>
    282e:	f4 01       	movw	r30, r8
    2830:	81 93       	st	Z+, r24
    2832:	91 93       	st	Z+, r25
    2834:	4f 01       	movw	r8, r30
            /* Copy received positions (angles) to struct */
            memcpy(&pos, &packet->data[1], sizeof(pos));

            /* Ensure correct endianness */
            uint16_t * pos_array = (uint16_t *) &pos; //(void *)
            for (int i = 0; i < 4; i++) {
    2836:	e6 15       	cp	r30, r6
    2838:	f7 05       	cpc	r31, r7
    283a:	a1 f7       	brne	.-24     	; 0x2824 <_Z11task_serverPv+0x120>
            }
            /* Pass positions to internal layer */
            int8_t error = set_fin_pos(&pos);

            /* Set error code in response */
            packet->data[0] = error;
    283c:	f7 01       	movw	r30, r14
    283e:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    2840:	93 2d       	mov	r25, r3
    2842:	84 2d       	mov	r24, r4
    2844:	0e c0       	rjmp	.+28     	; 0x2862 <_Z11task_serverPv+0x15e>
        case GS_FIN_CMD_SET_MAX_DRAG: {
            /* Pass command to internal layer */
            int8_t error = set_max_drag();

            /* Set error code in response */
            packet->data[0] = error;
    2846:	f7 01       	movw	r30, r14
    2848:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    284a:	93 2d       	mov	r25, r3
    284c:	84 2d       	mov	r24, r4
    284e:	09 c0       	rjmp	.+18     	; 0x2862 <_Z11task_serverPv+0x15e>
        case GS_FIN_CMD_SET_MIN_DRAG: {
            /* Pass command to internal layer */
            int8_t error = set_min_drag();

            /* Set error code in response */
            packet->data[0] = error;
    2850:	f7 01       	movw	r30, r14
    2852:	16 86       	std	Z+14, r1	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    2854:	93 2d       	mov	r25, r3
    2856:	84 2d       	mov	r24, r4
    2858:	04 c0       	rjmp	.+8      	; 0x2862 <_Z11task_serverPv+0x15e>
            break;
        }

        default: {
            /* Set error code in response to no command found */
            packet->data[0] = FIN_CMD_NOT_FOUND;
    285a:	f7 01       	movw	r30, r14
    285c:	26 86       	std	Z+14, r2	; 0x0e
	}


static void process_fin_cmd(csp_conn_t * conn, csp_packet_t * packet)
{
    uint16_t reply_length = 1;
    285e:	93 2d       	mov	r25, r3
    2860:	84 2d       	mov	r24, r4
            break;
        }
    }

    /* Send response */
    packet->length = reply_length;
    2862:	f7 01       	movw	r30, r14
    2864:	90 87       	std	Z+8, r25	; 0x08
    2866:	81 87       	std	Z+9, r24	; 0x09
    if (!csp_send(conn, packet, 0)) {
    2868:	20 e0       	ldi	r18, 0x00	; 0
    286a:	30 e0       	ldi	r19, 0x00	; 0
    286c:	a9 01       	movw	r20, r18
    286e:	b7 01       	movw	r22, r14
    2870:	c8 01       	movw	r24, r16
    2872:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <csp_send>
    2876:	89 2b       	or	r24, r25
    2878:	09 f0       	breq	.+2      	; 0x287c <_Z11task_serverPv+0x178>
    287a:	9d cf       	rjmp	.-198    	; 0x27b6 <_Z11task_serverPv+0xb2>
        csp_buffer_free(packet);
    287c:	c7 01       	movw	r24, r14
    287e:	6a d6       	rcall	.+3284   	; 0x3554 <csp_buffer_free>
    2880:	9a cf       	rjmp	.-204    	; 0x27b6 <_Z11task_serverPv+0xb2>
                    process_fin_cmd(conn, packet);
                    break;

                default:
                    /* Let the service handler reply pings, buffer use, etc. */
                    csp_service_handler(conn, packet);
    2882:	b7 01       	movw	r22, r14
    2884:	c8 01       	movw	r24, r16
    2886:	0e 94 97 28 	call	0x512e	; 0x512e <csp_service_handler>
                    break;
    288a:	95 cf       	rjmp	.-214    	; 0x27b6 <_Z11task_serverPv+0xb2>
            }
        }

        /* Close current connection, and handle next */
        csp_close(conn);
    288c:	c8 01       	movw	r24, r16
    288e:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <csp_close>
    2892:	6f cf       	rjmp	.-290    	; 0x2772 <_Z11task_serverPv+0x6e>

00002894 <_Z17stepper_1_cs_initv>:
};

//functions for controlling certain pins of steppers

void stepper_1_cs_init(void) {
	PORTJ|=(1<<PJ6); //for enable pin
    2894:	e5 e0       	ldi	r30, 0x05	; 5
    2896:	f1 e0       	ldi	r31, 0x01	; 1
    2898:	80 81       	ld	r24, Z
    289a:	80 64       	ori	r24, 0x40	; 64
    289c:	80 83       	st	Z, r24
	PORTH|=(1<<PH6); // for cs pin
    289e:	e2 e0       	ldi	r30, 0x02	; 2
    28a0:	f1 e0       	ldi	r31, 0x01	; 1
    28a2:	80 81       	ld	r24, Z
    28a4:	80 64       	ori	r24, 0x40	; 64
    28a6:	80 83       	st	Z, r24
	DDRJ&=~(1<<PJ6);
    28a8:	e4 e0       	ldi	r30, 0x04	; 4
    28aa:	f1 e0       	ldi	r31, 0x01	; 1
    28ac:	80 81       	ld	r24, Z
    28ae:	8f 7b       	andi	r24, 0xBF	; 191
    28b0:	80 83       	st	Z, r24
	DDRH|=(1<<PH6);
    28b2:	e1 e0       	ldi	r30, 0x01	; 1
    28b4:	f1 e0       	ldi	r31, 0x01	; 1
    28b6:	80 81       	ld	r24, Z
    28b8:	80 64       	ori	r24, 0x40	; 64
    28ba:	80 83       	st	Z, r24
    28bc:	08 95       	ret

000028be <_Z14stepper_1_csonv>:
}

void stepper_1_cson(void) {
	DDRH&=~(1<<PH6);
    28be:	e1 e0       	ldi	r30, 0x01	; 1
    28c0:	f1 e0       	ldi	r31, 0x01	; 1
    28c2:	80 81       	ld	r24, Z
    28c4:	8f 7b       	andi	r24, 0xBF	; 191
    28c6:	80 83       	st	Z, r24
    28c8:	08 95       	ret

000028ca <_Z15stepper_1_csoffv>:
}

void stepper_1_csoff(void) {
	DDRH|=(1<<PH6);
    28ca:	e1 e0       	ldi	r30, 0x01	; 1
    28cc:	f1 e0       	ldi	r31, 0x01	; 1
    28ce:	80 81       	ld	r24, Z
    28d0:	80 64       	ori	r24, 0x40	; 64
    28d2:	80 83       	st	Z, r24
    28d4:	08 95       	ret

000028d6 <_Z12stepper_1_env>:
}

void stepper_1_en(void) {
	DDRJ&=~(1<<PJ6);
    28d6:	e4 e0       	ldi	r30, 0x04	; 4
    28d8:	f1 e0       	ldi	r31, 0x01	; 1
    28da:	80 81       	ld	r24, Z
    28dc:	8f 7b       	andi	r24, 0xBF	; 191
    28de:	80 83       	st	Z, r24
    28e0:	08 95       	ret

000028e2 <_Z13stepper_1_disv>:
}

void stepper_1_dis(void) {
	DDRJ|=(1<<PJ6);
    28e2:	e4 e0       	ldi	r30, 0x04	; 4
    28e4:	f1 e0       	ldi	r31, 0x01	; 1
    28e6:	80 81       	ld	r24, Z
    28e8:	80 64       	ori	r24, 0x40	; 64
    28ea:	80 83       	st	Z, r24
    28ec:	08 95       	ret

000028ee <_Z17stepper_2_cs_initv>:
}

void stepper_2_cs_init(void) {
	PORTJ|=(1<<PJ5); //for enable pin
    28ee:	e5 e0       	ldi	r30, 0x05	; 5
    28f0:	f1 e0       	ldi	r31, 0x01	; 1
    28f2:	80 81       	ld	r24, Z
    28f4:	80 62       	ori	r24, 0x20	; 32
    28f6:	80 83       	st	Z, r24
	PORTL|=(1<<PL5); // for cs pin
    28f8:	eb e0       	ldi	r30, 0x0B	; 11
    28fa:	f1 e0       	ldi	r31, 0x01	; 1
    28fc:	80 81       	ld	r24, Z
    28fe:	80 62       	ori	r24, 0x20	; 32
    2900:	80 83       	st	Z, r24
	DDRJ&=~(1<<PJ5);
    2902:	e4 e0       	ldi	r30, 0x04	; 4
    2904:	f1 e0       	ldi	r31, 0x01	; 1
    2906:	80 81       	ld	r24, Z
    2908:	8f 7d       	andi	r24, 0xDF	; 223
    290a:	80 83       	st	Z, r24
	DDRL|=(1<<PL5);
    290c:	ea e0       	ldi	r30, 0x0A	; 10
    290e:	f1 e0       	ldi	r31, 0x01	; 1
    2910:	80 81       	ld	r24, Z
    2912:	80 62       	ori	r24, 0x20	; 32
    2914:	80 83       	st	Z, r24
    2916:	08 95       	ret

00002918 <_Z14stepper_2_csonv>:
}

void stepper_2_cson(void) {
	DDRL&=~(1<<PL5);
    2918:	ea e0       	ldi	r30, 0x0A	; 10
    291a:	f1 e0       	ldi	r31, 0x01	; 1
    291c:	80 81       	ld	r24, Z
    291e:	8f 7d       	andi	r24, 0xDF	; 223
    2920:	80 83       	st	Z, r24
    2922:	08 95       	ret

00002924 <_Z15stepper_2_csoffv>:
	
}

void stepper_2_csoff(void) {
	DDRL|=(1<<PL5);
    2924:	ea e0       	ldi	r30, 0x0A	; 10
    2926:	f1 e0       	ldi	r31, 0x01	; 1
    2928:	80 81       	ld	r24, Z
    292a:	80 62       	ori	r24, 0x20	; 32
    292c:	80 83       	st	Z, r24
    292e:	08 95       	ret

00002930 <_Z12stepper_2_env>:
}

void stepper_2_en(void) {
	DDRJ&=~(1<<PJ5);
    2930:	e4 e0       	ldi	r30, 0x04	; 4
    2932:	f1 e0       	ldi	r31, 0x01	; 1
    2934:	80 81       	ld	r24, Z
    2936:	8f 7d       	andi	r24, 0xDF	; 223
    2938:	80 83       	st	Z, r24
    293a:	08 95       	ret

0000293c <_Z13stepper_2_disv>:
}

void stepper_2_dis(void) {
	DDRJ|=(1<<PJ5);
    293c:	e4 e0       	ldi	r30, 0x04	; 4
    293e:	f1 e0       	ldi	r31, 0x01	; 1
    2940:	80 81       	ld	r24, Z
    2942:	80 62       	ori	r24, 0x20	; 32
    2944:	80 83       	st	Z, r24
    2946:	08 95       	ret

00002948 <_Z14get_fin_statusP13gs_fin_status>:

//get currents

//get mode

}
    2948:	08 95       	ret

0000294a <_Z11set_fin_posPK16gs_fin_positions>:



gs_fin_cmd_error_t set_fin_pos(const gs_fin_positions_t * pos) {}
    294a:	08 95       	ret

0000294c <_Z12set_max_dragv>:

gs_fin_cmd_error_t set_max_drag(void) {}
    294c:	08 95       	ret

0000294e <_Z12set_min_dragv>:

gs_fin_cmd_error_t set_min_drag(void) {}
    294e:	08 95       	ret

00002950 <_Z12change_ustepv>:
	
gs_fin_cmd_error_t change_ustep(void) {
	
	//When operating at less than 16 times microstepping, be sure to first position to a suitable, symmetric switching position, before changing MRES, otherwise the motor behavior may differ for left and right rotation. For 16 times microstepping, interpolation to 256 microsteps gives best results!
	
}
    2950:	08 95       	ret

00002952 <_Z18setup_temp_sensorsv>:

	void setup_temp_sensors(void) {
		ADMUX=0x40;
    2952:	80 e4       	ldi	r24, 0x40	; 64
    2954:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7c007c>
		ADCSRA=0b10000100; //set adc clock
    2958:	84 e8       	ldi	r24, 0x84	; 132
    295a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7c007a>
		ADCSRB=0x00; 
    295e:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7c007b>
		DIDR0=0x0F; //turn of digital input bufs
    2962:	8f e0       	ldi	r24, 0x0F	; 15
    2964:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7c007e>
    2968:	08 95       	ret

0000296a <_Z17read_temp_sensorsPj>:
		
	}

	void read_temp_sensors(uint16_t *array){
    296a:	dc 01       	movw	r26, r24
		double tempstore=0;
		portENTER_CRITICAL();
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	f8 94       	cli
    2970:	0f 92       	push	r0
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK1;
    2972:	ec e7       	ldi	r30, 0x7C	; 124
    2974:	f0 e0       	ldi	r31, 0x00	; 0
    2976:	80 81       	ld	r24, Z
    2978:	80 7f       	andi	r24, 0xF0	; 240
    297a:	83 60       	ori	r24, 0x03	; 3
    297c:	80 83       	st	Z, r24
		ADCSRA|=(1<<ADSC);
    297e:	ea e7       	ldi	r30, 0x7A	; 122
    2980:	f0 e0       	ldi	r31, 0x00	; 0
    2982:	80 81       	ld	r24, Z
    2984:	80 64       	ori	r24, 0x40	; 64
    2986:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    2988:	90 81       	ld	r25, Z
    298a:	96 fd       	sbrc	r25, 6
    298c:	fd cf       	rjmp	.-6      	; 0x2988 <_Z17read_temp_sensorsPj+0x1e>
		//tempstore=(TEMP_RES_VAL*ADC)/(1024-ADC);    //sort this out
		//*(array)=(uint16_t)(TEMP_CAL_BETA/(log((tempstore)/TEMP_RES_INF));
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK2;
    298e:	ec e7       	ldi	r30, 0x7C	; 124
    2990:	f0 e0       	ldi	r31, 0x00	; 0
    2992:	90 81       	ld	r25, Z
    2994:	90 7f       	andi	r25, 0xF0	; 240
    2996:	92 60       	ori	r25, 0x02	; 2
    2998:	90 83       	st	Z, r25
		ADCSRA|=(1<<ADSC);
    299a:	ea e7       	ldi	r30, 0x7A	; 122
    299c:	f0 e0       	ldi	r31, 0x00	; 0
    299e:	80 81       	ld	r24, Z
    29a0:	80 64       	ori	r24, 0x40	; 64
    29a2:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    29a4:	90 81       	ld	r25, Z
    29a6:	96 fd       	sbrc	r25, 6
    29a8:	fd cf       	rjmp	.-6      	; 0x29a4 <_Z17read_temp_sensorsPj+0x3a>
		*(array+1)=ADC;
    29aa:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    29ae:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    29b2:	13 96       	adiw	r26, 0x03	; 3
    29b4:	9c 93       	st	X, r25
    29b6:	8e 93       	st	-X, r24
    29b8:	12 97       	sbiw	r26, 0x02	; 2
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK3;
    29ba:	ec e7       	ldi	r30, 0x7C	; 124
    29bc:	f0 e0       	ldi	r31, 0x00	; 0
    29be:	90 81       	ld	r25, Z
    29c0:	90 7f       	andi	r25, 0xF0	; 240
    29c2:	91 60       	ori	r25, 0x01	; 1
    29c4:	90 83       	st	Z, r25
		ADCSRA|=(1<<ADSC);
    29c6:	ea e7       	ldi	r30, 0x7A	; 122
    29c8:	f0 e0       	ldi	r31, 0x00	; 0
    29ca:	80 81       	ld	r24, Z
    29cc:	80 64       	ori	r24, 0x40	; 64
    29ce:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    29d0:	90 81       	ld	r25, Z
    29d2:	96 fd       	sbrc	r25, 6
    29d4:	fd cf       	rjmp	.-6      	; 0x29d0 <_Z17read_temp_sensorsPj+0x66>
		*(array+2)=ADC;
    29d6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    29da:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    29de:	15 96       	adiw	r26, 0x05	; 5
    29e0:	9c 93       	st	X, r25
    29e2:	8e 93       	st	-X, r24
    29e4:	14 97       	sbiw	r26, 0x04	; 4
		
		ADMUX=(ADMUX&~(0x0F))|TEMP_MASK4;
    29e6:	ec e7       	ldi	r30, 0x7C	; 124
    29e8:	f0 e0       	ldi	r31, 0x00	; 0
    29ea:	80 81       	ld	r24, Z
    29ec:	80 7f       	andi	r24, 0xF0	; 240
    29ee:	80 83       	st	Z, r24
		ADCSRA|=(1<<ADSC);
    29f0:	ea e7       	ldi	r30, 0x7A	; 122
    29f2:	f0 e0       	ldi	r31, 0x00	; 0
    29f4:	80 81       	ld	r24, Z
    29f6:	80 64       	ori	r24, 0x40	; 64
    29f8:	80 83       	st	Z, r24
		while(ADCSRA&(1<<ADSC));
    29fa:	90 81       	ld	r25, Z
    29fc:	96 fd       	sbrc	r25, 6
    29fe:	fd cf       	rjmp	.-6      	; 0x29fa <_Z17read_temp_sensorsPj+0x90>
		*(array+3)=ADC;
    2a00:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
    2a04:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
    2a08:	17 96       	adiw	r26, 0x07	; 7
    2a0a:	9c 93       	st	X, r25
    2a0c:	8e 93       	st	-X, r24
    2a0e:	16 97       	sbiw	r26, 0x06	; 6
		portEXIT_CRITICAL();
    2a10:	0f 90       	pop	r0
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	08 95       	ret

00002a16 <_Z11init_serverv>:
    return CSP_TASK_RETURN;
}



gs_fin_cmd_error_t init_server(void) {
    2a16:	ef 92       	push	r14
    2a18:	ff 92       	push	r15
    2a1a:	0f 93       	push	r16
	tmc2041(void (csinitin()),void (csonin()),void (csoffin()),void (enstepin()), void (disstepin()),
	uniman_step_config_t configin) : csinit(csinitin), cson(csonin), csoff(csoffin) , enstep(enstepin),
	disstep(disstepin) {
		
		config=configin;
		csinit();
    2a1c:	1f 93       	push	r17
    2a1e:	3a df       	rcall	.-396    	; 0x2894 <_Z17stepper_1_cs_initv>
    2a20:	66 df       	rcall	.-308    	; 0x28ee <_Z17stepper_2_cs_initv>
		
	tmc2041 stepper1(&stepper_1_cs_init,&stepper_1_cson,&stepper_1_csoff,&stepper_1_en, &stepper_1_dis,  uniman_step1_conf);
	tmc2041 stepper2(&stepper_2_cs_init,&stepper_2_cson,&stepper_2_csoff,&stepper_2_en, &stepper_2_dis,  uniman_step2_conf);	
	
	
	if(!csp_thread_create(task_server, "SERVER", 270, NULL, 2, &handle_server)) {
    2a22:	0f 2e       	mov	r0, r31
    2a24:	f0 e7       	ldi	r31, 0x70	; 112
    2a26:	ef 2e       	mov	r14, r31
    2a28:	f6 e0       	ldi	r31, 0x06	; 6
    2a2a:	ff 2e       	mov	r15, r31
    2a2c:	f0 2d       	mov	r31, r0
    2a2e:	02 e0       	ldi	r16, 0x02	; 2
    2a30:	10 e0       	ldi	r17, 0x00	; 0
    2a32:	20 e0       	ldi	r18, 0x00	; 0
    2a34:	30 e0       	ldi	r19, 0x00	; 0
    2a36:	4e e0       	ldi	r20, 0x0E	; 14
    2a38:	51 e0       	ldi	r21, 0x01	; 1
    2a3a:	6b ec       	ldi	r22, 0xCB	; 203
    2a3c:	72 e0       	ldi	r23, 0x02	; 2
    2a3e:	82 e8       	ldi	r24, 0x82	; 130
    2a40:	93 e1       	ldi	r25, 0x13	; 19
    2a42:	19 d4       	rcall	.+2098   	; 0x3276 <csp_thread_create>
    2a44:	21 e0       	ldi	r18, 0x01	; 1
    2a46:	89 2b       	or	r24, r25
    2a48:	09 f4       	brne	.+2      	; 0x2a4c <_Z11init_serverv+0x36>
    2a4a:	20 e0       	ldi	r18, 0x00	; 0

	//should also initalise other things such as temp sensors and steppers here
	
	//also remember to initalise the status frame
	
}
    2a4c:	82 2f       	mov	r24, r18
    2a4e:	81 95       	neg	r24
    2a50:	1f 91       	pop	r17
    2a52:	0f 91       	pop	r16
    2a54:	ff 90       	pop	r15
    2a56:	ef 90       	pop	r14
    2a58:	08 95       	ret

00002a5a <_ZN8SPIClass5beginEv>:

//PB4 is CS pin for CAN controller

void SPIClass::begin()
{
  uint8_t sreg = SREG;
    2a5a:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2a5c:	f8 94       	cli
  if (!initialized) {
    2a5e:	80 91 67 20 	lds	r24, 0x2067	; 0x802067 <_ZN8SPIClass11initializedE>
    2a62:	81 11       	cpse	r24, r1
    2a64:	0f c0       	rjmp	.+30     	; 0x2a84 <_ZN8SPIClass5beginEv+0x2a>
    // Set SS to high so a connected chip will be "deselected" by default
   // uint8_t port = digitalPinToPort(SS);
    //uint8_t bit = digitalPinToBitMask(SS);
    //volatile uint8_t *reg = portModeRegister(port);
	
	DDRB|=(1<<PB4); // sets SS to output
    2a66:	24 9a       	sbi	0x04, 4	; 4
	DDRB|=(1<<PB0);
    2a68:	20 9a       	sbi	0x04, 0	; 4
	PORTB|=(1<<PB0);
    2a6a:	28 9a       	sbi	0x05, 0	; 5

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
	
	PORTB|=(1<<PB4); // then set SS high
    2a6c:	2c 9a       	sbi	0x05, 4	; 5
   // pinMode(SS, OUTPUT);

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
		DDRB|=(1<<PB1); //set SCK out
    2a6e:	21 9a       	sbi	0x04, 1	; 4
		DDRB|=(1<<PB2); // set MOSI out
    2a70:	22 9a       	sbi	0x04, 2	; 4

	
	
    SPCR |= (1<<(MSTR));
    2a72:	8c b5       	in	r24, 0x2c	; 44
    2a74:	80 61       	ori	r24, 0x10	; 16
    2a76:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<(SPE));
    2a78:	8c b5       	in	r24, 0x2c	; 44
    2a7a:	80 64       	ori	r24, 0x40	; 64
    2a7c:	8c bd       	out	0x2c, r24	; 44
	SPCR |= (1<<(SPR0)) | (1<<SPR1);
    2a7e:	8c b5       	in	r24, 0x2c	; 44
    2a80:	83 60       	ori	r24, 0x03	; 3
    2a82:	8c bd       	out	0x2c, r24	; 44


    //pinMode(SCK, OUTPUT);
    //pinMode(MOSI, OUTPUT);
  }
  initialized++; // reference count
    2a84:	80 91 67 20 	lds	r24, 0x2067	; 0x802067 <_ZN8SPIClass11initializedE>
    2a88:	8f 5f       	subi	r24, 0xFF	; 255
    2a8a:	80 93 67 20 	sts	0x2067, r24	; 0x802067 <_ZN8SPIClass11initializedE>
  SREG = sreg;
    2a8e:	9f bf       	out	0x3f, r25	; 63
    2a90:	08 95       	ret

00002a92 <_ZN8SPIClass3endEv>:
}

void SPIClass::end() {
  uint8_t sreg = SREG;
    2a92:	9f b7       	in	r25, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2a94:	f8 94       	cli
  // Decrease the reference counter
  if (initialized)
    2a96:	80 91 67 20 	lds	r24, 0x2067	; 0x802067 <_ZN8SPIClass11initializedE>
    2a9a:	88 23       	and	r24, r24
    2a9c:	29 f0       	breq	.+10     	; 0x2aa8 <_ZN8SPIClass3endEv+0x16>
    initialized--;
    2a9e:	81 50       	subi	r24, 0x01	; 1
    2aa0:	80 93 67 20 	sts	0x2067, r24	; 0x802067 <_ZN8SPIClass11initializedE>
  // If there are no more references disable SPI
  if (!initialized) {
    2aa4:	81 11       	cpse	r24, r1
    2aa6:	05 c0       	rjmp	.+10     	; 0x2ab2 <_ZN8SPIClass3endEv+0x20>
    SPCR &= ~(1<<(SPE));
    2aa8:	8c b5       	in	r24, 0x2c	; 44
    2aaa:	8f 7b       	andi	r24, 0xBF	; 191
    2aac:	8c bd       	out	0x2c, r24	; 44
    interruptMode = 0;
    2aae:	10 92 66 20 	sts	0x2066, r1	; 0x802066 <_ZN8SPIClass13interruptModeE>
    #ifdef SPI_TRANSACTION_MISMATCH_LED
    inTransactionFlag = 0;
    #endif
  }
  SREG = sreg;
    2ab2:	9f bf       	out	0x3f, r25	; 63
    2ab4:	08 95       	ret

00002ab6 <_ZN8SPIClass14usingInterruptEh>:
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    2ab6:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2ab8:	f8 94       	cli
  switch (interruptNumber) {
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	88 30       	cpi	r24, 0x08	; 8
    2abe:	91 05       	cpc	r25, r1
    2ac0:	a8 f4       	brcc	.+42     	; 0x2aec <_ZN8SPIClass14usingInterruptEh+0x36>
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	88 27       	eor	r24, r24
    2ac6:	e1 54       	subi	r30, 0x41	; 65
    2ac8:	ff 4f       	sbci	r31, 0xFF	; 255
    2aca:	8f 4f       	sbci	r24, 0xFF	; 255
    2acc:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    2ad0:	80 e2       	ldi	r24, 0x20	; 32
    2ad2:	12 c0       	rjmp	.+36     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    2ad4:	81 e0       	ldi	r24, 0x01	; 1
    2ad6:	10 c0       	rjmp	.+32     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    2ad8:	82 e0       	ldi	r24, 0x02	; 2
    2ada:	0e c0       	rjmp	.+28     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    2adc:	84 e0       	ldi	r24, 0x04	; 4
    2ade:	0c c0       	rjmp	.+24     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    2ae0:	88 e0       	ldi	r24, 0x08	; 8
    2ae2:	0a c0       	rjmp	.+20     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    2ae4:	80 e4       	ldi	r24, 0x40	; 64
    2ae6:	08 c0       	rjmp	.+16     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    2ae8:	80 e8       	ldi	r24, 0x80	; 128
    2aea:	06 c0       	rjmp	.+12     	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  #endif
  default:
    interruptMode = 2;
    2aec:	82 e0       	ldi	r24, 0x02	; 2
    2aee:	80 93 66 20 	sts	0x2066, r24	; 0x802066 <_ZN8SPIClass13interruptModeE>
  #endif
#endif

void SPIClass::usingInterrupt(uint8_t interruptNumber)
{
  uint8_t mask = 0;
    2af2:	80 e0       	ldi	r24, 0x00	; 0
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
  #endif
  default:
    interruptMode = 2;
    break;
    2af4:	01 c0       	rjmp	.+2      	; 0x2af8 <_ZN8SPIClass14usingInterruptEh+0x42>
  uint8_t mask = 0;
  uint8_t sreg = SREG;
  cli(); // Protect from a scheduler and prevent transactionBegin
  switch (interruptNumber) {
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    2af6:	80 e1       	ldi	r24, 0x10	; 16
  #endif
  default:
    interruptMode = 2;
    break;
  }
  interruptMask |= mask;
    2af8:	90 91 65 20 	lds	r25, 0x2065	; 0x802065 <_ZN8SPIClass13interruptMaskE>
    2afc:	89 2b       	or	r24, r25
    2afe:	80 93 65 20 	sts	0x2065, r24	; 0x802065 <_ZN8SPIClass13interruptMaskE>
  if (!interruptMode)
    2b02:	80 91 66 20 	lds	r24, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    2b06:	81 11       	cpse	r24, r1
    2b08:	03 c0       	rjmp	.+6      	; 0x2b10 <_ZN8SPIClass14usingInterruptEh+0x5a>
    interruptMode = 1;
    2b0a:	81 e0       	ldi	r24, 0x01	; 1
    2b0c:	80 93 66 20 	sts	0x2066, r24	; 0x802066 <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    2b10:	2f bf       	out	0x3f, r18	; 63
    2b12:	08 95       	ret

00002b14 <_ZN8SPIClass17notUsingInterruptEh>:
}

void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    2b14:	90 91 66 20 	lds	r25, 0x2066	; 0x802066 <_ZN8SPIClass13interruptModeE>
    2b18:	92 30       	cpi	r25, 0x02	; 2
    2b1a:	49 f1       	breq	.+82     	; 0x2b6e <_ZN8SPIClass17notUsingInterruptEh+0x5a>
    return;
  uint8_t mask = 0;
  uint8_t sreg = SREG;
    2b1c:	2f b7       	in	r18, 0x3f	; 63
  cli(); // Protect from a scheduler and prevent transactionBegin
    2b1e:	f8 94       	cli
  switch (interruptNumber) {
    2b20:	90 e0       	ldi	r25, 0x00	; 0
    2b22:	88 30       	cpi	r24, 0x08	; 8
    2b24:	91 05       	cpc	r25, r1
    2b26:	b8 f4       	brcc	.+46     	; 0x2b56 <_ZN8SPIClass17notUsingInterruptEh+0x42>
    2b28:	fc 01       	movw	r30, r24
    2b2a:	88 27       	eor	r24, r24
    2b2c:	e9 53       	subi	r30, 0x39	; 57
    2b2e:	ff 4f       	sbci	r31, 0xFF	; 255
    2b30:	8f 4f       	sbci	r24, 0xFF	; 255
    2b32:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
  #ifdef SPI_INT0_MASK
  case 0: mask = SPI_INT0_MASK; break;
    2b36:	80 e1       	ldi	r24, 0x10	; 16
    2b38:	0f c0       	rjmp	.+30     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT1_MASK
  case 1: mask = SPI_INT1_MASK; break;
    2b3a:	80 e2       	ldi	r24, 0x20	; 32
    2b3c:	0d c0       	rjmp	.+26     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT2_MASK
  case 2: mask = SPI_INT2_MASK; break;
    2b3e:	81 e0       	ldi	r24, 0x01	; 1
    2b40:	0b c0       	rjmp	.+22     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT3_MASK
  case 3: mask = SPI_INT3_MASK; break;
    2b42:	82 e0       	ldi	r24, 0x02	; 2
    2b44:	09 c0       	rjmp	.+18     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT4_MASK
  case 4: mask = SPI_INT4_MASK; break;
    2b46:	84 e0       	ldi	r24, 0x04	; 4
    2b48:	07 c0       	rjmp	.+14     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT5_MASK
  case 5: mask = SPI_INT5_MASK; break;
    2b4a:	88 e0       	ldi	r24, 0x08	; 8
    2b4c:	05 c0       	rjmp	.+10     	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT6_MASK
  case 6: mask = SPI_INT6_MASK; break;
    2b4e:	80 e4       	ldi	r24, 0x40	; 64
    2b50:	03 c0       	rjmp	.+6      	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
  #endif
  #ifdef SPI_INT7_MASK
  case 7: mask = SPI_INT7_MASK; break;
    2b52:	80 e8       	ldi	r24, 0x80	; 128
    2b54:	01 c0       	rjmp	.+2      	; 0x2b58 <_ZN8SPIClass17notUsingInterruptEh+0x44>
void SPIClass::notUsingInterrupt(uint8_t interruptNumber)
{
  // Once in mode 2 we can't go back to 0 without a proper reference count
  if (interruptMode == 2)
    return;
  uint8_t mask = 0;
    2b56:	80 e0       	ldi	r24, 0x00	; 0
  #endif
  default:
    break;
    // this case can't be reached
  }
  interruptMask &= ~mask;
    2b58:	80 95       	com	r24
    2b5a:	90 91 65 20 	lds	r25, 0x2065	; 0x802065 <_ZN8SPIClass13interruptMaskE>
    2b5e:	89 23       	and	r24, r25
    2b60:	80 93 65 20 	sts	0x2065, r24	; 0x802065 <_ZN8SPIClass13interruptMaskE>
  if (!interruptMask)
    2b64:	81 11       	cpse	r24, r1
    2b66:	02 c0       	rjmp	.+4      	; 0x2b6c <_ZN8SPIClass17notUsingInterruptEh+0x58>
    interruptMode = 0;
    2b68:	10 92 66 20 	sts	0x2066, r1	; 0x802066 <_ZN8SPIClass13interruptModeE>
  SREG = sreg;
    2b6c:	2f bf       	out	0x3f, r18	; 63
    2b6e:	08 95       	ret

00002b70 <_ZL4wdtrPv>:
}
/*-----------------------------------------------------------*/


static void wdtr(void* pvParameters) {
	 wdt_reset();
    2b70:	a8 95       	wdr
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
    2b72:	9d e0       	ldi	r25, 0x0D	; 13
    2b74:	88 e1       	ldi	r24, 0x18	; 24
    2b76:	0f b6       	in	r0, 0x3f	; 63
    2b78:	f8 94       	cli
    2b7a:	a8 95       	wdr
    2b7c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    2b80:	0f be       	out	0x3f, r0	; 63
    2b82:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
	 wdt_enable(WDTO_500MS);
	 
	 int a =0;
	 
	for(;;) {
	wdt_reset();
    2b86:	a8 95       	wdr
	vTaskDelay(200/ portTICK_PERIOD_MS);
    2b88:	84 e1       	ldi	r24, 0x14	; 20
    2b8a:	90 e0       	ldi	r25, 0x00	; 0
    2b8c:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <vTaskDelay>
	contled(TOGCON,0);
    2b90:	60 e0       	ldi	r22, 0x00	; 0
    2b92:	70 e0       	ldi	r23, 0x00	; 0
    2b94:	80 e0       	ldi	r24, 0x00	; 0
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	30 dd       	rcall	.-1440   	; 0x25fa <_Z7contledii>
    2b9a:	f5 cf       	rjmp	.-22     	; 0x2b86 <_ZL4wdtrPv+0x16>

00002b9c <_Z11task_clientPv>:
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    2b9c:	0f 2e       	mov	r0, r31
    2b9e:	f9 e4       	ldi	r31, 0x49	; 73
    2ba0:	af 2e       	mov	r10, r31
    2ba2:	f3 e1       	ldi	r31, 0x13	; 19
    2ba4:	bf 2e       	mov	r11, r31
    2ba6:	f0 2d       	mov	r31, r0
    2ba8:	12 e0       	ldi	r17, 0x02	; 2
		volatile unsigned int *sp=(volatile unsigned int *)SP;
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
		csp_log_info("SP = 0x%04x\n",StackP);;
    2baa:	0f 2e       	mov	r0, r31
    2bac:	fc e3       	ldi	r31, 0x3C	; 60
    2bae:	cf 2e       	mov	r12, r31
    2bb0:	f3 e1       	ldi	r31, 0x13	; 19
    2bb2:	df 2e       	mov	r13, r31
    2bb4:	f0 2d       	mov	r31, r0
		int result = csp_ping(1, 100, 10, CSP_O_NONE);

		if (result==-1) {csp_log_error("Ping Failed\n");}
    2bb6:	0f 2e       	mov	r0, r31
    2bb8:	ff e2       	ldi	r31, 0x2F	; 47
    2bba:	8f 2e       	mov	r8, r31
    2bbc:	f3 e1       	ldi	r31, 0x13	; 19
    2bbe:	9f 2e       	mov	r9, r31
    2bc0:	f0 2d       	mov	r31, r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    2bc2:	0f 2e       	mov	r0, r31
    2bc4:	f9 e1       	ldi	r31, 0x19	; 25
    2bc6:	ef 2e       	mov	r14, r31
    2bc8:	f3 e1       	ldi	r31, 0x13	; 19
    2bca:	ff 2e       	mov	r15, r31
    2bcc:	f0 2d       	mov	r31, r0
	for(;;) {

		/**
		 * Try ping
		 */
	csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    2bce:	80 e0       	ldi	r24, 0x00	; 0
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	0e 94 c6 3d 	call	0x7b8c	; 0x7b8c <uxTaskGetStackHighWaterMark2>
    2bd6:	c8 2f       	mov	r28, r24
    2bd8:	d9 2f       	mov	r29, r25
    2bda:	80 e0       	ldi	r24, 0x00	; 0
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	0e 94 ad 3a 	call	0x755a	; 0x755a <pcTaskGetName>
    2be2:	df 93       	push	r29
    2be4:	cf 93       	push	r28
    2be6:	9f 93       	push	r25
    2be8:	8f 93       	push	r24
    2bea:	bf 92       	push	r11
    2bec:	af 92       	push	r10
    2bee:	1f 93       	push	r17
    2bf0:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		csp_sleep_ms(1000);
    2bf4:	84 e6       	ldi	r24, 0x64	; 100
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <vTaskDelay>
		
		//int *sph = 0x3E;
		//volatile unsigned int *sph = (volatile unsigned int *)0x5E;
		//volatile unsigned int *spl = (volatile unsigned int *)0x5D;
		volatile unsigned int *sp=(volatile unsigned int *)SP;
    2bfc:	ed b7       	in	r30, 0x3d	; 61
    2bfe:	fe b7       	in	r31, 0x3e	; 62
		
		
		//uint16_t StackP = ((*(sph))<<8)+(*(spl));
		int StackP= *sp;
    2c00:	80 81       	ld	r24, Z
    2c02:	91 81       	ldd	r25, Z+1	; 0x01
		csp_log_info("SP = 0x%04x\n",StackP);;
    2c04:	9f 93       	push	r25
    2c06:	8f 93       	push	r24
    2c08:	df 92       	push	r13
    2c0a:	cf 92       	push	r12
    2c0c:	1f 93       	push	r17
    2c0e:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		int result = csp_ping(1, 100, 10, CSP_O_NONE);
    2c12:	00 e0       	ldi	r16, 0x00	; 0
    2c14:	2a e0       	ldi	r18, 0x0A	; 10
    2c16:	30 e0       	ldi	r19, 0x00	; 0
    2c18:	44 e6       	ldi	r20, 0x64	; 100
    2c1a:	50 e0       	ldi	r21, 0x00	; 0
    2c1c:	60 e0       	ldi	r22, 0x00	; 0
    2c1e:	70 e0       	ldi	r23, 0x00	; 0
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	0e 94 db 27 	call	0x4fb6	; 0x4fb6 <csp_ping>
    2c26:	ec 01       	movw	r28, r24

		if (result==-1) {csp_log_error("Ping Failed\n");}
    2c28:	8d b7       	in	r24, 0x3d	; 61
    2c2a:	9e b7       	in	r25, 0x3e	; 62
    2c2c:	0c 96       	adiw	r24, 0x0c	; 12
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	9e bf       	out	0x3e, r25	; 62
    2c34:	0f be       	out	0x3f, r0	; 63
    2c36:	8d bf       	out	0x3d, r24	; 61
    2c38:	cf 3f       	cpi	r28, 0xFF	; 255
    2c3a:	9f ef       	ldi	r25, 0xFF	; 255
    2c3c:	d9 07       	cpc	r29, r25
    2c3e:	41 f4       	brne	.+16     	; 0x2c50 <_Z11task_clientPv+0xb4>
    2c40:	9f 92       	push	r9
    2c42:	8f 92       	push	r8
    2c44:	1f 92       	push	r1
    2c46:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    2c4a:	0f 90       	pop	r0
    2c4c:	0f 90       	pop	r0
    2c4e:	0f 90       	pop	r0
		csp_log_info("Ping result %d [ms]\r\n", result);
    2c50:	df 93       	push	r29
    2c52:	cf 93       	push	r28
    2c54:	ff 92       	push	r15
    2c56:	ef 92       	push	r14
    2c58:	1f 93       	push	r17
    2c5a:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>

		csp_sleep_ms(1000);
    2c5e:	84 e6       	ldi	r24, 0x64	; 100
    2c60:	90 e0       	ldi	r25, 0x00	; 0
    2c62:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <vTaskDelay>

	csp_packet_t * packet;
	csp_conn_t * conn;
	//usart_pstr_p(PSTR("client task init"),1);

	for(;;) {
    2c66:	0f 90       	pop	r0
    2c68:	0f 90       	pop	r0
    2c6a:	0f 90       	pop	r0
    2c6c:	0f 90       	pop	r0
    2c6e:	0f 90       	pop	r0
    2c70:	ae cf       	rjmp	.-164    	; 0x2bce <_Z11task_clientPv+0x32>

00002c72 <main>:

	


int main( void )
{
    2c72:	cf 92       	push	r12
    2c74:	df 92       	push	r13
    2c76:	ef 92       	push	r14
    2c78:	ff 92       	push	r15
    2c7a:	0f 93       	push	r16
    2c7c:	1f 93       	push	r17
    2c7e:	cf 93       	push	r28
    2c80:	df 93       	push	r29
    2c82:	1f 92       	push	r1
    2c84:	1f 92       	push	r1
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
	usart_init(MYUBRR);
    2c8a:	83 e0       	ldi	r24, 0x03	; 3
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	06 d1       	rcall	.+524    	; 0x2e9c <usart_init>
fdevopen( &usart_putchar_printf,0);
    2c90:	60 e0       	ldi	r22, 0x00	; 0
    2c92:	70 e0       	ldi	r23, 0x00	; 0
    2c94:	86 e6       	ldi	r24, 0x66	; 102
    2c96:	97 e1       	ldi	r25, 0x17	; 23
    2c98:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <fdevopen>
    2c9c:	9d e0       	ldi	r25, 0x0D	; 13
    2c9e:	88 e1       	ldi	r24, 0x18	; 24
    2ca0:	0f b6       	in	r0, 0x3f	; 63
    2ca2:	f8 94       	cli
    2ca4:	a8 95       	wdr
    2ca6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>
    2caa:	0f be       	out	0x3f, r0	; 63
    2cac:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7c0060>


	
	wdt_enable(WDTO_500MS); // set watchdog up to reset if not called after 2s
	//pwrredinit();
	enableleds();
    2cb0:	9a dc       	rcall	.-1740   	; 0x25e6 <_Z10enableledsv>



		int error=0;
		
		error+=csp_buffer_init(4, MSGMAX);
    2cb2:	62 e3       	ldi	r22, 0x32	; 50
    2cb4:	70 e0       	ldi	r23, 0x00	; 0
    2cb6:	84 e0       	ldi	r24, 0x04	; 4
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	11 d3       	rcall	.+1570   	; 0x32de <csp_buffer_init>
    2cbc:	6c 01       	movw	r12, r24

	
		// Init CSP with address MY_ADDRESS 
		error+=csp_init(MY_ADDRESS);
    2cbe:	86 e0       	ldi	r24, 0x06	; 6
    2cc0:	0e 94 81 21 	call	0x4302	; 0x4302 <csp_init>
    2cc4:	c8 0e       	add	r12, r24
    2cc6:	d9 1e       	adc	r13, r25
		
		error+=csp_can_init(0,&can_conf);
    2cc8:	6c e7       	ldi	r22, 0x7C	; 124
    2cca:	72 e0       	ldi	r23, 0x02	; 2
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	0e 94 30 2f 	call	0x5e60	; 0x5e60 <csp_can_init>
    2cd2:	c8 0e       	add	r12, r24
    2cd4:	d9 1e       	adc	r13, r25
		
		error+=csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_can, 0xFF);
    2cd6:	2f ef       	ldi	r18, 0xFF	; 255
    2cd8:	46 e1       	ldi	r20, 0x16	; 22
    2cda:	52 e0       	ldi	r21, 0x02	; 2
    2cdc:	65 e0       	ldi	r22, 0x05	; 5
    2cde:	80 e2       	ldi	r24, 0x20	; 32
    2ce0:	0e 94 76 30 	call	0x60ec	; 0x60ec <csp_rtable_set>
    2ce4:	c8 0e       	add	r12, r24
    2ce6:	d9 1e       	adc	r13, r25

		// Start router task with 500 word stack, OS task priority 1 		
		error+=csp_route_start_task(180, 1);
    2ce8:	61 e0       	ldi	r22, 0x01	; 1
    2cea:	70 e0       	ldi	r23, 0x00	; 0
    2cec:	84 eb       	ldi	r24, 0xB4	; 180
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	0e 94 b1 27 	call	0x4f62	; 0x4f62 <csp_route_start_task>
    2cf4:	c8 0e       	add	r12, r24
		
		
		
		error-=init_server();
    2cf6:	d9 1e       	adc	r13, r25
    2cf8:	8e de       	rcall	.-740    	; 0x2a16 <_Z11init_serverv>
    2cfa:	c8 1a       	sub	r12, r24
    2cfc:	d1 08       	sbc	r13, r1
    2cfe:	87 fd       	sbrc	r24, 7
    2d00:	d3 94       	inc	r13
		printf("%d",error);
    2d02:	df 92       	push	r13
    2d04:	cf 92       	push	r12
    2d06:	84 e8       	ldi	r24, 0x84	; 132
    2d08:	93 e1       	ldi	r25, 0x13	; 19
    2d0a:	9f 93       	push	r25
    2d0c:	8f 93       	push	r24
    2d0e:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>

		// Client 
		
		csp_thread_handle_t handle_client;
		error+=csp_thread_create(task_client, "CLIENT", 220, NULL, 1, &handle_client);
    2d12:	ce 01       	movw	r24, r28
    2d14:	01 96       	adiw	r24, 0x01	; 1
    2d16:	7c 01       	movw	r14, r24
    2d18:	01 e0       	ldi	r16, 0x01	; 1
    2d1a:	10 e0       	ldi	r17, 0x00	; 0
    2d1c:	20 e0       	ldi	r18, 0x00	; 0
    2d1e:	30 e0       	ldi	r19, 0x00	; 0
    2d20:	4c ed       	ldi	r20, 0xDC	; 220
    2d22:	50 e0       	ldi	r21, 0x00	; 0
    2d24:	67 e0       	ldi	r22, 0x07	; 7
    2d26:	73 e0       	ldi	r23, 0x03	; 3
    2d28:	8e ec       	ldi	r24, 0xCE	; 206
    2d2a:	95 e1       	ldi	r25, 0x15	; 21
    2d2c:	a4 d2       	rcall	.+1352   	; 0x3276 <csp_thread_create>
    2d2e:	c8 0e       	add	r12, r24
    2d30:	d9 1e       	adc	r13, r25
		
		//csp_log_reset("test");
		error+=csp_thread_create(CanRxFunc,"CANRX",180,NULL,3,&handle_canrx);
    2d32:	0f 2e       	mov	r0, r31
    2d34:	f8 e6       	ldi	r31, 0x68	; 104
    2d36:	ef 2e       	mov	r14, r31
    2d38:	f0 e2       	ldi	r31, 0x20	; 32
    2d3a:	ff 2e       	mov	r15, r31
    2d3c:	f0 2d       	mov	r31, r0
    2d3e:	03 e0       	ldi	r16, 0x03	; 3
    2d40:	10 e0       	ldi	r17, 0x00	; 0
    2d42:	20 e0       	ldi	r18, 0x00	; 0
    2d44:	30 e0       	ldi	r19, 0x00	; 0
    2d46:	44 eb       	ldi	r20, 0xB4	; 180
    2d48:	50 e0       	ldi	r21, 0x00	; 0
    2d4a:	6e e0       	ldi	r22, 0x0E	; 14
    2d4c:	73 e0       	ldi	r23, 0x03	; 3
    2d4e:	8b e0       	ldi	r24, 0x0B	; 11
    2d50:	91 e1       	ldi	r25, 0x11	; 17
    2d52:	91 d2       	rcall	.+1314   	; 0x3276 <csp_thread_create>
		
		if(error!=0) {
    2d54:	8c 0d       	add	r24, r12
    2d56:	9d 1d       	adc	r25, r13
    2d58:	0f 90       	pop	r0
    2d5a:	0f 90       	pop	r0
    2d5c:	0f 90       	pop	r0
    2d5e:	0f 90       	pop	r0
    2d60:	89 2b       	or	r24, r25
			contled(ONCON,2);
    2d62:	81 f0       	breq	.+32     	; 0x2d84 <main+0x112>
    2d64:	62 e0       	ldi	r22, 0x02	; 2
    2d66:	70 e0       	ldi	r23, 0x00	; 0
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	46 dc       	rcall	.-1908   	; 0x25fa <_Z7contledii>
			csp_log_reset("Setup Error");
    2d6e:	88 e7       	ldi	r24, 0x78	; 120
    2d70:	93 e1       	ldi	r25, 0x13	; 19
    2d72:	9f 93       	push	r25
    2d74:	8f 93       	push	r24
    2d76:	86 e0       	ldi	r24, 0x06	; 6
    2d78:	8f 93       	push	r24
    2d7a:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
    2d7e:	0f 90       	pop	r0
    2d80:	0f 90       	pop	r0
		//csp_debug_toggle_level(CSP_INFO);
		//csp_debug_toggle_level(CSP_WARN);
		//csp_debug_toggle_level(CSP_ERROR);

		
		printf("Conn table\r\n");
    2d82:	0f 90       	pop	r0
    2d84:	8b e6       	ldi	r24, 0x6B	; 107
    2d86:	93 e1       	ldi	r25, 0x13	; 19
    2d88:	9f 93       	push	r25
    2d8a:	8f 93       	push	r24
    2d8c:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
		csp_conn_print_table();
    2d90:	2d d7       	rcall	.+3674   	; 0x3bec <csp_conn_print_table>

		printf("Route table\r\n");
    2d92:	8d e5       	ldi	r24, 0x5D	; 93
    2d94:	93 e1       	ldi	r25, 0x13	; 19
    2d96:	9f 93       	push	r25
    2d98:	8f 93       	push	r24
    2d9a:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
		csp_route_print_table();
    2d9e:	0e 94 ac 30 	call	0x6158	; 0x6158 <csp_rtable_print>

		printf("Interfaces\r\n");
    2da2:	80 e5       	ldi	r24, 0x50	; 80
    2da4:	93 e1       	ldi	r25, 0x13	; 19
    2da6:	9f 93       	push	r25
    2da8:	8f 93       	push	r24
    2daa:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
		csp_route_print_interfaces();
    2dae:	0e 94 c4 20 	call	0x4188	; 0x4188 <csp_iflist_print>
		
		
		xTaskCreate(wdtr,"WDT",configMINIMAL_STACK_SIZE,NULL,3,NULL);
    2db2:	e1 2c       	mov	r14, r1
    2db4:	f1 2c       	mov	r15, r1
    2db6:	03 e0       	ldi	r16, 0x03	; 3
    2db8:	20 e0       	ldi	r18, 0x00	; 0
    2dba:	30 e0       	ldi	r19, 0x00	; 0
    2dbc:	44 e6       	ldi	r20, 0x64	; 100
    2dbe:	50 e0       	ldi	r21, 0x00	; 0
    2dc0:	64 e1       	ldi	r22, 0x14	; 20
    2dc2:	73 e0       	ldi	r23, 0x03	; 3
    2dc4:	88 eb       	ldi	r24, 0xB8	; 184
    2dc6:	95 e1       	ldi	r25, 0x15	; 21
    2dc8:	0e 94 c4 38 	call	0x7188	; 0x7188 <xTaskCreate>
		//while(1);
	 	 //xTaskCreate(TaskBlinkserial, "blinks", 128, NULL, 3, NULL);
	// usart_pstr_p(PSTR("LED init"),1);


	vTaskStartScheduler();
    2dcc:	0e 94 6f 3a 	call	0x74de	; 0x74de <vTaskStartScheduler>
    2dd0:	0f 90       	pop	r0
    2dd2:	0f 90       	pop	r0
    2dd4:	0f 90       	pop	r0
    2dd6:	0f 90       	pop	r0
    2dd8:	0f 90       	pop	r0
    2dda:	0f 90       	pop	r0
	
	

	return 0;
}
    2ddc:	80 e0       	ldi	r24, 0x00	; 0
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	0f 90       	pop	r0
    2de2:	0f 90       	pop	r0
    2de4:	df 91       	pop	r29
    2de6:	cf 91       	pop	r28
    2de8:	1f 91       	pop	r17
    2dea:	0f 91       	pop	r16
    2dec:	ff 90       	pop	r15
    2dee:	ef 90       	pop	r14
    2df0:	df 90       	pop	r13
    2df2:	cf 90       	pop	r12
    2df4:	08 95       	ret

00002df6 <__vector_3>:
	vTaskDelete(NULL);
}



ISR(INT2_vect){
    2df6:	1f 92       	push	r1
    2df8:	0f 92       	push	r0
    2dfa:	0f b6       	in	r0, 0x3f	; 63
    2dfc:	0f 92       	push	r0
    2dfe:	11 24       	eor	r1, r1
    2e00:	0b b6       	in	r0, 0x3b	; 59
    2e02:	0f 92       	push	r0
    2e04:	2f 93       	push	r18
    2e06:	3f 93       	push	r19
    2e08:	4f 93       	push	r20
    2e0a:	5f 93       	push	r21
    2e0c:	6f 93       	push	r22
    2e0e:	7f 93       	push	r23
    2e10:	8f 93       	push	r24
    2e12:	9f 93       	push	r25
    2e14:	af 93       	push	r26
    2e16:	bf 93       	push	r27
    2e18:	ef 93       	push	r30
    2e1a:	ff 93       	push	r31
    2e1c:	cf 93       	push	r28
    2e1e:	df 93       	push	r29
    2e20:	1f 92       	push	r1
    2e22:	cd b7       	in	r28, 0x3d	; 61
    2e24:	de b7       	in	r29, 0x3e	; 62
	//if((PORTB&PB5)>>PB5) return;
		
	PCIFR&=~(1<<PCIF0);
    2e26:	d8 98       	cbi	0x1b, 0	; 27
	//while(1);

	volatile BaseType_t xYieldRequired;

	 // Resume the suspended task.
	 xYieldRequired = xTaskResumeFromISR(handle_canrx);
    2e28:	80 91 68 20 	lds	r24, 0x2068	; 0x802068 <handle_canrx>
    2e2c:	90 91 69 20 	lds	r25, 0x2069	; 0x802069 <handle_canrx+0x1>
    2e30:	0e 94 1b 3a 	call	0x7436	; 0x7436 <xTaskResumeFromISR>
    2e34:	89 83       	std	Y+1, r24	; 0x01

	 if( xYieldRequired == pdTRUE )
    2e36:	89 81       	ldd	r24, Y+1	; 0x01
    2e38:	81 30       	cpi	r24, 0x01	; 1
    2e3a:	11 f4       	brne	.+4      	; 0x2e40 <__vector_3+0x4a>
	 {
		 // We should switch context so the ISR returns to a different task.
		 // NOTE:  How this is done depends on the port you are using.  Check
		 // the documentation and examples for your port.
		 taskYIELD();
    2e3c:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <vPortYield>
	 }

}
    2e40:	0f 90       	pop	r0
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	ff 91       	pop	r31
    2e48:	ef 91       	pop	r30
    2e4a:	bf 91       	pop	r27
    2e4c:	af 91       	pop	r26
    2e4e:	9f 91       	pop	r25
    2e50:	8f 91       	pop	r24
    2e52:	7f 91       	pop	r23
    2e54:	6f 91       	pop	r22
    2e56:	5f 91       	pop	r21
    2e58:	4f 91       	pop	r20
    2e5a:	3f 91       	pop	r19
    2e5c:	2f 91       	pop	r18
    2e5e:	0f 90       	pop	r0
    2e60:	0b be       	out	0x3b, r0	; 59
    2e62:	0f 90       	pop	r0
    2e64:	0f be       	out	0x3f, r0	; 63
    2e66:	0f 90       	pop	r0
    2e68:	1f 90       	pop	r1
    2e6a:	18 95       	reti

00002e6c <__vector_default>:
}



ISR(BADISR_vect)
{
    2e6c:	1f 92       	push	r1
    2e6e:	0f 92       	push	r0
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	0f 92       	push	r0
    2e74:	11 24       	eor	r1, r1
	//FORCERESET
 printf("Unex Vector");
    2e76:	8d e0       	ldi	r24, 0x0D	; 13
    2e78:	93 e1       	ldi	r25, 0x13	; 19
    2e7a:	9f 93       	push	r25
    2e7c:	8f 93       	push	r24
    2e7e:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
	FORCERESET
    2e82:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
    2e86:	80 e0       	ldi	r24, 0x00	; 0
    2e88:	93 e1       	ldi	r25, 0x13	; 19
    2e8a:	9f 93       	push	r25
    2e8c:	8f 93       	push	r24
    2e8e:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
    2e92:	0f 90       	pop	r0
    2e94:	0f 90       	pop	r0
    2e96:	0f 90       	pop	r0
    2e98:	0f 90       	pop	r0
    2e9a:	ff cf       	rjmp	.-2      	; 0x2e9a <__vector_default+0x2e>

00002e9c <usart_init>:
	return b;
}

void usart_nl(void) {
			usart_putchar('\r');
			usart_putchar('\n');
    2e9c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
    2ea0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
    2ea4:	e0 ec       	ldi	r30, 0xC0	; 192
    2ea6:	f0 e0       	ldi	r31, 0x00	; 0
    2ea8:	80 81       	ld	r24, Z
    2eaa:	82 60       	ori	r24, 0x02	; 2
    2eac:	80 83       	st	Z, r24
    2eae:	88 e0       	ldi	r24, 0x08	; 8
    2eb0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
    2eb4:	86 e0       	ldi	r24, 0x06	; 6
    2eb6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
    2eba:	08 95       	ret

00002ebc <usart_putchar>:
    2ebc:	e0 ec       	ldi	r30, 0xC0	; 192
    2ebe:	f0 e0       	ldi	r31, 0x00	; 0
    2ec0:	90 81       	ld	r25, Z
    2ec2:	95 ff       	sbrs	r25, 5
    2ec4:	fd cf       	rjmp	.-6      	; 0x2ec0 <usart_putchar+0x4>
    2ec6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
    2eca:	08 95       	ret

00002ecc <usart_putchar_printf>:
}

int usart_putchar_printf(char var, FILE *stream) {
    2ecc:	cf 93       	push	r28
    2ece:	c8 2f       	mov	r28, r24
	if (var == '\n') usart_putchar('\r');
    2ed0:	8a 30       	cpi	r24, 0x0A	; 10
    2ed2:	11 f4       	brne	.+4      	; 0x2ed8 <usart_putchar_printf+0xc>
    2ed4:	8d e0       	ldi	r24, 0x0D	; 13
    2ed6:	f2 df       	rcall	.-28     	; 0x2ebc <usart_putchar>
	usart_putchar(var);
    2ed8:	8c 2f       	mov	r24, r28
    2eda:	f0 df       	rcall	.-32     	; 0x2ebc <usart_putchar>
	return 0;
}
    2edc:	80 e0       	ldi	r24, 0x00	; 0
    2ede:	90 e0       	ldi	r25, 0x00	; 0
    2ee0:	cf 91       	pop	r28
    2ee2:	08 95       	ret

00002ee4 <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS/FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    2ee4:	0c 94 df 31 	jmp	0x63be	; 0x63be <pvPortMalloc>
}
    2ee8:	08 95       	ret

00002eea <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    2eea:	0c 94 9f 31 	jmp	0x633e	; 0x633e <vPortFree>
    2eee:	08 95       	ret

00002ef0 <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    2ef0:	40 e0       	ldi	r20, 0x00	; 0
    2ef2:	0c 94 a5 35 	jmp	0x6b4a	; 0x6b4a <xQueueGenericCreate>
    2ef6:	08 95       	ret

00002ef8 <csp_queue_enqueue>:
    2ef8:	0f 93       	push	r16
    2efa:	1f 93       	push	r17
    2efc:	cf 93       	push	r28
    2efe:	df 93       	push	r29
    2f00:	ec 01       	movw	r28, r24
    2f02:	8b 01       	movw	r16, r22
    2f04:	ca 01       	movw	r24, r20
    2f06:	b9 01       	movw	r22, r18
    2f08:	6f 3f       	cpi	r22, 0xFF	; 255
    2f0a:	2f ef       	ldi	r18, 0xFF	; 255
    2f0c:	72 07       	cpc	r23, r18
    2f0e:	81 05       	cpc	r24, r1
    2f10:	91 05       	cpc	r25, r1
    2f12:	41 f0       	breq	.+16     	; 0x2f24 <csp_queue_enqueue+0x2c>
    2f14:	2a e0       	ldi	r18, 0x0A	; 10
    2f16:	30 e0       	ldi	r19, 0x00	; 0
    2f18:	40 e0       	ldi	r20, 0x00	; 0
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__udivmodsi4>
    2f20:	ca 01       	movw	r24, r20
    2f22:	b9 01       	movw	r22, r18
    2f24:	20 e0       	ldi	r18, 0x00	; 0
    2f26:	ab 01       	movw	r20, r22
    2f28:	b8 01       	movw	r22, r16
    2f2a:	ce 01       	movw	r24, r28
    2f2c:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <xQueueGenericSend>
    2f30:	08 2e       	mov	r0, r24
    2f32:	00 0c       	add	r0, r0
    2f34:	99 0b       	sbc	r25, r25
    2f36:	df 91       	pop	r29
    2f38:	cf 91       	pop	r28
    2f3a:	1f 91       	pop	r17
    2f3c:	0f 91       	pop	r16
    2f3e:	08 95       	ret

00002f40 <csp_queue_enqueue_isr>:
    2f40:	20 e0       	ldi	r18, 0x00	; 0
    2f42:	0e 94 7d 36 	call	0x6cfa	; 0x6cfa <xQueueGenericSendFromISR>
    2f46:	08 2e       	mov	r0, r24
    2f48:	00 0c       	add	r0, r0
    2f4a:	99 0b       	sbc	r25, r25
    2f4c:	08 95       	ret

00002f4e <csp_queue_dequeue>:
    2f4e:	0f 93       	push	r16
    2f50:	1f 93       	push	r17
    2f52:	cf 93       	push	r28
    2f54:	df 93       	push	r29
    2f56:	ec 01       	movw	r28, r24
    2f58:	8b 01       	movw	r16, r22
    2f5a:	2f 3f       	cpi	r18, 0xFF	; 255
    2f5c:	8f ef       	ldi	r24, 0xFF	; 255
    2f5e:	38 07       	cpc	r19, r24
    2f60:	41 05       	cpc	r20, r1
    2f62:	51 05       	cpc	r21, r1
    2f64:	41 f0       	breq	.+16     	; 0x2f76 <csp_queue_dequeue+0x28>
    2f66:	ca 01       	movw	r24, r20
    2f68:	b9 01       	movw	r22, r18
    2f6a:	2a e0       	ldi	r18, 0x0A	; 10
    2f6c:	30 e0       	ldi	r19, 0x00	; 0
    2f6e:	40 e0       	ldi	r20, 0x00	; 0
    2f70:	50 e0       	ldi	r21, 0x00	; 0
    2f72:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__udivmodsi4>
    2f76:	a9 01       	movw	r20, r18
    2f78:	b8 01       	movw	r22, r16
    2f7a:	ce 01       	movw	r24, r28
    2f7c:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <xQueueReceive>
    2f80:	08 2e       	mov	r0, r24
    2f82:	00 0c       	add	r0, r0
    2f84:	99 0b       	sbc	r25, r25
    2f86:	df 91       	pop	r29
    2f88:	cf 91       	pop	r28
    2f8a:	1f 91       	pop	r17
    2f8c:	0f 91       	pop	r16
    2f8e:	08 95       	ret

00002f90 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    2f90:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <uxQueueMessagesWaiting>
}
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	08 95       	ret

00002f98 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    2f98:	cf 93       	push	r28
    2f9a:	df 93       	push	r29
    2f9c:	ec 01       	movw	r28, r24
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	0e 94 65 36 	call	0x6cca	; 0x6cca <xQueueCreateMutex>
    2fa4:	99 83       	std	Y+1, r25	; 0x01
    2fa6:	88 83       	st	Y, r24
    2fa8:	21 e0       	ldi	r18, 0x01	; 1
    2faa:	30 e0       	ldi	r19, 0x00	; 0
    2fac:	89 2b       	or	r24, r25
    2fae:	11 f4       	brne	.+4      	; 0x2fb4 <csp_mutex_create+0x1c>
    2fb0:	20 e0       	ldi	r18, 0x00	; 0
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	c9 01       	movw	r24, r18
    2fb6:	df 91       	pop	r29
    2fb8:	cf 91       	pop	r28
    2fba:	08 95       	ret

00002fbc <csp_bin_sem_create>:
    2fbc:	cf 93       	push	r28
    2fbe:	df 93       	push	r29
    2fc0:	ec 01       	movw	r28, r24
    2fc2:	43 e0       	ldi	r20, 0x03	; 3
    2fc4:	60 e0       	ldi	r22, 0x00	; 0
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	0e 94 a5 35 	call	0x6b4a	; 0x6b4a <xQueueGenericCreate>
    2fcc:	99 83       	std	Y+1, r25	; 0x01
    2fce:	88 83       	st	Y, r24
    2fd0:	00 97       	sbiw	r24, 0x00	; 0
    2fd2:	39 f0       	breq	.+14     	; 0x2fe2 <csp_bin_sem_create+0x26>
    2fd4:	20 e0       	ldi	r18, 0x00	; 0
    2fd6:	40 e0       	ldi	r20, 0x00	; 0
    2fd8:	50 e0       	ldi	r21, 0x00	; 0
    2fda:	60 e0       	ldi	r22, 0x00	; 0
    2fdc:	70 e0       	ldi	r23, 0x00	; 0
    2fde:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <xQueueGenericSend>
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	df 91       	pop	r29
    2fe8:	cf 91       	pop	r28
    2fea:	08 95       	ret

00002fec <csp_bin_sem_wait>:
    2fec:	cf 92       	push	r12
    2fee:	df 92       	push	r13
    2ff0:	ef 92       	push	r14
    2ff2:	ff 92       	push	r15
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	ec 01       	movw	r28, r24
    2ffa:	6a 01       	movw	r12, r20
    2ffc:	7b 01       	movw	r14, r22
    2ffe:	df 93       	push	r29
    3000:	cf 93       	push	r28
    3002:	87 ea       	ldi	r24, 0xA7	; 167
    3004:	91 e0       	ldi	r25, 0x01	; 1
    3006:	9f 93       	push	r25
    3008:	8f 93       	push	r24
    300a:	87 e0       	ldi	r24, 0x07	; 7
    300c:	8f 93       	push	r24
    300e:	3e d7       	rcall	.+3708   	; 0x3e8c <do_csp_debug>
    3010:	0f 90       	pop	r0
    3012:	0f 90       	pop	r0
    3014:	0f 90       	pop	r0
    3016:	0f 90       	pop	r0
    3018:	0f 90       	pop	r0
    301a:	8f ef       	ldi	r24, 0xFF	; 255
    301c:	c8 16       	cp	r12, r24
    301e:	d8 06       	cpc	r13, r24
    3020:	e1 04       	cpc	r14, r1
    3022:	f1 04       	cpc	r15, r1
    3024:	51 f0       	breq	.+20     	; 0x303a <csp_bin_sem_wait+0x4e>
    3026:	c7 01       	movw	r24, r14
    3028:	b6 01       	movw	r22, r12
    302a:	2a e0       	ldi	r18, 0x0A	; 10
    302c:	30 e0       	ldi	r19, 0x00	; 0
    302e:	40 e0       	ldi	r20, 0x00	; 0
    3030:	50 e0       	ldi	r21, 0x00	; 0
    3032:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__udivmodsi4>
    3036:	69 01       	movw	r12, r18
    3038:	7a 01       	movw	r14, r20
    303a:	b6 01       	movw	r22, r12
    303c:	88 81       	ld	r24, Y
    303e:	99 81       	ldd	r25, Y+1	; 0x01
    3040:	0e 94 3e 37 	call	0x6e7c	; 0x6e7c <xQueueSemaphoreTake>
    3044:	21 e0       	ldi	r18, 0x01	; 1
    3046:	30 e0       	ldi	r19, 0x00	; 0
    3048:	81 30       	cpi	r24, 0x01	; 1
    304a:	11 f0       	breq	.+4      	; 0x3050 <csp_bin_sem_wait+0x64>
    304c:	20 e0       	ldi	r18, 0x00	; 0
    304e:	30 e0       	ldi	r19, 0x00	; 0
    3050:	c9 01       	movw	r24, r18
    3052:	df 91       	pop	r29
    3054:	cf 91       	pop	r28
    3056:	ff 90       	pop	r15
    3058:	ef 90       	pop	r14
    305a:	df 90       	pop	r13
    305c:	cf 90       	pop	r12
    305e:	08 95       	ret

00003060 <csp_bin_sem_post>:
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
    3060:	cf 93       	push	r28
    3062:	df 93       	push	r29
    3064:	ec 01       	movw	r28, r24
	csp_log_lock("Post: %p", sem);
    3066:	df 93       	push	r29
    3068:	cf 93       	push	r28
    306a:	8e e9       	ldi	r24, 0x9E	; 158
    306c:	91 e0       	ldi	r25, 0x01	; 1
    306e:	9f 93       	push	r25
    3070:	8f 93       	push	r24
    3072:	87 e0       	ldi	r24, 0x07	; 7
    3074:	8f 93       	push	r24
    3076:	0a d7       	rcall	.+3604   	; 0x3e8c <do_csp_debug>
	if (xSemaphoreGive(*sem) == pdPASS) {
    3078:	20 e0       	ldi	r18, 0x00	; 0
    307a:	40 e0       	ldi	r20, 0x00	; 0
    307c:	50 e0       	ldi	r21, 0x00	; 0
    307e:	60 e0       	ldi	r22, 0x00	; 0
    3080:	70 e0       	ldi	r23, 0x00	; 0
    3082:	88 81       	ld	r24, Y
    3084:	99 81       	ldd	r25, Y+1	; 0x01
    3086:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <xQueueGenericSend>
    308a:	21 e0       	ldi	r18, 0x01	; 1
    308c:	30 e0       	ldi	r19, 0x00	; 0
    308e:	0f 90       	pop	r0
    3090:	0f 90       	pop	r0
    3092:	0f 90       	pop	r0
    3094:	0f 90       	pop	r0
    3096:	0f 90       	pop	r0
    3098:	81 30       	cpi	r24, 0x01	; 1
    309a:	11 f0       	breq	.+4      	; 0x30a0 <csp_bin_sem_post+0x40>
    309c:	20 e0       	ldi	r18, 0x00	; 0
    309e:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    30a0:	c9 01       	movw	r24, r18
    30a2:	df 91       	pop	r29
    30a4:	cf 91       	pop	r28
    30a6:	08 95       	ret

000030a8 <csp_sys_tasklist>:

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed portCHAR *) out);
#else
	vTaskList(out);
    30a8:	0e 94 f3 3e 	call	0x7de6	; 0x7de6 <vTaskList>
#endif
	return CSP_ERR_NONE;
}
    30ac:	80 e0       	ldi	r24, 0x00	; 0
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	08 95       	ret

000030b2 <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    30b2:	0e 94 aa 3a 	call	0x7554	; 0x7554 <uxTaskGetNumberOfTasks>
}
    30b6:	28 e2       	ldi	r18, 0x28	; 40
    30b8:	82 9f       	mul	r24, r18
    30ba:	c0 01       	movw	r24, r0
    30bc:	11 24       	eor	r1, r1
    30be:	08 95       	ret

000030c0 <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    30c0:	4f 92       	push	r4
    30c2:	5f 92       	push	r5
    30c4:	6f 92       	push	r6
    30c6:	7f 92       	push	r7
    30c8:	8f 92       	push	r8
    30ca:	9f 92       	push	r9
    30cc:	af 92       	push	r10
    30ce:	bf 92       	push	r11
    30d0:	cf 92       	push	r12
    30d2:	df 92       	push	r13
    30d4:	ef 92       	push	r14
    30d6:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    30d8:	0f 2e       	mov	r0, r31
    30da:	f0 e1       	ldi	r31, 0x10	; 16
    30dc:	cf 2e       	mov	r12, r31
    30de:	f7 e2       	ldi	r31, 0x27	; 39
    30e0:	df 2e       	mov	r13, r31
    30e2:	e1 2c       	mov	r14, r1
    30e4:	f1 2c       	mov	r15, r1
    30e6:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    30e8:	44 24       	eor	r4, r4
    30ea:	4a 94       	dec	r4
    30ec:	54 2c       	mov	r5, r4
    30ee:	32 01       	movw	r6, r4
    30f0:	81 2c       	mov	r8, r1
    30f2:	91 2c       	mov	r9, r1
    30f4:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    30f6:	c6 01       	movw	r24, r12
    30f8:	88 0d       	add	r24, r8
    30fa:	99 1d       	adc	r25, r9
    30fc:	0e 94 df 31 	call	0x63be	; 0x63be <pvPortMalloc>
		if (pmem == NULL) {
    3100:	00 97       	sbiw	r24, 0x00	; 0
    3102:	59 f4       	brne	.+22     	; 0x311a <csp_sys_memfree+0x5a>
			max = size + total;
    3104:	24 01       	movw	r4, r8
    3106:	35 01       	movw	r6, r10
    3108:	4c 0c       	add	r4, r12
    310a:	5d 1c       	adc	r5, r13
    310c:	6e 1c       	adc	r6, r14
    310e:	7f 1c       	adc	r7, r15
			size = size / 2;
    3110:	f6 94       	lsr	r15
    3112:	e7 94       	ror	r14
    3114:	d7 94       	ror	r13
    3116:	c7 94       	ror	r12
    3118:	15 c0       	rjmp	.+42     	; 0x3144 <csp_sys_memfree+0x84>
		} else {
			total += size;
    311a:	8c 0c       	add	r8, r12
    311c:	9d 1c       	adc	r9, r13
    311e:	ae 1c       	adc	r10, r14
    3120:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    3122:	b7 01       	movw	r22, r14
    3124:	a6 01       	movw	r20, r12
    3126:	48 0d       	add	r20, r8
    3128:	59 1d       	adc	r21, r9
    312a:	6a 1d       	adc	r22, r10
    312c:	7b 1d       	adc	r23, r11
    312e:	44 15       	cp	r20, r4
    3130:	55 05       	cpc	r21, r5
    3132:	66 05       	cpc	r22, r6
    3134:	77 05       	cpc	r23, r7
    3136:	20 f0       	brcs	.+8      	; 0x3140 <csp_sys_memfree+0x80>
				size = size / 2;
    3138:	f6 94       	lsr	r15
    313a:	e7 94       	ror	r14
    313c:	d7 94       	ror	r13
    313e:	c7 94       	ror	r12
			vPortFree(pmem);
    3140:	0e 94 9f 31 	call	0x633e	; 0x633e <vPortFree>
		}
		if (size < 32) break;
    3144:	80 e2       	ldi	r24, 0x20	; 32
    3146:	c8 16       	cp	r12, r24
    3148:	d1 04       	cpc	r13, r1
    314a:	e1 04       	cpc	r14, r1
    314c:	f1 04       	cpc	r15, r1
    314e:	98 f6       	brcc	.-90     	; 0x30f6 <csp_sys_memfree+0x36>
	}

	return total;
}
    3150:	c5 01       	movw	r24, r10
    3152:	b4 01       	movw	r22, r8
    3154:	ff 90       	pop	r15
    3156:	ef 90       	pop	r14
    3158:	df 90       	pop	r13
    315a:	cf 90       	pop	r12
    315c:	bf 90       	pop	r11
    315e:	af 90       	pop	r10
    3160:	9f 90       	pop	r9
    3162:	8f 90       	pop	r8
    3164:	7f 90       	pop	r7
    3166:	6f 90       	pop	r6
    3168:	5f 90       	pop	r5
    316a:	4f 90       	pop	r4
    316c:	08 95       	ret

0000316e <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    316e:	80 e0       	ldi	r24, 0x00	; 0
    3170:	90 e0       	ldi	r25, 0x00	; 0
    3172:	89 2b       	or	r24, r25
    3174:	21 f0       	breq	.+8      	; 0x317e <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    3176:	81 e0       	ldi	r24, 0x01	; 1
    3178:	90 e0       	ldi	r25, 0x00	; 0
    317a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    317e:	80 e0       	ldi	r24, 0x00	; 0
    3180:	90 e0       	ldi	r25, 0x00	; 0
    3182:	89 2b       	or	r24, r25
    3184:	19 f0       	breq	.+6      	; 0x318c <csp_sys_reboot+0x1e>
		cpu_reset();
    3186:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    318a:	ff cf       	rjmp	.-2      	; 0x318a <csp_sys_reboot+0x1c>
		while (1);
	}
	
	csp_log_error("Failed to reboot");
    318c:	8c ec       	ldi	r24, 0xCC	; 204
    318e:	91 e0       	ldi	r25, 0x01	; 1
    3190:	9f 93       	push	r25
    3192:	8f 93       	push	r24
    3194:	1f 92       	push	r1
    3196:	7a d6       	rcall	.+3316   	; 0x3e8c <do_csp_debug>

	return CSP_ERR_INVAL;
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0f 90       	pop	r0
}
    319e:	8e ef       	ldi	r24, 0xFE	; 254
    31a0:	9f ef       	ldi	r25, 0xFF	; 255
    31a2:	08 95       	ret

000031a4 <csp_sys_shutdown>:

int csp_sys_shutdown(void) {

	extern void __attribute__((weak)) cpu_shutdown(void);
	if (cpu_shutdown) {
    31a4:	80 e0       	ldi	r24, 0x00	; 0
    31a6:	90 e0       	ldi	r25, 0x00	; 0
    31a8:	89 2b       	or	r24, r25
    31aa:	19 f0       	breq	.+6      	; 0x31b2 <csp_sys_shutdown+0xe>
		cpu_shutdown();
    31ac:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    31b0:	ff cf       	rjmp	.-2      	; 0x31b0 <csp_sys_shutdown+0xc>
		while (1);
	}

	csp_log_error("Failed to shutdown");
    31b2:	89 eb       	ldi	r24, 0xB9	; 185
    31b4:	91 e0       	ldi	r25, 0x01	; 1
    31b6:	9f 93       	push	r25
    31b8:	8f 93       	push	r24
    31ba:	1f 92       	push	r1
    31bc:	67 d6       	rcall	.+3278   	; 0x3e8c <do_csp_debug>

	return CSP_ERR_INVAL;
    31be:	0f 90       	pop	r0
    31c0:	0f 90       	pop	r0
    31c2:	0f 90       	pop	r0
}
    31c4:	8e ef       	ldi	r24, 0xFE	; 254
    31c6:	9f ef       	ldi	r25, 0xFF	; 255
    31c8:	08 95       	ret

000031ca <csp_sys_set_color>:

void csp_sys_set_color(csp_color_t color) {
    31ca:	98 2f       	mov	r25, r24

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
    31cc:	e8 2f       	mov	r30, r24
    31ce:	ef 70       	andi	r30, 0x0F	; 15
    31d0:	4e 2f       	mov	r20, r30
    31d2:	50 e0       	ldi	r21, 0x00	; 0
    31d4:	fa 01       	movw	r30, r20
    31d6:	31 97       	sbiw	r30, 0x01	; 1
    31d8:	e8 30       	cpi	r30, 0x08	; 8
    31da:	f1 05       	cpc	r31, r1
    31dc:	d8 f4       	brcc	.+54     	; 0x3214 <csp_sys_set_color+0x4a>
    31de:	88 27       	eor	r24, r24
    31e0:	e2 56       	subi	r30, 0x62	; 98
    31e2:	ff 4f       	sbci	r31, 0xFF	; 255
    31e4:	8f 4f       	sbci	r24, 0xFF	; 255
    31e6:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
		case COLOR_BLACK:
			color_code = 30; break;
		case COLOR_RED:
			color_code = 31; break;
    31ea:	2f e1       	ldi	r18, 0x1F	; 31
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	17 c0       	rjmp	.+46     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_GREEN:
			color_code = 32; break;
    31f0:	20 e2       	ldi	r18, 0x20	; 32
    31f2:	30 e0       	ldi	r19, 0x00	; 0
    31f4:	14 c0       	rjmp	.+40     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_YELLOW:
			color_code = 33; break;
    31f6:	21 e2       	ldi	r18, 0x21	; 33
    31f8:	30 e0       	ldi	r19, 0x00	; 0
    31fa:	11 c0       	rjmp	.+34     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_BLUE:
			color_code = 34; break;
    31fc:	22 e2       	ldi	r18, 0x22	; 34
    31fe:	30 e0       	ldi	r19, 0x00	; 0
    3200:	0e c0       	rjmp	.+28     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_MAGENTA:
			color_code = 35; break;
    3202:	23 e2       	ldi	r18, 0x23	; 35
    3204:	30 e0       	ldi	r19, 0x00	; 0
    3206:	0b c0       	rjmp	.+22     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_CYAN:
			color_code = 36; break;
    3208:	24 e2       	ldi	r18, 0x24	; 36
    320a:	30 e0       	ldi	r19, 0x00	; 0
    320c:	08 c0       	rjmp	.+16     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_WHITE:
			color_code = 37; break;
    320e:	25 e2       	ldi	r18, 0x25	; 37
    3210:	30 e0       	ldi	r19, 0x00	; 0
    3212:	05 c0       	rjmp	.+10     	; 0x321e <csp_sys_set_color+0x54>
		case COLOR_RESET:
		default:
			color_code = 0; break;
    3214:	20 e0       	ldi	r18, 0x00	; 0
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	02 c0       	rjmp	.+4      	; 0x321e <csp_sys_set_color+0x54>
void csp_sys_set_color(csp_color_t color) {

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
		case COLOR_BLACK:
			color_code = 30; break;
    321a:	2e e1       	ldi	r18, 0x1E	; 30
    321c:	30 e0       	ldi	r19, 0x00	; 0
		case COLOR_RESET:
		default:
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
    321e:	89 2f       	mov	r24, r25
    3220:	80 7f       	andi	r24, 0xF0	; 240
    3222:	80 32       	cpi	r24, 0x20	; 32
    3224:	49 f0       	breq	.+18     	; 0x3238 <csp_sys_set_color+0x6e>
    3226:	18 f4       	brcc	.+6      	; 0x322e <csp_sys_set_color+0x64>
    3228:	80 31       	cpi	r24, 0x10	; 16
    322a:	91 f0       	breq	.+36     	; 0x3250 <csp_sys_set_color+0x86>
    322c:	0e c0       	rjmp	.+28     	; 0x324a <csp_sys_set_color+0x80>
    322e:	80 33       	cpi	r24, 0x30	; 48
    3230:	31 f0       	breq	.+12     	; 0x323e <csp_sys_set_color+0x74>
    3232:	80 34       	cpi	r24, 0x40	; 64
    3234:	39 f0       	breq	.+14     	; 0x3244 <csp_sys_set_color+0x7a>
    3236:	09 c0       	rjmp	.+18     	; 0x324a <csp_sys_set_color+0x80>
		case COLOR_BOLD:
			modifier_code = 1; break;
		case COLOR_UNDERLINE:
			modifier_code = 2; break;
    3238:	82 e0       	ldi	r24, 0x02	; 2
    323a:	90 e0       	ldi	r25, 0x00	; 0
    323c:	0b c0       	rjmp	.+22     	; 0x3254 <csp_sys_set_color+0x8a>
		case COLOR_BLINK:
			modifier_code = 3; break;
    323e:	83 e0       	ldi	r24, 0x03	; 3
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	08 c0       	rjmp	.+16     	; 0x3254 <csp_sys_set_color+0x8a>
		case COLOR_HIDE:
			modifier_code = 4; break;
    3244:	84 e0       	ldi	r24, 0x04	; 4
    3246:	90 e0       	ldi	r25, 0x00	; 0
    3248:	05 c0       	rjmp	.+10     	; 0x3254 <csp_sys_set_color+0x8a>
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
    324a:	80 e0       	ldi	r24, 0x00	; 0
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	02 c0       	rjmp	.+4      	; 0x3254 <csp_sys_set_color+0x8a>
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
		case COLOR_BOLD:
			modifier_code = 1; break;
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	90 e0       	ldi	r25, 0x00	; 0
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
	}

	printf("\033[%u;%um", modifier_code, color_code);
    3254:	3f 93       	push	r19
    3256:	2f 93       	push	r18
    3258:	9f 93       	push	r25
    325a:	8f 93       	push	r24
    325c:	80 eb       	ldi	r24, 0xB0	; 176
    325e:	91 e0       	ldi	r25, 0x01	; 1
    3260:	9f 93       	push	r25
    3262:	8f 93       	push	r24
    3264:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
}
    3268:	0f 90       	pop	r0
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	0f 90       	pop	r0
    3272:	0f 90       	pop	r0
    3274:	08 95       	ret

00003276 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    3276:	ef 92       	push	r14
    3278:	ff 92       	push	r15
    327a:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
    327c:	0e 94 c4 38 	call	0x7188	; 0x7188 <xTaskCreate>
    3280:	21 e0       	ldi	r18, 0x01	; 1
    3282:	30 e0       	ldi	r19, 0x00	; 0
    3284:	81 30       	cpi	r24, 0x01	; 1
    3286:	11 f4       	brne	.+4      	; 0x328c <csp_thread_create+0x16>
    3288:	20 e0       	ldi	r18, 0x00	; 0
    328a:	30 e0       	ldi	r19, 0x00	; 0
	portBASE_TYPE ret = xTaskCreate(routine, (signed char *) thread_name, stack_depth, parameters, priority, handle);
#endif
	if (ret != pdTRUE)
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    328c:	88 27       	eor	r24, r24
    328e:	99 27       	eor	r25, r25
    3290:	82 1b       	sub	r24, r18
    3292:	93 0b       	sbc	r25, r19
    3294:	0f 91       	pop	r16
    3296:	ff 90       	pop	r15
    3298:	ef 90       	pop	r14
    329a:	08 95       	ret

0000329c <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    329c:	0e 94 a0 3a 	call	0x7540	; 0x7540 <xTaskGetTickCount>
    32a0:	bc 01       	movw	r22, r24
    32a2:	66 0f       	add	r22, r22
    32a4:	77 1f       	adc	r23, r23
    32a6:	88 0f       	add	r24, r24
    32a8:	99 1f       	adc	r25, r25
    32aa:	88 0f       	add	r24, r24
    32ac:	99 1f       	adc	r25, r25
    32ae:	88 0f       	add	r24, r24
    32b0:	99 1f       	adc	r25, r25
    32b2:	68 0f       	add	r22, r24
    32b4:	79 1f       	adc	r23, r25
    32b6:	80 e0       	ldi	r24, 0x00	; 0
    32b8:	90 e0       	ldi	r25, 0x00	; 0
    32ba:	08 95       	ret

000032bc <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    32bc:	0e 94 a0 3a 	call	0x7540	; 0x7540 <xTaskGetTickCount>
    32c0:	9c 01       	movw	r18, r24
    32c2:	36 95       	lsr	r19
    32c4:	27 95       	ror	r18
    32c6:	36 95       	lsr	r19
    32c8:	27 95       	ror	r18
    32ca:	ab e7       	ldi	r26, 0x7B	; 123
    32cc:	b4 e1       	ldi	r27, 0x14	; 20
    32ce:	0e 94 26 44 	call	0x884c	; 0x884c <__umulhisi3>
    32d2:	96 95       	lsr	r25
    32d4:	87 95       	ror	r24
    32d6:	bc 01       	movw	r22, r24
    32d8:	80 e0       	ldi	r24, 0x00	; 0
    32da:	90 e0       	ldi	r25, 0x00	; 0
}
    32dc:	08 95       	ret

000032de <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    32de:	cf 92       	push	r12
    32e0:	df 92       	push	r13
    32e2:	ef 92       	push	r14
    32e4:	ff 92       	push	r15
    32e6:	0f 93       	push	r16
    32e8:	1f 93       	push	r17
    32ea:	cf 93       	push	r28
    32ec:	df 93       	push	r29
    32ee:	1f 92       	push	r1
    32f0:	1f 92       	push	r1
    32f2:	cd b7       	in	r28, 0x3d	; 61
    32f4:	de b7       	in	r29, 0x3e	; 62
    32f6:	90 93 22 03 	sts	0x0322, r25	; 0x800322 <count+0x1>
    32fa:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <count>
    32fe:	9b 01       	movw	r18, r22
    3300:	22 5f       	subi	r18, 0xF2	; 242
    3302:	3f 4f       	sbci	r19, 0xFF	; 255
    3304:	30 93 20 03 	sts	0x0320, r19	; 0x800320 <size+0x1>
    3308:	20 93 1f 03 	sts	0x031F, r18	; 0x80031f <size>
    330c:	6b 01       	movw	r12, r22
    330e:	22 e1       	ldi	r18, 0x12	; 18
    3310:	c2 0e       	add	r12, r18
    3312:	d1 1c       	adc	r13, r1
    3314:	8c 9d       	mul	r24, r12
    3316:	80 01       	movw	r16, r0
    3318:	8d 9d       	mul	r24, r13
    331a:	10 0d       	add	r17, r0
    331c:	9c 9d       	mul	r25, r12
    331e:	10 0d       	add	r17, r0
    3320:	11 24       	eor	r1, r1
    3322:	c8 01       	movw	r24, r16
    3324:	df dd       	rcall	.-1090   	; 0x2ee4 <csp_malloc>
    3326:	90 93 24 03 	sts	0x0324, r25	; 0x800324 <csp_buffer_pool+0x1>
    332a:	80 93 23 03 	sts	0x0323, r24	; 0x800323 <csp_buffer_pool>
    332e:	89 2b       	or	r24, r25
    3330:	09 f4       	brne	.+2      	; 0x3334 <csp_buffer_init+0x56>
    3332:	4f c0       	rjmp	.+158    	; 0x33d2 <csp_buffer_init+0xf4>
    3334:	62 e0       	ldi	r22, 0x02	; 2
    3336:	70 e0       	ldi	r23, 0x00	; 0
    3338:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <count>
    333c:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <count+0x1>
    3340:	d7 dd       	rcall	.-1106   	; 0x2ef0 <csp_queue_create>
    3342:	90 93 26 03 	sts	0x0326, r25	; 0x800326 <csp_buffers+0x1>
    3346:	80 93 25 03 	sts	0x0325, r24	; 0x800325 <csp_buffers>
    334a:	89 2b       	or	r24, r25
    334c:	d1 f1       	breq	.+116    	; 0x33c2 <csp_buffer_init+0xe4>
    334e:	a8 01       	movw	r20, r16
    3350:	60 e0       	ldi	r22, 0x00	; 0
    3352:	70 e0       	ldi	r23, 0x00	; 0
    3354:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <csp_buffer_pool>
    3358:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <csp_buffer_pool+0x1>
    335c:	0e 94 aa 44 	call	0x8954	; 0x8954 <memset>
    3360:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <count>
    3364:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <count+0x1>
    3368:	89 2b       	or	r24, r25
    336a:	b1 f1       	breq	.+108    	; 0x33d8 <csp_buffer_init+0xfa>
    336c:	e1 2c       	mov	r14, r1
    336e:	f1 2c       	mov	r15, r1
    3370:	00 e0       	ldi	r16, 0x00	; 0
    3372:	10 e0       	ldi	r17, 0x00	; 0
    3374:	e0 91 23 03 	lds	r30, 0x0323	; 0x800323 <csp_buffer_pool>
    3378:	f0 91 24 03 	lds	r31, 0x0324	; 0x800324 <csp_buffer_pool+0x1>
    337c:	ee 0d       	add	r30, r14
    337e:	ff 1d       	adc	r31, r15
    3380:	fa 83       	std	Y+2, r31	; 0x02
    3382:	e9 83       	std	Y+1, r30	; 0x01
    3384:	11 82       	std	Z+1, r1	; 0x01
    3386:	10 82       	st	Z, r1
    3388:	e9 81       	ldd	r30, Y+1	; 0x01
    338a:	fa 81       	ldd	r31, Y+2	; 0x02
    338c:	f3 83       	std	Z+3, r31	; 0x03
    338e:	e2 83       	std	Z+2, r30	; 0x02
    3390:	20 e0       	ldi	r18, 0x00	; 0
    3392:	30 e0       	ldi	r19, 0x00	; 0
    3394:	a9 01       	movw	r20, r18
    3396:	be 01       	movw	r22, r28
    3398:	6f 5f       	subi	r22, 0xFF	; 255
    339a:	7f 4f       	sbci	r23, 0xFF	; 255
    339c:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <csp_buffers>
    33a0:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <csp_buffers+0x1>
    33a4:	a9 dd       	rcall	.-1198   	; 0x2ef8 <csp_queue_enqueue>
    33a6:	0f 5f       	subi	r16, 0xFF	; 255
    33a8:	1f 4f       	sbci	r17, 0xFF	; 255
    33aa:	ec 0c       	add	r14, r12
    33ac:	fd 1c       	adc	r15, r13
    33ae:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <count>
    33b2:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <count+0x1>
    33b6:	08 17       	cp	r16, r24
    33b8:	19 07       	cpc	r17, r25
    33ba:	e0 f2       	brcs	.-72     	; 0x3374 <csp_buffer_init+0x96>
    33bc:	80 e0       	ldi	r24, 0x00	; 0
    33be:	90 e0       	ldi	r25, 0x00	; 0
    33c0:	0d c0       	rjmp	.+26     	; 0x33dc <csp_buffer_init+0xfe>
    33c2:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <csp_buffer_pool>
    33c6:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <csp_buffer_pool+0x1>
    33ca:	8f dd       	rcall	.-1250   	; 0x2eea <csp_free>
    33cc:	8f ef       	ldi	r24, 0xFF	; 255
    33ce:	9f ef       	ldi	r25, 0xFF	; 255
    33d0:	05 c0       	rjmp	.+10     	; 0x33dc <csp_buffer_init+0xfe>
    33d2:	8f ef       	ldi	r24, 0xFF	; 255
    33d4:	9f ef       	ldi	r25, 0xFF	; 255
    33d6:	02 c0       	rjmp	.+4      	; 0x33dc <csp_buffer_init+0xfe>
    33d8:	80 e0       	ldi	r24, 0x00	; 0
    33da:	90 e0       	ldi	r25, 0x00	; 0
    33dc:	0f 90       	pop	r0
    33de:	0f 90       	pop	r0
    33e0:	df 91       	pop	r29
    33e2:	cf 91       	pop	r28
    33e4:	1f 91       	pop	r17
    33e6:	0f 91       	pop	r16
    33e8:	ff 90       	pop	r15
    33ea:	ef 90       	pop	r14
    33ec:	df 90       	pop	r13
    33ee:	cf 90       	pop	r12
    33f0:	08 95       	ret

000033f2 <csp_buffer_get>:
    33f2:	cf 93       	push	r28
    33f4:	df 93       	push	r29
    33f6:	1f 92       	push	r1
    33f8:	1f 92       	push	r1
    33fa:	cd b7       	in	r28, 0x3d	; 61
    33fc:	de b7       	in	r29, 0x3e	; 62
    33fe:	1a 82       	std	Y+2, r1	; 0x02
    3400:	19 82       	std	Y+1, r1	; 0x01
    3402:	ac 01       	movw	r20, r24
    3404:	42 5f       	subi	r20, 0xF2	; 242
    3406:	5f 4f       	sbci	r21, 0xFF	; 255
    3408:	20 91 1f 03 	lds	r18, 0x031F	; 0x80031f <size>
    340c:	30 91 20 03 	lds	r19, 0x0320	; 0x800320 <size+0x1>
    3410:	24 17       	cp	r18, r20
    3412:	35 07       	cpc	r19, r21
    3414:	80 f4       	brcc	.+32     	; 0x3436 <csp_buffer_get+0x44>
    3416:	9f 93       	push	r25
    3418:	8f 93       	push	r24
    341a:	84 e9       	ldi	r24, 0x94	; 148
    341c:	92 e0       	ldi	r25, 0x02	; 2
    341e:	9f 93       	push	r25
    3420:	8f 93       	push	r24
    3422:	1f 92       	push	r1
    3424:	33 d5       	rcall	.+2662   	; 0x3e8c <do_csp_debug>
    3426:	0f 90       	pop	r0
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	80 e0       	ldi	r24, 0x00	; 0
    3432:	90 e0       	ldi	r25, 0x00	; 0
    3434:	57 c0       	rjmp	.+174    	; 0x34e4 <csp_buffer_get+0xf2>
    3436:	20 e0       	ldi	r18, 0x00	; 0
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	a9 01       	movw	r20, r18
    343c:	be 01       	movw	r22, r28
    343e:	6f 5f       	subi	r22, 0xFF	; 255
    3440:	7f 4f       	sbci	r23, 0xFF	; 255
    3442:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <csp_buffers>
    3446:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <csp_buffers+0x1>
    344a:	81 dd       	rcall	.-1278   	; 0x2f4e <csp_queue_dequeue>
    344c:	e9 81       	ldd	r30, Y+1	; 0x01
    344e:	fa 81       	ldd	r31, Y+2	; 0x02
    3450:	30 97       	sbiw	r30, 0x00	; 0
    3452:	61 f4       	brne	.+24     	; 0x346c <csp_buffer_get+0x7a>
    3454:	85 e8       	ldi	r24, 0x85	; 133
    3456:	92 e0       	ldi	r25, 0x02	; 2
    3458:	9f 93       	push	r25
    345a:	8f 93       	push	r24
    345c:	1f 92       	push	r1
    345e:	16 d5       	rcall	.+2604   	; 0x3e8c <do_csp_debug>
    3460:	0f 90       	pop	r0
    3462:	0f 90       	pop	r0
    3464:	0f 90       	pop	r0
    3466:	80 e0       	ldi	r24, 0x00	; 0
    3468:	90 e0       	ldi	r25, 0x00	; 0
    346a:	3c c0       	rjmp	.+120    	; 0x34e4 <csp_buffer_get+0xf2>
    346c:	83 81       	ldd	r24, Z+3	; 0x03
    346e:	8f 93       	push	r24
    3470:	82 81       	ldd	r24, Z+2	; 0x02
    3472:	8f 93       	push	r24
    3474:	ff 93       	push	r31
    3476:	ef 93       	push	r30
    3478:	8a e7       	ldi	r24, 0x7A	; 122
    347a:	92 e0       	ldi	r25, 0x02	; 2
    347c:	9f 93       	push	r25
    347e:	8f 93       	push	r24
    3480:	83 e0       	ldi	r24, 0x03	; 3
    3482:	8f 93       	push	r24
    3484:	03 d5       	rcall	.+2566   	; 0x3e8c <do_csp_debug>
    3486:	e9 81       	ldd	r30, Y+1	; 0x01
    3488:	fa 81       	ldd	r31, Y+2	; 0x02
    348a:	0f b6       	in	r0, 0x3f	; 63
    348c:	f8 94       	cli
    348e:	de bf       	out	0x3e, r29	; 62
    3490:	0f be       	out	0x3f, r0	; 63
    3492:	cd bf       	out	0x3d, r28	; 61
    3494:	82 81       	ldd	r24, Z+2	; 0x02
    3496:	93 81       	ldd	r25, Z+3	; 0x03
    3498:	e8 17       	cp	r30, r24
    349a:	f9 07       	cpc	r31, r25
    349c:	d9 f0       	breq	.+54     	; 0x34d4 <csp_buffer_get+0xe2>
    349e:	87 e6       	ldi	r24, 0x67	; 103
    34a0:	92 e0       	ldi	r25, 0x02	; 2
    34a2:	9f 93       	push	r25
    34a4:	8f 93       	push	r24
    34a6:	1f 92       	push	r1
    34a8:	f1 d4       	rcall	.+2530   	; 0x3e8c <do_csp_debug>
    34aa:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <csp_buffer_pool>
    34ae:	90 91 24 03 	lds	r25, 0x0324	; 0x800324 <csp_buffer_pool+0x1>
    34b2:	0e 94 9f 31 	call	0x633e	; 0x633e <vPortFree>
    34b6:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <size>
    34ba:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <size+0x1>
    34be:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <count>
    34c2:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <count+0x1>
    34c6:	0b df       	rcall	.-490    	; 0x32de <csp_buffer_init>
    34c8:	0f 90       	pop	r0
    34ca:	0f 90       	pop	r0
    34cc:	0f 90       	pop	r0
    34ce:	80 e0       	ldi	r24, 0x00	; 0
    34d0:	90 e0       	ldi	r25, 0x00	; 0
    34d2:	08 c0       	rjmp	.+16     	; 0x34e4 <csp_buffer_get+0xf2>
    34d4:	80 81       	ld	r24, Z
    34d6:	91 81       	ldd	r25, Z+1	; 0x01
    34d8:	01 96       	adiw	r24, 0x01	; 1
    34da:	91 83       	std	Z+1, r25	; 0x01
    34dc:	80 83       	st	Z, r24
    34de:	89 81       	ldd	r24, Y+1	; 0x01
    34e0:	9a 81       	ldd	r25, Y+2	; 0x02
    34e2:	04 96       	adiw	r24, 0x04	; 4
    34e4:	0f 90       	pop	r0
    34e6:	0f 90       	pop	r0
    34e8:	df 91       	pop	r29
    34ea:	cf 91       	pop	r28
    34ec:	08 95       	ret

000034ee <csp_buffer_free_isr>:
    34ee:	cf 93       	push	r28
    34f0:	df 93       	push	r29
    34f2:	00 d0       	rcall	.+0      	; 0x34f4 <csp_buffer_free_isr+0x6>
    34f4:	cd b7       	in	r28, 0x3d	; 61
    34f6:	de b7       	in	r29, 0x3e	; 62
    34f8:	19 82       	std	Y+1, r1	; 0x01
    34fa:	00 97       	sbiw	r24, 0x00	; 0
    34fc:	29 f1       	breq	.+74     	; 0x3548 <csp_buffer_free_isr+0x5a>
    34fe:	fc 01       	movw	r30, r24
    3500:	34 97       	sbiw	r30, 0x04	; 4
    3502:	fb 83       	std	Y+3, r31	; 0x03
    3504:	ea 83       	std	Y+2, r30	; 0x02
    3506:	22 81       	ldd	r18, Z+2	; 0x02
    3508:	33 81       	ldd	r19, Z+3	; 0x03
    350a:	e2 17       	cp	r30, r18
    350c:	f3 07       	cpc	r31, r19
    350e:	e1 f4       	brne	.+56     	; 0x3548 <csp_buffer_free_isr+0x5a>
    3510:	20 81       	ld	r18, Z
    3512:	31 81       	ldd	r19, Z+1	; 0x01
    3514:	21 15       	cp	r18, r1
    3516:	31 05       	cpc	r19, r1
    3518:	b9 f0       	breq	.+46     	; 0x3548 <csp_buffer_free_isr+0x5a>
    351a:	22 30       	cpi	r18, 0x02	; 2
    351c:	31 05       	cpc	r19, r1
    351e:	28 f0       	brcs	.+10     	; 0x352a <csp_buffer_free_isr+0x3c>
    3520:	21 50       	subi	r18, 0x01	; 1
    3522:	31 09       	sbc	r19, r1
    3524:	31 83       	std	Z+1, r19	; 0x01
    3526:	20 83       	st	Z, r18
    3528:	0f c0       	rjmp	.+30     	; 0x3548 <csp_buffer_free_isr+0x5a>
    352a:	fc 01       	movw	r30, r24
    352c:	34 97       	sbiw	r30, 0x04	; 4
    352e:	11 82       	std	Z+1, r1	; 0x01
    3530:	10 82       	st	Z, r1
    3532:	ae 01       	movw	r20, r28
    3534:	4f 5f       	subi	r20, 0xFF	; 255
    3536:	5f 4f       	sbci	r21, 0xFF	; 255
    3538:	be 01       	movw	r22, r28
    353a:	6e 5f       	subi	r22, 0xFE	; 254
    353c:	7f 4f       	sbci	r23, 0xFF	; 255
    353e:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <csp_buffers>
    3542:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <csp_buffers+0x1>
    3546:	fc dc       	rcall	.-1544   	; 0x2f40 <csp_queue_enqueue_isr>
    3548:	0f 90       	pop	r0
    354a:	0f 90       	pop	r0
    354c:	0f 90       	pop	r0
    354e:	df 91       	pop	r29
    3550:	cf 91       	pop	r28
    3552:	08 95       	ret

00003554 <csp_buffer_free>:
    3554:	cf 93       	push	r28
    3556:	df 93       	push	r29
    3558:	1f 92       	push	r1
    355a:	1f 92       	push	r1
    355c:	cd b7       	in	r28, 0x3d	; 61
    355e:	de b7       	in	r29, 0x3e	; 62
    3560:	00 97       	sbiw	r24, 0x00	; 0
    3562:	51 f4       	brne	.+20     	; 0x3578 <csp_buffer_free+0x24>
    3564:	8a e4       	ldi	r24, 0x4A	; 74
    3566:	92 e0       	ldi	r25, 0x02	; 2
    3568:	9f 93       	push	r25
    356a:	8f 93       	push	r24
    356c:	1f 92       	push	r1
    356e:	8e d4       	rcall	.+2332   	; 0x3e8c <do_csp_debug>
    3570:	0f 90       	pop	r0
    3572:	0f 90       	pop	r0
    3574:	0f 90       	pop	r0
    3576:	62 c0       	rjmp	.+196    	; 0x363c <csp_buffer_free+0xe8>
    3578:	fc 01       	movw	r30, r24
    357a:	34 97       	sbiw	r30, 0x04	; 4
    357c:	fa 83       	std	Y+2, r31	; 0x02
    357e:	e9 83       	std	Y+1, r30	; 0x01
    3580:	22 81       	ldd	r18, Z+2	; 0x02
    3582:	33 81       	ldd	r19, Z+3	; 0x03
    3584:	e2 17       	cp	r30, r18
    3586:	f3 07       	cpc	r31, r19
    3588:	71 f0       	breq	.+28     	; 0x35a6 <csp_buffer_free+0x52>
    358a:	9f 93       	push	r25
    358c:	8f 93       	push	r24
    358e:	86 e2       	ldi	r24, 0x26	; 38
    3590:	92 e0       	ldi	r25, 0x02	; 2
    3592:	9f 93       	push	r25
    3594:	8f 93       	push	r24
    3596:	1f 92       	push	r1
    3598:	79 d4       	rcall	.+2290   	; 0x3e8c <do_csp_debug>
    359a:	0f 90       	pop	r0
    359c:	0f 90       	pop	r0
    359e:	0f 90       	pop	r0
    35a0:	0f 90       	pop	r0
    35a2:	0f 90       	pop	r0
    35a4:	4b c0       	rjmp	.+150    	; 0x363c <csp_buffer_free+0xe8>
    35a6:	dc 01       	movw	r26, r24
    35a8:	14 97       	sbiw	r26, 0x04	; 4
    35aa:	2d 91       	ld	r18, X+
    35ac:	3c 91       	ld	r19, X
    35ae:	21 15       	cp	r18, r1
    35b0:	31 05       	cpc	r19, r1
    35b2:	71 f4       	brne	.+28     	; 0x35d0 <csp_buffer_free+0x7c>
    35b4:	ff 93       	push	r31
    35b6:	ef 93       	push	r30
    35b8:	89 e0       	ldi	r24, 0x09	; 9
    35ba:	92 e0       	ldi	r25, 0x02	; 2
    35bc:	9f 93       	push	r25
    35be:	8f 93       	push	r24
    35c0:	1f 92       	push	r1
    35c2:	64 d4       	rcall	.+2248   	; 0x3e8c <do_csp_debug>
    35c4:	0f 90       	pop	r0
    35c6:	0f 90       	pop	r0
    35c8:	0f 90       	pop	r0
    35ca:	0f 90       	pop	r0
    35cc:	0f 90       	pop	r0
    35ce:	36 c0       	rjmp	.+108    	; 0x363c <csp_buffer_free+0xe8>
    35d0:	22 30       	cpi	r18, 0x02	; 2
    35d2:	31 05       	cpc	r19, r1
    35d4:	b0 f0       	brcs	.+44     	; 0x3602 <csp_buffer_free+0xae>
    35d6:	21 50       	subi	r18, 0x01	; 1
    35d8:	31 09       	sbc	r19, r1
    35da:	dc 01       	movw	r26, r24
    35dc:	14 97       	sbiw	r26, 0x04	; 4
    35de:	2d 93       	st	X+, r18
    35e0:	3c 93       	st	X, r19
    35e2:	3f 93       	push	r19
    35e4:	2f 93       	push	r18
    35e6:	ff 93       	push	r31
    35e8:	ef 93       	push	r30
    35ea:	86 ee       	ldi	r24, 0xE6	; 230
    35ec:	91 e0       	ldi	r25, 0x01	; 1
    35ee:	9f 93       	push	r25
    35f0:	8f 93       	push	r24
    35f2:	1f 92       	push	r1
    35f4:	4b d4       	rcall	.+2198   	; 0x3e8c <do_csp_debug>
    35f6:	0f b6       	in	r0, 0x3f	; 63
    35f8:	f8 94       	cli
    35fa:	de bf       	out	0x3e, r29	; 62
    35fc:	0f be       	out	0x3f, r0	; 63
    35fe:	cd bf       	out	0x3d, r28	; 61
    3600:	1d c0       	rjmp	.+58     	; 0x363c <csp_buffer_free+0xe8>
    3602:	dc 01       	movw	r26, r24
    3604:	14 97       	sbiw	r26, 0x04	; 4
    3606:	1d 92       	st	X+, r1
    3608:	1c 92       	st	X, r1
    360a:	ff 93       	push	r31
    360c:	ef 93       	push	r30
    360e:	8d ed       	ldi	r24, 0xDD	; 221
    3610:	91 e0       	ldi	r25, 0x01	; 1
    3612:	9f 93       	push	r25
    3614:	8f 93       	push	r24
    3616:	83 e0       	ldi	r24, 0x03	; 3
    3618:	8f 93       	push	r24
    361a:	38 d4       	rcall	.+2160   	; 0x3e8c <do_csp_debug>
    361c:	20 e0       	ldi	r18, 0x00	; 0
    361e:	30 e0       	ldi	r19, 0x00	; 0
    3620:	a9 01       	movw	r20, r18
    3622:	be 01       	movw	r22, r28
    3624:	6f 5f       	subi	r22, 0xFF	; 255
    3626:	7f 4f       	sbci	r23, 0xFF	; 255
    3628:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <csp_buffers>
    362c:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <csp_buffers+0x1>
    3630:	63 dc       	rcall	.-1850   	; 0x2ef8 <csp_queue_enqueue>
    3632:	0f 90       	pop	r0
    3634:	0f 90       	pop	r0
    3636:	0f 90       	pop	r0
    3638:	0f 90       	pop	r0
    363a:	0f 90       	pop	r0
    363c:	0f 90       	pop	r0
    363e:	0f 90       	pop	r0
    3640:	df 91       	pop	r29
    3642:	cf 91       	pop	r28
    3644:	08 95       	ret

00003646 <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    3646:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <csp_buffers>
    364a:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <csp_buffers+0x1>
    364e:	a0 cc       	rjmp	.-1728   	; 0x2f90 <csp_queue_size>
}
    3650:	08 95       	ret

00003652 <csp_conn_flush_rx_queue>:

inline int csp_conn_flags(csp_conn_t * conn) {

	return conn->idin.flags;

}
    3652:	0f 93       	push	r16
    3654:	1f 93       	push	r17
    3656:	cf 93       	push	r28
    3658:	df 93       	push	r29
    365a:	1f 92       	push	r1
    365c:	1f 92       	push	r1
    365e:	cd b7       	in	r28, 0x3d	; 61
    3660:	de b7       	in	r29, 0x3e	; 62
    3662:	8c 01       	movw	r16, r24
    3664:	05 c0       	rjmp	.+10     	; 0x3670 <csp_conn_flush_rx_queue+0x1e>
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	9a 81       	ldd	r25, Y+2	; 0x02
    366a:	00 97       	sbiw	r24, 0x00	; 0
    366c:	09 f0       	breq	.+2      	; 0x3670 <csp_conn_flush_rx_queue+0x1e>
    366e:	72 df       	rcall	.-284    	; 0x3554 <csp_buffer_free>
    3670:	20 e0       	ldi	r18, 0x00	; 0
    3672:	30 e0       	ldi	r19, 0x00	; 0
    3674:	a9 01       	movw	r20, r18
    3676:	be 01       	movw	r22, r28
    3678:	6f 5f       	subi	r22, 0xFF	; 255
    367a:	7f 4f       	sbci	r23, 0xFF	; 255
    367c:	f8 01       	movw	r30, r16
    367e:	84 85       	ldd	r24, Z+12	; 0x0c
    3680:	95 85       	ldd	r25, Z+13	; 0x0d
    3682:	65 dc       	rcall	.-1846   	; 0x2f4e <csp_queue_dequeue>
    3684:	01 97       	sbiw	r24, 0x01	; 1
    3686:	79 f3       	breq	.-34     	; 0x3666 <csp_conn_flush_rx_queue+0x14>
    3688:	80 e0       	ldi	r24, 0x00	; 0
    368a:	90 e0       	ldi	r25, 0x00	; 0
    368c:	0f 90       	pop	r0
    368e:	0f 90       	pop	r0
    3690:	df 91       	pop	r29
    3692:	cf 91       	pop	r28
    3694:	1f 91       	pop	r17
    3696:	0f 91       	pop	r16
    3698:	08 95       	ret

0000369a <csp_conn_enqueue_packet>:
    369a:	0f 93       	push	r16
    369c:	1f 93       	push	r17
    369e:	cf 93       	push	r28
    36a0:	df 93       	push	r29
    36a2:	1f 92       	push	r1
    36a4:	1f 92       	push	r1
    36a6:	cd b7       	in	r28, 0x3d	; 61
    36a8:	de b7       	in	r29, 0x3e	; 62
    36aa:	7a 83       	std	Y+2, r23	; 0x02
    36ac:	69 83       	std	Y+1, r22	; 0x01
    36ae:	00 97       	sbiw	r24, 0x00	; 0
    36b0:	31 f1       	breq	.+76     	; 0x36fe <csp_conn_enqueue_packet+0x64>
    36b2:	8c 01       	movw	r16, r24
    36b4:	20 e0       	ldi	r18, 0x00	; 0
    36b6:	30 e0       	ldi	r19, 0x00	; 0
    36b8:	a9 01       	movw	r20, r18
    36ba:	be 01       	movw	r22, r28
    36bc:	6f 5f       	subi	r22, 0xFF	; 255
    36be:	7f 4f       	sbci	r23, 0xFF	; 255
    36c0:	fc 01       	movw	r30, r24
    36c2:	84 85       	ldd	r24, Z+12	; 0x0c
    36c4:	95 85       	ldd	r25, Z+13	; 0x0d
    36c6:	18 dc       	rcall	.-2000   	; 0x2ef8 <csp_queue_enqueue>
    36c8:	01 97       	sbiw	r24, 0x01	; 1
    36ca:	e1 f0       	breq	.+56     	; 0x3704 <csp_conn_enqueue_packet+0x6a>
    36cc:	f8 01       	movw	r30, r16
    36ce:	84 85       	ldd	r24, Z+12	; 0x0c
    36d0:	95 85       	ldd	r25, Z+13	; 0x0d
    36d2:	5e dc       	rcall	.-1860   	; 0x2f90 <csp_queue_size>
    36d4:	9f 93       	push	r25
    36d6:	8f 93       	push	r24
    36d8:	f8 01       	movw	r30, r16
    36da:	85 85       	ldd	r24, Z+13	; 0x0d
    36dc:	8f 93       	push	r24
    36de:	84 85       	ldd	r24, Z+12	; 0x0c
    36e0:	8f 93       	push	r24
    36e2:	8d ec       	ldi	r24, 0xCD	; 205
    36e4:	94 e0       	ldi	r25, 0x04	; 4
    36e6:	9f 93       	push	r25
    36e8:	8f 93       	push	r24
    36ea:	1f 92       	push	r1
    36ec:	cf d3       	rcall	.+1950   	; 0x3e8c <do_csp_debug>
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	f8 94       	cli
    36f2:	de bf       	out	0x3e, r29	; 62
    36f4:	0f be       	out	0x3f, r0	; 63
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	8f ef       	ldi	r24, 0xFF	; 255
    36fa:	9f ef       	ldi	r25, 0xFF	; 255
    36fc:	05 c0       	rjmp	.+10     	; 0x3708 <csp_conn_enqueue_packet+0x6e>
    36fe:	8e ef       	ldi	r24, 0xFE	; 254
    3700:	9f ef       	ldi	r25, 0xFF	; 255
    3702:	02 c0       	rjmp	.+4      	; 0x3708 <csp_conn_enqueue_packet+0x6e>
    3704:	80 e0       	ldi	r24, 0x00	; 0
    3706:	90 e0       	ldi	r25, 0x00	; 0
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	df 91       	pop	r29
    370e:	cf 91       	pop	r28
    3710:	1f 91       	pop	r17
    3712:	0f 91       	pop	r16
    3714:	08 95       	ret

00003716 <csp_conn_init>:
    3716:	0f 93       	push	r16
    3718:	1f 93       	push	r17
    371a:	cf 93       	push	r28
    371c:	df 93       	push	r29
    371e:	be dd       	rcall	.-1156   	; 0x329c <csp_get_ms>
    3720:	cb 01       	movw	r24, r22
    3722:	0e 94 89 44 	call	0x8912	; 0x8912 <srand>
    3726:	0e 94 86 44 	call	0x890c	; 0x890c <rand>
    372a:	8f 71       	andi	r24, 0x1F	; 31
    372c:	90 78       	andi	r25, 0x80	; 128
    372e:	99 23       	and	r25, r25
    3730:	24 f4       	brge	.+8      	; 0x373a <csp_conn_init+0x24>
    3732:	01 97       	sbiw	r24, 0x01	; 1
    3734:	80 6e       	ori	r24, 0xE0	; 224
    3736:	9f 6f       	ori	r25, 0xFF	; 255
    3738:	01 96       	adiw	r24, 0x01	; 1
    373a:	80 5e       	subi	r24, 0xE0	; 224
    373c:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <sport>
    3740:	88 e2       	ldi	r24, 0x28	; 40
    3742:	93 e0       	ldi	r25, 0x03	; 3
    3744:	3b dc       	rcall	.-1930   	; 0x2fbc <csp_bin_sem_create>
    3746:	01 97       	sbiw	r24, 0x01	; 1
    3748:	29 f4       	brne	.+10     	; 0x3754 <csp_conn_init+0x3e>
    374a:	cf e2       	ldi	r28, 0x2F	; 47
    374c:	d3 e0       	ldi	r29, 0x03	; 3
    374e:	0f e1       	ldi	r16, 0x1F	; 31
    3750:	14 e0       	ldi	r17, 0x04	; 4
    3752:	1c c0       	rjmp	.+56     	; 0x378c <csp_conn_init+0x76>
    3754:	8a ea       	ldi	r24, 0xAA	; 170
    3756:	94 e0       	ldi	r25, 0x04	; 4
    3758:	9f 93       	push	r25
    375a:	8f 93       	push	r24
    375c:	1f 92       	push	r1
    375e:	96 d3       	rcall	.+1836   	; 0x3e8c <do_csp_debug>
    3760:	0f 90       	pop	r0
    3762:	0f 90       	pop	r0
    3764:	0f 90       	pop	r0
    3766:	8f ef       	ldi	r24, 0xFF	; 255
    3768:	9f ef       	ldi	r25, 0xFF	; 255
    376a:	32 c0       	rjmp	.+100    	; 0x37d0 <csp_conn_init+0xba>
    376c:	89 e8       	ldi	r24, 0x89	; 137
    376e:	94 e0       	ldi	r25, 0x04	; 4
    3770:	9f 93       	push	r25
    3772:	8f 93       	push	r24
    3774:	1f 92       	push	r1
    3776:	8a d3       	rcall	.+1812   	; 0x3e8c <do_csp_debug>
    3778:	0f 90       	pop	r0
    377a:	0f 90       	pop	r0
    377c:	0f 90       	pop	r0
    377e:	8f ef       	ldi	r24, 0xFF	; 255
    3780:	9f ef       	ldi	r25, 0xFF	; 255
    3782:	26 c0       	rjmp	.+76     	; 0x37d0 <csp_conn_init+0xba>
    3784:	68 96       	adiw	r28, 0x18	; 24
    3786:	0c 17       	cp	r16, r28
    3788:	1d 07       	cpc	r17, r29
    378a:	79 f0       	breq	.+30     	; 0x37aa <csp_conn_init+0x94>
    378c:	62 e0       	ldi	r22, 0x02	; 2
    378e:	70 e0       	ldi	r23, 0x00	; 0
    3790:	84 e6       	ldi	r24, 0x64	; 100
    3792:	90 e0       	ldi	r25, 0x00	; 0
    3794:	ad db       	rcall	.-2214   	; 0x2ef0 <csp_queue_create>
    3796:	9b 87       	std	Y+11, r25	; 0x0b
    3798:	8a 87       	std	Y+10, r24	; 0x0a
    379a:	fe 01       	movw	r30, r28
    379c:	31 97       	sbiw	r30, 0x01	; 1
    379e:	10 82       	st	Z, r1
    37a0:	ce 01       	movw	r24, r28
    37a2:	fa db       	rcall	.-2060   	; 0x2f98 <csp_mutex_create>
    37a4:	01 97       	sbiw	r24, 0x01	; 1
    37a6:	71 f3       	breq	.-36     	; 0x3784 <csp_conn_init+0x6e>
    37a8:	e1 cf       	rjmp	.-62     	; 0x376c <csp_conn_init+0x56>
    37aa:	8b e2       	ldi	r24, 0x2B	; 43
    37ac:	93 e0       	ldi	r25, 0x03	; 3
    37ae:	06 dc       	rcall	.-2036   	; 0x2fbc <csp_bin_sem_create>
    37b0:	01 97       	sbiw	r24, 0x01	; 1
    37b2:	61 f0       	breq	.+24     	; 0x37cc <csp_conn_init+0xb6>
    37b4:	87 e6       	ldi	r24, 0x67	; 103
    37b6:	94 e0       	ldi	r25, 0x04	; 4
    37b8:	9f 93       	push	r25
    37ba:	8f 93       	push	r24
    37bc:	1f 92       	push	r1
    37be:	66 d3       	rcall	.+1740   	; 0x3e8c <do_csp_debug>
    37c0:	0f 90       	pop	r0
    37c2:	0f 90       	pop	r0
    37c4:	0f 90       	pop	r0
    37c6:	8f ef       	ldi	r24, 0xFF	; 255
    37c8:	9f ef       	ldi	r25, 0xFF	; 255
    37ca:	02 c0       	rjmp	.+4      	; 0x37d0 <csp_conn_init+0xba>
    37cc:	80 e0       	ldi	r24, 0x00	; 0
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	df 91       	pop	r29
    37d2:	cf 91       	pop	r28
    37d4:	1f 91       	pop	r17
    37d6:	0f 91       	pop	r16
    37d8:	08 95       	ret

000037da <csp_conn_find>:
    37da:	8f 92       	push	r8
    37dc:	9f 92       	push	r9
    37de:	af 92       	push	r10
    37e0:	bf 92       	push	r11
    37e2:	cf 92       	push	r12
    37e4:	df 92       	push	r13
    37e6:	ef 92       	push	r14
    37e8:	ff 92       	push	r15
    37ea:	6b 01       	movw	r12, r22
    37ec:	7c 01       	movw	r14, r24
    37ee:	49 01       	movw	r8, r18
    37f0:	5a 01       	movw	r10, r20
    37f2:	ed e2       	ldi	r30, 0x2D	; 45
    37f4:	f3 e0       	ldi	r31, 0x03	; 3
    37f6:	80 e0       	ldi	r24, 0x00	; 0
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	31 81       	ldd	r19, Z+1	; 0x01
    37fc:	33 23       	and	r19, r19
    37fe:	09 f1       	breq	.+66     	; 0x3842 <csp_conn_find+0x68>
    3800:	20 81       	ld	r18, Z
    3802:	21 11       	cpse	r18, r1
    3804:	1e c0       	rjmp	.+60     	; 0x3842 <csp_conn_find+0x68>
    3806:	44 81       	ldd	r20, Z+4	; 0x04
    3808:	55 81       	ldd	r21, Z+5	; 0x05
    380a:	66 81       	ldd	r22, Z+6	; 0x06
    380c:	77 81       	ldd	r23, Z+7	; 0x07
    380e:	4c 25       	eor	r20, r12
    3810:	5d 25       	eor	r21, r13
    3812:	6e 25       	eor	r22, r14
    3814:	7f 25       	eor	r23, r15
    3816:	48 21       	and	r20, r8
    3818:	59 21       	and	r21, r9
    381a:	6a 21       	and	r22, r10
    381c:	7b 21       	and	r23, r11
    381e:	45 2b       	or	r20, r21
    3820:	46 2b       	or	r20, r22
    3822:	47 2b       	or	r20, r23
    3824:	71 f4       	brne	.+28     	; 0x3842 <csp_conn_find+0x68>
    3826:	9c 01       	movw	r18, r24
    3828:	22 0f       	add	r18, r18
    382a:	33 1f       	adc	r19, r19
    382c:	82 0f       	add	r24, r18
    382e:	93 1f       	adc	r25, r19
    3830:	88 0f       	add	r24, r24
    3832:	99 1f       	adc	r25, r25
    3834:	88 0f       	add	r24, r24
    3836:	99 1f       	adc	r25, r25
    3838:	88 0f       	add	r24, r24
    383a:	99 1f       	adc	r25, r25
    383c:	83 5d       	subi	r24, 0xD3	; 211
    383e:	9c 4f       	sbci	r25, 0xFC	; 252
    3840:	07 c0       	rjmp	.+14     	; 0x3850 <csp_conn_find+0x76>
    3842:	01 96       	adiw	r24, 0x01	; 1
    3844:	78 96       	adiw	r30, 0x18	; 24
    3846:	8a 30       	cpi	r24, 0x0A	; 10
    3848:	91 05       	cpc	r25, r1
    384a:	b9 f6       	brne	.-82     	; 0x37fa <csp_conn_find+0x20>
    384c:	80 e0       	ldi	r24, 0x00	; 0
    384e:	90 e0       	ldi	r25, 0x00	; 0
    3850:	ff 90       	pop	r15
    3852:	ef 90       	pop	r14
    3854:	df 90       	pop	r13
    3856:	cf 90       	pop	r12
    3858:	bf 90       	pop	r11
    385a:	af 90       	pop	r10
    385c:	9f 90       	pop	r9
    385e:	8f 90       	pop	r8
    3860:	08 95       	ret

00003862 <csp_conn_allocate>:
    3862:	1f 93       	push	r17
    3864:	cf 93       	push	r28
    3866:	df 93       	push	r29
    3868:	18 2f       	mov	r17, r24
    386a:	44 e6       	ldi	r20, 0x64	; 100
    386c:	50 e0       	ldi	r21, 0x00	; 0
    386e:	60 e0       	ldi	r22, 0x00	; 0
    3870:	70 e0       	ldi	r23, 0x00	; 0
    3872:	8b e2       	ldi	r24, 0x2B	; 43
    3874:	93 e0       	ldi	r25, 0x03	; 3
    3876:	ba db       	rcall	.-2188   	; 0x2fec <csp_bin_sem_wait>
    3878:	01 97       	sbiw	r24, 0x01	; 1
    387a:	61 f0       	breq	.+24     	; 0x3894 <csp_conn_allocate+0x32>
    387c:	8d e4       	ldi	r24, 0x4D	; 77
    387e:	94 e0       	ldi	r25, 0x04	; 4
    3880:	9f 93       	push	r25
    3882:	8f 93       	push	r24
    3884:	1f 92       	push	r1
    3886:	02 d3       	rcall	.+1540   	; 0x3e8c <do_csp_debug>
    3888:	0f 90       	pop	r0
    388a:	0f 90       	pop	r0
    388c:	0f 90       	pop	r0
    388e:	80 e0       	ldi	r24, 0x00	; 0
    3890:	90 e0       	ldi	r25, 0x00	; 0
    3892:	5a c0       	rjmp	.+180    	; 0x3948 <csp_conn_allocate+0xe6>
    3894:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <csp_conn_last_given.3263>
    3898:	90 e0       	ldi	r25, 0x00	; 0
    389a:	01 96       	adiw	r24, 0x01	; 1
    389c:	6a e0       	ldi	r22, 0x0A	; 10
    389e:	70 e0       	ldi	r23, 0x00	; 0
    38a0:	0e 94 e9 43 	call	0x87d2	; 0x87d2 <__divmodhi4>
    38a4:	fc 01       	movw	r30, r24
    38a6:	ee 0f       	add	r30, r30
    38a8:	ff 1f       	adc	r31, r31
    38aa:	e8 0f       	add	r30, r24
    38ac:	f9 1f       	adc	r31, r25
    38ae:	ee 0f       	add	r30, r30
    38b0:	ff 1f       	adc	r31, r31
    38b2:	ee 0f       	add	r30, r30
    38b4:	ff 1f       	adc	r31, r31
    38b6:	ee 0f       	add	r30, r30
    38b8:	ff 1f       	adc	r31, r31
    38ba:	e3 5d       	subi	r30, 0xD3	; 211
    38bc:	fc 4f       	sbci	r31, 0xFC	; 252
    38be:	41 81       	ldd	r20, Z+1	; 0x01
    38c0:	41 11       	cpse	r20, r1
    38c2:	38 c0       	rjmp	.+112    	; 0x3934 <csp_conn_allocate+0xd2>
    38c4:	ef 01       	movw	r28, r30
    38c6:	17 c0       	rjmp	.+46     	; 0x38f6 <csp_conn_allocate+0x94>
    38c8:	ec 01       	movw	r28, r24
    38ca:	cc 0f       	add	r28, r28
    38cc:	dd 1f       	adc	r29, r29
    38ce:	c8 0f       	add	r28, r24
    38d0:	d9 1f       	adc	r29, r25
    38d2:	cc 0f       	add	r28, r28
    38d4:	dd 1f       	adc	r29, r29
    38d6:	cc 0f       	add	r28, r28
    38d8:	dd 1f       	adc	r29, r29
    38da:	cc 0f       	add	r28, r28
    38dc:	dd 1f       	adc	r29, r29
    38de:	c3 5d       	subi	r28, 0xD3	; 211
    38e0:	dc 4f       	sbci	r29, 0xFC	; 252
    38e2:	49 81       	ldd	r20, Y+1	; 0x01
    38e4:	44 23       	and	r20, r20
    38e6:	39 f0       	breq	.+14     	; 0x38f6 <csp_conn_allocate+0x94>
    38e8:	01 96       	adiw	r24, 0x01	; 1
    38ea:	bf 01       	movw	r22, r30
    38ec:	0e 94 e9 43 	call	0x87d2	; 0x87d2 <__divmodhi4>
    38f0:	21 50       	subi	r18, 0x01	; 1
    38f2:	31 09       	sbc	r19, r1
    38f4:	49 f7       	brne	.-46     	; 0x38c8 <csp_conn_allocate+0x66>
    38f6:	29 81       	ldd	r18, Y+1	; 0x01
    38f8:	21 30       	cpi	r18, 0x01	; 1
    38fa:	79 f4       	brne	.+30     	; 0x391a <csp_conn_allocate+0xb8>
    38fc:	84 e3       	ldi	r24, 0x34	; 52
    38fe:	94 e0       	ldi	r25, 0x04	; 4
    3900:	9f 93       	push	r25
    3902:	8f 93       	push	r24
    3904:	1f 92       	push	r1
    3906:	c2 d2       	rcall	.+1412   	; 0x3e8c <do_csp_debug>
    3908:	8b e2       	ldi	r24, 0x2B	; 43
    390a:	93 e0       	ldi	r25, 0x03	; 3
    390c:	a9 db       	rcall	.-2222   	; 0x3060 <csp_bin_sem_post>
    390e:	0f 90       	pop	r0
    3910:	0f 90       	pop	r0
    3912:	0f 90       	pop	r0
    3914:	80 e0       	ldi	r24, 0x00	; 0
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	17 c0       	rjmp	.+46     	; 0x3948 <csp_conn_allocate+0xe6>
    391a:	91 e0       	ldi	r25, 0x01	; 1
    391c:	99 83       	std	Y+1, r25	; 0x01
    391e:	1f 86       	std	Y+15, r1	; 0x0f
    3920:	1e 86       	std	Y+14, r1	; 0x0e
    3922:	18 83       	st	Y, r17
    3924:	80 93 27 03 	sts	0x0327, r24	; 0x800327 <csp_conn_last_given.3263>
    3928:	8b e2       	ldi	r24, 0x2B	; 43
    392a:	93 e0       	ldi	r25, 0x03	; 3
    392c:	99 db       	rcall	.-2254   	; 0x3060 <csp_bin_sem_post>
    392e:	8c 2f       	mov	r24, r28
    3930:	9d 2f       	mov	r25, r29
    3932:	0a c0       	rjmp	.+20     	; 0x3948 <csp_conn_allocate+0xe6>
    3934:	01 96       	adiw	r24, 0x01	; 1
    3936:	6a e0       	ldi	r22, 0x0A	; 10
    3938:	70 e0       	ldi	r23, 0x00	; 0
    393a:	0e 94 e9 43 	call	0x87d2	; 0x87d2 <__divmodhi4>
    393e:	29 e0       	ldi	r18, 0x09	; 9
    3940:	30 e0       	ldi	r19, 0x00	; 0
    3942:	ea e0       	ldi	r30, 0x0A	; 10
    3944:	f0 e0       	ldi	r31, 0x00	; 0
    3946:	c0 cf       	rjmp	.-128    	; 0x38c8 <csp_conn_allocate+0x66>
    3948:	df 91       	pop	r29
    394a:	cf 91       	pop	r28
    394c:	1f 91       	pop	r17
    394e:	08 95       	ret

00003950 <csp_conn_new>:
    3950:	8f 92       	push	r8
    3952:	9f 92       	push	r9
    3954:	af 92       	push	r10
    3956:	bf 92       	push	r11
    3958:	cf 92       	push	r12
    395a:	df 92       	push	r13
    395c:	ef 92       	push	r14
    395e:	ff 92       	push	r15
    3960:	cf 93       	push	r28
    3962:	df 93       	push	r29
    3964:	4b 01       	movw	r8, r22
    3966:	5c 01       	movw	r10, r24
    3968:	69 01       	movw	r12, r18
    396a:	7a 01       	movw	r14, r20
    396c:	80 e0       	ldi	r24, 0x00	; 0
    396e:	79 df       	rcall	.-270    	; 0x3862 <csp_conn_allocate>
    3970:	ec 01       	movw	r28, r24
    3972:	89 2b       	or	r24, r25
    3974:	79 f0       	breq	.+30     	; 0x3994 <csp_conn_new+0x44>
    3976:	8c 82       	std	Y+4, r8	; 0x04
    3978:	9d 82       	std	Y+5, r9	; 0x05
    397a:	ae 82       	std	Y+6, r10	; 0x06
    397c:	bf 82       	std	Y+7, r11	; 0x07
    397e:	c8 86       	std	Y+8, r12	; 0x08
    3980:	d9 86       	std	Y+9, r13	; 0x09
    3982:	ea 86       	std	Y+10, r14	; 0x0a
    3984:	fb 86       	std	Y+11, r15	; 0x0b
    3986:	8a dc       	rcall	.-1772   	; 0x329c <csp_get_ms>
    3988:	68 8b       	std	Y+16, r22	; 0x10
    398a:	79 8b       	std	Y+17, r23	; 0x11
    398c:	8a 8b       	std	Y+18, r24	; 0x12
    398e:	9b 8b       	std	Y+19, r25	; 0x13
    3990:	ce 01       	movw	r24, r28
    3992:	5f de       	rcall	.-834    	; 0x3652 <csp_conn_flush_rx_queue>
    3994:	ce 01       	movw	r24, r28
    3996:	df 91       	pop	r29
    3998:	cf 91       	pop	r28
    399a:	ff 90       	pop	r15
    399c:	ef 90       	pop	r14
    399e:	df 90       	pop	r13
    39a0:	cf 90       	pop	r12
    39a2:	bf 90       	pop	r11
    39a4:	af 90       	pop	r10
    39a6:	9f 90       	pop	r9
    39a8:	8f 90       	pop	r8
    39aa:	08 95       	ret

000039ac <csp_close>:
    39ac:	cf 93       	push	r28
    39ae:	df 93       	push	r29
    39b0:	ec 01       	movw	r28, r24
    39b2:	89 2b       	or	r24, r25
    39b4:	61 f4       	brne	.+24     	; 0x39ce <csp_close+0x22>
    39b6:	84 e1       	ldi	r24, 0x14	; 20
    39b8:	94 e0       	ldi	r25, 0x04	; 4
    39ba:	9f 93       	push	r25
    39bc:	8f 93       	push	r24
    39be:	1f 92       	push	r1
    39c0:	65 d2       	rcall	.+1226   	; 0x3e8c <do_csp_debug>
    39c2:	0f 90       	pop	r0
    39c4:	0f 90       	pop	r0
    39c6:	0f 90       	pop	r0
    39c8:	8e ef       	ldi	r24, 0xFE	; 254
    39ca:	9f ef       	ldi	r25, 0xFF	; 255
    39cc:	2d c0       	rjmp	.+90     	; 0x3a28 <csp_close+0x7c>
    39ce:	89 81       	ldd	r24, Y+1	; 0x01
    39d0:	81 11       	cpse	r24, r1
    39d2:	0d c0       	rjmp	.+26     	; 0x39ee <csp_close+0x42>
    39d4:	80 e0       	ldi	r24, 0x00	; 0
    39d6:	94 e0       	ldi	r25, 0x04	; 4
    39d8:	9f 93       	push	r25
    39da:	8f 93       	push	r24
    39dc:	85 e0       	ldi	r24, 0x05	; 5
    39de:	8f 93       	push	r24
    39e0:	55 d2       	rcall	.+1194   	; 0x3e8c <do_csp_debug>
    39e2:	0f 90       	pop	r0
    39e4:	0f 90       	pop	r0
    39e6:	0f 90       	pop	r0
    39e8:	80 e0       	ldi	r24, 0x00	; 0
    39ea:	90 e0       	ldi	r25, 0x00	; 0
    39ec:	1d c0       	rjmp	.+58     	; 0x3a28 <csp_close+0x7c>
    39ee:	44 e6       	ldi	r20, 0x64	; 100
    39f0:	50 e0       	ldi	r21, 0x00	; 0
    39f2:	60 e0       	ldi	r22, 0x00	; 0
    39f4:	70 e0       	ldi	r23, 0x00	; 0
    39f6:	8b e2       	ldi	r24, 0x2B	; 43
    39f8:	93 e0       	ldi	r25, 0x03	; 3
    39fa:	f8 da       	rcall	.-2576   	; 0x2fec <csp_bin_sem_wait>
    39fc:	01 97       	sbiw	r24, 0x01	; 1
    39fe:	61 f0       	breq	.+24     	; 0x3a18 <csp_close+0x6c>
    3a00:	86 ee       	ldi	r24, 0xE6	; 230
    3a02:	93 e0       	ldi	r25, 0x03	; 3
    3a04:	9f 93       	push	r25
    3a06:	8f 93       	push	r24
    3a08:	1f 92       	push	r1
    3a0a:	40 d2       	rcall	.+1152   	; 0x3e8c <do_csp_debug>
    3a0c:	0f 90       	pop	r0
    3a0e:	0f 90       	pop	r0
    3a10:	0f 90       	pop	r0
    3a12:	8d ef       	ldi	r24, 0xFD	; 253
    3a14:	9f ef       	ldi	r25, 0xFF	; 255
    3a16:	08 c0       	rjmp	.+16     	; 0x3a28 <csp_close+0x7c>
    3a18:	19 82       	std	Y+1, r1	; 0x01
    3a1a:	ce 01       	movw	r24, r28
    3a1c:	1a de       	rcall	.-972    	; 0x3652 <csp_conn_flush_rx_queue>
    3a1e:	8b e2       	ldi	r24, 0x2B	; 43
    3a20:	93 e0       	ldi	r25, 0x03	; 3
    3a22:	1e db       	rcall	.-2500   	; 0x3060 <csp_bin_sem_post>
    3a24:	80 e0       	ldi	r24, 0x00	; 0
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	df 91       	pop	r29
    3a2a:	cf 91       	pop	r28
    3a2c:	08 95       	ret

00003a2e <csp_connect>:
    3a2e:	6f 92       	push	r6
    3a30:	7f 92       	push	r7
    3a32:	8f 92       	push	r8
    3a34:	9f 92       	push	r9
    3a36:	af 92       	push	r10
    3a38:	bf 92       	push	r11
    3a3a:	cf 92       	push	r12
    3a3c:	df 92       	push	r13
    3a3e:	ef 92       	push	r14
    3a40:	ff 92       	push	r15
    3a42:	0f 93       	push	r16
    3a44:	1f 93       	push	r17
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	86 2e       	mov	r8, r22
    3a4c:	14 2f       	mov	r17, r20
    3a4e:	98 2e       	mov	r9, r24
    3a50:	99 0c       	add	r9, r9
    3a52:	99 0c       	add	r9, r9
    3a54:	99 0c       	add	r9, r9
    3a56:	99 0c       	add	r9, r9
    3a58:	99 0c       	add	r9, r9
    3a5a:	99 0c       	add	r9, r9
    3a5c:	09 2d       	mov	r16, r9
    3a5e:	3f d4       	rcall	.+2174   	; 0x42de <csp_get_address>
    3a60:	c8 2f       	mov	r28, r24
    3a62:	c2 95       	swap	r28
    3a64:	c0 7f       	andi	r28, 0xF0	; 240
    3a66:	82 95       	swap	r24
    3a68:	81 70       	andi	r24, 0x01	; 1
    3a6a:	08 2b       	or	r16, r24
    3a6c:	88 2d       	mov	r24, r8
    3a6e:	8f 71       	andi	r24, 0x1F	; 31
    3a70:	98 2f       	mov	r25, r24
    3a72:	99 0f       	add	r25, r25
    3a74:	09 2b       	or	r16, r25
    3a76:	91 2f       	mov	r25, r17
    3a78:	9f 73       	andi	r25, 0x3F	; 63
    3a7a:	a9 2e       	mov	r10, r25
    3a7c:	d9 2f       	mov	r29, r25
    3a7e:	b1 2c       	mov	r11, r1
    3a80:	88 0c       	add	r8, r8
    3a82:	88 0c       	add	r8, r8
    3a84:	88 0c       	add	r8, r8
    3a86:	88 0c       	add	r8, r8
    3a88:	82 95       	swap	r24
    3a8a:	8f 70       	andi	r24, 0x0F	; 15
    3a8c:	98 2a       	or	r9, r24
    3a8e:	27 d4       	rcall	.+2126   	; 0x42de <csp_get_address>
    3a90:	8f 71       	andi	r24, 0x1F	; 31
    3a92:	88 0f       	add	r24, r24
    3a94:	98 2a       	or	r9, r24
    3a96:	12 95       	swap	r17
    3a98:	11 0f       	add	r17, r17
    3a9a:	11 0f       	add	r17, r17
    3a9c:	10 7c       	andi	r17, 0xC0	; 192
    3a9e:	a6 94       	lsr	r10
    3aa0:	a6 94       	lsr	r10
    3aa2:	8a 28       	or	r8, r10
    3aa4:	c0 fe       	sbrs	r12, 0
    3aa6:	0c c0       	rjmp	.+24     	; 0x3ac0 <csp_connect+0x92>
    3aa8:	8b e9       	ldi	r24, 0x9B	; 155
    3aaa:	93 e0       	ldi	r25, 0x03	; 3
    3aac:	9f 93       	push	r25
    3aae:	8f 93       	push	r24
    3ab0:	1f 92       	push	r1
    3ab2:	ec d1       	rcall	.+984    	; 0x3e8c <do_csp_debug>
    3ab4:	0f 90       	pop	r0
    3ab6:	0f 90       	pop	r0
    3ab8:	0f 90       	pop	r0
    3aba:	80 e0       	ldi	r24, 0x00	; 0
    3abc:	90 e0       	ldi	r25, 0x00	; 0
    3abe:	7a c0       	rjmp	.+244    	; 0x3bb4 <csp_connect+0x186>
    3ac0:	c2 fe       	sbrs	r12, 2
    3ac2:	0c c0       	rjmp	.+24     	; 0x3adc <csp_connect+0xae>
    3ac4:	80 e4       	ldi	r24, 0x40	; 64
    3ac6:	93 e0       	ldi	r25, 0x03	; 3
    3ac8:	9f 93       	push	r25
    3aca:	8f 93       	push	r24
    3acc:	1f 92       	push	r1
    3ace:	de d1       	rcall	.+956    	; 0x3e8c <do_csp_debug>
    3ad0:	0f 90       	pop	r0
    3ad2:	0f 90       	pop	r0
    3ad4:	0f 90       	pop	r0
    3ad6:	80 e0       	ldi	r24, 0x00	; 0
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
    3ada:	6c c0       	rjmp	.+216    	; 0x3bb4 <csp_connect+0x186>
    3adc:	c4 fe       	sbrs	r12, 4
    3ade:	0c c0       	rjmp	.+24     	; 0x3af8 <csp_connect+0xca>
    3ae0:	89 ee       	ldi	r24, 0xE9	; 233
    3ae2:	92 e0       	ldi	r25, 0x02	; 2
    3ae4:	9f 93       	push	r25
    3ae6:	8f 93       	push	r24
    3ae8:	1f 92       	push	r1
    3aea:	d0 d1       	rcall	.+928    	; 0x3e8c <do_csp_debug>
    3aec:	0f 90       	pop	r0
    3aee:	0f 90       	pop	r0
    3af0:	0f 90       	pop	r0
    3af2:	80 e0       	ldi	r24, 0x00	; 0
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	5e c0       	rjmp	.+188    	; 0x3bb4 <csp_connect+0x186>
    3af8:	c6 fe       	sbrs	r12, 6
    3afa:	05 c0       	rjmp	.+10     	; 0x3b06 <csp_connect+0xd8>
    3afc:	bb 24       	eor	r11, r11
    3afe:	b3 94       	inc	r11
    3b00:	66 24       	eor	r6, r6
    3b02:	63 94       	inc	r6
    3b04:	01 c0       	rjmp	.+2      	; 0x3b08 <csp_connect+0xda>
    3b06:	61 2c       	mov	r6, r1
    3b08:	48 ee       	ldi	r20, 0xE8	; 232
    3b0a:	53 e0       	ldi	r21, 0x03	; 3
    3b0c:	60 e0       	ldi	r22, 0x00	; 0
    3b0e:	70 e0       	ldi	r23, 0x00	; 0
    3b10:	88 e2       	ldi	r24, 0x28	; 40
    3b12:	93 e0       	ldi	r25, 0x03	; 3
    3b14:	6b da       	rcall	.-2858   	; 0x2fec <csp_bin_sem_wait>
    3b16:	01 97       	sbiw	r24, 0x01	; 1
    3b18:	09 f0       	breq	.+2      	; 0x3b1c <csp_connect+0xee>
    3b1a:	45 c0       	rjmp	.+138    	; 0x3ba6 <csp_connect+0x178>
    3b1c:	a0 90 2a 03 	lds	r10, 0x032A	; 0x80032a <sport>
    3b20:	68 94       	set
    3b22:	77 24       	eor	r7, r7
    3b24:	75 f8       	bld	r7, 5
    3b26:	1f c0       	rjmp	.+62     	; 0x3b66 <csp_connect+0x138>
    3b28:	90 34       	cpi	r25, 0x40	; 64
    3b2a:	10 f0       	brcs	.+4      	; 0x3b30 <csp_connect+0x102>
    3b2c:	70 92 2a 03 	sts	0x032A, r7	; 0x80032a <sport>
    3b30:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <sport>
    3b34:	98 2f       	mov	r25, r24
    3b36:	9f 73       	andi	r25, 0x3F	; 63
    3b38:	10 7c       	andi	r17, 0xC0	; 192
    3b3a:	19 2b       	or	r17, r25
    3b3c:	82 95       	swap	r24
    3b3e:	88 0f       	add	r24, r24
    3b40:	88 0f       	add	r24, r24
    3b42:	80 7c       	andi	r24, 0xC0	; 192
    3b44:	df 73       	andi	r29, 0x3F	; 63
    3b46:	d8 2b       	or	r29, r24
    3b48:	96 95       	lsr	r25
    3b4a:	96 95       	lsr	r25
    3b4c:	c0 7f       	andi	r28, 0xF0	; 240
    3b4e:	c9 2b       	or	r28, r25
    3b50:	20 e0       	ldi	r18, 0x00	; 0
    3b52:	30 ec       	ldi	r19, 0xC0	; 192
    3b54:	4f e0       	ldi	r20, 0x0F	; 15
    3b56:	50 e0       	ldi	r21, 0x00	; 0
    3b58:	6b 2d       	mov	r22, r11
    3b5a:	7d 2f       	mov	r23, r29
    3b5c:	8c 2f       	mov	r24, r28
    3b5e:	90 2f       	mov	r25, r16
    3b60:	3c de       	rcall	.-904    	; 0x37da <csp_conn_find>
    3b62:	89 2b       	or	r24, r25
    3b64:	39 f0       	breq	.+14     	; 0x3b74 <csp_connect+0x146>
    3b66:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <sport>
    3b6a:	9f 5f       	subi	r25, 0xFF	; 255
    3b6c:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <sport>
    3b70:	a9 12       	cpse	r10, r25
    3b72:	da cf       	rjmp	.-76     	; 0x3b28 <csp_connect+0xfa>
    3b74:	88 e2       	ldi	r24, 0x28	; 40
    3b76:	93 e0       	ldi	r25, 0x03	; 3
    3b78:	73 da       	rcall	.-2842   	; 0x3060 <csp_bin_sem_post>
    3b7a:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <sport>
    3b7e:	a8 16       	cp	r10, r24
    3b80:	a9 f0       	breq	.+42     	; 0x3bac <csp_connect+0x17e>
    3b82:	26 2d       	mov	r18, r6
    3b84:	31 2f       	mov	r19, r17
    3b86:	48 2d       	mov	r20, r8
    3b88:	59 2d       	mov	r21, r9
    3b8a:	6b 2d       	mov	r22, r11
    3b8c:	7d 2f       	mov	r23, r29
    3b8e:	8c 2f       	mov	r24, r28
    3b90:	90 2f       	mov	r25, r16
    3b92:	de de       	rcall	.-580    	; 0x3950 <csp_conn_new>
    3b94:	fc 01       	movw	r30, r24
    3b96:	00 97       	sbiw	r24, 0x00	; 0
    3b98:	61 f0       	breq	.+24     	; 0x3bb2 <csp_connect+0x184>
    3b9a:	c4 8a       	std	Z+20, r12	; 0x14
    3b9c:	d5 8a       	std	Z+21, r13	; 0x15
    3b9e:	e6 8a       	std	Z+22, r14	; 0x16
    3ba0:	f7 8a       	std	Z+23, r15	; 0x17
    3ba2:	9f 2f       	mov	r25, r31
    3ba4:	07 c0       	rjmp	.+14     	; 0x3bb4 <csp_connect+0x186>
    3ba6:	80 e0       	ldi	r24, 0x00	; 0
    3ba8:	90 e0       	ldi	r25, 0x00	; 0
    3baa:	04 c0       	rjmp	.+8      	; 0x3bb4 <csp_connect+0x186>
    3bac:	80 e0       	ldi	r24, 0x00	; 0
    3bae:	90 e0       	ldi	r25, 0x00	; 0
    3bb0:	01 c0       	rjmp	.+2      	; 0x3bb4 <csp_connect+0x186>
    3bb2:	9f 2f       	mov	r25, r31
    3bb4:	df 91       	pop	r29
    3bb6:	cf 91       	pop	r28
    3bb8:	1f 91       	pop	r17
    3bba:	0f 91       	pop	r16
    3bbc:	ff 90       	pop	r15
    3bbe:	ef 90       	pop	r14
    3bc0:	df 90       	pop	r13
    3bc2:	cf 90       	pop	r12
    3bc4:	bf 90       	pop	r11
    3bc6:	af 90       	pop	r10
    3bc8:	9f 90       	pop	r9
    3bca:	8f 90       	pop	r8
    3bcc:	7f 90       	pop	r7
    3bce:	6f 90       	pop	r6
    3bd0:	08 95       	ret

00003bd2 <csp_conn_dport>:
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	95 81       	ldd	r25, Z+5	; 0x05
    3bd6:	92 95       	swap	r25
    3bd8:	96 95       	lsr	r25
    3bda:	96 95       	lsr	r25
    3bdc:	93 70       	andi	r25, 0x03	; 3
    3bde:	86 81       	ldd	r24, Z+6	; 0x06
    3be0:	8f 70       	andi	r24, 0x0F	; 15
    3be2:	88 0f       	add	r24, r24
    3be4:	88 0f       	add	r24, r24
    3be6:	89 2b       	or	r24, r25
    3be8:	90 e0       	ldi	r25, 0x00	; 0
    3bea:	08 95       	ret

00003bec <csp_conn_print_table>:

#ifdef CSP_DEBUG
void csp_conn_print_table(void) {
    3bec:	ef 92       	push	r14
    3bee:	ff 92       	push	r15
    3bf0:	0f 93       	push	r16
    3bf2:	1f 93       	push	r17
    3bf4:	cf 93       	push	r28
    3bf6:	df 93       	push	r29
    3bf8:	0f 2e       	mov	r0, r31
    3bfa:	fd e2       	ldi	r31, 0x2D	; 45
    3bfc:	ef 2e       	mov	r14, r31
    3bfe:	f3 e0       	ldi	r31, 0x03	; 3
    3c00:	ff 2e       	mov	r15, r31
    3c02:	f0 2d       	mov	r31, r0

	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    3c04:	c0 e0       	ldi	r28, 0x00	; 0
    3c06:	d0 e0       	ldi	r29, 0x00	; 0
		conn = &arr_conn[i];
		printf("[%02u %p] S:%u, %u -> %u, %u -> %u, sock: %p\n",
    3c08:	0b eb       	ldi	r16, 0xBB	; 187
    3c0a:	12 e0       	ldi	r17, 0x02	; 2
    3c0c:	f7 01       	movw	r30, r14
    3c0e:	87 85       	ldd	r24, Z+15	; 0x0f
    3c10:	8f 93       	push	r24
    3c12:	86 85       	ldd	r24, Z+14	; 0x0e
    3c14:	8f 93       	push	r24
    3c16:	ce 01       	movw	r24, r28
    3c18:	88 0f       	add	r24, r24
    3c1a:	99 1f       	adc	r25, r25
    3c1c:	fc 01       	movw	r30, r24
    3c1e:	ec 0f       	add	r30, r28
    3c20:	fd 1f       	adc	r31, r29
    3c22:	ee 0f       	add	r30, r30
    3c24:	ff 1f       	adc	r31, r31
    3c26:	ee 0f       	add	r30, r30
    3c28:	ff 1f       	adc	r31, r31
    3c2a:	ee 0f       	add	r30, r30
    3c2c:	ff 1f       	adc	r31, r31
    3c2e:	ee 5c       	subi	r30, 0xCE	; 206
    3c30:	fc 4f       	sbci	r31, 0xFC	; 252
    3c32:	20 81       	ld	r18, Z
    3c34:	2f 73       	andi	r18, 0x3F	; 63
    3c36:	1f 92       	push	r1
    3c38:	2f 93       	push	r18
    3c3a:	20 81       	ld	r18, Z
    3c3c:	32 2f       	mov	r19, r18
    3c3e:	32 95       	swap	r19
    3c40:	36 95       	lsr	r19
    3c42:	36 95       	lsr	r19
    3c44:	33 70       	andi	r19, 0x03	; 3
    3c46:	21 81       	ldd	r18, Z+1	; 0x01
    3c48:	2f 70       	andi	r18, 0x0F	; 15
    3c4a:	22 0f       	add	r18, r18
    3c4c:	22 0f       	add	r18, r18
    3c4e:	23 2b       	or	r18, r19
    3c50:	1f 92       	push	r1
    3c52:	2f 93       	push	r18
    3c54:	fc 01       	movw	r30, r24
    3c56:	ec 0f       	add	r30, r28
    3c58:	fd 1f       	adc	r31, r29
    3c5a:	ee 0f       	add	r30, r30
    3c5c:	ff 1f       	adc	r31, r31
    3c5e:	ee 0f       	add	r30, r30
    3c60:	ff 1f       	adc	r31, r31
    3c62:	ee 0f       	add	r30, r30
    3c64:	ff 1f       	adc	r31, r31
    3c66:	ed 5c       	subi	r30, 0xCD	; 205
    3c68:	fc 4f       	sbci	r31, 0xFC	; 252
    3c6a:	20 81       	ld	r18, Z
    3c6c:	32 2f       	mov	r19, r18
    3c6e:	32 95       	swap	r19
    3c70:	3f 70       	andi	r19, 0x0F	; 15
    3c72:	21 81       	ldd	r18, Z+1	; 0x01
    3c74:	21 70       	andi	r18, 0x01	; 1
    3c76:	22 95       	swap	r18
    3c78:	20 7f       	andi	r18, 0xF0	; 240
    3c7a:	23 2b       	or	r18, r19
    3c7c:	1f 92       	push	r1
    3c7e:	2f 93       	push	r18
    3c80:	fc 01       	movw	r30, r24
    3c82:	ec 0f       	add	r30, r28
    3c84:	fd 1f       	adc	r31, r29
    3c86:	ee 0f       	add	r30, r30
    3c88:	ff 1f       	adc	r31, r31
    3c8a:	ee 0f       	add	r30, r30
    3c8c:	ff 1f       	adc	r31, r31
    3c8e:	ee 0f       	add	r30, r30
    3c90:	ff 1f       	adc	r31, r31
    3c92:	ec 5c       	subi	r30, 0xCC	; 204
    3c94:	fc 4f       	sbci	r31, 0xFC	; 252
    3c96:	80 81       	ld	r24, Z
    3c98:	86 95       	lsr	r24
    3c9a:	8f 71       	andi	r24, 0x1F	; 31
    3c9c:	1f 92       	push	r1
    3c9e:	8f 93       	push	r24
    3ca0:	f7 01       	movw	r30, r14
    3ca2:	81 81       	ldd	r24, Z+1	; 0x01
    3ca4:	1f 92       	push	r1
    3ca6:	8f 93       	push	r24
    3ca8:	ff 92       	push	r15
    3caa:	ef 92       	push	r14
    3cac:	df 93       	push	r29
    3cae:	cf 93       	push	r28
    3cb0:	1f 93       	push	r17
    3cb2:	0f 93       	push	r16
    3cb4:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
void csp_conn_print_table(void) {

	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    3cb8:	21 96       	adiw	r28, 0x01	; 1
    3cba:	98 e1       	ldi	r25, 0x18	; 24
    3cbc:	e9 0e       	add	r14, r25
    3cbe:	f1 1c       	adc	r15, r1
    3cc0:	ed b7       	in	r30, 0x3d	; 61
    3cc2:	fe b7       	in	r31, 0x3e	; 62
    3cc4:	72 96       	adiw	r30, 0x12	; 18
    3cc6:	0f b6       	in	r0, 0x3f	; 63
    3cc8:	f8 94       	cli
    3cca:	fe bf       	out	0x3e, r31	; 62
    3ccc:	0f be       	out	0x3f, r0	; 63
    3cce:	ed bf       	out	0x3d, r30	; 61
    3cd0:	ca 30       	cpi	r28, 0x0A	; 10
    3cd2:	d1 05       	cpc	r29, r1
    3cd4:	09 f0       	breq	.+2      	; 0x3cd8 <csp_conn_print_table+0xec>
    3cd6:	9a cf       	rjmp	.-204    	; 0x3c0c <csp_conn_print_table+0x20>
#ifdef CSP_USE_RDP
		if (conn->idin.flags & CSP_FRDP)
			csp_rdp_conn_print(conn);
#endif
	}
}
    3cd8:	df 91       	pop	r29
    3cda:	cf 91       	pop	r28
    3cdc:	1f 91       	pop	r17
    3cde:	0f 91       	pop	r16
    3ce0:	ff 90       	pop	r15
    3ce2:	ef 90       	pop	r14
    3ce4:	08 95       	ret

00003ce6 <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    3ce6:	cf 92       	push	r12
    3ce8:	df 92       	push	r13
    3cea:	ef 92       	push	r14
    3cec:	ff 92       	push	r15
    3cee:	0f 93       	push	r16
    3cf0:	1f 93       	push	r17
    3cf2:	cf 93       	push	r28
    3cf4:	df 93       	push	r29
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    3cf6:	8a 01       	movw	r16, r20
    3cf8:	9b 01       	movw	r18, r22
    3cfa:	01 50       	subi	r16, 0x01	; 1
    3cfc:	11 09       	sbc	r17, r1
    3cfe:	21 09       	sbc	r18, r1
    3d00:	31 09       	sbc	r19, r1
    3d02:	45 2b       	or	r20, r21
    3d04:	46 2b       	or	r20, r22
    3d06:	47 2b       	or	r20, r23
    3d08:	39 f1       	breq	.+78     	; 0x3d58 <csp_crc32_memory+0x72>
    3d0a:	c8 2f       	mov	r28, r24
    3d0c:	d9 2f       	mov	r29, r25
    3d0e:	4f ef       	ldi	r20, 0xFF	; 255
    3d10:	5f ef       	ldi	r21, 0xFF	; 255
    3d12:	ba 01       	movw	r22, r20
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    3d14:	89 91       	ld	r24, Y+
    3d16:	6a 01       	movw	r12, r20
    3d18:	7b 01       	movw	r14, r22
    3d1a:	c8 26       	eor	r12, r24
    3d1c:	d7 01       	movw	r26, r14
    3d1e:	c6 01       	movw	r24, r12
    3d20:	99 27       	eor	r25, r25
    3d22:	aa 27       	eor	r26, r26
    3d24:	bb 27       	eor	r27, r27
    3d26:	fc 01       	movw	r30, r24
    3d28:	ee 0f       	add	r30, r30
    3d2a:	ff 1f       	adc	r31, r31
    3d2c:	ee 0f       	add	r30, r30
    3d2e:	ff 1f       	adc	r31, r31
    3d30:	e4 51       	subi	r30, 0x14	; 20
    3d32:	fb 4f       	sbci	r31, 0xFB	; 251
    3d34:	85 91       	lpm	r24, Z+
    3d36:	95 91       	lpm	r25, Z+
    3d38:	a5 91       	lpm	r26, Z+
    3d3a:	b4 91       	lpm	r27, Z
    3d3c:	45 2f       	mov	r20, r21
    3d3e:	56 2f       	mov	r21, r22
    3d40:	67 2f       	mov	r22, r23
    3d42:	77 27       	eor	r23, r23
    3d44:	48 27       	eor	r20, r24
    3d46:	59 27       	eor	r21, r25
    3d48:	6a 27       	eor	r22, r26
    3d4a:	7b 27       	eor	r23, r27

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    3d4c:	01 50       	subi	r16, 0x01	; 1
    3d4e:	11 09       	sbc	r17, r1
    3d50:	21 09       	sbc	r18, r1
    3d52:	31 09       	sbc	r19, r1
    3d54:	f8 f6       	brcc	.-66     	; 0x3d14 <csp_crc32_memory+0x2e>
    3d56:	03 c0       	rjmp	.+6      	; 0x3d5e <csp_crc32_memory+0x78>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    3d58:	4f ef       	ldi	r20, 0xFF	; 255
    3d5a:	5f ef       	ldi	r21, 0xFF	; 255
    3d5c:	ba 01       	movw	r22, r20
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    3d5e:	cb 01       	movw	r24, r22
    3d60:	ba 01       	movw	r22, r20
    3d62:	60 95       	com	r22
    3d64:	70 95       	com	r23
    3d66:	80 95       	com	r24
    3d68:	90 95       	com	r25
}
    3d6a:	df 91       	pop	r29
    3d6c:	cf 91       	pop	r28
    3d6e:	1f 91       	pop	r17
    3d70:	0f 91       	pop	r16
    3d72:	ff 90       	pop	r15
    3d74:	ef 90       	pop	r14
    3d76:	df 90       	pop	r13
    3d78:	cf 90       	pop	r12
    3d7a:	08 95       	ret

00003d7c <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet, bool include_header) {
    3d7c:	cf 93       	push	r28
    3d7e:	df 93       	push	r29

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    3d80:	00 97       	sbiw	r24, 0x00	; 0
    3d82:	19 f1       	breq	.+70     	; 0x3dca <csp_crc32_append+0x4e>
    3d84:	ec 01       	movw	r28, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    3d86:	66 23       	and	r22, r22
    3d88:	49 f0       	breq	.+18     	; 0x3d9c <csp_crc32_append+0x20>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id));
    3d8a:	48 85       	ldd	r20, Y+8	; 0x08
    3d8c:	59 85       	ldd	r21, Y+9	; 0x09
    3d8e:	4c 5f       	subi	r20, 0xFC	; 252
    3d90:	5f 4f       	sbci	r21, 0xFF	; 255
    3d92:	60 e0       	ldi	r22, 0x00	; 0
    3d94:	70 e0       	ldi	r23, 0x00	; 0
    3d96:	0a 96       	adiw	r24, 0x0a	; 10
    3d98:	a6 df       	rcall	.-180    	; 0x3ce6 <csp_crc32_memory>
    3d9a:	06 c0       	rjmp	.+12     	; 0x3da8 <csp_crc32_append+0x2c>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length);
    3d9c:	48 85       	ldd	r20, Y+8	; 0x08
    3d9e:	59 85       	ldd	r21, Y+9	; 0x09
    3da0:	60 e0       	ldi	r22, 0x00	; 0
    3da2:	70 e0       	ldi	r23, 0x00	; 0
    3da4:	0e 96       	adiw	r24, 0x0e	; 14
	}
	crc = csp_hton32(crc);
    3da6:	9f df       	rcall	.-194    	; 0x3ce6 <csp_crc32_memory>
    3da8:	ee d0       	rcall	.+476    	; 0x3f86 <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    3daa:	e8 85       	ldd	r30, Y+8	; 0x08
    3dac:	f9 85       	ldd	r31, Y+9	; 0x09
    3dae:	ec 0f       	add	r30, r28
    3db0:	fd 1f       	adc	r31, r29
    3db2:	66 87       	std	Z+14, r22	; 0x0e
    3db4:	77 87       	std	Z+15, r23	; 0x0f
    3db6:	80 8b       	std	Z+16, r24	; 0x10
    3db8:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    3dba:	88 85       	ldd	r24, Y+8	; 0x08
    3dbc:	99 85       	ldd	r25, Y+9	; 0x09
    3dbe:	04 96       	adiw	r24, 0x04	; 4
    3dc0:	99 87       	std	Y+9, r25	; 0x09
    3dc2:	88 87       	std	Y+8, r24	; 0x08

	return CSP_ERR_NONE;
    3dc4:	80 e0       	ldi	r24, 0x00	; 0
    3dc6:	90 e0       	ldi	r25, 0x00	; 0
    3dc8:	02 c0       	rjmp	.+4      	; 0x3dce <csp_crc32_append+0x52>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    3dca:	8e ef       	ldi	r24, 0xFE	; 254
    3dcc:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    3dce:	df 91       	pop	r29
    3dd0:	cf 91       	pop	r28
    3dd2:	08 95       	ret

00003dd4 <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet, bool include_header) {
    3dd4:	ef 92       	push	r14
    3dd6:	ff 92       	push	r15
    3dd8:	0f 93       	push	r16
    3dda:	1f 93       	push	r17
    3ddc:	cf 93       	push	r28
    3dde:	df 93       	push	r29
    3de0:	00 d0       	rcall	.+0      	; 0x3de2 <csp_crc32_verify+0xe>
    3de2:	1f 92       	push	r1
    3de4:	cd b7       	in	r28, 0x3d	; 61
    3de6:	de b7       	in	r29, 0x3e	; 62

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    3de8:	00 97       	sbiw	r24, 0x00	; 0
    3dea:	09 f4       	brne	.+2      	; 0x3dee <csp_crc32_verify+0x1a>
    3dec:	3c c0       	rjmp	.+120    	; 0x3e66 <csp_crc32_verify+0x92>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    3dee:	fc 01       	movw	r30, r24
    3df0:	40 85       	ldd	r20, Z+8	; 0x08
    3df2:	51 85       	ldd	r21, Z+9	; 0x09
    3df4:	44 30       	cpi	r20, 0x04	; 4
    3df6:	51 05       	cpc	r21, r1
    3df8:	c8 f1       	brcs	.+114    	; 0x3e6c <csp_crc32_verify+0x98>
    3dfa:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	if (include_header) {
    3dfc:	66 23       	and	r22, r22
    3dfe:	49 f0       	breq	.+18     	; 0x3e12 <csp_crc32_verify+0x3e>
		crc = csp_crc32_memory((uint8_t *) &packet->id, packet->length + sizeof(packet->id) - sizeof(uint32_t));
    3e00:	60 e0       	ldi	r22, 0x00	; 0
    3e02:	70 e0       	ldi	r23, 0x00	; 0
    3e04:	0a 96       	adiw	r24, 0x0a	; 10
    3e06:	6f df       	rcall	.-290    	; 0x3ce6 <csp_crc32_memory>
    3e08:	69 83       	std	Y+1, r22	; 0x01
    3e0a:	7a 83       	std	Y+2, r23	; 0x02
    3e0c:	8b 83       	std	Y+3, r24	; 0x03
    3e0e:	9c 83       	std	Y+4, r25	; 0x04
    3e10:	0a c0       	rjmp	.+20     	; 0x3e26 <csp_crc32_verify+0x52>
	} else {
		crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    3e12:	44 50       	subi	r20, 0x04	; 4
    3e14:	51 09       	sbc	r21, r1
    3e16:	60 e0       	ldi	r22, 0x00	; 0
    3e18:	70 e0       	ldi	r23, 0x00	; 0
    3e1a:	0e 96       	adiw	r24, 0x0e	; 14
    3e1c:	64 df       	rcall	.-312    	; 0x3ce6 <csp_crc32_memory>
    3e1e:	69 83       	std	Y+1, r22	; 0x01
    3e20:	7a 83       	std	Y+2, r23	; 0x02
    3e22:	8b 83       	std	Y+3, r24	; 0x03
    3e24:	9c 83       	std	Y+4, r25	; 0x04
	}
	crc = csp_hton32(crc);
    3e26:	69 81       	ldd	r22, Y+1	; 0x01
    3e28:	7a 81       	ldd	r23, Y+2	; 0x02
    3e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e2e:	ab d0       	rcall	.+342    	; 0x3f86 <csp_hton32>
    3e30:	69 83       	std	Y+1, r22	; 0x01
    3e32:	7a 83       	std	Y+2, r23	; 0x02
    3e34:	8b 83       	std	Y+3, r24	; 0x03
    3e36:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    3e38:	f8 01       	movw	r30, r16
    3e3a:	e0 84       	ldd	r14, Z+8	; 0x08
    3e3c:	f1 84       	ldd	r15, Z+9	; 0x09
    3e3e:	c8 01       	movw	r24, r16
    3e40:	8e 0d       	add	r24, r14
    3e42:	9f 1d       	adc	r25, r15
    3e44:	44 e0       	ldi	r20, 0x04	; 4
    3e46:	50 e0       	ldi	r21, 0x00	; 0
    3e48:	be 01       	movw	r22, r28
    3e4a:	6f 5f       	subi	r22, 0xFF	; 255
    3e4c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e4e:	0a 96       	adiw	r24, 0x0a	; 10
    3e50:	0e 94 94 44 	call	0x8928	; 0x8928 <memcmp>
    3e54:	00 97       	sbiw	r24, 0x00	; 0
    3e56:	69 f4       	brne	.+26     	; 0x3e72 <csp_crc32_verify+0x9e>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    3e58:	f4 e0       	ldi	r31, 0x04	; 4
    3e5a:	ef 1a       	sub	r14, r31
    3e5c:	f1 08       	sbc	r15, r1
    3e5e:	f8 01       	movw	r30, r16
    3e60:	f1 86       	std	Z+9, r15	; 0x09
    3e62:	e0 86       	std	Z+8, r14	; 0x08
		return CSP_ERR_NONE;
    3e64:	08 c0       	rjmp	.+16     	; 0x3e76 <csp_crc32_verify+0xa2>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    3e66:	8e ef       	ldi	r24, 0xFE	; 254
    3e68:	9f ef       	ldi	r25, 0xFF	; 255
    3e6a:	05 c0       	rjmp	.+10     	; 0x3e76 <csp_crc32_verify+0xa2>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    3e6c:	8e ef       	ldi	r24, 0xFE	; 254
    3e6e:	9f ef       	ldi	r25, 0xFF	; 255
    3e70:	02 c0       	rjmp	.+4      	; 0x3e76 <csp_crc32_verify+0xa2>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    3e72:	8e ef       	ldi	r24, 0xFE	; 254
    3e74:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    3e76:	0f 90       	pop	r0
    3e78:	0f 90       	pop	r0
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	df 91       	pop	r29
    3e80:	cf 91       	pop	r28
    3e82:	1f 91       	pop	r17
    3e84:	0f 91       	pop	r16
    3e86:	ff 90       	pop	r15
    3e88:	ef 90       	pop	r14
    3e8a:	08 95       	ret

00003e8c <do_csp_debug>:
{
	csp_debug_hook_func = f;
}

void do_csp_debug(csp_debug_level_t level, const char *format, ...)
{
    3e8c:	ff 92       	push	r15
    3e8e:	0f 93       	push	r16
    3e90:	1f 93       	push	r17
    3e92:	cf 93       	push	r28
    3e94:	df 93       	push	r29
    3e96:	cd b7       	in	r28, 0x3d	; 61
    3e98:	de b7       	in	r29, 0x3e	; 62
    3e9a:	19 85       	ldd	r17, Y+9	; 0x09
	int color = COLOR_RESET;
	va_list args;

	/* Don't print anything if log level is disabled */
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
    3e9c:	18 30       	cpi	r17, 0x08	; 8
    3e9e:	08 f0       	brcs	.+2      	; 0x3ea2 <do_csp_debug+0x16>
    3ea0:	64 c0       	rjmp	.+200    	; 0x3f6a <do_csp_debug+0xde>
    3ea2:	e1 2f       	mov	r30, r17
    3ea4:	f0 e0       	ldi	r31, 0x00	; 0
    3ea6:	e6 5f       	subi	r30, 0xF6	; 246
    3ea8:	fd 4f       	sbci	r31, 0xFD	; 253
    3eaa:	80 81       	ld	r24, Z
    3eac:	88 23       	and	r24, r24
    3eae:	09 f4       	brne	.+2      	; 0x3eb2 <do_csp_debug+0x26>
    3eb0:	5c c0       	rjmp	.+184    	; 0x3f6a <do_csp_debug+0xde>
		return;

	switch(level) {
    3eb2:	81 2f       	mov	r24, r17
    3eb4:	90 e0       	ldi	r25, 0x00	; 0
    3eb6:	88 30       	cpi	r24, 0x08	; 8
    3eb8:	91 05       	cpc	r25, r1
    3eba:	08 f0       	brcs	.+2      	; 0x3ebe <do_csp_debug+0x32>
    3ebc:	56 c0       	rjmp	.+172    	; 0x3f6a <do_csp_debug+0xde>
    3ebe:	fc 01       	movw	r30, r24
    3ec0:	88 27       	eor	r24, r24
    3ec2:	ea 55       	subi	r30, 0x5A	; 90
    3ec4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ec6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ec8:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
		break;
	case CSP_ERROR:
		color = COLOR_RED | COLOR_BOLD;
    3ecc:	82 e1       	ldi	r24, 0x12	; 18
    3ece:	0b c0       	rjmp	.+22     	; 0x3ee6 <do_csp_debug+0x5a>
		break;
	case CSP_WARN:
		color = COLOR_YELLOW | COLOR_BOLD;
    3ed0:	84 e1       	ldi	r24, 0x14	; 20
		break;
    3ed2:	09 c0       	rjmp	.+18     	; 0x3ee6 <do_csp_debug+0x5a>
	case CSP_RESET:
		color = COLOR_RED | COLOR_BOLD;
		break;
	case CSP_BUFFER:
		color = COLOR_MAGENTA;
    3ed4:	86 e0       	ldi	r24, 0x06	; 6
		break;
    3ed6:	07 c0       	rjmp	.+14     	; 0x3ee6 <do_csp_debug+0x5a>
	case CSP_PACKET:
		color = COLOR_GREEN;
    3ed8:	83 e0       	ldi	r24, 0x03	; 3
		break;
    3eda:	05 c0       	rjmp	.+10     	; 0x3ee6 <do_csp_debug+0x5a>
	case CSP_PROTOCOL:
		color = COLOR_BLUE;
    3edc:	85 e0       	ldi	r24, 0x05	; 5
		break;
    3ede:	03 c0       	rjmp	.+6      	; 0x3ee6 <do_csp_debug+0x5a>
	case CSP_LOCK:
		color = COLOR_CYAN;
    3ee0:	87 e0       	ldi	r24, 0x07	; 7
		break;
    3ee2:	01 c0       	rjmp	.+2      	; 0x3ee6 <do_csp_debug+0x5a>
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
		return;

	switch(level) {
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
    3ee4:	83 e1       	ldi	r24, 0x13	; 19
		break;
	default:
		return;
	}

	va_start(args, format);
    3ee6:	ae 01       	movw	r20, r28
    3ee8:	44 5f       	subi	r20, 0xF4	; 244
    3eea:	5f 4f       	sbci	r21, 0xFF	; 255
    3eec:	f4 2e       	mov	r15, r20
    3eee:	05 2f       	mov	r16, r21

	/* If csp_debug_hook symbol is defined, pass on the message.
	 * Otherwise, just print with pretty colors ... */
	if (csp_debug_hook_func) {
    3ef0:	e0 91 1d 04 	lds	r30, 0x041D	; 0x80041d <csp_debug_hook_func>
    3ef4:	f0 91 1e 04 	lds	r31, 0x041E	; 0x80041e <csp_debug_hook_func+0x1>
    3ef8:	30 97       	sbiw	r30, 0x00	; 0
    3efa:	29 f0       	breq	.+10     	; 0x3f06 <do_csp_debug+0x7a>
		csp_debug_hook_func(level, format, args);
    3efc:	6a 85       	ldd	r22, Y+10	; 0x0a
    3efe:	7b 85       	ldd	r23, Y+11	; 0x0b
    3f00:	81 2f       	mov	r24, r17
    3f02:	19 95       	eicall
    3f04:	15 c0       	rjmp	.+42     	; 0x3f30 <do_csp_debug+0xa4>
	} else {
		csp_sys_set_color(color);
    3f06:	61 d9       	rcall	.-3390   	; 0x31ca <csp_sys_set_color>
#ifdef __AVR__
		vfprintf_P(stdout, format, args);
    3f08:	4f 2d       	mov	r20, r15
    3f0a:	50 2f       	mov	r21, r16
    3f0c:	6a 85       	ldd	r22, Y+10	; 0x0a
    3f0e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3f10:	80 91 6c 20 	lds	r24, 0x206C	; 0x80206c <__iob+0x2>
    3f14:	90 91 6d 20 	lds	r25, 0x206D	; 0x80206d <__iob+0x3>
    3f18:	0e 94 fe 45 	call	0x8bfc	; 0x8bfc <vfprintf_P>
#else
		vprintf(format, args);
#endif
		printf("\r\n");
    3f1c:	86 e0       	ldi	r24, 0x06	; 6
    3f1e:	99 e0       	ldi	r25, 0x09	; 9
    3f20:	9f 93       	push	r25
    3f22:	8f 93       	push	r24
    3f24:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
		csp_sys_set_color(COLOR_RESET);
    3f28:	80 ef       	ldi	r24, 0xF0	; 240
    3f2a:	4f d9       	rcall	.-3426   	; 0x31ca <csp_sys_set_color>
    3f2c:	0f 90       	pop	r0
    3f2e:	0f 90       	pop	r0
	}

	va_end(args);
	if(level==CSP_RESET){
    3f30:	16 30       	cpi	r17, 0x06	; 6
    3f32:	d9 f4       	brne	.+54     	; 0x3f6a <do_csp_debug+0xde>
		printf("CSP RESET %s",pcTaskGetName(NULL));
    3f34:	80 e0       	ldi	r24, 0x00	; 0
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	0e 94 ad 3a 	call	0x755a	; 0x755a <pcTaskGetName>
    3f3c:	9f 93       	push	r25
    3f3e:	8f 93       	push	r24
    3f40:	89 ef       	ldi	r24, 0xF9	; 249
    3f42:	98 e0       	ldi	r25, 0x08	; 8
    3f44:	9f 93       	push	r25
    3f46:	8f 93       	push	r24
    3f48:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
	FORCERESET
    3f4c:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
    3f50:	8c ee       	ldi	r24, 0xEC	; 236
    3f52:	98 e0       	ldi	r25, 0x08	; 8
    3f54:	9f 93       	push	r25
    3f56:	8f 93       	push	r24
    3f58:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	0f 90       	pop	r0
    3f62:	0f 90       	pop	r0
    3f64:	0f 90       	pop	r0
    3f66:	0f 90       	pop	r0
    3f68:	ff cf       	rjmp	.-2      	; 0x3f68 <do_csp_debug+0xdc>
	}
}
    3f6a:	df 91       	pop	r29
    3f6c:	cf 91       	pop	r28
    3f6e:	1f 91       	pop	r17
    3f70:	0f 91       	pop	r16
    3f72:	ff 90       	pop	r15
    3f74:	08 95       	ret

00003f76 <csp_hton16>:
	return h16;
#else
	return (((h16 & 0xff00) >> 8) |
			((h16 & 0x00ff) << 8));
#endif
}
    3f76:	98 27       	eor	r25, r24
    3f78:	89 27       	eor	r24, r25
    3f7a:	98 27       	eor	r25, r24
    3f7c:	08 95       	ret

00003f7e <csp_ntoh16>:

/* Convert 16-bit number from network byte order to host byte order */
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}
    3f7e:	98 27       	eor	r25, r24
    3f80:	89 27       	eor	r24, r25
    3f82:	98 27       	eor	r25, r24
    3f84:	08 95       	ret

00003f86 <csp_hton32>:

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    3f86:	cf 92       	push	r12
    3f88:	df 92       	push	r13
    3f8a:	ef 92       	push	r14
    3f8c:	ff 92       	push	r15
    3f8e:	0f 93       	push	r16
    3f90:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    3f92:	c9 2e       	mov	r12, r25
    3f94:	dd 24       	eor	r13, r13
    3f96:	ee 24       	eor	r14, r14
    3f98:	ff 24       	eor	r15, r15
    3f9a:	36 2f       	mov	r19, r22
    3f9c:	22 27       	eor	r18, r18
    3f9e:	11 27       	eor	r17, r17
    3fa0:	00 27       	eor	r16, r16
    3fa2:	0c 29       	or	r16, r12
    3fa4:	1d 29       	or	r17, r13
    3fa6:	2e 29       	or	r18, r14
    3fa8:	3f 29       	or	r19, r15
    3faa:	6b 01       	movw	r12, r22
    3fac:	7c 01       	movw	r14, r24
    3fae:	cc 24       	eor	r12, r12
    3fb0:	ee 24       	eor	r14, r14
    3fb2:	ff 24       	eor	r15, r15
    3fb4:	fe 2c       	mov	r15, r14
    3fb6:	ed 2c       	mov	r14, r13
    3fb8:	dc 2c       	mov	r13, r12
    3fba:	cc 24       	eor	r12, r12
    3fbc:	0c 29       	or	r16, r12
    3fbe:	1d 29       	or	r17, r13
    3fc0:	2e 29       	or	r18, r14
    3fc2:	3f 29       	or	r19, r15
    3fc4:	dc 01       	movw	r26, r24
    3fc6:	cb 01       	movw	r24, r22
    3fc8:	88 27       	eor	r24, r24
    3fca:	99 27       	eor	r25, r25
    3fcc:	bb 27       	eor	r27, r27
    3fce:	89 2f       	mov	r24, r25
    3fd0:	9a 2f       	mov	r25, r26
    3fd2:	ab 2f       	mov	r26, r27
    3fd4:	bb 27       	eor	r27, r27
    3fd6:	bc 01       	movw	r22, r24
    3fd8:	cd 01       	movw	r24, r26
    3fda:	60 2b       	or	r22, r16
    3fdc:	71 2b       	or	r23, r17
    3fde:	82 2b       	or	r24, r18
    3fe0:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    3fe2:	1f 91       	pop	r17
    3fe4:	0f 91       	pop	r16
    3fe6:	ff 90       	pop	r15
    3fe8:	ef 90       	pop	r14
    3fea:	df 90       	pop	r13
    3fec:	cf 90       	pop	r12
    3fee:	08 95       	ret

00003ff0 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    3ff0:	cf 92       	push	r12
    3ff2:	df 92       	push	r13
    3ff4:	ef 92       	push	r14
    3ff6:	ff 92       	push	r15
    3ff8:	0f 93       	push	r16
    3ffa:	1f 93       	push	r17
	return csp_hton32(n32);
    3ffc:	c9 2e       	mov	r12, r25
    3ffe:	dd 24       	eor	r13, r13
    4000:	ee 24       	eor	r14, r14
    4002:	ff 24       	eor	r15, r15
    4004:	36 2f       	mov	r19, r22
    4006:	22 27       	eor	r18, r18
    4008:	11 27       	eor	r17, r17
    400a:	00 27       	eor	r16, r16
    400c:	0c 29       	or	r16, r12
    400e:	1d 29       	or	r17, r13
    4010:	2e 29       	or	r18, r14
    4012:	3f 29       	or	r19, r15
    4014:	6b 01       	movw	r12, r22
    4016:	7c 01       	movw	r14, r24
    4018:	cc 24       	eor	r12, r12
    401a:	ee 24       	eor	r14, r14
    401c:	ff 24       	eor	r15, r15
    401e:	fe 2c       	mov	r15, r14
    4020:	ed 2c       	mov	r14, r13
    4022:	dc 2c       	mov	r13, r12
    4024:	cc 24       	eor	r12, r12
    4026:	0c 29       	or	r16, r12
    4028:	1d 29       	or	r17, r13
    402a:	2e 29       	or	r18, r14
    402c:	3f 29       	or	r19, r15
    402e:	dc 01       	movw	r26, r24
    4030:	cb 01       	movw	r24, r22
    4032:	88 27       	eor	r24, r24
    4034:	99 27       	eor	r25, r25
    4036:	bb 27       	eor	r27, r27
    4038:	89 2f       	mov	r24, r25
    403a:	9a 2f       	mov	r25, r26
    403c:	ab 2f       	mov	r26, r27
    403e:	bb 27       	eor	r27, r27
    4040:	bc 01       	movw	r22, r24
    4042:	cd 01       	movw	r24, r26
    4044:	60 2b       	or	r22, r16
    4046:	71 2b       	or	r23, r17
    4048:	82 2b       	or	r24, r18
    404a:	93 2b       	or	r25, r19
}
    404c:	1f 91       	pop	r17
    404e:	0f 91       	pop	r16
    4050:	ff 90       	pop	r15
    4052:	ef 90       	pop	r14
    4054:	df 90       	pop	r13
    4056:	cf 90       	pop	r12
    4058:	08 95       	ret

0000405a <csp_bytesize>:
	}

}

#ifdef CSP_DEBUG
static int csp_bytesize(char *buf, int len, unsigned long int n) {
    405a:	0f 93       	push	r16
    405c:	1f 93       	push	r17
    405e:	cf 93       	push	r28
    4060:	df 93       	push	r29
    4062:	c8 2f       	mov	r28, r24
    4064:	d9 2f       	mov	r29, r25
    4066:	16 2f       	mov	r17, r22
    4068:	07 2f       	mov	r16, r23
	char postfix;
	double size;

	if (n >= 1048576) {
    406a:	21 15       	cp	r18, r1
    406c:	31 05       	cpc	r19, r1
    406e:	80 e1       	ldi	r24, 0x10	; 16
    4070:	48 07       	cpc	r20, r24
    4072:	51 05       	cpc	r21, r1
    4074:	60 f0       	brcs	.+24     	; 0x408e <csp_bytesize+0x34>
		size = n/1048576.0;
    4076:	ca 01       	movw	r24, r20
    4078:	b9 01       	movw	r22, r18
    407a:	0e 94 e4 42 	call	0x85c8	; 0x85c8 <__floatunsisf>
    407e:	20 e0       	ldi	r18, 0x00	; 0
    4080:	30 e0       	ldi	r19, 0x00	; 0
    4082:	40 e8       	ldi	r20, 0x80	; 128
    4084:	55 e3       	ldi	r21, 0x35	; 53
    4086:	0e 94 21 43 	call	0x8642	; 0x8642 <__mulsf3>
		postfix = 'M';
    408a:	2d e4       	ldi	r18, 0x4D	; 77
    408c:	17 c0       	rjmp	.+46     	; 0x40bc <csp_bytesize+0x62>
	} else if (n >= 1024) {
    408e:	21 15       	cp	r18, r1
    4090:	84 e0       	ldi	r24, 0x04	; 4
    4092:	38 07       	cpc	r19, r24
    4094:	41 05       	cpc	r20, r1
    4096:	51 05       	cpc	r21, r1
    4098:	60 f0       	brcs	.+24     	; 0x40b2 <csp_bytesize+0x58>
		size = n/1024.;
    409a:	ca 01       	movw	r24, r20
    409c:	b9 01       	movw	r22, r18
    409e:	0e 94 e4 42 	call	0x85c8	; 0x85c8 <__floatunsisf>
    40a2:	20 e0       	ldi	r18, 0x00	; 0
    40a4:	30 e0       	ldi	r19, 0x00	; 0
    40a6:	40 e8       	ldi	r20, 0x80	; 128
    40a8:	5a e3       	ldi	r21, 0x3A	; 58
    40aa:	0e 94 21 43 	call	0x8642	; 0x8642 <__mulsf3>
		postfix = 'K';
    40ae:	2b e4       	ldi	r18, 0x4B	; 75
    40b0:	05 c0       	rjmp	.+10     	; 0x40bc <csp_bytesize+0x62>
	} else {
		size = n;
    40b2:	ca 01       	movw	r24, r20
    40b4:	b9 01       	movw	r22, r18
    40b6:	0e 94 e4 42 	call	0x85c8	; 0x85c8 <__floatunsisf>
		postfix = 'B';
    40ba:	22 e4       	ldi	r18, 0x42	; 66
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
    40bc:	1f 92       	push	r1
    40be:	2f 93       	push	r18
    40c0:	9f 93       	push	r25
    40c2:	8f 93       	push	r24
    40c4:	7f 93       	push	r23
    40c6:	6f 93       	push	r22
    40c8:	89 e0       	ldi	r24, 0x09	; 9
    40ca:	99 e0       	ldi	r25, 0x09	; 9
    40cc:	9f 93       	push	r25
    40ce:	8f 93       	push	r24
    40d0:	0f 93       	push	r16
    40d2:	1f 93       	push	r17
    40d4:	df 93       	push	r29
    40d6:	cf 93       	push	r28
    40d8:	0e 94 94 45 	call	0x8b28	; 0x8b28 <snprintf_P>
    40dc:	2d b7       	in	r18, 0x3d	; 61
    40de:	3e b7       	in	r19, 0x3e	; 62
    40e0:	24 5f       	subi	r18, 0xF4	; 244
    40e2:	3f 4f       	sbci	r19, 0xFF	; 255
    40e4:	0f b6       	in	r0, 0x3f	; 63
    40e6:	f8 94       	cli
    40e8:	3e bf       	out	0x3e, r19	; 62
    40ea:	0f be       	out	0x3f, r0	; 63
    40ec:	2d bf       	out	0x3d, r18	; 61
}
    40ee:	df 91       	pop	r29
    40f0:	cf 91       	pop	r28
    40f2:	1f 91       	pop	r17
    40f4:	0f 91       	pop	r16
    40f6:	08 95       	ret

000040f8 <csp_iflist_get_by_name>:
#include <csp/csp.h>

/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
    40f8:	0f 93       	push	r16
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	8c 01       	movw	r16, r24
	csp_iface_t *ifc = interfaces;
    4102:	c0 91 1f 04 	lds	r28, 0x041F	; 0x80041f <interfaces>
    4106:	d0 91 20 04 	lds	r29, 0x0420	; 0x800420 <interfaces+0x1>
	while(ifc) {
    410a:	20 97       	sbiw	r28, 0x00	; 0
    410c:	71 f0       	breq	.+28     	; 0x412a <csp_iflist_get_by_name+0x32>
		if (strncmp(ifc->name, name, 10) == 0)
    410e:	4a e0       	ldi	r20, 0x0A	; 10
    4110:	50 e0       	ldi	r21, 0x00	; 0
    4112:	b8 01       	movw	r22, r16
    4114:	88 81       	ld	r24, Y
    4116:	99 81       	ldd	r25, Y+1	; 0x01
    4118:	0e 94 b8 44 	call	0x8970	; 0x8970 <strncmp>
    411c:	89 2b       	or	r24, r25
    411e:	29 f0       	breq	.+10     	; 0x412a <csp_iflist_get_by_name+0x32>
			break;
		ifc = ifc->next;
    4120:	09 a8       	ldd	r0, Y+49	; 0x31
    4122:	da a9       	ldd	r29, Y+50	; 0x32
    4124:	c0 2d       	mov	r28, r0
/* Interfaces are stored in a linked list*/
static csp_iface_t * interfaces = NULL;

csp_iface_t * csp_iflist_get_by_name(char *name) {
	csp_iface_t *ifc = interfaces;
	while(ifc) {
    4126:	20 97       	sbiw	r28, 0x00	; 0
    4128:	91 f7       	brne	.-28     	; 0x410e <csp_iflist_get_by_name+0x16>
		if (strncmp(ifc->name, name, 10) == 0)
			break;
		ifc = ifc->next;
	}
	return ifc;
}
    412a:	ce 01       	movw	r24, r28
    412c:	df 91       	pop	r29
    412e:	cf 91       	pop	r28
    4130:	1f 91       	pop	r17
    4132:	0f 91       	pop	r16
    4134:	08 95       	ret

00004136 <csp_iflist_add>:

void csp_iflist_add(csp_iface_t *ifc) {

	/* Add interface to pool */
	if (interfaces == NULL) {
    4136:	a0 91 1f 04 	lds	r26, 0x041F	; 0x80041f <interfaces>
    413a:	b0 91 20 04 	lds	r27, 0x0420	; 0x800420 <interfaces+0x1>
    413e:	10 97       	sbiw	r26, 0x00	; 0
    4140:	41 f4       	brne	.+16     	; 0x4152 <csp_iflist_add+0x1c>
		/* This is the first interface to be added */
		interfaces = ifc;
    4142:	90 93 20 04 	sts	0x0420, r25	; 0x800420 <interfaces+0x1>
    4146:	80 93 1f 04 	sts	0x041F, r24	; 0x80041f <interfaces>
		ifc->next = NULL;
    414a:	fc 01       	movw	r30, r24
    414c:	12 aa       	std	Z+50, r1	; 0x32
    414e:	11 aa       	std	Z+49, r1	; 0x31
    4150:	08 95       	ret
	} else {
		/* One or more interfaces were already added */
		csp_iface_t * i = interfaces;
		while (i != ifc && i->next)
    4152:	a8 17       	cp	r26, r24
    4154:	b9 07       	cpc	r27, r25
    4156:	b9 f0       	breq	.+46     	; 0x4186 <csp_iflist_add+0x50>
    4158:	d1 96       	adiw	r26, 0x31	; 49
    415a:	ed 91       	ld	r30, X+
    415c:	fc 91       	ld	r31, X
    415e:	d2 97       	sbiw	r26, 0x32	; 50
    4160:	30 97       	sbiw	r30, 0x00	; 0
    4162:	41 f4       	brne	.+16     	; 0x4174 <csp_iflist_add+0x3e>
    4164:	fd 01       	movw	r30, r26
    4166:	0a c0       	rjmp	.+20     	; 0x417c <csp_iflist_add+0x46>
    4168:	21 a9       	ldd	r18, Z+49	; 0x31
    416a:	32 a9       	ldd	r19, Z+50	; 0x32
    416c:	21 15       	cp	r18, r1
    416e:	31 05       	cpc	r19, r1
    4170:	29 f0       	breq	.+10     	; 0x417c <csp_iflist_add+0x46>
    4172:	f9 01       	movw	r30, r18
    4174:	8e 17       	cp	r24, r30
    4176:	9f 07       	cpc	r25, r31
    4178:	b9 f7       	brne	.-18     	; 0x4168 <csp_iflist_add+0x32>
    417a:	08 95       	ret
			i = i->next;

		/* Insert interface last if not already in pool */
		if (i != ifc && i->next == NULL) {
			i->next = ifc;
    417c:	92 ab       	std	Z+50, r25	; 0x32
    417e:	81 ab       	std	Z+49, r24	; 0x31
			ifc->next = NULL;
    4180:	fc 01       	movw	r30, r24
    4182:	12 aa       	std	Z+50, r1	; 0x32
    4184:	11 aa       	std	Z+49, r1	; 0x31
    4186:	08 95       	ret

00004188 <csp_iflist_print>:
 	}
 
	return snprintf(buf, len, "%.1f%c", size, postfix);
}

void csp_iflist_print(void) {
    4188:	af 92       	push	r10
    418a:	bf 92       	push	r11
    418c:	cf 92       	push	r12
    418e:	df 92       	push	r13
    4190:	ef 92       	push	r14
    4192:	ff 92       	push	r15
    4194:	0f 93       	push	r16
    4196:	1f 93       	push	r17
    4198:	cf 93       	push	r28
    419a:	df 93       	push	r29
    419c:	cd b7       	in	r28, 0x3d	; 61
    419e:	de b7       	in	r29, 0x3e	; 62
    41a0:	e2 97       	sbiw	r28, 0x32	; 50
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	de bf       	out	0x3e, r29	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	cd bf       	out	0x3d, r28	; 61
	csp_iface_t * i = interfaces;
    41ac:	00 91 1f 04 	lds	r16, 0x041F	; 0x80041f <interfaces>
    41b0:	10 91 20 04 	lds	r17, 0x0420	; 0x800420 <interfaces+0x1>
	char txbuf[25], rxbuf[25];

	while (i) {
    41b4:	01 15       	cp	r16, r1
    41b6:	11 05       	cpc	r17, r1
    41b8:	09 f4       	brne	.+2      	; 0x41bc <csp_iflist_print+0x34>
    41ba:	80 c0       	rjmp	.+256    	; 0x42bc <csp_iflist_print+0x134>
		csp_bytesize(txbuf, 25, i->txbytes);
    41bc:	ce 01       	movw	r24, r28
    41be:	01 96       	adiw	r24, 0x01	; 1
    41c0:	5c 01       	movw	r10, r24
		csp_bytesize(rxbuf, 25, i->rxbytes);
    41c2:	7e 01       	movw	r14, r28
    41c4:	9a e1       	ldi	r25, 0x1A	; 26
    41c6:	e9 0e       	add	r14, r25
    41c8:	f1 1c       	adc	r15, r1
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    41ca:	0f 2e       	mov	r0, r31
    41cc:	f0 e1       	ldi	r31, 0x10	; 16
    41ce:	cf 2e       	mov	r12, r31
    41d0:	f9 e0       	ldi	r31, 0x09	; 9
    41d2:	df 2e       	mov	r13, r31
    41d4:	f0 2d       	mov	r31, r0
void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
		csp_bytesize(txbuf, 25, i->txbytes);
    41d6:	f8 01       	movw	r30, r16
    41d8:	25 a1       	ldd	r18, Z+37	; 0x25
    41da:	36 a1       	ldd	r19, Z+38	; 0x26
    41dc:	47 a1       	ldd	r20, Z+39	; 0x27
    41de:	50 a5       	ldd	r21, Z+40	; 0x28
    41e0:	69 e1       	ldi	r22, 0x19	; 25
    41e2:	70 e0       	ldi	r23, 0x00	; 0
    41e4:	c5 01       	movw	r24, r10
    41e6:	39 df       	rcall	.-398    	; 0x405a <csp_bytesize>
		csp_bytesize(rxbuf, 25, i->rxbytes);
    41e8:	f8 01       	movw	r30, r16
    41ea:	21 a5       	ldd	r18, Z+41	; 0x29
    41ec:	32 a5       	ldd	r19, Z+42	; 0x2a
    41ee:	43 a5       	ldd	r20, Z+43	; 0x2b
    41f0:	54 a5       	ldd	r21, Z+44	; 0x2c
    41f2:	69 e1       	ldi	r22, 0x19	; 25
    41f4:	70 e0       	ldi	r23, 0x00	; 0
    41f6:	c7 01       	movw	r24, r14
    41f8:	30 df       	rcall	.-416    	; 0x405a <csp_bytesize>
		printf("%-5s   tx: %05"PRIu32" rx: %05"PRIu32" txe: %05"PRIu32" rxe: %05"PRIu32"\r\n"
    41fa:	ff 92       	push	r15
    41fc:	ef 92       	push	r14
    41fe:	f8 01       	movw	r30, r16
    4200:	84 a5       	ldd	r24, Z+44	; 0x2c
    4202:	8f 93       	push	r24
    4204:	83 a5       	ldd	r24, Z+43	; 0x2b
    4206:	8f 93       	push	r24
    4208:	82 a5       	ldd	r24, Z+42	; 0x2a
    420a:	8f 93       	push	r24
    420c:	81 a5       	ldd	r24, Z+41	; 0x29
    420e:	8f 93       	push	r24
    4210:	bf 92       	push	r11
    4212:	af 92       	push	r10
    4214:	80 a5       	ldd	r24, Z+40	; 0x28
    4216:	8f 93       	push	r24
    4218:	87 a1       	ldd	r24, Z+39	; 0x27
    421a:	8f 93       	push	r24
    421c:	86 a1       	ldd	r24, Z+38	; 0x26
    421e:	8f 93       	push	r24
    4220:	85 a1       	ldd	r24, Z+37	; 0x25
    4222:	8f 93       	push	r24
    4224:	84 a1       	ldd	r24, Z+36	; 0x24
    4226:	8f 93       	push	r24
    4228:	83 a1       	ldd	r24, Z+35	; 0x23
    422a:	8f 93       	push	r24
    422c:	82 a1       	ldd	r24, Z+34	; 0x22
    422e:	8f 93       	push	r24
    4230:	81 a1       	ldd	r24, Z+33	; 0x21
    4232:	8f 93       	push	r24
    4234:	80 a1       	ldd	r24, Z+32	; 0x20
    4236:	8f 93       	push	r24
    4238:	87 8d       	ldd	r24, Z+31	; 0x1f
    423a:	8f 93       	push	r24
    423c:	86 8d       	ldd	r24, Z+30	; 0x1e
    423e:	8f 93       	push	r24
    4240:	85 8d       	ldd	r24, Z+29	; 0x1d
    4242:	8f 93       	push	r24
    4244:	84 8d       	ldd	r24, Z+28	; 0x1c
    4246:	8f 93       	push	r24
    4248:	83 8d       	ldd	r24, Z+27	; 0x1b
    424a:	8f 93       	push	r24
    424c:	82 8d       	ldd	r24, Z+26	; 0x1a
    424e:	8f 93       	push	r24
    4250:	81 8d       	ldd	r24, Z+25	; 0x19
    4252:	8f 93       	push	r24
    4254:	80 8d       	ldd	r24, Z+24	; 0x18
    4256:	8f 93       	push	r24
    4258:	87 89       	ldd	r24, Z+23	; 0x17
    425a:	8f 93       	push	r24
    425c:	86 89       	ldd	r24, Z+22	; 0x16
    425e:	8f 93       	push	r24
    4260:	85 89       	ldd	r24, Z+21	; 0x15
    4262:	8f 93       	push	r24
    4264:	84 89       	ldd	r24, Z+20	; 0x14
    4266:	8f 93       	push	r24
    4268:	83 89       	ldd	r24, Z+19	; 0x13
    426a:	8f 93       	push	r24
    426c:	82 89       	ldd	r24, Z+18	; 0x12
    426e:	8f 93       	push	r24
    4270:	81 89       	ldd	r24, Z+17	; 0x11
    4272:	8f 93       	push	r24
    4274:	80 89       	ldd	r24, Z+16	; 0x10
    4276:	8f 93       	push	r24
    4278:	87 85       	ldd	r24, Z+15	; 0x0f
    427a:	8f 93       	push	r24
    427c:	86 85       	ldd	r24, Z+14	; 0x0e
    427e:	8f 93       	push	r24
    4280:	85 85       	ldd	r24, Z+13	; 0x0d
    4282:	8f 93       	push	r24
    4284:	84 85       	ldd	r24, Z+12	; 0x0c
    4286:	8f 93       	push	r24
    4288:	83 85       	ldd	r24, Z+11	; 0x0b
    428a:	8f 93       	push	r24
    428c:	82 85       	ldd	r24, Z+10	; 0x0a
    428e:	8f 93       	push	r24
    4290:	81 85       	ldd	r24, Z+9	; 0x09
    4292:	8f 93       	push	r24
    4294:	81 81       	ldd	r24, Z+1	; 0x01
    4296:	8f 93       	push	r24
    4298:	80 81       	ld	r24, Z
    429a:	8f 93       	push	r24
    429c:	df 92       	push	r13
    429e:	cf 92       	push	r12
    42a0:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
		       "        drop: %05"PRIu32" autherr: %05"PRIu32 " frame: %05"PRIu32"\r\n"
		       "        txb: %"PRIu32" (%s) rxb: %"PRIu32" (%s)\r\n\r\n",
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
    42a4:	f8 01       	movw	r30, r16
    42a6:	01 a9       	ldd	r16, Z+49	; 0x31
    42a8:	12 a9       	ldd	r17, Z+50	; 0x32

void csp_iflist_print(void) {
	csp_iface_t * i = interfaces;
	char txbuf[25], rxbuf[25];

	while (i) {
    42aa:	0f b6       	in	r0, 0x3f	; 63
    42ac:	f8 94       	cli
    42ae:	de bf       	out	0x3e, r29	; 62
    42b0:	0f be       	out	0x3f, r0	; 63
    42b2:	cd bf       	out	0x3d, r28	; 61
    42b4:	01 15       	cp	r16, r1
    42b6:	11 05       	cpc	r17, r1
    42b8:	09 f0       	breq	.+2      	; 0x42bc <csp_iflist_print+0x134>
    42ba:	8d cf       	rjmp	.-230    	; 0x41d6 <csp_iflist_print+0x4e>
		       i->name, i->tx, i->rx, i->tx_error, i->rx_error, i->drop,
		       i->autherr, i->frame, i->txbytes, txbuf, i->rxbytes, rxbuf);
		i = i->next;
	}

}
    42bc:	e2 96       	adiw	r28, 0x32	; 50
    42be:	0f b6       	in	r0, 0x3f	; 63
    42c0:	f8 94       	cli
    42c2:	de bf       	out	0x3e, r29	; 62
    42c4:	0f be       	out	0x3f, r0	; 63
    42c6:	cd bf       	out	0x3d, r28	; 61
    42c8:	df 91       	pop	r29
    42ca:	cf 91       	pop	r28
    42cc:	1f 91       	pop	r17
    42ce:	0f 91       	pop	r16
    42d0:	ff 90       	pop	r15
    42d2:	ef 90       	pop	r14
    42d4:	df 90       	pop	r13
    42d6:	cf 90       	pop	r12
    42d8:	bf 90       	pop	r11
    42da:	af 90       	pop	r10
    42dc:	08 95       	ret

000042de <csp_get_address>:
	return csp_model;
}

void csp_set_revision(const char *revision)
{
	csp_revision = revision;
    42de:	80 91 25 04 	lds	r24, 0x0425	; 0x800425 <csp_my_address>
    42e2:	08 95       	ret

000042e4 <csp_get_hostname>:
    42e4:	80 91 23 04 	lds	r24, 0x0423	; 0x800423 <csp_hostname>
    42e8:	90 91 24 04 	lds	r25, 0x0424	; 0x800424 <csp_hostname+0x1>
    42ec:	08 95       	ret

000042ee <csp_get_model>:
    42ee:	80 91 21 04 	lds	r24, 0x0421	; 0x800421 <csp_model>
    42f2:	90 91 22 04 	lds	r25, 0x0422	; 0x800422 <csp_model+0x1>
    42f6:	08 95       	ret

000042f8 <csp_get_revision>:
}

const char *csp_get_revision(void)
{
	return csp_revision;
}
    42f8:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <csp_revision>
    42fc:	90 91 13 02 	lds	r25, 0x0213	; 0x800213 <csp_revision+0x1>
    4300:	08 95       	ret

00004302 <csp_init>:

int csp_init(unsigned char address) {
    4302:	cf 93       	push	r28
    4304:	df 93       	push	r29
extern csp_queue_handle_t csp_promisc_queue;
#endif

void csp_set_address(uint8_t addr)
{
	csp_my_address = addr;
    4306:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <csp_my_address>
	int ret;

	/* Initialize CSP */
	csp_set_address(address);

	ret = csp_conn_init();
    430a:	05 da       	rcall	.-3062   	; 0x3716 <csp_conn_init>
	if (ret != CSP_ERR_NONE)
    430c:	00 97       	sbiw	r24, 0x00	; 0
		return ret;

	ret = csp_port_init();
    430e:	e9 f4       	brne	.+58     	; 0x434a <csp_init+0x48>
    4310:	53 d2       	rcall	.+1190   	; 0x47b8 <csp_port_init>
	if (ret != CSP_ERR_NONE)
    4312:	00 97       	sbiw	r24, 0x00	; 0
		return ret;

	ret = csp_qfifo_init();
    4314:	d1 f4       	brne	.+52     	; 0x434a <csp_init+0x48>
    4316:	d6 d2       	rcall	.+1452   	; 0x48c4 <csp_qfifo_init>
    4318:	ec 01       	movw	r28, r24
	if (ret != CSP_ERR_NONE)
    431a:	00 97       	sbiw	r24, 0x00	; 0
		return ret;

	/* Loopback */
	csp_iflist_add(&csp_if_lo);
    431c:	a9 f4       	brne	.+42     	; 0x4348 <csp_init+0x46>
    431e:	89 e4       	ldi	r24, 0x49	; 73
    4320:	92 e0       	ldi	r25, 0x02	; 2
    4322:	09 df       	rcall	.-494    	; 0x4136 <csp_iflist_add>

	/* Register loopback route */
	csp_route_set(csp_get_address(), &csp_if_lo, CSP_NODE_MAC);
    4324:	2f ef       	ldi	r18, 0xFF	; 255
    4326:	49 e4       	ldi	r20, 0x49	; 73
    4328:	52 e0       	ldi	r21, 0x02	; 2
    432a:	65 e0       	ldi	r22, 0x05	; 5
    432c:	80 91 25 04 	lds	r24, 0x0425	; 0x800425 <csp_my_address>
    4330:	0e 94 76 30 	call	0x60ec	; 0x60ec <csp_rtable_set>

	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);
    4334:	2f ef       	ldi	r18, 0xFF	; 255
    4336:	49 e4       	ldi	r20, 0x49	; 73
    4338:	52 e0       	ldi	r21, 0x02	; 2
    433a:	65 e0       	ldi	r22, 0x05	; 5
    433c:	80 e2       	ldi	r24, 0x20	; 32
    433e:	0e 94 76 30 	call	0x60ec	; 0x60ec <csp_rtable_set>

	return CSP_ERR_NONE;
    4342:	8c 2f       	mov	r24, r28
    4344:	9d 2f       	mov	r25, r29
    4346:	01 c0       	rjmp	.+2      	; 0x434a <csp_init+0x48>
	if (ret != CSP_ERR_NONE)
		return ret;

	ret = csp_qfifo_init();
	if (ret != CSP_ERR_NONE)
		return ret;
    4348:	9d 2f       	mov	r25, r29
	/* Also register loopback as default, until user redefines default route */
	csp_route_set(CSP_DEFAULT_ROUTE, &csp_if_lo, CSP_NODE_MAC);

	return CSP_ERR_NONE;

}
    434a:	df 91       	pop	r29
    434c:	cf 91       	pop	r28
    434e:	08 95       	ret

00004350 <csp_socket>:

csp_socket_t * csp_socket(uint32_t opts) {
    4350:	cf 92       	push	r12
    4352:	df 92       	push	r13
    4354:	ef 92       	push	r14
    4356:	ff 92       	push	r15
    4358:	cf 93       	push	r28
    435a:	df 93       	push	r29
    435c:	6b 01       	movw	r12, r22
    435e:	7c 01       	movw	r14, r24
	
	/* Validate socket options */
#ifndef CSP_USE_RDP
	if (opts & CSP_SO_RDPREQ) {
    4360:	60 ff       	sbrs	r22, 0
    4362:	0c c0       	rjmp	.+24     	; 0x437c <csp_socket+0x2c>
		csp_log_error("Attempt to create socket that requires RDP, but CSP was compiled without RDP support");
    4364:	8f ec       	ldi	r24, 0xCF	; 207
    4366:	9b e0       	ldi	r25, 0x0B	; 11
    4368:	9f 93       	push	r25
    436a:	8f 93       	push	r24
    436c:	1f 92       	push	r1
    436e:	8e dd       	rcall	.-1252   	; 0x3e8c <do_csp_debug>
		return NULL;
    4370:	0f 90       	pop	r0
    4372:	0f 90       	pop	r0
    4374:	0f 90       	pop	r0
    4376:	80 e0       	ldi	r24, 0x00	; 0
    4378:	90 e0       	ldi	r25, 0x00	; 0
    437a:	50 c0       	rjmp	.+160    	; 0x441c <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_XTEA
	if (opts & CSP_SO_XTEAREQ) {
    437c:	64 ff       	sbrs	r22, 4
    437e:	0c c0       	rjmp	.+24     	; 0x4398 <csp_socket+0x48>
		csp_log_error("Attempt to create socket that requires XTEA, but CSP was compiled without XTEA support");
    4380:	88 e7       	ldi	r24, 0x78	; 120
    4382:	9b e0       	ldi	r25, 0x0B	; 11
    4384:	9f 93       	push	r25
    4386:	8f 93       	push	r24
    4388:	1f 92       	push	r1
    438a:	80 dd       	rcall	.-1280   	; 0x3e8c <do_csp_debug>
		return NULL;
    438c:	0f 90       	pop	r0
    438e:	0f 90       	pop	r0
    4390:	0f 90       	pop	r0
    4392:	80 e0       	ldi	r24, 0x00	; 0
    4394:	90 e0       	ldi	r25, 0x00	; 0
    4396:	42 c0       	rjmp	.+132    	; 0x441c <csp_socket+0xcc>
	}
#endif

#ifndef CSP_USE_HMAC
	if (opts & CSP_SO_HMACREQ) {
    4398:	62 ff       	sbrs	r22, 2
    439a:	0c c0       	rjmp	.+24     	; 0x43b4 <csp_socket+0x64>
		csp_log_error("Attempt to create socket that requires HMAC, but CSP was compiled without HMAC support");
    439c:	81 e2       	ldi	r24, 0x21	; 33
    439e:	9b e0       	ldi	r25, 0x0B	; 11
    43a0:	9f 93       	push	r25
    43a2:	8f 93       	push	r24
    43a4:	1f 92       	push	r1
    43a6:	72 dd       	rcall	.-1308   	; 0x3e8c <do_csp_debug>
		return NULL;
    43a8:	0f 90       	pop	r0
    43aa:	0f 90       	pop	r0
    43ac:	0f 90       	pop	r0
    43ae:	80 e0       	ldi	r24, 0x00	; 0
    43b0:	90 e0       	ldi	r25, 0x00	; 0
    43b2:	34 c0       	rjmp	.+104    	; 0x441c <csp_socket+0xcc>
		return NULL;
	} 
#endif
	
	/* Drop packet if reserved flags are set */
	if (opts & ~(CSP_SO_RDPREQ | CSP_SO_XTEAREQ | CSP_SO_HMACREQ | CSP_SO_CRC32REQ | CSP_SO_CONN_LESS)) {
    43b4:	dc 01       	movw	r26, r24
    43b6:	cb 01       	movw	r24, r22
    43b8:	8a 7a       	andi	r24, 0xAA	; 170
    43ba:	9e 7f       	andi	r25, 0xFE	; 254
    43bc:	89 2b       	or	r24, r25
    43be:	8a 2b       	or	r24, r26
    43c0:	8b 2b       	or	r24, r27
    43c2:	61 f0       	breq	.+24     	; 0x43dc <csp_socket+0x8c>
		csp_log_error("Invalid socket option");
    43c4:	8b e0       	ldi	r24, 0x0B	; 11
    43c6:	9b e0       	ldi	r25, 0x0B	; 11
    43c8:	9f 93       	push	r25
    43ca:	8f 93       	push	r24
    43cc:	1f 92       	push	r1
    43ce:	5e dd       	rcall	.-1348   	; 0x3e8c <do_csp_debug>
		return NULL;
    43d0:	0f 90       	pop	r0
    43d2:	0f 90       	pop	r0
    43d4:	0f 90       	pop	r0
    43d6:	80 e0       	ldi	r24, 0x00	; 0
    43d8:	90 e0       	ldi	r25, 0x00	; 0
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
    43da:	20 c0       	rjmp	.+64     	; 0x441c <csp_socket+0xcc>
    43dc:	81 e0       	ldi	r24, 0x01	; 1
    43de:	41 da       	rcall	.-2942   	; 0x3862 <csp_conn_allocate>
    43e0:	ec 01       	movw	r28, r24
	if (sock == NULL)
    43e2:	89 2b       	or	r24, r25
    43e4:	b1 f0       	breq	.+44     	; 0x4412 <csp_socket+0xc2>
		return NULL;

	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
    43e6:	d0 fe       	sbrs	r13, 0
    43e8:	0b c0       	rjmp	.+22     	; 0x4400 <csp_socket+0xb0>
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
    43ea:	62 e0       	ldi	r22, 0x02	; 2
    43ec:	70 e0       	ldi	r23, 0x00	; 0
    43ee:	84 e6       	ldi	r24, 0x64	; 100
    43f0:	90 e0       	ldi	r25, 0x00	; 0
    43f2:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <csp_queue_create>
    43f6:	9f 87       	std	Y+15, r25	; 0x0f
    43f8:	8e 87       	std	Y+14, r24	; 0x0e
		if (sock->socket == NULL)
    43fa:	89 2b       	or	r24, r25
    43fc:	19 f4       	brne	.+6      	; 0x4404 <csp_socket+0xb4>
    43fe:	0c c0       	rjmp	.+24     	; 0x4418 <csp_socket+0xc8>
			return NULL;
	} else {
		sock->socket = NULL;
    4400:	1f 86       	std	Y+15, r1	; 0x0f
    4402:	1e 86       	std	Y+14, r1	; 0x0e
	}
	sock->opts = opts;
    4404:	cc 8a       	std	Y+20, r12	; 0x14
    4406:	dd 8a       	std	Y+21, r13	; 0x15
    4408:	ee 8a       	std	Y+22, r14	; 0x16
    440a:	ff 8a       	std	Y+23, r15	; 0x17

	return sock;
    440c:	8c 2f       	mov	r24, r28
    440e:	9d 2f       	mov	r25, r29
    4410:	05 c0       	rjmp	.+10     	; 0x441c <csp_socket+0xcc>
	}

	/* Use CSP buffers instead? */
	csp_socket_t * sock = csp_conn_allocate(CONN_SERVER);
	if (sock == NULL)
		return NULL;
    4412:	80 e0       	ldi	r24, 0x00	; 0
    4414:	90 e0       	ldi	r25, 0x00	; 0
    4416:	02 c0       	rjmp	.+4      	; 0x441c <csp_socket+0xcc>
	/* If connectionless, init the queue to a pre-defined size
	 * if not, the user must init the queue using csp_listen */
	if (opts & CSP_SO_CONN_LESS) {
		sock->socket = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(csp_packet_t *));
		if (sock->socket == NULL)
			return NULL;
    4418:	80 e0       	ldi	r24, 0x00	; 0
    441a:	90 e0       	ldi	r25, 0x00	; 0
	}
	sock->opts = opts;

	return sock;

}
    441c:	df 91       	pop	r29
    441e:	cf 91       	pop	r28
    4420:	ff 90       	pop	r15
    4422:	ef 90       	pop	r14
    4424:	df 90       	pop	r13
    4426:	cf 90       	pop	r12
    4428:	08 95       	ret

0000442a <csp_accept>:

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {
    442a:	cf 93       	push	r28
    442c:	df 93       	push	r29
    442e:	1f 92       	push	r1
    4430:	1f 92       	push	r1
    4432:	cd b7       	in	r28, 0x3d	; 61
    4434:	de b7       	in	r29, 0x3e	; 62

	if (sock == NULL)
    4436:	00 97       	sbiw	r24, 0x00	; 0
    4438:	89 f0       	breq	.+34     	; 0x445c <csp_accept+0x32>
		return NULL;

	if (sock->socket == NULL)
    443a:	fc 01       	movw	r30, r24
    443c:	86 85       	ldd	r24, Z+14	; 0x0e
    443e:	97 85       	ldd	r25, Z+15	; 0x0f
    4440:	00 97       	sbiw	r24, 0x00	; 0
    4442:	79 f0       	breq	.+30     	; 0x4462 <csp_accept+0x38>
    4444:	9a 01       	movw	r18, r20
    4446:	ab 01       	movw	r20, r22
		return NULL;

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
    4448:	be 01       	movw	r22, r28
    444a:	6f 5f       	subi	r22, 0xFF	; 255
    444c:	7f 4f       	sbci	r23, 0xFF	; 255
    444e:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <csp_queue_dequeue>
    4452:	01 97       	sbiw	r24, 0x01	; 1
    4454:	49 f4       	brne	.+18     	; 0x4468 <csp_accept+0x3e>
		return conn;
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	08 c0       	rjmp	.+16     	; 0x446c <csp_accept+0x42>
}

csp_conn_t * csp_accept(csp_socket_t * sock, uint32_t timeout) {

	if (sock == NULL)
		return NULL;
    445c:	80 e0       	ldi	r24, 0x00	; 0
    445e:	90 e0       	ldi	r25, 0x00	; 0
    4460:	05 c0       	rjmp	.+10     	; 0x446c <csp_accept+0x42>

	if (sock->socket == NULL)
		return NULL;
    4462:	80 e0       	ldi	r24, 0x00	; 0
    4464:	90 e0       	ldi	r25, 0x00	; 0
    4466:	02 c0       	rjmp	.+4      	; 0x446c <csp_accept+0x42>

	csp_conn_t * conn;
	if (csp_queue_dequeue(sock->socket, &conn, timeout) == CSP_QUEUE_OK)
		return conn;

	return NULL;
    4468:	80 e0       	ldi	r24, 0x00	; 0
    446a:	90 e0       	ldi	r25, 0x00	; 0

}
    446c:	0f 90       	pop	r0
    446e:	0f 90       	pop	r0
    4470:	df 91       	pop	r29
    4472:	cf 91       	pop	r28
    4474:	08 95       	ret

00004476 <csp_read>:

csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {
    4476:	cf 93       	push	r28
    4478:	df 93       	push	r29
    447a:	1f 92       	push	r1
    447c:	1f 92       	push	r1
    447e:	cd b7       	in	r28, 0x3d	; 61
    4480:	de b7       	in	r29, 0x3e	; 62

	csp_packet_t * packet = NULL;
    4482:	1a 82       	std	Y+2, r1	; 0x02
    4484:	19 82       	std	Y+1, r1	; 0x01

	if (conn == NULL || conn->state != CONN_OPEN)
    4486:	00 97       	sbiw	r24, 0x00	; 0
    4488:	91 f0       	breq	.+36     	; 0x44ae <csp_read+0x38>
    448a:	fc 01       	movw	r30, r24
    448c:	21 81       	ldd	r18, Z+1	; 0x01
    448e:	21 30       	cpi	r18, 0x01	; 1
    4490:	89 f4       	brne	.+34     	; 0x44b4 <csp_read+0x3e>
    4492:	9a 01       	movw	r18, r20
    4494:	ab 01       	movw	r20, r22

	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
    4496:	be 01       	movw	r22, r28
    4498:	6f 5f       	subi	r22, 0xFF	; 255
    449a:	7f 4f       	sbci	r23, 0xFF	; 255
    449c:	84 85       	ldd	r24, Z+12	; 0x0c
    449e:	95 85       	ldd	r25, Z+13	; 0x0d
    44a0:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <csp_queue_dequeue>
    44a4:	01 97       	sbiw	r24, 0x01	; 1
    44a6:	49 f4       	brne	.+18     	; 0x44ba <csp_read+0x44>
	/* Packet read could trigger ACK transmission */
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_check_ack(conn);
#endif

	return packet;
    44a8:	89 81       	ldd	r24, Y+1	; 0x01
    44aa:	9a 81       	ldd	r25, Y+2	; 0x02
    44ac:	08 c0       	rjmp	.+16     	; 0x44be <csp_read+0x48>
csp_packet_t * csp_read(csp_conn_t * conn, uint32_t timeout) {

	csp_packet_t * packet = NULL;

	if (conn == NULL || conn->state != CONN_OPEN)
		return NULL;
    44ae:	80 e0       	ldi	r24, 0x00	; 0
    44b0:	90 e0       	ldi	r25, 0x00	; 0
    44b2:	05 c0       	rjmp	.+10     	; 0x44be <csp_read+0x48>
    44b4:	80 e0       	ldi	r24, 0x00	; 0
    44b6:	90 e0       	ldi	r25, 0x00	; 0
    44b8:	02 c0       	rjmp	.+4      	; 0x44be <csp_read+0x48>
	for (prio = 0; prio < CSP_RX_QUEUES; prio++)
		if (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			break;
#else
	if (csp_queue_dequeue(conn->rx_queue[0], &packet, timeout) != CSP_QUEUE_OK)
		return NULL;
    44ba:	80 e0       	ldi	r24, 0x00	; 0
    44bc:	90 e0       	ldi	r25, 0x00	; 0
		csp_rdp_check_ack(conn);
#endif

	return packet;

}
    44be:	0f 90       	pop	r0
    44c0:	0f 90       	pop	r0
    44c2:	df 91       	pop	r29
    44c4:	cf 91       	pop	r28
    44c6:	08 95       	ret

000044c8 <csp_send_direct>:

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {
    44c8:	4f 92       	push	r4
    44ca:	5f 92       	push	r5
    44cc:	6f 92       	push	r6
    44ce:	7f 92       	push	r7
    44d0:	8f 92       	push	r8
    44d2:	9f 92       	push	r9
    44d4:	af 92       	push	r10
    44d6:	bf 92       	push	r11
    44d8:	cf 92       	push	r12
    44da:	df 92       	push	r13
    44dc:	ef 92       	push	r14
    44de:	ff 92       	push	r15
    44e0:	0f 93       	push	r16
    44e2:	1f 93       	push	r17
    44e4:	cf 93       	push	r28
    44e6:	df 93       	push	r29
    44e8:	86 2e       	mov	r8, r22
    44ea:	97 2e       	mov	r9, r23
    44ec:	a8 2e       	mov	r10, r24
    44ee:	b9 2e       	mov	r11, r25
    44f0:	6a 01       	movw	r12, r20
    44f2:	e9 01       	movw	r28, r18
    44f4:	27 01       	movw	r4, r14
    44f6:	38 01       	movw	r6, r16

	if (packet == NULL) {
    44f8:	41 15       	cp	r20, r1
    44fa:	51 05       	cpc	r21, r1
    44fc:	61 f4       	brne	.+24     	; 0x4516 <csp_send_direct+0x4e>
		csp_log_error("csp_send_direct called with NULL packet");
    44fe:	83 ee       	ldi	r24, 0xE3	; 227
    4500:	9a e0       	ldi	r25, 0x0A	; 10
    4502:	9f 93       	push	r25
    4504:	8f 93       	push	r24
    4506:	1f 92       	push	r1
    4508:	c1 dc       	rcall	.-1662   	; 0x3e8c <do_csp_debug>
		goto err;
    450a:	0f 90       	pop	r0
    450c:	0f 90       	pop	r0
    450e:	0f 90       	pop	r0
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    4510:	86 ef       	ldi	r24, 0xF6	; 246
    4512:	9f ef       	ldi	r25, 0xFF	; 255

int csp_send_direct(csp_id_t idout, csp_packet_t * packet, csp_iface_t * ifout, uint32_t timeout) {

	if (packet == NULL) {
		csp_log_error("csp_send_direct called with NULL packet");
		goto err;
    4514:	cf c0       	rjmp	.+414    	; 0x46b4 <csp_send_direct+0x1ec>
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
    4516:	20 97       	sbiw	r28, 0x00	; 0
    4518:	21 f0       	breq	.+8      	; 0x4522 <csp_send_direct+0x5a>
    451a:	8c 81       	ldd	r24, Y+4	; 0x04
    451c:	9d 81       	ldd	r25, Y+5	; 0x05
    451e:	89 2b       	or	r24, r25
    4520:	b1 f4       	brne	.+44     	; 0x454e <csp_send_direct+0x86>
		csp_log_error("No route to host: %#08x", idout.ext);
    4522:	bf 92       	push	r11
    4524:	af 92       	push	r10
    4526:	9f 92       	push	r9
    4528:	8f 92       	push	r8
    452a:	8b ec       	ldi	r24, 0xCB	; 203
    452c:	9a e0       	ldi	r25, 0x0A	; 10
    452e:	9f 93       	push	r25
    4530:	8f 93       	push	r24
    4532:	1f 92       	push	r1
    4534:	ab dc       	rcall	.-1706   	; 0x3e8c <do_csp_debug>
		goto err;
    4536:	2d b7       	in	r18, 0x3d	; 61
    4538:	3e b7       	in	r19, 0x3e	; 62
    453a:	29 5f       	subi	r18, 0xF9	; 249
    453c:	3f 4f       	sbci	r19, 0xFF	; 255
    453e:	0f b6       	in	r0, 0x3f	; 63
    4540:	f8 94       	cli
    4542:	3e bf       	out	0x3e, r19	; 62
    4544:	0f be       	out	0x3f, r0	; 63
    4546:	2d bf       	out	0x3d, r18	; 61
	return CSP_ERR_NONE;

tx_err:
	ifout->tx_error++;
err:
	return CSP_ERR_TX;
    4548:	86 ef       	ldi	r24, 0xF6	; 246
    454a:	9f ef       	ldi	r25, 0xFF	; 255
		goto err;
	}

	if ((ifout == NULL) || (ifout->nexthop == NULL)) {
		csp_log_error("No route to host: %#08x", idout.ext);
		goto err;
    454c:	b3 c0       	rjmp	.+358    	; 0x46b4 <csp_send_direct+0x1ec>
	}

	csp_log_packet("OUT: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %u VIA: %s",
    454e:	8b 2d       	mov	r24, r11
    4550:	86 95       	lsr	r24
    4552:	8f 71       	andi	r24, 0x1F	; 31
    4554:	08 2f       	mov	r16, r24
    4556:	10 e0       	ldi	r17, 0x00	; 0
    4558:	99 81       	ldd	r25, Y+1	; 0x01
    455a:	9f 93       	push	r25
    455c:	98 81       	ld	r25, Y
    455e:	9f 93       	push	r25
    4560:	fa 01       	movw	r30, r20
    4562:	91 85       	ldd	r25, Z+9	; 0x09
    4564:	9f 93       	push	r25
    4566:	90 85       	ldd	r25, Z+8	; 0x08
    4568:	9f 93       	push	r25
    456a:	1f 92       	push	r1
    456c:	6f 93       	push	r22
    456e:	9b 2d       	mov	r25, r11
    4570:	92 95       	swap	r25
    4572:	96 95       	lsr	r25
    4574:	96 95       	lsr	r25
    4576:	93 70       	andi	r25, 0x03	; 3
    4578:	1f 92       	push	r1
    457a:	9f 93       	push	r25
    457c:	97 2f       	mov	r25, r23
    457e:	9f 73       	andi	r25, 0x3F	; 63
    4580:	1f 92       	push	r1
    4582:	9f 93       	push	r25
    4584:	27 2f       	mov	r18, r23
    4586:	22 95       	swap	r18
    4588:	26 95       	lsr	r18
    458a:	26 95       	lsr	r18
    458c:	23 70       	andi	r18, 0x03	; 3
    458e:	9a 2d       	mov	r25, r10
    4590:	9f 70       	andi	r25, 0x0F	; 15
    4592:	99 0f       	add	r25, r25
    4594:	99 0f       	add	r25, r25
    4596:	92 2b       	or	r25, r18
    4598:	1f 92       	push	r1
    459a:	9f 93       	push	r25
    459c:	2a 2d       	mov	r18, r10
    459e:	22 95       	swap	r18
    45a0:	2f 70       	andi	r18, 0x0F	; 15
    45a2:	9b 2d       	mov	r25, r11
    45a4:	91 70       	andi	r25, 0x01	; 1
    45a6:	92 95       	swap	r25
    45a8:	90 7f       	andi	r25, 0xF0	; 240
    45aa:	92 2b       	or	r25, r18
    45ac:	1f 92       	push	r1
    45ae:	9f 93       	push	r25
    45b0:	1f 92       	push	r1
    45b2:	8f 93       	push	r24
    45b4:	8c e8       	ldi	r24, 0x8C	; 140
    45b6:	9a e0       	ldi	r25, 0x0A	; 10
    45b8:	9f 93       	push	r25
    45ba:	8f 93       	push	r24
    45bc:	84 e0       	ldi	r24, 0x04	; 4
    45be:	8f 93       	push	r24
    45c0:	65 dc       	rcall	.-1846   	; 0x3e8c <do_csp_debug>
		idout.src, idout.dst, idout.dport, idout.sport, idout.pri, idout.flags, packet->length, ifout->name);

	/* Copy identifier to packet (before crc, xtea and hmac) */
	packet->id.ext = idout.ext;
    45c2:	f6 01       	movw	r30, r12
    45c4:	82 86       	std	Z+10, r8	; 0x0a
    45c6:	93 86       	std	Z+11, r9	; 0x0b
    45c8:	a4 86       	std	Z+12, r10	; 0x0c
    45ca:	b5 86       	std	Z+13, r11	; 0x0d
		csp_promisc_add(packet);
	}
#endif

	/* Only encrypt packets from the current node */
	if (idout.src == csp_get_address()) {
    45cc:	80 91 25 04 	lds	r24, 0x0425	; 0x800425 <csp_my_address>
    45d0:	90 e0       	ldi	r25, 0x00	; 0
    45d2:	2d b7       	in	r18, 0x3d	; 61
    45d4:	3e b7       	in	r19, 0x3e	; 62
    45d6:	2d 5e       	subi	r18, 0xED	; 237
    45d8:	3f 4f       	sbci	r19, 0xFF	; 255
    45da:	0f b6       	in	r0, 0x3f	; 63
    45dc:	f8 94       	cli
    45de:	3e bf       	out	0x3e, r19	; 62
    45e0:	0f be       	out	0x3f, r0	; 63
    45e2:	2d bf       	out	0x3d, r18	; 61
    45e4:	08 17       	cp	r16, r24
    45e6:	19 07       	cpc	r17, r25
    45e8:	61 f5       	brne	.+88     	; 0x4642 <csp_send_direct+0x17a>
		/* Append HMAC */
		if (idout.flags & CSP_FHMAC) {
    45ea:	83 fe       	sbrs	r8, 3
    45ec:	0b c0       	rjmp	.+22     	; 0x4604 <csp_send_direct+0x13c>
				/* HMAC append failed */
				csp_log_warn("HMAC append failed!");
				goto tx_err;
			}
#else
			csp_log_warn("Attempt to send packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    45ee:	8d e2       	ldi	r24, 0x2D	; 45
    45f0:	9a e0       	ldi	r25, 0x0A	; 10
    45f2:	9f 93       	push	r25
    45f4:	8f 93       	push	r24
    45f6:	81 e0       	ldi	r24, 0x01	; 1
    45f8:	8f 93       	push	r24
    45fa:	48 dc       	rcall	.-1904   	; 0x3e8c <do_csp_debug>
			goto tx_err;
    45fc:	0f 90       	pop	r0
    45fe:	0f 90       	pop	r0
    4600:	0f 90       	pop	r0
    4602:	4b c0       	rjmp	.+150    	; 0x469a <csp_send_direct+0x1d2>
#endif
		}

		/* Append CRC32 */
		if (idout.flags & CSP_FCRC32) {
    4604:	80 fe       	sbrs	r8, 0
#ifdef CSP_USE_CRC32
			/* Calculate and add CRC32 (does not include header for backwards compatability with csp1.x) */
			if (csp_crc32_append(packet, false) != 0) {
    4606:	10 c0       	rjmp	.+32     	; 0x4628 <csp_send_direct+0x160>
    4608:	60 e0       	ldi	r22, 0x00	; 0
    460a:	c6 01       	movw	r24, r12
    460c:	b7 db       	rcall	.-2194   	; 0x3d7c <csp_crc32_append>
    460e:	89 2b       	or	r24, r25
    4610:	59 f0       	breq	.+22     	; 0x4628 <csp_send_direct+0x160>
				/* CRC32 append failed */
				csp_log_warn("CRC32 append failed!");
    4612:	88 e1       	ldi	r24, 0x18	; 24
    4614:	9a e0       	ldi	r25, 0x0A	; 10
    4616:	9f 93       	push	r25
    4618:	8f 93       	push	r24
    461a:	81 e0       	ldi	r24, 0x01	; 1
    461c:	8f 93       	push	r24
    461e:	36 dc       	rcall	.-1940   	; 0x3e8c <do_csp_debug>
				goto tx_err;
    4620:	0f 90       	pop	r0
    4622:	0f 90       	pop	r0
    4624:	0f 90       	pop	r0
    4626:	39 c0       	rjmp	.+114    	; 0x469a <csp_send_direct+0x1d2>
			csp_log_warn("Attempt to send packet with CRC32, but CSP was compiled without CRC32 support. Sending without CRC32r");
			idout.flags &= ~(CSP_FCRC32);
#endif
		}

		if (idout.flags & CSP_FXTEA) {
    4628:	82 fe       	sbrs	r8, 2
    462a:	0b c0       	rjmp	.+22     	; 0x4642 <csp_send_direct+0x17a>
				goto tx_err;
			}

			packet->length += sizeof(nonce_n);
#else
			csp_log_warn("Attempt to send XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    462c:	84 eb       	ldi	r24, 0xB4	; 180
    462e:	99 e0       	ldi	r25, 0x09	; 9
    4630:	9f 93       	push	r25
    4632:	8f 93       	push	r24
    4634:	81 e0       	ldi	r24, 0x01	; 1
    4636:	8f 93       	push	r24
    4638:	29 dc       	rcall	.-1966   	; 0x3e8c <do_csp_debug>
			goto tx_err;
    463a:	0f 90       	pop	r0
    463c:	0f 90       	pop	r0
    463e:	0f 90       	pop	r0
    4640:	2c c0       	rjmp	.+88     	; 0x469a <csp_send_direct+0x1d2>
#endif
		}
	}

	/* Store length before passing to interface */
	uint16_t bytes = packet->length;
    4642:	f6 01       	movw	r30, r12
    4644:	00 85       	ldd	r16, Z+8	; 0x08
    4646:	11 85       	ldd	r17, Z+9	; 0x09
	uint16_t mtu = ifout->mtu;
    4648:	8e 81       	ldd	r24, Y+6	; 0x06
    464a:	9f 81       	ldd	r25, Y+7	; 0x07

	if (mtu > 0 && bytes > mtu)
    464c:	00 97       	sbiw	r24, 0x00	; 0
    464e:	19 f0       	breq	.+6      	; 0x4656 <csp_send_direct+0x18e>
    4650:	80 17       	cp	r24, r16
    4652:	91 07       	cpc	r25, r17
    4654:	10 f1       	brcs	.+68     	; 0x469a <csp_send_direct+0x1d2>
		goto tx_err;

	if ((*ifout->nexthop)(ifout, packet, timeout) != CSP_ERR_NONE)
    4656:	ec 81       	ldd	r30, Y+4	; 0x04
    4658:	fd 81       	ldd	r31, Y+5	; 0x05
    465a:	a3 01       	movw	r20, r6
    465c:	92 01       	movw	r18, r4
    465e:	b6 01       	movw	r22, r12
    4660:	ce 01       	movw	r24, r28
    4662:	19 95       	eicall
    4664:	00 97       	sbiw	r24, 0x00	; 0
    4666:	c9 f4       	brne	.+50     	; 0x469a <csp_send_direct+0x1d2>
		goto tx_err;

	ifout->tx++;
    4668:	49 85       	ldd	r20, Y+9	; 0x09
    466a:	5a 85       	ldd	r21, Y+10	; 0x0a
    466c:	6b 85       	ldd	r22, Y+11	; 0x0b
    466e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4670:	4f 5f       	subi	r20, 0xFF	; 255
    4672:	5f 4f       	sbci	r21, 0xFF	; 255
    4674:	6f 4f       	sbci	r22, 0xFF	; 255
    4676:	7f 4f       	sbci	r23, 0xFF	; 255
    4678:	49 87       	std	Y+9, r20	; 0x09
    467a:	5a 87       	std	Y+10, r21	; 0x0a
    467c:	6b 87       	std	Y+11, r22	; 0x0b
    467e:	7c 87       	std	Y+12, r23	; 0x0c
	ifout->txbytes += bytes;
    4680:	4d a1       	ldd	r20, Y+37	; 0x25
    4682:	5e a1       	ldd	r21, Y+38	; 0x26
    4684:	6f a1       	ldd	r22, Y+39	; 0x27
    4686:	78 a5       	ldd	r23, Y+40	; 0x28
    4688:	40 0f       	add	r20, r16
    468a:	51 1f       	adc	r21, r17
    468c:	61 1d       	adc	r22, r1
    468e:	71 1d       	adc	r23, r1
    4690:	4d a3       	std	Y+37, r20	; 0x25
    4692:	5e a3       	std	Y+38, r21	; 0x26
    4694:	6f a3       	std	Y+39, r22	; 0x27
    4696:	78 a7       	std	Y+40, r23	; 0x28
	return CSP_ERR_NONE;
    4698:	0d c0       	rjmp	.+26     	; 0x46b4 <csp_send_direct+0x1ec>

tx_err:
	ifout->tx_error++;
    469a:	89 89       	ldd	r24, Y+17	; 0x11
    469c:	9a 89       	ldd	r25, Y+18	; 0x12
    469e:	ab 89       	ldd	r26, Y+19	; 0x13
    46a0:	bc 89       	ldd	r27, Y+20	; 0x14
    46a2:	01 96       	adiw	r24, 0x01	; 1
    46a4:	a1 1d       	adc	r26, r1
    46a6:	b1 1d       	adc	r27, r1
    46a8:	89 8b       	std	Y+17, r24	; 0x11
    46aa:	9a 8b       	std	Y+18, r25	; 0x12
    46ac:	ab 8b       	std	Y+19, r26	; 0x13
    46ae:	bc 8b       	std	Y+20, r27	; 0x14
err:
	return CSP_ERR_TX;
    46b0:	86 ef       	ldi	r24, 0xF6	; 246
    46b2:	9f ef       	ldi	r25, 0xFF	; 255

}
    46b4:	df 91       	pop	r29
    46b6:	cf 91       	pop	r28
    46b8:	1f 91       	pop	r17
    46ba:	0f 91       	pop	r16
    46bc:	ff 90       	pop	r15
    46be:	ef 90       	pop	r14
    46c0:	df 90       	pop	r13
    46c2:	cf 90       	pop	r12
    46c4:	bf 90       	pop	r11
    46c6:	af 90       	pop	r10
    46c8:	9f 90       	pop	r9
    46ca:	8f 90       	pop	r8
    46cc:	7f 90       	pop	r7
    46ce:	6f 90       	pop	r6
    46d0:	5f 90       	pop	r5
    46d2:	4f 90       	pop	r4
    46d4:	08 95       	ret

000046d6 <csp_send>:

int csp_send(csp_conn_t * conn, csp_packet_t * packet, uint32_t timeout) {
    46d6:	8f 92       	push	r8
    46d8:	9f 92       	push	r9
    46da:	af 92       	push	r10
    46dc:	bf 92       	push	r11
    46de:	cf 92       	push	r12
    46e0:	df 92       	push	r13
    46e2:	ef 92       	push	r14
    46e4:	ff 92       	push	r15
    46e6:	0f 93       	push	r16
    46e8:	1f 93       	push	r17
    46ea:	cf 93       	push	r28
    46ec:	df 93       	push	r29
    46ee:	ec 01       	movw	r28, r24
    46f0:	6b 01       	movw	r12, r22
    46f2:	49 01       	movw	r8, r18
    46f4:	5a 01       	movw	r10, r20

	int ret;

	if ((conn == NULL) || (packet == NULL) || (conn->state != CONN_OPEN)) {
    46f6:	89 2b       	or	r24, r25
    46f8:	29 f0       	breq	.+10     	; 0x4704 <csp_send+0x2e>
    46fa:	67 2b       	or	r22, r23
    46fc:	19 f0       	breq	.+6      	; 0x4704 <csp_send+0x2e>
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
    4700:	81 30       	cpi	r24, 0x01	; 1
    4702:	61 f0       	breq	.+24     	; 0x471c <csp_send+0x46>
		csp_log_error("Invalid call to csp_send");
    4704:	8b e9       	ldi	r24, 0x9B	; 155
    4706:	99 e0       	ldi	r25, 0x09	; 9
    4708:	9f 93       	push	r25
    470a:	8f 93       	push	r24
    470c:	1f 92       	push	r1
    470e:	be db       	rcall	.-2180   	; 0x3e8c <do_csp_debug>
		return 0;
    4710:	0f 90       	pop	r0
    4712:	0f 90       	pop	r0
    4714:	0f 90       	pop	r0
    4716:	80 e0       	ldi	r24, 0x00	; 0
    4718:	90 e0       	ldi	r25, 0x00	; 0
    471a:	1a c0       	rjmp	.+52     	; 0x4750 <csp_send+0x7a>
			return 0;
		}
	}
#endif

	csp_iface_t * ifout = csp_rtable_find_iface(conn->idout.dst);
    471c:	9a 85       	ldd	r25, Y+10	; 0x0a
    471e:	92 95       	swap	r25
    4720:	9f 70       	andi	r25, 0x0F	; 15
    4722:	8b 85       	ldd	r24, Y+11	; 0x0b
    4724:	81 70       	andi	r24, 0x01	; 1
    4726:	82 95       	swap	r24
    4728:	80 7f       	andi	r24, 0xF0	; 240
    472a:	89 2b       	or	r24, r25
    472c:	0e 94 35 30 	call	0x606a	; 0x606a <csp_rtable_find_iface>
    4730:	9c 01       	movw	r18, r24
	ret = csp_send_direct(conn->idout, packet, ifout, timeout);
    4732:	68 85       	ldd	r22, Y+8	; 0x08
    4734:	79 85       	ldd	r23, Y+9	; 0x09
    4736:	8a 85       	ldd	r24, Y+10	; 0x0a
    4738:	9b 85       	ldd	r25, Y+11	; 0x0b
    473a:	85 01       	movw	r16, r10
    473c:	74 01       	movw	r14, r8
    473e:	a6 01       	movw	r20, r12
    4740:	c3 de       	rcall	.-634    	; 0x44c8 <csp_send_direct>

	return (ret == CSP_ERR_NONE) ? 1 : 0;
    4742:	31 e0       	ldi	r19, 0x01	; 1
    4744:	20 e0       	ldi	r18, 0x00	; 0
    4746:	89 2b       	or	r24, r25
    4748:	09 f0       	breq	.+2      	; 0x474c <csp_send+0x76>
    474a:	30 e0       	ldi	r19, 0x00	; 0
    474c:	83 2f       	mov	r24, r19
    474e:	92 2f       	mov	r25, r18

}
    4750:	df 91       	pop	r29
    4752:	cf 91       	pop	r28
    4754:	1f 91       	pop	r17
    4756:	0f 91       	pop	r16
    4758:	ff 90       	pop	r15
    475a:	ef 90       	pop	r14
    475c:	df 90       	pop	r13
    475e:	cf 90       	pop	r12
    4760:	bf 90       	pop	r11
    4762:	af 90       	pop	r10
    4764:	9f 90       	pop	r9
    4766:	8f 90       	pop	r8
    4768:	08 95       	ret

0000476a <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
    476a:	80 32       	cpi	r24, 0x20	; 32
    476c:	91 05       	cpc	r25, r1
    476e:	f0 f4       	brcc	.+60     	; 0x47ac <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    4770:	fc 01       	movw	r30, r24
    4772:	ee 0f       	add	r30, r30
    4774:	ff 1f       	adc	r31, r31
    4776:	e8 0f       	add	r30, r24
    4778:	f9 1f       	adc	r31, r25
    477a:	ea 5d       	subi	r30, 0xDA	; 218
    477c:	fb 4f       	sbci	r31, 0xFB	; 251
    477e:	20 81       	ld	r18, Z
    4780:	21 30       	cpi	r18, 0x01	; 1
    4782:	59 f4       	brne	.+22     	; 0x479a <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    4784:	fc 01       	movw	r30, r24
    4786:	ee 0f       	add	r30, r30
    4788:	ff 1f       	adc	r31, r31
    478a:	8e 0f       	add	r24, r30
    478c:	9f 1f       	adc	r25, r31
    478e:	fc 01       	movw	r30, r24
    4790:	ea 5d       	subi	r30, 0xDA	; 218
    4792:	fb 4f       	sbci	r31, 0xFB	; 251
    4794:	81 81       	ldd	r24, Z+1	; 0x01
    4796:	92 81       	ldd	r25, Z+2	; 0x02
    4798:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    479a:	80 91 86 04 	lds	r24, 0x0486	; 0x800486 <ports+0x60>
    479e:	81 30       	cpi	r24, 0x01	; 1
    47a0:	41 f4       	brne	.+16     	; 0x47b2 <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    47a2:	80 91 87 04 	lds	r24, 0x0487	; 0x800487 <ports+0x61>
    47a6:	90 91 88 04 	lds	r25, 0x0488	; 0x800488 <ports+0x62>
    47aa:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
		return NULL;
    47ac:	80 e0       	ldi	r24, 0x00	; 0
    47ae:	90 e0       	ldi	r25, 0x00	; 0
    47b0:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    47b2:	80 e0       	ldi	r24, 0x00	; 0
    47b4:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    47b6:	08 95       	ret

000047b8 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    47b8:	83 e6       	ldi	r24, 0x63	; 99
    47ba:	e6 e2       	ldi	r30, 0x26	; 38
    47bc:	f4 e0       	ldi	r31, 0x04	; 4
    47be:	df 01       	movw	r26, r30
    47c0:	1d 92       	st	X+, r1
    47c2:	8a 95       	dec	r24
    47c4:	e9 f7       	brne	.-6      	; 0x47c0 <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    47c6:	80 e0       	ldi	r24, 0x00	; 0
    47c8:	90 e0       	ldi	r25, 0x00	; 0
    47ca:	08 95       	ret

000047cc <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    47cc:	cf 93       	push	r28
    47ce:	df 93       	push	r29
    47d0:	9c 01       	movw	r18, r24
	
	if (socket == NULL)
    47d2:	89 2b       	or	r24, r25
    47d4:	99 f0       	breq	.+38     	; 0x47fc <csp_listen+0x30>
    47d6:	cb 01       	movw	r24, r22
    47d8:	e9 01       	movw	r28, r18
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    47da:	62 e0       	ldi	r22, 0x02	; 2
    47dc:	70 e0       	ldi	r23, 0x00	; 0
    47de:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <csp_queue_create>
    47e2:	9f 87       	std	Y+15, r25	; 0x0f
    47e4:	8e 87       	std	Y+14, r24	; 0x0e
	if (socket->socket == NULL)
    47e6:	21 e0       	ldi	r18, 0x01	; 1
    47e8:	30 e0       	ldi	r19, 0x00	; 0
    47ea:	89 2b       	or	r24, r25
    47ec:	11 f0       	breq	.+4      	; 0x47f2 <csp_listen+0x26>
    47ee:	20 e0       	ldi	r18, 0x00	; 0
    47f0:	30 e0       	ldi	r19, 0x00	; 0
    47f2:	88 27       	eor	r24, r24
    47f4:	99 27       	eor	r25, r25
    47f6:	82 1b       	sub	r24, r18
    47f8:	93 0b       	sbc	r25, r19
    47fa:	02 c0       	rjmp	.+4      	; 0x4800 <csp_listen+0x34>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    47fc:	8e ef       	ldi	r24, 0xFE	; 254
    47fe:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    4800:	df 91       	pop	r29
    4802:	cf 91       	pop	r28
    4804:	08 95       	ret

00004806 <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
    4806:	0f 93       	push	r16
    4808:	1f 93       	push	r17
    480a:	cf 93       	push	r28
    480c:	df 93       	push	r29
	
	if (socket == NULL)
    480e:	00 97       	sbiw	r24, 0x00	; 0
    4810:	09 f4       	brne	.+2      	; 0x4814 <csp_bind+0xe>
    4812:	51 c0       	rjmp	.+162    	; 0x48b6 <csp_bind+0xb0>
    4814:	8c 01       	movw	r16, r24
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    4816:	61 32       	cpi	r22, 0x21	; 33
    4818:	88 f0       	brcs	.+34     	; 0x483c <csp_bind+0x36>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports", CSP_ANY);
    481a:	1f 92       	push	r1
    481c:	80 e2       	ldi	r24, 0x20	; 32
    481e:	8f 93       	push	r24
    4820:	8b e5       	ldi	r24, 0x5B	; 91
    4822:	9c e0       	ldi	r25, 0x0C	; 12
    4824:	9f 93       	push	r25
    4826:	8f 93       	push	r24
    4828:	1f 92       	push	r1
    482a:	30 db       	rcall	.-2464   	; 0x3e8c <do_csp_debug>
		return CSP_ERR_INVAL;
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	0f 90       	pop	r0
    4832:	0f 90       	pop	r0
    4834:	0f 90       	pop	r0
    4836:	8e ef       	ldi	r24, 0xFE	; 254
    4838:	9f ef       	ldi	r25, 0xFF	; 255
    483a:	3f c0       	rjmp	.+126    	; 0x48ba <csp_bind+0xb4>
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    483c:	c6 2f       	mov	r28, r22
    483e:	d0 e0       	ldi	r29, 0x00	; 0
    4840:	fe 01       	movw	r30, r28
    4842:	ee 0f       	add	r30, r30
    4844:	ff 1f       	adc	r31, r31
    4846:	ec 0f       	add	r30, r28
    4848:	fd 1f       	adc	r31, r29
    484a:	ea 5d       	subi	r30, 0xDA	; 218
    484c:	fb 4f       	sbci	r31, 0xFB	; 251
    484e:	80 81       	ld	r24, Z
    4850:	88 23       	and	r24, r24
    4852:	81 f0       	breq	.+32     	; 0x4874 <csp_bind+0x6e>
		csp_log_error("Port %d is already in use", port);
    4854:	1f 92       	push	r1
    4856:	6f 93       	push	r22
    4858:	81 e4       	ldi	r24, 0x41	; 65
    485a:	9c e0       	ldi	r25, 0x0C	; 12
    485c:	9f 93       	push	r25
    485e:	8f 93       	push	r24
    4860:	1f 92       	push	r1
    4862:	14 db       	rcall	.-2520   	; 0x3e8c <do_csp_debug>
		return CSP_ERR_USED;
    4864:	0f 90       	pop	r0
    4866:	0f 90       	pop	r0
    4868:	0f 90       	pop	r0
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	8c ef       	ldi	r24, 0xFC	; 252
    4870:	9f ef       	ldi	r25, 0xFF	; 255
    4872:	23 c0       	rjmp	.+70     	; 0x48ba <csp_bind+0xb4>
	}

	csp_log_info("Binding socket %p to port %u", socket, port);
    4874:	1f 92       	push	r1
    4876:	6f 93       	push	r22
    4878:	1f 93       	push	r17
    487a:	0f 93       	push	r16
    487c:	84 e2       	ldi	r24, 0x24	; 36
    487e:	9c e0       	ldi	r25, 0x0C	; 12
    4880:	9f 93       	push	r25
    4882:	8f 93       	push	r24
    4884:	82 e0       	ldi	r24, 0x02	; 2
    4886:	8f 93       	push	r24
    4888:	01 db       	rcall	.-2558   	; 0x3e8c <do_csp_debug>

	/* Save listener */
	ports[port].socket = socket;
    488a:	ce 01       	movw	r24, r28
    488c:	88 0f       	add	r24, r24
    488e:	99 1f       	adc	r25, r25
    4890:	c8 0f       	add	r28, r24
    4892:	d9 1f       	adc	r29, r25
    4894:	ca 5d       	subi	r28, 0xDA	; 218
    4896:	db 4f       	sbci	r29, 0xFB	; 251
    4898:	1a 83       	std	Y+2, r17	; 0x02
    489a:	09 83       	std	Y+1, r16	; 0x01
	ports[port].state = PORT_OPEN;
    489c:	81 e0       	ldi	r24, 0x01	; 1
    489e:	88 83       	st	Y, r24

	return CSP_ERR_NONE;
    48a0:	8d b7       	in	r24, 0x3d	; 61
    48a2:	9e b7       	in	r25, 0x3e	; 62
    48a4:	07 96       	adiw	r24, 0x07	; 7
    48a6:	0f b6       	in	r0, 0x3f	; 63
    48a8:	f8 94       	cli
    48aa:	9e bf       	out	0x3e, r25	; 62
    48ac:	0f be       	out	0x3f, r0	; 63
    48ae:	8d bf       	out	0x3d, r24	; 61
    48b0:	80 e0       	ldi	r24, 0x00	; 0
    48b2:	90 e0       	ldi	r25, 0x00	; 0
    48b4:	02 c0       	rjmp	.+4      	; 0x48ba <csp_bind+0xb4>
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    48b6:	8e ef       	ldi	r24, 0xFE	; 254
    48b8:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    48ba:	df 91       	pop	r29
    48bc:	cf 91       	pop	r28
    48be:	1f 91       	pop	r17
    48c0:	0f 91       	pop	r16
    48c2:	08 95       	ret

000048c4 <csp_qfifo_init>:
int csp_qfifo_init(void) {
	int prio;

	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
    48c4:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <qfifo>
    48c8:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <qfifo+0x1>
    48cc:	89 2b       	or	r24, r25
    48ce:	61 f4       	brne	.+24     	; 0x48e8 <csp_qfifo_init+0x24>
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
    48d0:	64 e0       	ldi	r22, 0x04	; 4
    48d2:	70 e0       	ldi	r23, 0x00	; 0
    48d4:	8a e0       	ldi	r24, 0x0A	; 10
    48d6:	90 e0       	ldi	r25, 0x00	; 0
    48d8:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <csp_queue_create>
    48dc:	90 93 8a 04 	sts	0x048A, r25	; 0x80048a <qfifo+0x1>
    48e0:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <qfifo>
			if (!qfifo[prio])
    48e4:	89 2b       	or	r24, r25
    48e6:	19 f0       	breq	.+6      	; 0x48ee <csp_qfifo_init+0x2a>
	qfifo_events = csp_queue_create(CSP_FIFO_INPUT, sizeof(int));
	if (!qfifo_events)
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;
    48e8:	80 e0       	ldi	r24, 0x00	; 0
    48ea:	90 e0       	ldi	r25, 0x00	; 0
    48ec:	08 95       	ret
	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
			if (!qfifo[prio])
				return CSP_ERR_NOMEM;
    48ee:	8f ef       	ldi	r24, 0xFF	; 255
    48f0:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;

}
    48f2:	08 95       	ret

000048f4 <csp_qfifo_read>:
	if (!found) {
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
    48f4:	2f ef       	ldi	r18, 0xFF	; 255
    48f6:	3f ef       	ldi	r19, 0xFF	; 255
    48f8:	40 e0       	ldi	r20, 0x00	; 0
    48fa:	50 e0       	ldi	r21, 0x00	; 0
    48fc:	bc 01       	movw	r22, r24
    48fe:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <qfifo>
    4902:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <qfifo+0x1>
    4906:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <csp_queue_dequeue>
    490a:	01 97       	sbiw	r24, 0x01	; 1
    490c:	19 f4       	brne	.+6      	; 0x4914 <csp_qfifo_read+0x20>
		return CSP_ERR_TIMEDOUT;
#endif

	return CSP_ERR_NONE;
    490e:	80 e0       	ldi	r24, 0x00	; 0
    4910:	90 e0       	ldi	r25, 0x00	; 0
    4912:	08 95       	ret
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
		return CSP_ERR_TIMEDOUT;
    4914:	8d ef       	ldi	r24, 0xFD	; 253
    4916:	9f ef       	ldi	r25, 0xFF	; 255
#endif

	return CSP_ERR_NONE;

}
    4918:	08 95       	ret

0000491a <csp_qfifo_write>:

void csp_qfifo_write(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    491a:	cf 92       	push	r12
    491c:	df 92       	push	r13
    491e:	ef 92       	push	r14
    4920:	ff 92       	push	r15
    4922:	0f 93       	push	r16
    4924:	1f 93       	push	r17
    4926:	cf 93       	push	r28
    4928:	df 93       	push	r29
    492a:	00 d0       	rcall	.+0      	; 0x492c <csp_qfifo_write+0x12>
    492c:	1f 92       	push	r1
    492e:	cd b7       	in	r28, 0x3d	; 61
    4930:	de b7       	in	r29, 0x3e	; 62
    4932:	7c 01       	movw	r14, r24
    4934:	8b 01       	movw	r16, r22
    4936:	6a 01       	movw	r12, r20

	int result;

	if (packet == NULL) {
    4938:	00 97       	sbiw	r24, 0x00	; 0
    493a:	59 f4       	brne	.+22     	; 0x4952 <csp_qfifo_write+0x38>
		csp_log_warn("csp_new packet called with NULL packet");
    493c:	89 e0       	ldi	r24, 0x09	; 9
    493e:	9d e0       	ldi	r25, 0x0D	; 13
    4940:	9f 93       	push	r25
    4942:	8f 93       	push	r24
    4944:	81 e0       	ldi	r24, 0x01	; 1
    4946:	8f 93       	push	r24
    4948:	a1 da       	rcall	.-2750   	; 0x3e8c <do_csp_debug>
		return;
    494a:	0f 90       	pop	r0
    494c:	0f 90       	pop	r0
    494e:	0f 90       	pop	r0
    4950:	89 c0       	rjmp	.+274    	; 0x4a64 <csp_qfifo_write+0x14a>
	} else if (interface == NULL) {
    4952:	61 15       	cp	r22, r1
    4954:	71 05       	cpc	r23, r1
    4956:	a1 f4       	brne	.+40     	; 0x4980 <csp_qfifo_write+0x66>
		csp_log_warn("csp_new packet called with NULL interface");
    4958:	8f ed       	ldi	r24, 0xDF	; 223
    495a:	9c e0       	ldi	r25, 0x0C	; 12
    495c:	9f 93       	push	r25
    495e:	8f 93       	push	r24
    4960:	81 e0       	ldi	r24, 0x01	; 1
    4962:	8f 93       	push	r24
    4964:	93 da       	rcall	.-2778   	; 0x3e8c <do_csp_debug>
		if (pxTaskWoken == NULL)
    4966:	0f 90       	pop	r0
    4968:	0f 90       	pop	r0
    496a:	0f 90       	pop	r0
    496c:	cd 28       	or	r12, r13
    496e:	21 f4       	brne	.+8      	; 0x4978 <csp_qfifo_write+0x5e>
			csp_buffer_free(packet);
    4970:	c7 01       	movw	r24, r14
    4972:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    4976:	76 c0       	rjmp	.+236    	; 0x4a64 <csp_qfifo_write+0x14a>
		else
			csp_buffer_free_isr(packet);
    4978:	c7 01       	movw	r24, r14
    497a:	0e 94 77 1a 	call	0x34ee	; 0x34ee <csp_buffer_free_isr>
    497e:	72 c0       	rjmp	.+228    	; 0x4a64 <csp_qfifo_write+0x14a>
		return;
	}

	csp_qfifo_t queue_element;
	queue_element.interface = interface;
    4980:	7a 83       	std	Y+2, r23	; 0x02
    4982:	69 83       	std	Y+1, r22	; 0x01
	queue_element.packet = packet;
    4984:	9c 83       	std	Y+4, r25	; 0x04
    4986:	8b 83       	std	Y+3, r24	; 0x03
	int fifo = packet->id.pri;
#else
	int fifo = 0;
#endif

	if (pxTaskWoken == NULL)
    4988:	41 15       	cp	r20, r1
    498a:	51 05       	cpc	r21, r1
    498c:	81 f4       	brne	.+32     	; 0x49ae <csp_qfifo_write+0x94>
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
    498e:	20 e0       	ldi	r18, 0x00	; 0
    4990:	30 e0       	ldi	r19, 0x00	; 0
    4992:	a9 01       	movw	r20, r18
    4994:	be 01       	movw	r22, r28
    4996:	6f 5f       	subi	r22, 0xFF	; 255
    4998:	7f 4f       	sbci	r23, 0xFF	; 255
    499a:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <qfifo>
    499e:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <qfifo+0x1>
    49a2:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <csp_queue_enqueue>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    49a6:	01 97       	sbiw	r24, 0x01	; 1
    49a8:	09 f0       	breq	.+2      	; 0x49ac <csp_qfifo_write+0x92>
    49aa:	43 c0       	rjmp	.+134    	; 0x4a32 <csp_qfifo_write+0x118>
    49ac:	0b c0       	rjmp	.+22     	; 0x49c4 <csp_qfifo_write+0xaa>
#endif

	if (pxTaskWoken == NULL)
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
	else
		result = csp_queue_enqueue_isr(qfifo[fifo], &queue_element, pxTaskWoken);
    49ae:	be 01       	movw	r22, r28
    49b0:	6f 5f       	subi	r22, 0xFF	; 255
    49b2:	7f 4f       	sbci	r23, 0xFF	; 255
    49b4:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <qfifo>
    49b8:	90 91 8a 04 	lds	r25, 0x048A	; 0x80048a <qfifo+0x1>
    49bc:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <csp_queue_enqueue_isr>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    49c0:	01 97       	sbiw	r24, 0x01	; 1
    49c2:	e9 f4       	brne	.+58     	; 0x49fe <csp_qfifo_write+0xe4>
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
	} else {
		interface->rx++;
    49c4:	f8 01       	movw	r30, r16
    49c6:	85 85       	ldd	r24, Z+13	; 0x0d
    49c8:	96 85       	ldd	r25, Z+14	; 0x0e
    49ca:	a7 85       	ldd	r26, Z+15	; 0x0f
    49cc:	b0 89       	ldd	r27, Z+16	; 0x10
    49ce:	01 96       	adiw	r24, 0x01	; 1
    49d0:	a1 1d       	adc	r26, r1
    49d2:	b1 1d       	adc	r27, r1
    49d4:	85 87       	std	Z+13, r24	; 0x0d
    49d6:	96 87       	std	Z+14, r25	; 0x0e
    49d8:	a7 87       	std	Z+15, r26	; 0x0f
    49da:	b0 8b       	std	Z+16, r27	; 0x10
		interface->rxbytes += packet->length;
    49dc:	f7 01       	movw	r30, r14
    49de:	20 85       	ldd	r18, Z+8	; 0x08
    49e0:	31 85       	ldd	r19, Z+9	; 0x09
    49e2:	f8 01       	movw	r30, r16
    49e4:	81 a5       	ldd	r24, Z+41	; 0x29
    49e6:	92 a5       	ldd	r25, Z+42	; 0x2a
    49e8:	a3 a5       	ldd	r26, Z+43	; 0x2b
    49ea:	b4 a5       	ldd	r27, Z+44	; 0x2c
    49ec:	82 0f       	add	r24, r18
    49ee:	93 1f       	adc	r25, r19
    49f0:	a1 1d       	adc	r26, r1
    49f2:	b1 1d       	adc	r27, r1
    49f4:	81 a7       	std	Z+41, r24	; 0x29
    49f6:	92 a7       	std	Z+42, r25	; 0x2a
    49f8:	a3 a7       	std	Z+43, r26	; 0x2b
    49fa:	b4 a7       	std	Z+44, r27	; 0x2c
    49fc:	33 c0       	rjmp	.+102    	; 0x4a64 <csp_qfifo_write+0x14a>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    49fe:	8b ea       	ldi	r24, 0xAB	; 171
    4a00:	9c e0       	ldi	r25, 0x0C	; 12
    4a02:	9f 93       	push	r25
    4a04:	8f 93       	push	r24
    4a06:	81 e0       	ldi	r24, 0x01	; 1
    4a08:	8f 93       	push	r24
    4a0a:	40 da       	rcall	.-2944   	; 0x3e8c <do_csp_debug>
		interface->drop++;
    4a0c:	f8 01       	movw	r30, r16
    4a0e:	81 8d       	ldd	r24, Z+25	; 0x19
    4a10:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a12:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4a14:	b4 8d       	ldd	r27, Z+28	; 0x1c
    4a16:	01 96       	adiw	r24, 0x01	; 1
    4a18:	a1 1d       	adc	r26, r1
    4a1a:	b1 1d       	adc	r27, r1
    4a1c:	81 8f       	std	Z+25, r24	; 0x19
    4a1e:	92 8f       	std	Z+26, r25	; 0x1a
    4a20:	a3 8f       	std	Z+27, r26	; 0x1b
    4a22:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
		else
			csp_buffer_free_isr(packet);
    4a24:	c7 01       	movw	r24, r14
    4a26:	0e 94 77 1a 	call	0x34ee	; 0x34ee <csp_buffer_free_isr>
    4a2a:	0f 90       	pop	r0
    4a2c:	0f 90       	pop	r0
    4a2e:	0f 90       	pop	r0
    4a30:	19 c0       	rjmp	.+50     	; 0x4a64 <csp_qfifo_write+0x14a>
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    4a32:	8b ea       	ldi	r24, 0xAB	; 171
    4a34:	9c e0       	ldi	r25, 0x0C	; 12
    4a36:	9f 93       	push	r25
    4a38:	8f 93       	push	r24
    4a3a:	81 e0       	ldi	r24, 0x01	; 1
    4a3c:	8f 93       	push	r24
    4a3e:	26 da       	rcall	.-2996   	; 0x3e8c <do_csp_debug>
		interface->drop++;
    4a40:	f8 01       	movw	r30, r16
    4a42:	81 8d       	ldd	r24, Z+25	; 0x19
    4a44:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a46:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4a48:	b4 8d       	ldd	r27, Z+28	; 0x1c
    4a4a:	01 96       	adiw	r24, 0x01	; 1
    4a4c:	a1 1d       	adc	r26, r1
    4a4e:	b1 1d       	adc	r27, r1
    4a50:	81 8f       	std	Z+25, r24	; 0x19
    4a52:	92 8f       	std	Z+26, r25	; 0x1a
    4a54:	a3 8f       	std	Z+27, r26	; 0x1b
    4a56:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
			csp_buffer_free(packet);
    4a58:	c7 01       	movw	r24, r14
    4a5a:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    4a5e:	0f 90       	pop	r0
    4a60:	0f 90       	pop	r0
    4a62:	0f 90       	pop	r0
	} else {
		interface->rx++;
		interface->rxbytes += packet->length;
	}

}
    4a64:	0f 90       	pop	r0
    4a66:	0f 90       	pop	r0
    4a68:	0f 90       	pop	r0
    4a6a:	0f 90       	pop	r0
    4a6c:	df 91       	pop	r29
    4a6e:	cf 91       	pop	r28
    4a70:	1f 91       	pop	r17
    4a72:	0f 91       	pop	r16
    4a74:	ff 90       	pop	r15
    4a76:	ef 90       	pop	r14
    4a78:	df 90       	pop	r13
    4a7a:	cf 90       	pop	r12
    4a7c:	08 95       	ret

00004a7e <csp_route_security_check>:
 * @param security_opts either socket_opts or conn_opts
 * @param interface pointer to incoming interface
 * @param packet pointer to packet
 * @return -1 Missing feature, -2 XTEA error, -3 CRC error, -4 HMAC error, 0 = OK.
 */
static int csp_route_security_check(uint32_t security_opts, csp_iface_t * interface, csp_packet_t * packet) {
    4a7e:	0f 93       	push	r16
    4a80:	1f 93       	push	r17
    4a82:	cf 93       	push	r28
    4a84:	df 93       	push	r29
    4a86:	8a 01       	movw	r16, r20
    4a88:	e9 01       	movw	r28, r18
		return CSP_ERR_XTEA;
	}
#endif

	/* CRC32 verified packet */
	if (packet->id.flags & CSP_FCRC32) {
    4a8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a8c:	80 ff       	sbrs	r24, 0
    4a8e:	2f c0       	rjmp	.+94     	; 0x4aee <csp_route_security_check+0x70>
#ifdef CSP_USE_CRC32
		if (packet->length < 4)
    4a90:	88 85       	ldd	r24, Y+8	; 0x08
    4a92:	99 85       	ldd	r25, Y+9	; 0x09
    4a94:	84 30       	cpi	r24, 0x04	; 4
    4a96:	91 05       	cpc	r25, r1
    4a98:	68 f4       	brcc	.+26     	; 0x4ab4 <csp_route_security_check+0x36>
			csp_log_error("Too short packet for CRC32, %u", packet->length);
    4a9a:	9f 93       	push	r25
    4a9c:	8f 93       	push	r24
    4a9e:	8f ea       	ldi	r24, 0xAF	; 175
    4aa0:	9d e0       	ldi	r25, 0x0D	; 13
    4aa2:	9f 93       	push	r25
    4aa4:	8f 93       	push	r24
    4aa6:	1f 92       	push	r1
    4aa8:	f1 d9       	rcall	.-3102   	; 0x3e8c <do_csp_debug>
    4aaa:	0f 90       	pop	r0
    4aac:	0f 90       	pop	r0
    4aae:	0f 90       	pop	r0
    4ab0:	0f 90       	pop	r0
    4ab2:	0f 90       	pop	r0
		/* Verify CRC32 (does not include header for backwards compatability with csp1.x) */
		if (csp_crc32_verify(packet, false) != 0) {
    4ab4:	60 e0       	ldi	r22, 0x00	; 0
    4ab6:	ce 01       	movw	r24, r28
    4ab8:	8d d9       	rcall	.-3302   	; 0x3dd4 <csp_crc32_verify>
    4aba:	00 97       	sbiw	r24, 0x00	; 0
    4abc:	49 f1       	breq	.+82     	; 0x4b10 <csp_route_security_check+0x92>
			/* Checksum failed */
			csp_log_error("CRC32 verification error! Discarding packet");
    4abe:	83 e8       	ldi	r24, 0x83	; 131
    4ac0:	9d e0       	ldi	r25, 0x0D	; 13
    4ac2:	9f 93       	push	r25
    4ac4:	8f 93       	push	r24
    4ac6:	1f 92       	push	r1
    4ac8:	e1 d9       	rcall	.-3134   	; 0x3e8c <do_csp_debug>
			interface->rx_error++;
    4aca:	f8 01       	movw	r30, r16
    4acc:	85 89       	ldd	r24, Z+21	; 0x15
    4ace:	96 89       	ldd	r25, Z+22	; 0x16
    4ad0:	a7 89       	ldd	r26, Z+23	; 0x17
    4ad2:	b0 8d       	ldd	r27, Z+24	; 0x18
    4ad4:	01 96       	adiw	r24, 0x01	; 1
    4ad6:	a1 1d       	adc	r26, r1
    4ad8:	b1 1d       	adc	r27, r1
    4ada:	85 8b       	std	Z+21, r24	; 0x15
    4adc:	96 8b       	std	Z+22, r25	; 0x16
    4ade:	a7 8b       	std	Z+23, r26	; 0x17
    4ae0:	b0 8f       	std	Z+24, r27	; 0x18
			return CSP_ERR_CRC32;
    4ae2:	0f 90       	pop	r0
    4ae4:	0f 90       	pop	r0
    4ae6:	0f 90       	pop	r0
    4ae8:	8a e9       	ldi	r24, 0x9A	; 154
    4aea:	9f ef       	ldi	r25, 0xFF	; 255
    4aec:	11 c0       	rjmp	.+34     	; 0x4b10 <csp_route_security_check+0x92>
		}
	} else if (security_opts & CSP_SO_CRC32REQ) {
    4aee:	66 ff       	sbrs	r22, 6
    4af0:	0d c0       	rjmp	.+26     	; 0x4b0c <csp_route_security_check+0x8e>
		csp_log_warn("Received packet without CRC32. Accepting packet");
    4af2:	83 e5       	ldi	r24, 0x53	; 83
    4af4:	9d e0       	ldi	r25, 0x0D	; 13
    4af6:	9f 93       	push	r25
    4af8:	8f 93       	push	r24
    4afa:	81 e0       	ldi	r24, 0x01	; 1
    4afc:	8f 93       	push	r24
    4afe:	c6 d9       	rcall	.-3188   	; 0x3e8c <do_csp_debug>
    4b00:	0f 90       	pop	r0
    4b02:	0f 90       	pop	r0
    4b04:	0f 90       	pop	r0
			return CSP_ERR_INVAL;
		}
	}
#endif

	return CSP_ERR_NONE;
    4b06:	80 e0       	ldi	r24, 0x00	; 0
    4b08:	90 e0       	ldi	r25, 0x00	; 0
    4b0a:	02 c0       	rjmp	.+4      	; 0x4b10 <csp_route_security_check+0x92>
    4b0c:	80 e0       	ldi	r24, 0x00	; 0
    4b0e:	90 e0       	ldi	r25, 0x00	; 0

}
    4b10:	df 91       	pop	r29
    4b12:	cf 91       	pop	r28
    4b14:	1f 91       	pop	r17
    4b16:	0f 91       	pop	r16
    4b18:	08 95       	ret

00004b1a <csp_route_work>:

int csp_route_work(uint32_t timeout) {
    4b1a:	cf 92       	push	r12
    4b1c:	df 92       	push	r13
    4b1e:	ef 92       	push	r14
    4b20:	ff 92       	push	r15
    4b22:	0f 93       	push	r16
    4b24:	1f 93       	push	r17
    4b26:	cf 93       	push	r28
    4b28:	df 93       	push	r29
    4b2a:	00 d0       	rcall	.+0      	; 0x4b2c <csp_route_work+0x12>
    4b2c:	00 d0       	rcall	.+0      	; 0x4b2e <csp_route_work+0x14>
    4b2e:	cd b7       	in	r28, 0x3d	; 61
    4b30:	de b7       	in	r29, 0x3e	; 62
	/* Check connection timeouts (currently only for RDP) */
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
    4b32:	ce 01       	movw	r24, r28
    4b34:	01 96       	adiw	r24, 0x01	; 1
    4b36:	de de       	rcall	.-580    	; 0x48f4 <csp_qfifo_read>
    4b38:	6c 01       	movw	r12, r24
    4b3a:	89 2b       	or	r24, r25
    4b3c:	09 f0       	breq	.+2      	; 0x4b40 <csp_route_work+0x26>
    4b3e:	9c c1       	rjmp	.+824    	; 0x4e78 <csp_route_work+0x35e>
		return -1;

	packet = input.packet;
    4b40:	eb 81       	ldd	r30, Y+3	; 0x03
    4b42:	fc 81       	ldd	r31, Y+4	; 0x04
    4b44:	fe 83       	std	Y+6, r31	; 0x06
    4b46:	ed 83       	std	Y+5, r30	; 0x05

	csp_log_packet("INP: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %"PRIu16" VIA: %s",
    4b48:	a9 81       	ldd	r26, Y+1	; 0x01
    4b4a:	ba 81       	ldd	r27, Y+2	; 0x02
    4b4c:	11 96       	adiw	r26, 0x01	; 1
    4b4e:	8c 91       	ld	r24, X
    4b50:	11 97       	sbiw	r26, 0x01	; 1
    4b52:	8f 93       	push	r24
    4b54:	8c 91       	ld	r24, X
    4b56:	8f 93       	push	r24
    4b58:	81 85       	ldd	r24, Z+9	; 0x09
    4b5a:	8f 93       	push	r24
    4b5c:	80 85       	ldd	r24, Z+8	; 0x08
    4b5e:	8f 93       	push	r24
    4b60:	82 85       	ldd	r24, Z+10	; 0x0a
    4b62:	1f 92       	push	r1
    4b64:	8f 93       	push	r24
    4b66:	85 85       	ldd	r24, Z+13	; 0x0d
    4b68:	82 95       	swap	r24
    4b6a:	86 95       	lsr	r24
    4b6c:	86 95       	lsr	r24
    4b6e:	83 70       	andi	r24, 0x03	; 3
    4b70:	1f 92       	push	r1
    4b72:	8f 93       	push	r24
    4b74:	83 85       	ldd	r24, Z+11	; 0x0b
    4b76:	8f 73       	andi	r24, 0x3F	; 63
    4b78:	1f 92       	push	r1
    4b7a:	8f 93       	push	r24
    4b7c:	83 85       	ldd	r24, Z+11	; 0x0b
    4b7e:	98 2f       	mov	r25, r24
    4b80:	92 95       	swap	r25
    4b82:	96 95       	lsr	r25
    4b84:	96 95       	lsr	r25
    4b86:	93 70       	andi	r25, 0x03	; 3
    4b88:	84 85       	ldd	r24, Z+12	; 0x0c
    4b8a:	8f 70       	andi	r24, 0x0F	; 15
    4b8c:	88 0f       	add	r24, r24
    4b8e:	88 0f       	add	r24, r24
    4b90:	89 2b       	or	r24, r25
    4b92:	1f 92       	push	r1
    4b94:	8f 93       	push	r24
    4b96:	84 85       	ldd	r24, Z+12	; 0x0c
    4b98:	98 2f       	mov	r25, r24
    4b9a:	92 95       	swap	r25
    4b9c:	9f 70       	andi	r25, 0x0F	; 15
    4b9e:	85 85       	ldd	r24, Z+13	; 0x0d
    4ba0:	81 70       	andi	r24, 0x01	; 1
    4ba2:	82 95       	swap	r24
    4ba4:	80 7f       	andi	r24, 0xF0	; 240
    4ba6:	89 2b       	or	r24, r25
    4ba8:	1f 92       	push	r1
    4baa:	8f 93       	push	r24
    4bac:	85 85       	ldd	r24, Z+13	; 0x0d
    4bae:	86 95       	lsr	r24
    4bb0:	8f 71       	andi	r24, 0x1F	; 31
    4bb2:	1f 92       	push	r1
    4bb4:	8f 93       	push	r24
    4bb6:	84 e2       	ldi	r24, 0x24	; 36
    4bb8:	9f e0       	ldi	r25, 0x0F	; 15
    4bba:	9f 93       	push	r25
    4bbc:	8f 93       	push	r24
    4bbe:	84 e0       	ldi	r24, 0x04	; 4
    4bc0:	8f 93       	push	r24
    4bc2:	64 d9       	rcall	.-3384   	; 0x3e8c <do_csp_debug>
		return 0;
	}
#endif

	/* If the message is not to me, route the message to the correct interface */
	if ((packet->id.dst != csp_get_address()) && (packet->id.dst != CSP_BROADCAST_ADDR)) {
    4bc4:	ed 81       	ldd	r30, Y+5	; 0x05
    4bc6:	fe 81       	ldd	r31, Y+6	; 0x06
    4bc8:	04 85       	ldd	r16, Z+12	; 0x0c
    4bca:	80 2f       	mov	r24, r16
    4bcc:	82 95       	swap	r24
    4bce:	8f 70       	andi	r24, 0x0F	; 15
    4bd0:	05 85       	ldd	r16, Z+13	; 0x0d
    4bd2:	01 70       	andi	r16, 0x01	; 1
    4bd4:	02 95       	swap	r16
    4bd6:	00 7f       	andi	r16, 0xF0	; 240
    4bd8:	08 2b       	or	r16, r24
    4bda:	10 e0       	ldi	r17, 0x00	; 0
    4bdc:	80 db       	rcall	.-2304   	; 0x42de <csp_get_address>
    4bde:	90 e0       	ldi	r25, 0x00	; 0
    4be0:	0f b6       	in	r0, 0x3f	; 63
    4be2:	f8 94       	cli
    4be4:	de bf       	out	0x3e, r29	; 62
    4be6:	0f be       	out	0x3f, r0	; 63
    4be8:	cd bf       	out	0x3d, r28	; 61
    4bea:	08 17       	cp	r16, r24
    4bec:	19 07       	cpc	r17, r25
    4bee:	09 f4       	brne	.+2      	; 0x4bf2 <csp_route_work+0xd8>
    4bf0:	3f c0       	rjmp	.+126    	; 0x4c70 <csp_route_work+0x156>
    4bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    4bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    4bf6:	84 85       	ldd	r24, Z+12	; 0x0c
    4bf8:	98 2f       	mov	r25, r24
    4bfa:	92 95       	swap	r25
    4bfc:	9f 70       	andi	r25, 0x0F	; 15
    4bfe:	85 85       	ldd	r24, Z+13	; 0x0d
    4c00:	81 70       	andi	r24, 0x01	; 1
    4c02:	82 95       	swap	r24
    4c04:	80 7f       	andi	r24, 0xF0	; 240
    4c06:	89 2b       	or	r24, r25
    4c08:	8f 31       	cpi	r24, 0x1F	; 31
    4c0a:	91 f1       	breq	.+100    	; 0x4c70 <csp_route_work+0x156>

		/* Find the destination interface */
		csp_iface_t * dstif = csp_rtable_find_iface(packet->id.dst);
    4c0c:	0e 94 35 30 	call	0x606a	; 0x606a <csp_rtable_find_iface>
    4c10:	fc 01       	movw	r30, r24

		/* If the message resolves to the input interface, don't loop it back out */
		if ((dstif == NULL) || ((dstif == input.interface) && (input.interface->split_horizon_off == 0))) {
    4c12:	00 97       	sbiw	r24, 0x00	; 0
    4c14:	41 f0       	breq	.+16     	; 0x4c26 <csp_route_work+0x10c>
    4c16:	29 81       	ldd	r18, Y+1	; 0x01
    4c18:	3a 81       	ldd	r19, Y+2	; 0x02
    4c1a:	82 17       	cp	r24, r18
    4c1c:	93 07       	cpc	r25, r19
    4c1e:	41 f4       	brne	.+16     	; 0x4c30 <csp_route_work+0x116>
    4c20:	20 85       	ldd	r18, Z+8	; 0x08
    4c22:	21 11       	cpse	r18, r1
    4c24:	05 c0       	rjmp	.+10     	; 0x4c30 <csp_route_work+0x116>
			csp_buffer_free(packet);
    4c26:	8d 81       	ldd	r24, Y+5	; 0x05
    4c28:	9e 81       	ldd	r25, Y+6	; 0x06
    4c2a:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4c2e:	63 c1       	rjmp	.+710    	; 0x4ef6 <csp_route_work+0x3dc>
		}

		/* Otherwise, actually send the message */
		if (csp_send_direct(packet->id, packet, dstif, 0) != CSP_ERR_NONE) {
    4c30:	4d 81       	ldd	r20, Y+5	; 0x05
    4c32:	5e 81       	ldd	r21, Y+6	; 0x06
    4c34:	da 01       	movw	r26, r20
    4c36:	1a 96       	adiw	r26, 0x0a	; 10
    4c38:	6d 91       	ld	r22, X+
    4c3a:	7d 91       	ld	r23, X+
    4c3c:	8d 91       	ld	r24, X+
    4c3e:	9c 91       	ld	r25, X
    4c40:	1d 97       	sbiw	r26, 0x0d	; 13
    4c42:	e1 2c       	mov	r14, r1
    4c44:	f1 2c       	mov	r15, r1
    4c46:	87 01       	movw	r16, r14
    4c48:	9f 01       	movw	r18, r30
    4c4a:	3e dc       	rcall	.-1924   	; 0x44c8 <csp_send_direct>
    4c4c:	00 97       	sbiw	r24, 0x00	; 0
    4c4e:	09 f4       	brne	.+2      	; 0x4c52 <csp_route_work+0x138>
    4c50:	17 c1       	rjmp	.+558    	; 0x4e80 <csp_route_work+0x366>
			csp_log_warn("Router failed to send");
    4c52:	8e e0       	ldi	r24, 0x0E	; 14
    4c54:	9f e0       	ldi	r25, 0x0F	; 15
    4c56:	9f 93       	push	r25
    4c58:	8f 93       	push	r24
    4c5a:	81 e0       	ldi	r24, 0x01	; 1
    4c5c:	8f 93       	push	r24
    4c5e:	16 d9       	rcall	.-3540   	; 0x3e8c <do_csp_debug>
			csp_buffer_free(packet);
    4c60:	8d 81       	ldd	r24, Y+5	; 0x05
    4c62:	9e 81       	ldd	r25, Y+6	; 0x06
    4c64:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    4c68:	0f 90       	pop	r0
    4c6a:	0f 90       	pop	r0
    4c6c:	0f 90       	pop	r0
    4c6e:	43 c1       	rjmp	.+646    	; 0x4ef6 <csp_route_work+0x3dc>
		/* Next message, please */
		return 0;
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
    4c70:	ed 81       	ldd	r30, Y+5	; 0x05
    4c72:	fe 81       	ldd	r31, Y+6	; 0x06
    4c74:	09 81       	ldd	r16, Y+1	; 0x01
    4c76:	1a 81       	ldd	r17, Y+2	; 0x02
 */
static int csp_route_check_options(csp_iface_t *interface, csp_packet_t *packet)
{
#ifndef CSP_USE_XTEA
	/* Drop XTEA packets */
	if (packet->id.flags & CSP_FXTEA) {
    4c78:	82 85       	ldd	r24, Z+10	; 0x0a
    4c7a:	82 ff       	sbrs	r24, 2
    4c7c:	16 c0       	rjmp	.+44     	; 0x4caa <csp_route_work+0x190>
		csp_log_error("Received XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4c7e:	87 e7       	ldi	r24, 0x77	; 119
    4c80:	9e e0       	ldi	r25, 0x0E	; 14
    4c82:	9f 93       	push	r25
    4c84:	8f 93       	push	r24
    4c86:	1f 92       	push	r1
    4c88:	01 d9       	rcall	.-3582   	; 0x3e8c <do_csp_debug>
		interface->autherr++;
    4c8a:	f8 01       	movw	r30, r16
    4c8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    4c8e:	96 8d       	ldd	r25, Z+30	; 0x1e
    4c90:	a7 8d       	ldd	r26, Z+31	; 0x1f
    4c92:	b0 a1       	ldd	r27, Z+32	; 0x20
    4c94:	01 96       	adiw	r24, 0x01	; 1
    4c96:	a1 1d       	adc	r26, r1
    4c98:	b1 1d       	adc	r27, r1
    4c9a:	85 8f       	std	Z+29, r24	; 0x1d
    4c9c:	96 8f       	std	Z+30, r25	; 0x1e
    4c9e:	a7 8f       	std	Z+31, r26	; 0x1f
    4ca0:	b0 a3       	std	Z+32, r27	; 0x20
    4ca2:	0f 90       	pop	r0
    4ca4:	0f 90       	pop	r0
    4ca6:	0f 90       	pop	r0
    4ca8:	ed c0       	rjmp	.+474    	; 0x4e84 <csp_route_work+0x36a>
	}
#endif

#ifndef CSP_USE_HMAC
	/* Drop HMAC packets */
	if (packet->id.flags & CSP_FHMAC) {
    4caa:	83 ff       	sbrs	r24, 3
		csp_log_error("Received packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    4cac:	16 c0       	rjmp	.+44     	; 0x4cda <csp_route_work+0x1c0>
    4cae:	8f e1       	ldi	r24, 0x1F	; 31
    4cb0:	9e e0       	ldi	r25, 0x0E	; 14
    4cb2:	9f 93       	push	r25
    4cb4:	8f 93       	push	r24
    4cb6:	1f 92       	push	r1
    4cb8:	e9 d8       	rcall	.-3630   	; 0x3e8c <do_csp_debug>
		interface->autherr++;
    4cba:	f8 01       	movw	r30, r16
    4cbc:	85 8d       	ldd	r24, Z+29	; 0x1d
    4cbe:	96 8d       	ldd	r25, Z+30	; 0x1e
    4cc0:	a7 8d       	ldd	r26, Z+31	; 0x1f
    4cc2:	b0 a1       	ldd	r27, Z+32	; 0x20
    4cc4:	01 96       	adiw	r24, 0x01	; 1
    4cc6:	a1 1d       	adc	r26, r1
    4cc8:	b1 1d       	adc	r27, r1
    4cca:	85 8f       	std	Z+29, r24	; 0x1d
    4ccc:	96 8f       	std	Z+30, r25	; 0x1e
    4cce:	a7 8f       	std	Z+31, r26	; 0x1f
    4cd0:	b0 a3       	std	Z+32, r27	; 0x20
    4cd2:	0f 90       	pop	r0
    4cd4:	0f 90       	pop	r0
    4cd6:	0f 90       	pop	r0
    4cd8:	d5 c0       	rjmp	.+426    	; 0x4e84 <csp_route_work+0x36a>
	}
#endif

#ifndef CSP_USE_RDP
	/* Drop RDP packets */
	if (packet->id.flags & CSP_FRDP) {
    4cda:	81 ff       	sbrs	r24, 1
		csp_log_error("Received RDP packet, but CSP was compiled without RDP support. Discarding packet");
    4cdc:	d8 c0       	rjmp	.+432    	; 0x4e8e <csp_route_work+0x374>
    4cde:	8e ec       	ldi	r24, 0xCE	; 206
    4ce0:	9d e0       	ldi	r25, 0x0D	; 13
    4ce2:	9f 93       	push	r25
    4ce4:	8f 93       	push	r24
    4ce6:	1f 92       	push	r1
    4ce8:	d1 d8       	rcall	.-3678   	; 0x3e8c <do_csp_debug>
		interface->rx_error++;
    4cea:	f8 01       	movw	r30, r16
    4cec:	85 89       	ldd	r24, Z+21	; 0x15
    4cee:	96 89       	ldd	r25, Z+22	; 0x16
    4cf0:	a7 89       	ldd	r26, Z+23	; 0x17
    4cf2:	b0 8d       	ldd	r27, Z+24	; 0x18
    4cf4:	01 96       	adiw	r24, 0x01	; 1
    4cf6:	a1 1d       	adc	r26, r1
    4cf8:	b1 1d       	adc	r27, r1
    4cfa:	85 8b       	std	Z+21, r24	; 0x15
    4cfc:	96 8b       	std	Z+22, r25	; 0x16
    4cfe:	a7 8b       	std	Z+23, r26	; 0x17
    4d00:	b0 8f       	std	Z+24, r27	; 0x18
    4d02:	0f 90       	pop	r0
    4d04:	0f 90       	pop	r0
    4d06:	0f 90       	pop	r0
    4d08:	bd c0       	rjmp	.+378    	; 0x4e84 <csp_route_work+0x36a>

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    4d0a:	d8 01       	movw	r26, r16
    4d0c:	54 96       	adiw	r26, 0x14	; 20
    4d0e:	6d 91       	ld	r22, X+
    4d10:	7d 91       	ld	r23, X+
    4d12:	8d 91       	ld	r24, X+
    4d14:	9c 91       	ld	r25, X
    4d16:	57 97       	sbiw	r26, 0x17	; 23
    4d18:	70 ff       	sbrs	r23, 0
    4d1a:	cb c0       	rjmp	.+406    	; 0x4eb2 <csp_route_work+0x398>
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    4d1c:	2d 81       	ldd	r18, Y+5	; 0x05
    4d1e:	3e 81       	ldd	r19, Y+6	; 0x06
    4d20:	49 81       	ldd	r20, Y+1	; 0x01
    4d22:	5a 81       	ldd	r21, Y+2	; 0x02
    4d24:	ac de       	rcall	.-680    	; 0x4a7e <csp_route_security_check>
    4d26:	99 23       	and	r25, r25
    4d28:	2c f4       	brge	.+10     	; 0x4d34 <csp_route_work+0x21a>
			csp_buffer_free(packet);
    4d2a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d2c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d2e:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4d32:	e1 c0       	rjmp	.+450    	; 0x4ef6 <csp_route_work+0x3dc>
		}
		if (csp_queue_enqueue(socket->socket, &packet, 0) != CSP_QUEUE_OK) {
    4d34:	20 e0       	ldi	r18, 0x00	; 0
    4d36:	30 e0       	ldi	r19, 0x00	; 0
    4d38:	a9 01       	movw	r20, r18
    4d3a:	be 01       	movw	r22, r28
    4d3c:	6b 5f       	subi	r22, 0xFB	; 251
    4d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d40:	f8 01       	movw	r30, r16
    4d42:	86 85       	ldd	r24, Z+14	; 0x0e
    4d44:	97 85       	ldd	r25, Z+15	; 0x0f
    4d46:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <csp_queue_enqueue>
    4d4a:	01 97       	sbiw	r24, 0x01	; 1
    4d4c:	09 f4       	brne	.+2      	; 0x4d50 <csp_route_work+0x236>
			csp_log_error("Conn-less socket queue full");
    4d4e:	d3 c0       	rjmp	.+422    	; 0x4ef6 <csp_route_work+0x3dc>
    4d50:	82 ef       	ldi	r24, 0xF2	; 242
    4d52:	9e e0       	ldi	r25, 0x0E	; 14
    4d54:	9f 93       	push	r25
    4d56:	8f 93       	push	r24
    4d58:	1f 92       	push	r1
    4d5a:	98 d8       	rcall	.-3792   	; 0x3e8c <do_csp_debug>
			csp_buffer_free(packet);
    4d5c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d5e:	9e 81       	ldd	r25, Y+6	; 0x06
    4d60:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4d64:	0f 90       	pop	r0
    4d66:	0f 90       	pop	r0
    4d68:	0f 90       	pop	r0
    4d6a:	c5 c0       	rjmp	.+394    	; 0x4ef6 <csp_route_work+0x3dc>
	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {

		/* Reject packet if no matching socket is found */
		if (!socket) {
			csp_buffer_free(packet);
    4d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d6e:	9e 81       	ldd	r25, Y+6	; 0x06
    4d70:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4d74:	c0 c0       	rjmp	.+384    	; 0x4ef6 <csp_route_work+0x3dc>
		}

		/* Run security check on incoming packet */
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    4d76:	2d 81       	ldd	r18, Y+5	; 0x05
    4d78:	3e 81       	ldd	r19, Y+6	; 0x06
    4d7a:	49 81       	ldd	r20, Y+1	; 0x01
    4d7c:	5a 81       	ldd	r21, Y+2	; 0x02
    4d7e:	d8 01       	movw	r26, r16
    4d80:	54 96       	adiw	r26, 0x14	; 20
    4d82:	6d 91       	ld	r22, X+
    4d84:	7d 91       	ld	r23, X+
    4d86:	8d 91       	ld	r24, X+
    4d88:	9c 91       	ld	r25, X
    4d8a:	57 97       	sbiw	r26, 0x17	; 23
    4d8c:	78 de       	rcall	.-784    	; 0x4a7e <csp_route_security_check>
    4d8e:	99 23       	and	r25, r25
    4d90:	2c f4       	brge	.+10     	; 0x4d9c <csp_route_work+0x282>
			csp_buffer_free(packet);
    4d92:	8d 81       	ldd	r24, Y+5	; 0x05
    4d94:	9e 81       	ldd	r25, Y+6	; 0x06
    4d96:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4d9a:	ad c0       	rjmp	.+346    	; 0x4ef6 <csp_route_work+0x3dc>
		}

		/* New incoming connection accepted */
		csp_id_t idout;
		idout.pri   = packet->id.pri;
    4d9c:	ed 81       	ldd	r30, Y+5	; 0x05
    4d9e:	fe 81       	ldd	r31, Y+6	; 0x06
    4da0:	85 85       	ldd	r24, Z+13	; 0x0d
    4da2:	80 7c       	andi	r24, 0xC0	; 192
		idout.src   = csp_get_address();
    4da4:	f8 2e       	mov	r15, r24
    4da6:	9b da       	rcall	.-2762   	; 0x42de <csp_get_address>
    4da8:	8f 71       	andi	r24, 0x1F	; 31
    4daa:	88 0f       	add	r24, r24
    4dac:	f8 2a       	or	r15, r24

		idout.dst   = packet->id.src;
    4dae:	ed 81       	ldd	r30, Y+5	; 0x05
    4db0:	fe 81       	ldd	r31, Y+6	; 0x06
    4db2:	85 85       	ldd	r24, Z+13	; 0x0d
    4db4:	86 95       	lsr	r24
    4db6:	84 fb       	bst	r24, 4
    4db8:	99 27       	eor	r25, r25
    4dba:	90 f9       	bld	r25, 0
    4dbc:	f9 2a       	or	r15, r25
		idout.dport = packet->id.sport;
    4dbe:	53 85       	ldd	r21, Z+11	; 0x0b
    4dc0:	45 2f       	mov	r20, r21
    4dc2:	4f 73       	andi	r20, 0x3F	; 63
    4dc4:	46 95       	lsr	r20
    4dc6:	46 95       	lsr	r20
    4dc8:	82 95       	swap	r24
    4dca:	80 7f       	andi	r24, 0xF0	; 240
    4dcc:	48 2b       	or	r20, r24
		idout.sport = packet->id.dport;
    4dce:	25 2f       	mov	r18, r21
    4dd0:	22 95       	swap	r18
    4dd2:	26 95       	lsr	r18
    4dd4:	26 95       	lsr	r18
    4dd6:	23 70       	andi	r18, 0x03	; 3
    4dd8:	34 85       	ldd	r19, Z+12	; 0x0c
    4dda:	3f 70       	andi	r19, 0x0F	; 15
    4ddc:	33 0f       	add	r19, r19
    4dde:	33 0f       	add	r19, r19
    4de0:	93 2f       	mov	r25, r19
    4de2:	92 2b       	or	r25, r18
    4de4:	35 2f       	mov	r19, r21
    4de6:	32 95       	swap	r19
    4de8:	33 0f       	add	r19, r19
    4dea:	33 0f       	add	r19, r19
    4dec:	30 7c       	andi	r19, 0xC0	; 192
    4dee:	39 2b       	or	r19, r25
		idout.flags = packet->id.flags;
    4df0:	22 85       	ldd	r18, Z+10	; 0x0a

		/* Create connection */
		conn = csp_conn_new(packet->id, idout);
    4df2:	62 85       	ldd	r22, Z+10	; 0x0a
    4df4:	73 85       	ldd	r23, Z+11	; 0x0b
    4df6:	84 85       	ldd	r24, Z+12	; 0x0c
    4df8:	95 85       	ldd	r25, Z+13	; 0x0d
    4dfa:	5f 2d       	mov	r21, r15
    4dfc:	0e 94 a8 1c 	call	0x3950	; 0x3950 <csp_conn_new>

		if (!conn) {
    4e00:	7c 01       	movw	r14, r24
    4e02:	89 2b       	or	r24, r25
			csp_log_error("No more connections available");
    4e04:	71 f4       	brne	.+28     	; 0x4e22 <csp_route_work+0x308>
    4e06:	84 ed       	ldi	r24, 0xD4	; 212
    4e08:	9e e0       	ldi	r25, 0x0E	; 14
    4e0a:	9f 93       	push	r25
    4e0c:	8f 93       	push	r24
    4e0e:	1f 92       	push	r1
    4e10:	3d d8       	rcall	.-3974   	; 0x3e8c <do_csp_debug>
			csp_buffer_free(packet);
    4e12:	8d 81       	ldd	r24, Y+5	; 0x05
    4e14:	9e 81       	ldd	r25, Y+6	; 0x06
    4e16:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4e1a:	0f 90       	pop	r0
    4e1c:	0f 90       	pop	r0
    4e1e:	0f 90       	pop	r0
    4e20:	6a c0       	rjmp	.+212    	; 0x4ef6 <csp_route_work+0x3dc>
		}

		/* Store the socket queue and options */
		conn->socket = socket->socket;
    4e22:	f8 01       	movw	r30, r16
    4e24:	86 85       	ldd	r24, Z+14	; 0x0e
    4e26:	97 85       	ldd	r25, Z+15	; 0x0f
    4e28:	d7 01       	movw	r26, r14
    4e2a:	1f 96       	adiw	r26, 0x0f	; 15
    4e2c:	9c 93       	st	X, r25
    4e2e:	8e 93       	st	-X, r24
    4e30:	1e 97       	sbiw	r26, 0x0e	; 14
		conn->opts = socket->opts;
    4e32:	84 89       	ldd	r24, Z+20	; 0x14
    4e34:	95 89       	ldd	r25, Z+21	; 0x15
    4e36:	a6 89       	ldd	r26, Z+22	; 0x16
    4e38:	b7 89       	ldd	r27, Z+23	; 0x17
    4e3a:	f7 01       	movw	r30, r14
    4e3c:	84 8b       	std	Z+20, r24	; 0x14
    4e3e:	95 8b       	std	Z+21, r25	; 0x15
    4e40:	a6 8b       	std	Z+22, r26	; 0x16
    4e42:	b7 8b       	std	Z+23, r27	; 0x17
    4e44:	13 c0       	rjmp	.+38     	; 0x4e6c <csp_route_work+0x352>

	/* Packet to existing connection */
	} else {

		/* Run security check on incoming packet */
		if (csp_route_security_check(conn->opts, input.interface, packet) < 0) {
    4e46:	2d 81       	ldd	r18, Y+5	; 0x05
    4e48:	3e 81       	ldd	r19, Y+6	; 0x06
    4e4a:	49 81       	ldd	r20, Y+1	; 0x01
    4e4c:	5a 81       	ldd	r21, Y+2	; 0x02
    4e4e:	d7 01       	movw	r26, r14
    4e50:	54 96       	adiw	r26, 0x14	; 20
    4e52:	6d 91       	ld	r22, X+
    4e54:	7d 91       	ld	r23, X+
    4e56:	8d 91       	ld	r24, X+
    4e58:	9c 91       	ld	r25, X
    4e5a:	57 97       	sbiw	r26, 0x17	; 23
    4e5c:	10 de       	rcall	.-992    	; 0x4a7e <csp_route_security_check>
    4e5e:	99 23       	and	r25, r25
    4e60:	2c f4       	brge	.+10     	; 0x4e6c <csp_route_work+0x352>
			csp_buffer_free(packet);
    4e62:	8d 81       	ldd	r24, Y+5	; 0x05
    4e64:	9e 81       	ldd	r25, Y+6	; 0x06
    4e66:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return 0;
    4e6a:	45 c0       	rjmp	.+138    	; 0x4ef6 <csp_route_work+0x3dc>
		return 0;
	}
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
    4e6c:	6d 81       	ldd	r22, Y+5	; 0x05
    4e6e:	7e 81       	ldd	r23, Y+6	; 0x06
    4e70:	c7 01       	movw	r24, r14
    4e72:	0e 94 0a 31 	call	0x6214	; 0x6214 <csp_udp_new_packet>
	return 0;
    4e76:	3f c0       	rjmp	.+126    	; 0x4ef6 <csp_route_work+0x3dc>
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
		return -1;
    4e78:	cc 24       	eor	r12, r12
    4e7a:	ca 94       	dec	r12
    4e7c:	dc 2c       	mov	r13, r12
    4e7e:	3b c0       	rjmp	.+118    	; 0x4ef6 <csp_route_work+0x3dc>
			csp_log_warn("Router failed to send");
			csp_buffer_free(packet);
		}

		/* Next message, please */
		return 0;
    4e80:	6c 01       	movw	r12, r24
    4e82:	39 c0       	rjmp	.+114    	; 0x4ef6 <csp_route_work+0x3dc>
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
		csp_buffer_free(packet);
    4e84:	8d 81       	ldd	r24, Y+5	; 0x05
    4e86:	9e 81       	ldd	r25, Y+6	; 0x06
    4e88:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
		return 0;
    4e8c:	34 c0       	rjmp	.+104    	; 0x4ef6 <csp_route_work+0x3dc>
	}

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);
    4e8e:	83 85       	ldd	r24, Z+11	; 0x0b
    4e90:	98 2f       	mov	r25, r24
    4e92:	92 95       	swap	r25
    4e94:	96 95       	lsr	r25
    4e96:	96 95       	lsr	r25
    4e98:	93 70       	andi	r25, 0x03	; 3
    4e9a:	84 85       	ldd	r24, Z+12	; 0x0c
    4e9c:	8f 70       	andi	r24, 0x0F	; 15
    4e9e:	88 0f       	add	r24, r24
    4ea0:	88 0f       	add	r24, r24
    4ea2:	89 2b       	or	r24, r25
    4ea4:	90 e0       	ldi	r25, 0x00	; 0
    4ea6:	61 dc       	rcall	.-1854   	; 0x476a <csp_port_get_socket>
    4ea8:	8c 01       	movw	r16, r24

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    4eaa:	89 2b       	or	r24, r25
    4eac:	09 f0       	breq	.+2      	; 0x4eb0 <csp_route_work+0x396>
    4eae:	2d cf       	rjmp	.-422    	; 0x4d0a <csp_route_work+0x1f0>
    4eb0:	11 c0       	rjmp	.+34     	; 0x4ed4 <csp_route_work+0x3ba>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    4eb2:	ed 81       	ldd	r30, Y+5	; 0x05
    4eb4:	fe 81       	ldd	r31, Y+6	; 0x06
    4eb6:	62 85       	ldd	r22, Z+10	; 0x0a
    4eb8:	73 85       	ldd	r23, Z+11	; 0x0b
    4eba:	84 85       	ldd	r24, Z+12	; 0x0c
    4ebc:	95 85       	ldd	r25, Z+13	; 0x0d
    4ebe:	20 e0       	ldi	r18, 0x00	; 0
    4ec0:	3f ef       	ldi	r19, 0xFF	; 255
    4ec2:	4f ef       	ldi	r20, 0xFF	; 255
    4ec4:	5f e3       	ldi	r21, 0x3F	; 63
    4ec6:	0e 94 ed 1b 	call	0x37da	; 0x37da <csp_conn_find>
    4eca:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4ecc:	89 2b       	or	r24, r25
    4ece:	09 f0       	breq	.+2      	; 0x4ed2 <csp_route_work+0x3b8>
    4ed0:	ba cf       	rjmp	.-140    	; 0x4e46 <csp_route_work+0x32c>
    4ed2:	51 cf       	rjmp	.-350    	; 0x4d76 <csp_route_work+0x25c>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    4ed4:	ed 81       	ldd	r30, Y+5	; 0x05
    4ed6:	fe 81       	ldd	r31, Y+6	; 0x06
    4ed8:	62 85       	ldd	r22, Z+10	; 0x0a
    4eda:	73 85       	ldd	r23, Z+11	; 0x0b
    4edc:	84 85       	ldd	r24, Z+12	; 0x0c
    4ede:	95 85       	ldd	r25, Z+13	; 0x0d
    4ee0:	20 e0       	ldi	r18, 0x00	; 0
    4ee2:	3f ef       	ldi	r19, 0xFF	; 255
    4ee4:	4f ef       	ldi	r20, 0xFF	; 255
    4ee6:	5f e3       	ldi	r21, 0x3F	; 63
    4ee8:	0e 94 ed 1b 	call	0x37da	; 0x37da <csp_conn_find>
    4eec:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4eee:	89 2b       	or	r24, r25
    4ef0:	09 f0       	breq	.+2      	; 0x4ef4 <csp_route_work+0x3da>
    4ef2:	a9 cf       	rjmp	.-174    	; 0x4e46 <csp_route_work+0x32c>
    4ef4:	3b cf       	rjmp	.-394    	; 0x4d6c <csp_route_work+0x252>
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
	return 0;
}
    4ef6:	c6 01       	movw	r24, r12
    4ef8:	26 96       	adiw	r28, 0x06	; 6
    4efa:	0f b6       	in	r0, 0x3f	; 63
    4efc:	f8 94       	cli
    4efe:	de bf       	out	0x3e, r29	; 62
    4f00:	0f be       	out	0x3f, r0	; 63
    4f02:	cd bf       	out	0x3d, r28	; 61
    4f04:	df 91       	pop	r29
    4f06:	cf 91       	pop	r28
    4f08:	1f 91       	pop	r17
    4f0a:	0f 91       	pop	r16
    4f0c:	ff 90       	pop	r15
    4f0e:	ef 90       	pop	r14
    4f10:	df 90       	pop	r13
    4f12:	cf 90       	pop	r12
    4f14:	08 95       	ret

00004f16 <csp_task_router>:

static CSP_DEFINE_TASK(csp_task_router) {

	/* Here there be routing */
	while (1) {
		csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
    4f16:	c0 e3       	ldi	r28, 0x30	; 48
    4f18:	dd e0       	ldi	r29, 0x0D	; 13
    4f1a:	68 94       	set
    4f1c:	ff 24       	eor	r15, r15
    4f1e:	f1 f8       	bld	r15, 1
    4f20:	80 e0       	ldi	r24, 0x00	; 0
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	0e 94 c6 3d 	call	0x7b8c	; 0x7b8c <uxTaskGetStackHighWaterMark2>
    4f28:	18 2f       	mov	r17, r24
    4f2a:	09 2f       	mov	r16, r25
    4f2c:	80 e0       	ldi	r24, 0x00	; 0
    4f2e:	90 e0       	ldi	r25, 0x00	; 0
    4f30:	0e 94 ad 3a 	call	0x755a	; 0x755a <pcTaskGetName>
    4f34:	0f 93       	push	r16
    4f36:	1f 93       	push	r17
    4f38:	9f 93       	push	r25
    4f3a:	8f 93       	push	r24
    4f3c:	df 93       	push	r29
    4f3e:	cf 93       	push	r28
    4f40:	ff 92       	push	r15
    4f42:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		csp_route_work(FIFO_TIMEOUT);
    4f46:	6f ef       	ldi	r22, 0xFF	; 255
    4f48:	7f ef       	ldi	r23, 0xFF	; 255
    4f4a:	80 e0       	ldi	r24, 0x00	; 0
    4f4c:	90 e0       	ldi	r25, 0x00	; 0
    4f4e:	e5 dd       	rcall	.-1078   	; 0x4b1a <csp_route_work>
    4f50:	8d b7       	in	r24, 0x3d	; 61
    4f52:	9e b7       	in	r25, 0x3e	; 62
    4f54:	07 96       	adiw	r24, 0x07	; 7
    4f56:	0f b6       	in	r0, 0x3f	; 63
    4f58:	f8 94       	cli
    4f5a:	9e bf       	out	0x3e, r25	; 62
    4f5c:	0f be       	out	0x3f, r0	; 63
    4f5e:	8d bf       	out	0x3d, r24	; 61
    4f60:	df cf       	rjmp	.-66     	; 0x4f20 <csp_task_router+0xa>

00004f62 <csp_route_start_task>:
	}

}

int csp_route_start_task(unsigned int task_stack_size, unsigned int priority) {
    4f62:	ef 92       	push	r14
    4f64:	ff 92       	push	r15
    4f66:	0f 93       	push	r16
    4f68:	1f 93       	push	r17

	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);
    4f6a:	0f 2e       	mov	r0, r31
    4f6c:	fb e8       	ldi	r31, 0x8B	; 139
    4f6e:	ef 2e       	mov	r14, r31
    4f70:	f4 e0       	ldi	r31, 0x04	; 4
    4f72:	ff 2e       	mov	r15, r31
    4f74:	f0 2d       	mov	r31, r0
    4f76:	8b 01       	movw	r16, r22
    4f78:	20 e0       	ldi	r18, 0x00	; 0
    4f7a:	30 e0       	ldi	r19, 0x00	; 0
    4f7c:	ac 01       	movw	r20, r24
    4f7e:	67 e9       	ldi	r22, 0x97	; 151
    4f80:	72 e0       	ldi	r23, 0x02	; 2
    4f82:	8b e8       	ldi	r24, 0x8B	; 139
    4f84:	97 e2       	ldi	r25, 0x27	; 39
    4f86:	0e 94 3b 19 	call	0x3276	; 0x3276 <csp_thread_create>

	if (ret != 0) {
    4f8a:	89 2b       	or	r24, r25
    4f8c:	69 f0       	breq	.+26     	; 0x4fa8 <csp_route_start_task+0x46>
		csp_log_error("Failed to start router task");
    4f8e:	87 e3       	ldi	r24, 0x37	; 55
    4f90:	9d e0       	ldi	r25, 0x0D	; 13
    4f92:	9f 93       	push	r25
    4f94:	8f 93       	push	r24
    4f96:	1f 92       	push	r1
    4f98:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_NOMEM;
    4f9c:	0f 90       	pop	r0
    4f9e:	0f 90       	pop	r0
    4fa0:	0f 90       	pop	r0
    4fa2:	8f ef       	ldi	r24, 0xFF	; 255
    4fa4:	9f ef       	ldi	r25, 0xFF	; 255
    4fa6:	02 c0       	rjmp	.+4      	; 0x4fac <csp_route_start_task+0x4a>
	}

	return CSP_ERR_NONE;
    4fa8:	80 e0       	ldi	r24, 0x00	; 0
    4faa:	90 e0       	ldi	r25, 0x00	; 0

}
    4fac:	1f 91       	pop	r17
    4fae:	0f 91       	pop	r16
    4fb0:	ff 90       	pop	r15
    4fb2:	ef 90       	pop	r14
    4fb4:	08 95       	ret

00004fb6 <csp_ping>:
#include <csp/csp_endian.h>

#include <csp/arch/csp_time.h>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {
    4fb6:	3f 92       	push	r3
    4fb8:	4f 92       	push	r4
    4fba:	5f 92       	push	r5
    4fbc:	6f 92       	push	r6
    4fbe:	7f 92       	push	r7
    4fc0:	8f 92       	push	r8
    4fc2:	9f 92       	push	r9
    4fc4:	af 92       	push	r10
    4fc6:	bf 92       	push	r11
    4fc8:	cf 92       	push	r12
    4fca:	df 92       	push	r13
    4fcc:	ef 92       	push	r14
    4fce:	ff 92       	push	r15
    4fd0:	0f 93       	push	r16
    4fd2:	1f 93       	push	r17
    4fd4:	cf 93       	push	r28
    4fd6:	df 93       	push	r29
    4fd8:	38 2e       	mov	r3, r24
    4fda:	4a 01       	movw	r8, r20
    4fdc:	5b 01       	movw	r10, r22
    4fde:	e9 01       	movw	r28, r18

	unsigned int i;
	uint32_t start, time, status = 0;

	/* Counter */
	start = csp_get_ms();
    4fe0:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    4fe4:	2b 01       	movw	r4, r22
    4fe6:	3c 01       	movw	r6, r24

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
    4fe8:	c0 2e       	mov	r12, r16
    4fea:	d1 2c       	mov	r13, r1
    4fec:	e1 2c       	mov	r14, r1
    4fee:	f1 2c       	mov	r15, r1
    4ff0:	95 01       	movw	r18, r10
    4ff2:	84 01       	movw	r16, r8
    4ff4:	41 e0       	ldi	r20, 0x01	; 1
    4ff6:	63 2d       	mov	r22, r3
    4ff8:	82 e0       	ldi	r24, 0x02	; 2
    4ffa:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <csp_connect>
    4ffe:	8c 01       	movw	r16, r24
	if (conn == NULL)
    5000:	89 2b       	or	r24, r25
    5002:	e1 f1       	breq	.+120    	; 0x507c <csp_ping+0xc6>
		return -1;

	/* Prepare data */
	csp_packet_t * packet;
	packet = csp_buffer_get(size);
    5004:	ce 01       	movw	r24, r28
    5006:	0e 94 f9 19 	call	0x33f2	; 0x33f2 <csp_buffer_get>
    500a:	7c 01       	movw	r14, r24
	if (packet == NULL)
    500c:	00 97       	sbiw	r24, 0x00	; 0
    500e:	c9 f1       	breq	.+114    	; 0x5082 <csp_ping+0xcc>
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
    5010:	fc 01       	movw	r30, r24
    5012:	d1 87       	std	Z+9, r29	; 0x09
    5014:	c0 87       	std	Z+8, r28	; 0x08
	for (i = 0; i < size; i++)
    5016:	20 97       	sbiw	r28, 0x00	; 0
    5018:	41 f0       	breq	.+16     	; 0x502a <csp_ping+0x74>
    501a:	3e 96       	adiw	r30, 0x0e	; 14
    501c:	80 e0       	ldi	r24, 0x00	; 0
    501e:	90 e0       	ldi	r25, 0x00	; 0
		packet->data[i] = i;
    5020:	81 93       	st	Z+, r24
	if (packet == NULL)
		goto out;

	/* Set data to increasing numbers */
	packet->length = size;
	for (i = 0; i < size; i++)
    5022:	01 96       	adiw	r24, 0x01	; 1
    5024:	c8 17       	cp	r28, r24
    5026:	d9 07       	cpc	r29, r25
    5028:	d9 f7       	brne	.-10     	; 0x5020 <csp_ping+0x6a>
		packet->data[i] = i;

	/* Try to send frame */
	if (!csp_send(conn, packet, 0))
    502a:	20 e0       	ldi	r18, 0x00	; 0
    502c:	30 e0       	ldi	r19, 0x00	; 0
    502e:	a9 01       	movw	r20, r18
    5030:	b7 01       	movw	r22, r14
    5032:	c8 01       	movw	r24, r16
    5034:	50 db       	rcall	.-2400   	; 0x46d6 <csp_send>
    5036:	89 2b       	or	r24, r25
    5038:	61 f1       	breq	.+88     	; 0x5092 <csp_ping+0xdc>
		goto out;

	/* Read incoming frame */
	packet = csp_read(conn, timeout);
    503a:	b5 01       	movw	r22, r10
    503c:	a4 01       	movw	r20, r8
    503e:	c8 01       	movw	r24, r16
    5040:	1a da       	rcall	.-3020   	; 0x4476 <csp_read>
    5042:	7c 01       	movw	r14, r24
	if (packet == NULL)
    5044:	00 97       	sbiw	r24, 0x00	; 0
    5046:	e9 f0       	breq	.+58     	; 0x5082 <csp_ping+0xcc>
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    5048:	20 97       	sbiw	r28, 0x00	; 0
    504a:	39 f1       	breq	.+78     	; 0x509a <csp_ping+0xe4>
		if (packet->data[i] != i % (0xff + 1))
    504c:	fc 01       	movw	r30, r24
    504e:	86 85       	ldd	r24, Z+14	; 0x0e
    5050:	81 11       	cpse	r24, r1
    5052:	28 c0       	rjmp	.+80     	; 0x50a4 <csp_ping+0xee>
    5054:	3f 96       	adiw	r30, 0x0f	; 15
    5056:	80 e0       	ldi	r24, 0x00	; 0
    5058:	90 e0       	ldi	r25, 0x00	; 0
    505a:	07 c0       	rjmp	.+14     	; 0x506a <csp_ping+0xb4>
    505c:	21 91       	ld	r18, Z+
    505e:	30 e0       	ldi	r19, 0x00	; 0
    5060:	ac 01       	movw	r20, r24
    5062:	55 27       	eor	r21, r21
    5064:	24 17       	cp	r18, r20
    5066:	35 07       	cpc	r19, r21
    5068:	09 f5       	brne	.+66     	; 0x50ac <csp_ping+0xf6>
	packet = csp_read(conn, timeout);
	if (packet == NULL)
		goto out;

	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
    506a:	01 96       	adiw	r24, 0x01	; 1
    506c:	c8 17       	cp	r28, r24
    506e:	d9 07       	cpc	r29, r25
    5070:	a9 f7       	brne	.-22     	; 0x505c <csp_ping+0xa6>
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    5072:	81 2c       	mov	r8, r1
    5074:	91 2c       	mov	r9, r1
    5076:	54 01       	movw	r10, r8
    5078:	83 94       	inc	r8
    507a:	1b c0       	rjmp	.+54     	; 0x50b2 <csp_ping+0xfc>
	start = csp_get_ms();

	/* Open connection */
	csp_conn_t * conn = csp_connect(CSP_PRIO_NORM, node, CSP_PING, timeout, conn_options);
	if (conn == NULL)
		return -1;
    507c:	8f ef       	ldi	r24, 0xFF	; 255
    507e:	9f ef       	ldi	r25, 0xFF	; 255
    5080:	2c c0       	rjmp	.+88     	; 0x50da <csp_ping+0x124>

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
	csp_close(conn);
    5082:	c8 01       	movw	r24, r16
    5084:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    5088:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>

	if (status) {
		return time;
	} else {
		return -1;
    508c:	8f ef       	ldi	r24, 0xFF	; 255
    508e:	9f ef       	ldi	r25, 0xFF	; 255
    5090:	24 c0       	rjmp	.+72     	; 0x50da <csp_ping+0x124>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    5092:	81 2c       	mov	r8, r1
    5094:	91 2c       	mov	r9, r1
    5096:	54 01       	movw	r10, r8
    5098:	0c c0       	rjmp	.+24     	; 0x50b2 <csp_ping+0xfc>
	/* Ensure that the data was actually echoed */
	for (i = 0; i < size; i++)
		if (packet->data[i] != i % (0xff + 1))
			goto out;

	status = 1;
    509a:	81 2c       	mov	r8, r1
    509c:	91 2c       	mov	r9, r1
    509e:	54 01       	movw	r10, r8
    50a0:	83 94       	inc	r8
    50a2:	07 c0       	rjmp	.+14     	; 0x50b2 <csp_ping+0xfc>


int csp_ping(uint8_t node, uint32_t timeout, unsigned int size, uint8_t conn_options) {

	unsigned int i;
	uint32_t start, time, status = 0;
    50a4:	81 2c       	mov	r8, r1
    50a6:	91 2c       	mov	r9, r1
    50a8:	54 01       	movw	r10, r8
    50aa:	03 c0       	rjmp	.+6      	; 0x50b2 <csp_ping+0xfc>
    50ac:	81 2c       	mov	r8, r1
    50ae:	91 2c       	mov	r9, r1
    50b0:	54 01       	movw	r10, r8
	status = 1;

out:
	/* Clean up */
	if (packet != NULL)
		csp_buffer_free(packet);
    50b2:	c7 01       	movw	r24, r14
    50b4:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
	csp_close(conn);
    50b8:	c8 01       	movw	r24, r16
    50ba:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <csp_close>

	/* We have a reply */
	time = (csp_get_ms() - start);
    50be:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    50c2:	dc 01       	movw	r26, r24
    50c4:	cb 01       	movw	r24, r22
    50c6:	84 19       	sub	r24, r4
    50c8:	95 09       	sbc	r25, r5
    50ca:	a6 09       	sbc	r26, r6
    50cc:	b7 09       	sbc	r27, r7

	if (status) {
    50ce:	89 28       	or	r8, r9
    50d0:	8a 28       	or	r8, r10
    50d2:	8b 28       	or	r8, r11
    50d4:	11 f4       	brne	.+4      	; 0x50da <csp_ping+0x124>
		return time;
	} else {
		return -1;
    50d6:	8f ef       	ldi	r24, 0xFF	; 255
    50d8:	9f ef       	ldi	r25, 0xFF	; 255
	}

}
    50da:	df 91       	pop	r29
    50dc:	cf 91       	pop	r28
    50de:	1f 91       	pop	r17
    50e0:	0f 91       	pop	r16
    50e2:	ff 90       	pop	r15
    50e4:	ef 90       	pop	r14
    50e6:	df 90       	pop	r13
    50e8:	cf 90       	pop	r12
    50ea:	bf 90       	pop	r11
    50ec:	af 90       	pop	r10
    50ee:	9f 90       	pop	r9
    50f0:	8f 90       	pop	r8
    50f2:	7f 90       	pop	r7
    50f4:	6f 90       	pop	r6
    50f6:	5f 90       	pop	r5
    50f8:	4f 90       	pop	r4
    50fa:	3f 90       	pop	r3
    50fc:	08 95       	ret

000050fe <wrap_32bit_memcpy>:
static csp_memcpy_fnc_t csp_cmp_memcpy_fnc = (csp_memcpy_fnc_t) memcpy;
#endif


void csp_cmp_set_memcpy(csp_memcpy_fnc_t fnc) {
	csp_cmp_memcpy_fnc = fnc;
    50fe:	cf 92       	push	r12
    5100:	df 92       	push	r13
    5102:	ef 92       	push	r14
    5104:	ff 92       	push	r15
    5106:	0f 93       	push	r16
    5108:	1f 93       	push	r17
    510a:	dc 01       	movw	r26, r24
    510c:	cb 01       	movw	r24, r22
    510e:	69 01       	movw	r12, r18
    5110:	7a 01       	movw	r14, r20
    5112:	a8 01       	movw	r20, r16
    5114:	b6 01       	movw	r22, r12
    5116:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>
    511a:	bc 01       	movw	r22, r24
    511c:	80 e0       	ldi	r24, 0x00	; 0
    511e:	90 e0       	ldi	r25, 0x00	; 0
    5120:	1f 91       	pop	r17
    5122:	0f 91       	pop	r16
    5124:	ff 90       	pop	r15
    5126:	ef 90       	pop	r14
    5128:	df 90       	pop	r13
    512a:	cf 90       	pop	r12
    512c:	08 95       	ret

0000512e <csp_service_handler>:
	cmp->type = CSP_CMP_REPLY;

	return ret;
}

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    512e:	6f 92       	push	r6
    5130:	7f 92       	push	r7
    5132:	8f 92       	push	r8
    5134:	9f 92       	push	r9
    5136:	af 92       	push	r10
    5138:	bf 92       	push	r11
    513a:	cf 92       	push	r12
    513c:	df 92       	push	r13
    513e:	ef 92       	push	r14
    5140:	ff 92       	push	r15
    5142:	0f 93       	push	r16
    5144:	1f 93       	push	r17
    5146:	cf 93       	push	r28
    5148:	df 93       	push	r29
    514a:	7c 01       	movw	r14, r24
    514c:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    514e:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <csp_conn_dport>
    5152:	87 30       	cpi	r24, 0x07	; 7
    5154:	91 05       	cpc	r25, r1
    5156:	08 f0       	brcs	.+2      	; 0x515a <csp_service_handler+0x2c>
    5158:	3a c2       	rjmp	.+1140   	; 0x55ce <csp_service_handler+0x4a0>
    515a:	fc 01       	movw	r30, r24
    515c:	88 27       	eor	r24, r24
    515e:	e2 55       	subi	r30, 0x52	; 82
    5160:	ff 4f       	sbci	r31, 0xFF	; 255
    5162:	8f 4f       	sbci	r24, 0xFF	; 255
    5164:	0c 94 1e 44 	jmp	0x883c	; 0x883c <__tablejump2__>

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    5168:	8e 85       	ldd	r24, Y+14	; 0x0e
    516a:	81 11       	cpse	r24, r1
    516c:	71 c1       	rjmp	.+738    	; 0x5450 <csp_service_handler+0x322>
		return ret;

	switch (cmp->code) {
    516e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5170:	83 30       	cpi	r24, 0x03	; 3
    5172:	09 f4       	brne	.+2      	; 0x5176 <csp_service_handler+0x48>
    5174:	6d c0       	rjmp	.+218    	; 0x5250 <csp_service_handler+0x122>
    5176:	30 f4       	brcc	.+12     	; 0x5184 <csp_service_handler+0x56>
    5178:	81 30       	cpi	r24, 0x01	; 1
    517a:	69 f0       	breq	.+26     	; 0x5196 <csp_service_handler+0x68>
    517c:	82 30       	cpi	r24, 0x02	; 2
    517e:	09 f4       	brne	.+2      	; 0x5182 <csp_service_handler+0x54>
    5180:	4d c0       	rjmp	.+154    	; 0x521c <csp_service_handler+0xee>
    5182:	5f c1       	rjmp	.+702    	; 0x5442 <csp_service_handler+0x314>
    5184:	85 30       	cpi	r24, 0x05	; 5
    5186:	09 f4       	brne	.+2      	; 0x518a <csp_service_handler+0x5c>
    5188:	01 c1       	rjmp	.+514    	; 0x538c <csp_service_handler+0x25e>
    518a:	08 f4       	brcc	.+2      	; 0x518e <csp_service_handler+0x60>
    518c:	e3 c0       	rjmp	.+454    	; 0x5354 <csp_service_handler+0x226>
    518e:	86 30       	cpi	r24, 0x06	; 6
    5190:	09 f4       	brne	.+2      	; 0x5194 <csp_service_handler+0x66>
    5192:	16 c1       	rjmp	.+556    	; 0x53c0 <csp_service_handler+0x292>
    5194:	56 c1       	rjmp	.+684    	; 0x5442 <csp_service_handler+0x314>
}

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, csp_get_revision(), CSP_CMP_IDENT_REV_LEN);
    5196:	b0 d8       	rcall	.-3744   	; 0x42f8 <csp_get_revision>
    5198:	44 e1       	ldi	r20, 0x14	; 20
    519a:	50 e0       	ldi	r21, 0x00	; 0
    519c:	bc 01       	movw	r22, r24
    519e:	ce 01       	movw	r24, r28
    51a0:	8e 5b       	subi	r24, 0xBE	; 190
    51a2:	9f 4f       	sbci	r25, 0xFF	; 255
    51a4:	0e 94 c6 44 	call	0x898c	; 0x898c <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    51a8:	fe 01       	movw	r30, r28
    51aa:	eb 5a       	subi	r30, 0xAB	; 171
    51ac:	ff 4f       	sbci	r31, 0xFF	; 255
    51ae:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    51b0:	8c e0       	ldi	r24, 0x0C	; 12
    51b2:	eb e9       	ldi	r30, 0x9B	; 155
    51b4:	f2 e0       	ldi	r31, 0x02	; 2
    51b6:	de 01       	movw	r26, r28
    51b8:	aa 5a       	subi	r26, 0xAA	; 170
    51ba:	bf 4f       	sbci	r27, 0xFF	; 255
    51bc:	01 90       	ld	r0, Z+
    51be:	0d 92       	st	X+, r0
    51c0:	8a 95       	dec	r24
    51c2:	e1 f7       	brne	.-8      	; 0x51bc <csp_service_handler+0x8e>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    51c4:	fe 01       	movw	r30, r28
    51c6:	ef 59       	subi	r30, 0x9F	; 159
    51c8:	ff 4f       	sbci	r31, 0xFF	; 255
    51ca:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    51cc:	89 e0       	ldi	r24, 0x09	; 9
    51ce:	e7 ea       	ldi	r30, 0xA7	; 167
    51d0:	f2 e0       	ldi	r31, 0x02	; 2
    51d2:	de 01       	movw	r26, r28
    51d4:	ae 59       	subi	r26, 0x9E	; 158
    51d6:	bf 4f       	sbci	r27, 0xFF	; 255
    51d8:	01 90       	ld	r0, Z+
    51da:	0d 92       	st	X+, r0
    51dc:	8a 95       	dec	r24
    51de:	e1 f7       	brne	.-8      	; 0x51d8 <csp_service_handler+0xaa>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    51e0:	fe 01       	movw	r30, r28
    51e2:	e6 59       	subi	r30, 0x96	; 150
    51e4:	ff 4f       	sbci	r31, 0xFF	; 255

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    51e6:	10 82       	st	Z, r1
    51e8:	7d d8       	rcall	.-3846   	; 0x42e4 <csp_get_hostname>
    51ea:	44 e1       	ldi	r20, 0x14	; 20
    51ec:	50 e0       	ldi	r21, 0x00	; 0
    51ee:	bc 01       	movw	r22, r24
    51f0:	ce 01       	movw	r24, r28
    51f2:	40 96       	adiw	r24, 0x10	; 16
    51f4:	0e 94 c6 44 	call	0x898c	; 0x898c <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    51f8:	1b a2       	std	Y+35, r1	; 0x23
    51fa:	79 d8       	rcall	.-3854   	; 0x42ee <csp_get_model>
    51fc:	4e e1       	ldi	r20, 0x1E	; 30
    51fe:	50 e0       	ldi	r21, 0x00	; 0
    5200:	bc 01       	movw	r22, r24
    5202:	ce 01       	movw	r24, r28
    5204:	84 96       	adiw	r24, 0x24	; 36
    5206:	0e 94 c6 44 	call	0x898c	; 0x898c <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    520a:	fe 01       	movw	r30, r28
    520c:	ef 5b       	subi	r30, 0xBF	; 191
    520e:	ff 4f       	sbci	r31, 0xFF	; 255
    5210:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    5212:	8d e5       	ldi	r24, 0x5D	; 93
    5214:	90 e0       	ldi	r25, 0x00	; 0
    5216:	99 87       	std	Y+9, r25	; 0x09
    5218:	88 87       	std	Y+8, r24	; 0x08
    521a:	ee c1       	rjmp	.+988    	; 0x55f8 <csp_service_handler+0x4ca>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
    521c:	ce 01       	movw	r24, r28
    521e:	42 96       	adiw	r24, 0x12	; 18
    5220:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <csp_iflist_get_by_name>
	if (ifc == NULL)
    5224:	00 97       	sbiw	r24, 0x00	; 0
    5226:	51 f0       	breq	.+20     	; 0x523c <csp_service_handler+0x10e>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    5228:	29 89       	ldd	r18, Y+17	; 0x11
    522a:	ac 01       	movw	r20, r24
    522c:	65 e0       	ldi	r22, 0x05	; 5
    522e:	88 89       	ldd	r24, Y+16	; 0x10
    5230:	5d d7       	rcall	.+3770   	; 0x60ec <csp_rtable_set>
    5232:	89 2b       	or	r24, r25
    5234:	31 f4       	brne	.+12     	; 0x5242 <csp_service_handler+0x114>
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    5236:	80 e0       	ldi	r24, 0x00	; 0
    5238:	90 e0       	ldi	r25, 0x00	; 0
    523a:	05 c0       	rjmp	.+10     	; 0x5246 <csp_service_handler+0x118>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    523c:	8e ef       	ldi	r24, 0xFE	; 254
    523e:	9f ef       	ldi	r25, 0xFF	; 255
    5240:	02 c0       	rjmp	.+4      	; 0x5246 <csp_service_handler+0x118>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;
    5242:	8e ef       	ldi	r24, 0xFE	; 254
    5244:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    5246:	2f e0       	ldi	r18, 0x0F	; 15
    5248:	30 e0       	ldi	r19, 0x00	; 0
    524a:	39 87       	std	Y+9, r19	; 0x09
    524c:	28 87       	std	Y+8, r18	; 0x08
    524e:	fb c0       	rjmp	.+502    	; 0x5446 <csp_service_handler+0x318>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
    5250:	ce 01       	movw	r24, r28
    5252:	40 96       	adiw	r24, 0x10	; 16
    5254:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <csp_iflist_get_by_name>
    5258:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    525a:	00 97       	sbiw	r24, 0x00	; 0
    525c:	09 f4       	brne	.+2      	; 0x5260 <csp_service_handler+0x132>
    525e:	73 c0       	rjmp	.+230    	; 0x5346 <csp_service_handler+0x218>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    5260:	fc 01       	movw	r30, r24
    5262:	61 85       	ldd	r22, Z+9	; 0x09
    5264:	72 85       	ldd	r23, Z+10	; 0x0a
    5266:	83 85       	ldd	r24, Z+11	; 0x0b
    5268:	94 85       	ldd	r25, Z+12	; 0x0c
    526a:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    526e:	6b 8f       	std	Y+27, r22	; 0x1b
    5270:	7c 8f       	std	Y+28, r23	; 0x1c
    5272:	8d 8f       	std	Y+29, r24	; 0x1d
    5274:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    5276:	f8 01       	movw	r30, r16
    5278:	65 85       	ldd	r22, Z+13	; 0x0d
    527a:	76 85       	ldd	r23, Z+14	; 0x0e
    527c:	87 85       	ldd	r24, Z+15	; 0x0f
    527e:	90 89       	ldd	r25, Z+16	; 0x10
    5280:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5284:	6f 8f       	std	Y+31, r22	; 0x1f
    5286:	78 a3       	std	Y+32, r23	; 0x20
    5288:	89 a3       	std	Y+33, r24	; 0x21
    528a:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    528c:	f8 01       	movw	r30, r16
    528e:	61 89       	ldd	r22, Z+17	; 0x11
    5290:	72 89       	ldd	r23, Z+18	; 0x12
    5292:	83 89       	ldd	r24, Z+19	; 0x13
    5294:	94 89       	ldd	r25, Z+20	; 0x14
    5296:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    529a:	6b a3       	std	Y+35, r22	; 0x23
    529c:	7c a3       	std	Y+36, r23	; 0x24
    529e:	8d a3       	std	Y+37, r24	; 0x25
    52a0:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    52a2:	f8 01       	movw	r30, r16
    52a4:	65 89       	ldd	r22, Z+21	; 0x15
    52a6:	76 89       	ldd	r23, Z+22	; 0x16
    52a8:	87 89       	ldd	r24, Z+23	; 0x17
    52aa:	90 8d       	ldd	r25, Z+24	; 0x18
    52ac:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    52b0:	6f a3       	std	Y+39, r22	; 0x27
    52b2:	78 a7       	std	Y+40, r23	; 0x28
    52b4:	89 a7       	std	Y+41, r24	; 0x29
    52b6:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    52b8:	f8 01       	movw	r30, r16
    52ba:	61 8d       	ldd	r22, Z+25	; 0x19
    52bc:	72 8d       	ldd	r23, Z+26	; 0x1a
    52be:	83 8d       	ldd	r24, Z+27	; 0x1b
    52c0:	94 8d       	ldd	r25, Z+28	; 0x1c
    52c2:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    52c6:	6b a7       	std	Y+43, r22	; 0x2b
    52c8:	7c a7       	std	Y+44, r23	; 0x2c
    52ca:	8d a7       	std	Y+45, r24	; 0x2d
    52cc:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    52ce:	f8 01       	movw	r30, r16
    52d0:	65 8d       	ldd	r22, Z+29	; 0x1d
    52d2:	76 8d       	ldd	r23, Z+30	; 0x1e
    52d4:	87 8d       	ldd	r24, Z+31	; 0x1f
    52d6:	90 a1       	ldd	r25, Z+32	; 0x20
    52d8:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    52dc:	6f a7       	std	Y+47, r22	; 0x2f
    52de:	78 ab       	std	Y+48, r23	; 0x30
    52e0:	89 ab       	std	Y+49, r24	; 0x31
    52e2:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    52e4:	f8 01       	movw	r30, r16
    52e6:	61 a1       	ldd	r22, Z+33	; 0x21
    52e8:	72 a1       	ldd	r23, Z+34	; 0x22
    52ea:	83 a1       	ldd	r24, Z+35	; 0x23
    52ec:	94 a1       	ldd	r25, Z+36	; 0x24
    52ee:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    52f2:	6b ab       	std	Y+51, r22	; 0x33
    52f4:	7c ab       	std	Y+52, r23	; 0x34
    52f6:	8d ab       	std	Y+53, r24	; 0x35
    52f8:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    52fa:	f8 01       	movw	r30, r16
    52fc:	65 a1       	ldd	r22, Z+37	; 0x25
    52fe:	76 a1       	ldd	r23, Z+38	; 0x26
    5300:	87 a1       	ldd	r24, Z+39	; 0x27
    5302:	90 a5       	ldd	r25, Z+40	; 0x28
    5304:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5308:	6f ab       	std	Y+55, r22	; 0x37
    530a:	78 af       	std	Y+56, r23	; 0x38
    530c:	89 af       	std	Y+57, r24	; 0x39
    530e:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    5310:	f8 01       	movw	r30, r16
    5312:	61 a5       	ldd	r22, Z+41	; 0x29
    5314:	72 a5       	ldd	r23, Z+42	; 0x2a
    5316:	83 a5       	ldd	r24, Z+43	; 0x2b
    5318:	94 a5       	ldd	r25, Z+44	; 0x2c
    531a:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    531e:	6b af       	std	Y+59, r22	; 0x3b
    5320:	7c af       	std	Y+60, r23	; 0x3c
    5322:	8d af       	std	Y+61, r24	; 0x3d
    5324:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    5326:	f8 01       	movw	r30, r16
    5328:	65 a5       	ldd	r22, Z+45	; 0x2d
    532a:	76 a5       	ldd	r23, Z+46	; 0x2e
    532c:	87 a5       	ldd	r24, Z+47	; 0x2f
    532e:	90 a9       	ldd	r25, Z+48	; 0x30
    5330:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5334:	fe 01       	movw	r30, r28
    5336:	ff 96       	adiw	r30, 0x3f	; 63
    5338:	60 83       	st	Z, r22
    533a:	71 83       	std	Z+1, r23	; 0x01
    533c:	82 83       	std	Z+2, r24	; 0x02
    533e:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    5340:	80 e0       	ldi	r24, 0x00	; 0
    5342:	90 e0       	ldi	r25, 0x00	; 0
    5344:	02 c0       	rjmp	.+4      	; 0x534a <csp_service_handler+0x21c>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_iflist_get_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    5346:	8e ef       	ldi	r24, 0xFE	; 254
    5348:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    534a:	25 e3       	ldi	r18, 0x35	; 53
    534c:	30 e0       	ldi	r19, 0x00	; 0
    534e:	39 87       	std	Y+9, r19	; 0x09
    5350:	28 87       	std	Y+8, r18	; 0x08
    5352:	79 c0       	rjmp	.+242    	; 0x5446 <csp_service_handler+0x318>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    5354:	68 89       	ldd	r22, Y+16	; 0x10
    5356:	79 89       	ldd	r23, Y+17	; 0x11
    5358:	8a 89       	ldd	r24, Y+18	; 0x12
    535a:	9b 89       	ldd	r25, Y+19	; 0x13
    535c:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5360:	9b 01       	movw	r18, r22
    5362:	ac 01       	movw	r20, r24
    5364:	68 8b       	std	Y+16, r22	; 0x10
    5366:	79 8b       	std	Y+17, r23	; 0x11
    5368:	8a 8b       	std	Y+18, r24	; 0x12
    536a:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    536c:	0c 89       	ldd	r16, Y+20	; 0x14
    536e:	09 3c       	cpi	r16, 0xC9	; 201
    5370:	08 f0       	brcs	.+2      	; 0x5374 <csp_service_handler+0x246>
    5372:	3f c1       	rjmp	.+638    	; 0x55f2 <csp_service_handler+0x4c4>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (uintptr_t) cmp->peek.data, (csp_memptr_t) (unsigned long) cmp->peek.addr, cmp->peek.len);
    5374:	10 e0       	ldi	r17, 0x00	; 0
    5376:	ce 01       	movw	r24, r28
    5378:	45 96       	adiw	r24, 0x15	; 21
    537a:	bc 01       	movw	r22, r24
    537c:	80 e0       	ldi	r24, 0x00	; 0
    537e:	90 e0       	ldi	r25, 0x00	; 0
    5380:	e0 91 14 02 	lds	r30, 0x0214	; 0x800214 <csp_cmp_memcpy_fnc>
    5384:	f0 91 15 02 	lds	r31, 0x0215	; 0x800215 <csp_cmp_memcpy_fnc+0x1>
    5388:	19 95       	eicall
    538a:	36 c1       	rjmp	.+620    	; 0x55f8 <csp_service_handler+0x4ca>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    538c:	68 89       	ldd	r22, Y+16	; 0x10
    538e:	79 89       	ldd	r23, Y+17	; 0x11
    5390:	8a 89       	ldd	r24, Y+18	; 0x12
    5392:	9b 89       	ldd	r25, Y+19	; 0x13
    5394:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5398:	68 8b       	std	Y+16, r22	; 0x10
    539a:	79 8b       	std	Y+17, r23	; 0x11
    539c:	8a 8b       	std	Y+18, r24	; 0x12
    539e:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    53a0:	0c 89       	ldd	r16, Y+20	; 0x14
    53a2:	09 3c       	cpi	r16, 0xC9	; 201
    53a4:	08 f0       	brcs	.+2      	; 0x53a8 <csp_service_handler+0x27a>
    53a6:	25 c1       	rjmp	.+586    	; 0x55f2 <csp_service_handler+0x4c4>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	csp_cmp_memcpy_fnc((csp_memptr_t) (unsigned long) cmp->poke.addr, (csp_memptr_t) (uintptr_t) cmp->poke.data, cmp->poke.len);
    53a8:	10 e0       	ldi	r17, 0x00	; 0
    53aa:	9e 01       	movw	r18, r28
    53ac:	2b 5e       	subi	r18, 0xEB	; 235
    53ae:	3f 4f       	sbci	r19, 0xFF	; 255
    53b0:	40 e0       	ldi	r20, 0x00	; 0
    53b2:	50 e0       	ldi	r21, 0x00	; 0
    53b4:	e0 91 14 02 	lds	r30, 0x0214	; 0x800214 <csp_cmp_memcpy_fnc>
    53b8:	f0 91 15 02 	lds	r31, 0x0215	; 0x800215 <csp_cmp_memcpy_fnc+0x1>
    53bc:	19 95       	eicall
    53be:	1c c1       	rjmp	.+568    	; 0x55f8 <csp_service_handler+0x4ca>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    53c0:	68 89       	ldd	r22, Y+16	; 0x10
    53c2:	79 89       	ldd	r23, Y+17	; 0x11
    53c4:	8a 89       	ldd	r24, Y+18	; 0x12
    53c6:	9b 89       	ldd	r25, Y+19	; 0x13
    53c8:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <csp_ntoh32>
    53cc:	68 8b       	std	Y+16, r22	; 0x10
    53ce:	79 8b       	std	Y+17, r23	; 0x11
    53d0:	8a 8b       	std	Y+18, r24	; 0x12
    53d2:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    53d4:	6c 89       	ldd	r22, Y+20	; 0x14
    53d6:	7d 89       	ldd	r23, Y+21	; 0x15
    53d8:	8e 89       	ldd	r24, Y+22	; 0x16
    53da:	9f 89       	ldd	r25, Y+23	; 0x17
    53dc:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <csp_ntoh32>
    53e0:	6c 8b       	std	Y+20, r22	; 0x14
    53e2:	7d 8b       	std	Y+21, r23	; 0x15
    53e4:	8e 8b       	std	Y+22, r24	; 0x16
    53e6:	9f 8b       	std	Y+23, r25	; 0x17

	if ((cmp->clock.tv_sec != 0) && (clock_set_time != NULL)) {
    53e8:	88 89       	ldd	r24, Y+16	; 0x10
    53ea:	99 89       	ldd	r25, Y+17	; 0x11
    53ec:	aa 89       	ldd	r26, Y+18	; 0x12
    53ee:	bb 89       	ldd	r27, Y+19	; 0x13
    53f0:	89 2b       	or	r24, r25
    53f2:	8a 2b       	or	r24, r26
    53f4:	8b 2b       	or	r24, r27
    53f6:	41 f0       	breq	.+16     	; 0x5408 <csp_service_handler+0x2da>
    53f8:	80 e0       	ldi	r24, 0x00	; 0
    53fa:	90 e0       	ldi	r25, 0x00	; 0
    53fc:	89 2b       	or	r24, r25
    53fe:	21 f0       	breq	.+8      	; 0x5408 <csp_service_handler+0x2da>
		clock_set_time(&cmp->clock);
    5400:	ce 01       	movw	r24, r28
    5402:	40 96       	adiw	r24, 0x10	; 16
    5404:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	if (clock_get_time != NULL) {
    5408:	80 e0       	ldi	r24, 0x00	; 0
    540a:	90 e0       	ldi	r25, 0x00	; 0
    540c:	89 2b       	or	r24, r25
    540e:	21 f0       	breq	.+8      	; 0x5418 <csp_service_handler+0x2ea>
		clock_get_time(&cmp->clock);
    5410:	ce 01       	movw	r24, r28
    5412:	40 96       	adiw	r24, 0x10	; 16
    5414:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	}

	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    5418:	68 89       	ldd	r22, Y+16	; 0x10
    541a:	79 89       	ldd	r23, Y+17	; 0x11
    541c:	8a 89       	ldd	r24, Y+18	; 0x12
    541e:	9b 89       	ldd	r25, Y+19	; 0x13
    5420:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5424:	68 8b       	std	Y+16, r22	; 0x10
    5426:	79 8b       	std	Y+17, r23	; 0x11
    5428:	8a 8b       	std	Y+18, r24	; 0x12
    542a:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    542c:	6c 89       	ldd	r22, Y+20	; 0x14
    542e:	7d 89       	ldd	r23, Y+21	; 0x15
    5430:	8e 89       	ldd	r24, Y+22	; 0x16
    5432:	9f 89       	ldd	r25, Y+23	; 0x17
    5434:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    5438:	6c 8b       	std	Y+20, r22	; 0x14
    543a:	7d 8b       	std	Y+21, r23	; 0x15
    543c:	8e 8b       	std	Y+22, r24	; 0x16
    543e:	9f 8b       	std	Y+23, r25	; 0x17
    5440:	db c0       	rjmp	.+438    	; 0x55f8 <csp_service_handler+0x4ca>
		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
			break;

		default:
			ret = CSP_ERR_INVAL;
    5442:	8e ef       	ldi	r24, 0xFE	; 254
    5444:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5446:	2f ef       	ldi	r18, 0xFF	; 255
    5448:	2e 87       	std	Y+14, r18	; 0x0e

	switch (csp_conn_dport(conn)) {

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    544a:	89 2b       	or	r24, r25
    544c:	09 f4       	brne	.+2      	; 0x5450 <csp_service_handler+0x322>
    544e:	c3 c0       	rjmp	.+390    	; 0x55d6 <csp_service_handler+0x4a8>
			csp_buffer_free(packet);
    5450:	ce 01       	movw	r24, r28
    5452:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
			return;
    5456:	d3 c0       	rjmp	.+422    	; 0x55fe <csp_service_handler+0x4d0>
		}
		break;

	case CSP_PING:
		/* A ping means, just echo the packet, so no changes */
		csp_log_info("SERVICE: Ping received");
    5458:	83 e6       	ldi	r24, 0x63	; 99
    545a:	9f e0       	ldi	r25, 0x0F	; 15
    545c:	9f 93       	push	r25
    545e:	8f 93       	push	r24
    5460:	82 e0       	ldi	r24, 0x02	; 2
    5462:	8f 93       	push	r24
    5464:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		break;
    5468:	0f 90       	pop	r0
    546a:	0f 90       	pop	r0
    546c:	0f 90       	pop	r0
    546e:	b3 c0       	rjmp	.+358    	; 0x55d6 <csp_service_handler+0x4a8>

	case CSP_PS: {
		/* Sanity check on request */
		if ((packet->length != 1) || (packet->data[0] != 0x55)) {
    5470:	88 85       	ldd	r24, Y+8	; 0x08
    5472:	99 85       	ldd	r25, Y+9	; 0x09
    5474:	01 97       	sbiw	r24, 0x01	; 1
    5476:	19 f4       	brne	.+6      	; 0x547e <csp_service_handler+0x350>
    5478:	8e 85       	ldd	r24, Y+14	; 0x0e
    547a:	85 35       	cpi	r24, 0x55	; 85
    547c:	21 f0       	breq	.+8      	; 0x5486 <csp_service_handler+0x358>
			/* Sanity check failed */
			csp_buffer_free(packet);
    547e:	ce 01       	movw	r24, r28
    5480:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    5484:	bc c0       	rjmp	.+376    	; 0x55fe <csp_service_handler+0x4d0>
			/* Clear the packet, it has been freed */
			packet = NULL;
			break;
		}
		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    5486:	0e 94 59 18 	call	0x30b2	; 0x30b2 <csp_sys_tasklist_size>
    548a:	8c 01       	movw	r16, r24
		char * pslist = csp_malloc(task_list_size);
    548c:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <csp_malloc>
    5490:	4c 01       	movw	r8, r24
		/* Check for malloc fail */
		if (pslist == NULL) {
    5492:	00 97       	sbiw	r24, 0x00	; 0
    5494:	a1 f4       	brne	.+40     	; 0x54be <csp_service_handler+0x390>
			/* Send out the data */
			strcpy((char *)packet->data, "Not enough memory");
    5496:	22 e1       	ldi	r18, 0x12	; 18
    5498:	e0 eb       	ldi	r30, 0xB0	; 176
    549a:	f2 e0       	ldi	r31, 0x02	; 2
    549c:	ce 01       	movw	r24, r28
    549e:	0e 96       	adiw	r24, 0x0e	; 14
    54a0:	dc 01       	movw	r26, r24
    54a2:	01 90       	ld	r0, Z+
    54a4:	0d 92       	st	X+, r0
    54a6:	2a 95       	dec	r18
    54a8:	e1 f7       	brne	.-8      	; 0x54a2 <csp_service_handler+0x374>
			packet->length = strlen((char *)packet->data);
    54aa:	fc 01       	movw	r30, r24
    54ac:	01 90       	ld	r0, Z+
    54ae:	00 20       	and	r0, r0
    54b0:	e9 f7       	brne	.-6      	; 0x54ac <csp_service_handler+0x37e>
    54b2:	31 97       	sbiw	r30, 0x01	; 1
    54b4:	e8 1b       	sub	r30, r24
    54b6:	f9 0b       	sbc	r31, r25
    54b8:	f9 87       	std	Y+9, r31	; 0x09
    54ba:	e8 87       	std	Y+8, r30	; 0x08
			/* Break and let the default handling send packet */
			break;
    54bc:	8c c0       	rjmp	.+280    	; 0x55d6 <csp_service_handler+0x4a8>
		}

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    54be:	0e 94 54 18 	call	0x30a8	; 0x30a8 <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    54c2:	b8 01       	movw	r22, r16
    54c4:	c4 01       	movw	r24, r8
    54c6:	0e 94 d5 44 	call	0x89aa	; 0x89aa <strnlen>
    54ca:	5c 01       	movw	r10, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    54cc:	18 16       	cp	r1, r24
    54ce:	19 06       	cpc	r1, r25
    54d0:	9c f5       	brge	.+102    	; 0x5538 <csp_service_handler+0x40a>
    54d2:	c1 2c       	mov	r12, r1
    54d4:	d1 2c       	mov	r13, r1
    54d6:	61 2c       	mov	r6, r1
    54d8:	71 2c       	mov	r7, r1

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    54da:	20 97       	sbiw	r28, 0x00	; 0
    54dc:	39 f4       	brne	.+14     	; 0x54ec <csp_service_handler+0x3be>
				packet = csp_buffer_get(CSP_RPS_MTU);
    54de:	84 ec       	ldi	r24, 0xC4	; 196
    54e0:	90 e0       	ldi	r25, 0x00	; 0
    54e2:	0e 94 f9 19 	call	0x33f2	; 0x33f2 <csp_buffer_get>
    54e6:	ec 01       	movw	r28, r24
			if (packet == NULL)
    54e8:	89 2b       	or	r24, r25
    54ea:	31 f1       	breq	.+76     	; 0x5538 <csp_service_handler+0x40a>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    54ec:	85 01       	movw	r16, r10
    54ee:	0c 19       	sub	r16, r12
    54f0:	1d 09       	sbc	r17, r13
    54f2:	05 3c       	cpi	r16, 0xC5	; 197
    54f4:	11 05       	cpc	r17, r1
    54f6:	14 f0       	brlt	.+4      	; 0x54fc <csp_service_handler+0x3ce>
    54f8:	04 ec       	ldi	r16, 0xC4	; 196
    54fa:	10 e0       	ldi	r17, 0x00	; 0
    54fc:	19 87       	std	Y+9, r17	; 0x09
    54fe:	08 87       	std	Y+8, r16	; 0x08

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    5500:	b4 01       	movw	r22, r8
    5502:	6c 0d       	add	r22, r12
    5504:	7d 1d       	adc	r23, r13
    5506:	a8 01       	movw	r20, r16
    5508:	ce 01       	movw	r24, r28
    550a:	0e 96       	adiw	r24, 0x0e	; 14
    550c:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>
			i += packet->length;
    5510:	c0 0e       	add	r12, r16
    5512:	d1 1e       	adc	r13, r17
			if (!csp_send(conn, packet, 0))
    5514:	20 e0       	ldi	r18, 0x00	; 0
    5516:	30 e0       	ldi	r19, 0x00	; 0
    5518:	a9 01       	movw	r20, r18
    551a:	be 01       	movw	r22, r28
    551c:	c7 01       	movw	r24, r14
    551e:	db d8       	rcall	.-3658   	; 0x46d6 <csp_send>
    5520:	89 2b       	or	r24, r25
    5522:	19 f4       	brne	.+6      	; 0x552a <csp_service_handler+0x3fc>
				csp_buffer_free(packet);
    5524:	ce 01       	movw	r24, r28
    5526:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    552a:	c6 2d       	mov	r28, r6
    552c:	d7 2d       	mov	r29, r7
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    552e:	ca 14       	cp	r12, r10
    5530:	db 04       	cpc	r13, r11
    5532:	9c f2       	brlt	.-90     	; 0x54da <csp_service_handler+0x3ac>
    5534:	c0 e0       	ldi	r28, 0x00	; 0
    5536:	d0 e0       	ldi	r29, 0x00	; 0

			/* Clear the packet reference when sent */
			packet = NULL;

		}
		csp_free(pslist);
    5538:	c4 01       	movw	r24, r8
    553a:	0e 94 75 17 	call	0x2eea	; 0x2eea <csp_free>
		break;
    553e:	4b c0       	rjmp	.+150    	; 0x55d6 <csp_service_handler+0x4a8>
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    5540:	0e 94 60 18 	call	0x30c0	; 0x30c0 <csp_sys_memfree>

		total = csp_hton32(total);
    5544:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    5548:	6e 87       	std	Y+14, r22	; 0x0e
    554a:	7f 87       	std	Y+15, r23	; 0x0f
    554c:	88 8b       	std	Y+16, r24	; 0x10
    554e:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    5550:	84 e0       	ldi	r24, 0x04	; 4
    5552:	90 e0       	ldi	r25, 0x00	; 0
    5554:	99 87       	std	Y+9, r25	; 0x09
    5556:	88 87       	std	Y+8, r24	; 0x08
    5558:	3e c0       	rjmp	.+124    	; 0x55d6 <csp_service_handler+0x4a8>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    555a:	6e 85       	ldd	r22, Y+14	; 0x0e
    555c:	7f 85       	ldd	r23, Y+15	; 0x0f
    555e:	88 89       	ldd	r24, Y+16	; 0x10
    5560:	99 89       	ldd	r25, Y+17	; 0x11
    5562:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <csp_ntoh32>

		/* If the magic word is valid, reboot */
		if (magic_word == CSP_REBOOT_MAGIC) {
    5566:	67 30       	cpi	r22, 0x07	; 7
    5568:	e0 e8       	ldi	r30, 0x80	; 128
    556a:	7e 07       	cpc	r23, r30
    556c:	e7 e0       	ldi	r30, 0x07	; 7
    556e:	8e 07       	cpc	r24, r30
    5570:	e0 e8       	ldi	r30, 0x80	; 128
    5572:	9e 07       	cpc	r25, r30
    5574:	19 f4       	brne	.+6      	; 0x557c <csp_service_handler+0x44e>
			csp_sys_reboot();
    5576:	0e 94 b7 18 	call	0x316e	; 0x316e <csp_sys_reboot>
    557a:	07 c0       	rjmp	.+14     	; 0x558a <csp_service_handler+0x45c>
		} else if (magic_word == CSP_REBOOT_SHUTDOWN_MAGIC) {
    557c:	6a 39       	cpi	r22, 0x9A	; 154
    557e:	72 45       	sbci	r23, 0x52	; 82
    5580:	85 4e       	sbci	r24, 0xE5	; 229
    5582:	91 4d       	sbci	r25, 0xD1	; 209
    5584:	11 f4       	brne	.+4      	; 0x558a <csp_service_handler+0x45c>
			csp_sys_shutdown();
    5586:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <csp_sys_shutdown>
		}


		
		csp_buffer_free(packet);
    558a:	ce 01       	movw	r24, r28
    558c:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    5590:	36 c0       	rjmp	.+108    	; 0x55fe <csp_service_handler+0x4d0>
		return;
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    5592:	0e 94 23 1b 	call	0x3646	; 0x3646 <csp_buffer_remaining>
		size = csp_hton32(size);
    5596:	bc 01       	movw	r22, r24
    5598:	99 0f       	add	r25, r25
    559a:	88 0b       	sbc	r24, r24
    559c:	99 0b       	sbc	r25, r25
    559e:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    55a2:	6e 87       	std	Y+14, r22	; 0x0e
    55a4:	7f 87       	std	Y+15, r23	; 0x0f
    55a6:	88 8b       	std	Y+16, r24	; 0x10
    55a8:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(size);
    55aa:	84 e0       	ldi	r24, 0x04	; 4
    55ac:	90 e0       	ldi	r25, 0x00	; 0
    55ae:	99 87       	std	Y+9, r25	; 0x09
    55b0:	88 87       	std	Y+8, r24	; 0x08
    55b2:	11 c0       	rjmp	.+34     	; 0x55d6 <csp_service_handler+0x4a8>
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    55b4:	0e 94 5e 19 	call	0x32bc	; 0x32bc <csp_get_s>
		time = csp_hton32(time);
    55b8:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    55bc:	6e 87       	std	Y+14, r22	; 0x0e
    55be:	7f 87       	std	Y+15, r23	; 0x0f
    55c0:	88 8b       	std	Y+16, r24	; 0x10
    55c2:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    55c4:	84 e0       	ldi	r24, 0x04	; 4
    55c6:	90 e0       	ldi	r25, 0x00	; 0
    55c8:	99 87       	std	Y+9, r25	; 0x09
    55ca:	88 87       	std	Y+8, r24	; 0x08
    55cc:	04 c0       	rjmp	.+8      	; 0x55d6 <csp_service_handler+0x4a8>
		break;
	}

	default:
		csp_buffer_free(packet);
    55ce:	ce 01       	movw	r24, r28
    55d0:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
		return;
    55d4:	14 c0       	rjmp	.+40     	; 0x55fe <csp_service_handler+0x4d0>
	}

	if (packet != NULL) {
    55d6:	20 97       	sbiw	r28, 0x00	; 0
    55d8:	91 f0       	breq	.+36     	; 0x55fe <csp_service_handler+0x4d0>
		if (!csp_send(conn, packet, 0))
    55da:	20 e0       	ldi	r18, 0x00	; 0
    55dc:	30 e0       	ldi	r19, 0x00	; 0
    55de:	a9 01       	movw	r20, r18
    55e0:	be 01       	movw	r22, r28
    55e2:	c7 01       	movw	r24, r14
    55e4:	78 d8       	rcall	.-3856   	; 0x46d6 <csp_send>
    55e6:	89 2b       	or	r24, r25
    55e8:	51 f4       	brne	.+20     	; 0x55fe <csp_service_handler+0x4d0>
			csp_buffer_free(packet);
    55ea:	ce 01       	movw	r24, r28
    55ec:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
    55f0:	06 c0       	rjmp	.+12     	; 0x55fe <csp_service_handler+0x4d0>
		default:
			ret = CSP_ERR_INVAL;
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    55f2:	8f ef       	ldi	r24, 0xFF	; 255
    55f4:	8e 87       	std	Y+14, r24	; 0x0e
    55f6:	2c cf       	rjmp	.-424    	; 0x5450 <csp_service_handler+0x322>
    55f8:	8f ef       	ldi	r24, 0xFF	; 255
    55fa:	8e 87       	std	Y+14, r24	; 0x0e
    55fc:	ec cf       	rjmp	.-40     	; 0x55d6 <csp_service_handler+0x4a8>
	if (packet != NULL) {
		if (!csp_send(conn, packet, 0))
			csp_buffer_free(packet);
	}

}
    55fe:	df 91       	pop	r29
    5600:	cf 91       	pop	r28
    5602:	1f 91       	pop	r17
    5604:	0f 91       	pop	r16
    5606:	ff 90       	pop	r15
    5608:	ef 90       	pop	r14
    560a:	df 90       	pop	r13
    560c:	cf 90       	pop	r12
    560e:	bf 90       	pop	r11
    5610:	af 90       	pop	r10
    5612:	9f 90       	pop	r9
    5614:	8f 90       	pop	r8
    5616:	7f 90       	pop	r7
    5618:	6f 90       	pop	r6
    561a:	08 95       	ret

0000561c <csp_can_pbuf_free>:
{
	buf->last_used = csp_get_ms();
}

static int csp_can_pbuf_free(csp_can_pbuf_element_t *buf)
{
    561c:	cf 93       	push	r28
    561e:	df 93       	push	r29
    5620:	ec 01       	movw	r28, r24
	/* Free CSP packet */
	if (buf->packet != NULL)
    5622:	8a 85       	ldd	r24, Y+10	; 0x0a
    5624:	9b 85       	ldd	r25, Y+11	; 0x0b
    5626:	00 97       	sbiw	r24, 0x00	; 0
    5628:	11 f0       	breq	.+4      	; 0x562e <csp_can_pbuf_free+0x12>
		csp_buffer_free(buf->packet);
    562a:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>

	/* Mark buffer element free */
	buf->packet = NULL;
    562e:	1b 86       	std	Y+11, r1	; 0x0b
    5630:	1a 86       	std	Y+10, r1	; 0x0a
	buf->state = BUF_FREE;
    5632:	1c 86       	std	Y+12, r1	; 0x0c
	buf->rx_count = 0;
    5634:	19 82       	std	Y+1, r1	; 0x01
    5636:	18 82       	st	Y, r1
	buf->cfpid = 0;
    5638:	1e 82       	std	Y+6, r1	; 0x06
    563a:	1f 82       	std	Y+7, r1	; 0x07
    563c:	18 86       	std	Y+8, r1	; 0x08
    563e:	19 86       	std	Y+9, r1	; 0x09
	buf->last_used = 0;
    5640:	1d 86       	std	Y+13, r1	; 0x0d
    5642:	1e 86       	std	Y+14, r1	; 0x0e
    5644:	1f 86       	std	Y+15, r1	; 0x0f
    5646:	18 8a       	std	Y+16, r1	; 0x10
	buf->remain = 0;
    5648:	1a 82       	std	Y+2, r1	; 0x02
    564a:	1b 82       	std	Y+3, r1	; 0x03
    564c:	1c 82       	std	Y+4, r1	; 0x04
    564e:	1d 82       	std	Y+5, r1	; 0x05

	return CSP_ERR_NONE;
}
    5650:	80 e0       	ldi	r24, 0x00	; 0
    5652:	90 e0       	ldi	r25, 0x00	; 0
    5654:	df 91       	pop	r29
    5656:	cf 91       	pop	r28
    5658:	08 95       	ret

0000565a <csp_can_tx>:

	return CSP_ERR_NONE;
}

static int csp_can_tx(csp_iface_t *interface, csp_packet_t *packet, uint32_t timeout)
{
    565a:	2f 92       	push	r2
    565c:	3f 92       	push	r3
    565e:	4f 92       	push	r4
    5660:	5f 92       	push	r5
    5662:	6f 92       	push	r6
    5664:	7f 92       	push	r7
    5666:	8f 92       	push	r8
    5668:	9f 92       	push	r9
    566a:	af 92       	push	r10
    566c:	bf 92       	push	r11
    566e:	cf 92       	push	r12
    5670:	df 92       	push	r13
    5672:	ef 92       	push	r14
    5674:	ff 92       	push	r15
    5676:	0f 93       	push	r16
    5678:	1f 93       	push	r17
    567a:	cf 93       	push	r28
    567c:	df 93       	push	r29
    567e:	cd b7       	in	r28, 0x3d	; 61
    5680:	de b7       	in	r29, 0x3e	; 62
    5682:	60 97       	sbiw	r28, 0x10	; 16
    5684:	0f b6       	in	r0, 0x3f	; 63
    5686:	f8 94       	cli
    5688:	de bf       	out	0x3e, r29	; 62
    568a:	0f be       	out	0x3f, r0	; 63
    568c:	cd bf       	out	0x3d, r28	; 61
    568e:	7a 87       	std	Y+10, r23	; 0x0a
    5690:	69 87       	std	Y+9, r22	; 0x09
}

static int csp_can_id_get(void)
{
	int id;
	if (csp_bin_sem_wait(&csp_can_id_sem, 1000) != CSP_SEMAPHORE_OK)
    5692:	48 ee       	ldi	r20, 0xE8	; 232
    5694:	53 e0       	ldi	r21, 0x03	; 3
    5696:	60 e0       	ldi	r22, 0x00	; 0
    5698:	70 e0       	ldi	r23, 0x00	; 0
    569a:	87 e0       	ldi	r24, 0x07	; 7
    569c:	96 e0       	ldi	r25, 0x06	; 6
    569e:	0e 94 f6 17 	call	0x2fec	; 0x2fec <csp_bin_sem_wait>
    56a2:	01 97       	sbiw	r24, 0x01	; 1
    56a4:	89 f4       	brne	.+34     	; 0x56c8 <csp_can_tx+0x6e>
		return CSP_ERR_TIMEDOUT;
	id = csp_can_id++;
    56a6:	80 90 09 06 	lds	r8, 0x0609	; 0x800609 <csp_can_id>
    56aa:	90 90 0a 06 	lds	r9, 0x060A	; 0x80060a <csp_can_id+0x1>
	csp_can_id = csp_can_id & ((1 << CFP_ID_SIZE) - 1);
    56ae:	c4 01       	movw	r24, r8
    56b0:	01 96       	adiw	r24, 0x01	; 1
    56b2:	93 70       	andi	r25, 0x03	; 3
    56b4:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <csp_can_id+0x1>
    56b8:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <csp_can_id>
	csp_bin_sem_post(&csp_can_id_sem);
    56bc:	87 e0       	ldi	r24, 0x07	; 7
    56be:	96 e0       	ldi	r25, 0x06	; 6
    56c0:	0e 94 30 18 	call	0x3060	; 0x3060 <csp_bin_sem_post>
	uint8_t bytes, overhead, avail, dest;
	uint8_t frame_buf[8];

	/* Get CFP identification number */
	int ident = csp_can_id_get();
	if (ident < 0) {
    56c4:	99 20       	and	r9, r9
    56c6:	84 f4       	brge	.+32     	; 0x56e8 <csp_can_tx+0x8e>
		csp_log_warn("Failed to get CFP identification number");
    56c8:	82 e6       	ldi	r24, 0x62	; 98
    56ca:	90 e1       	ldi	r25, 0x10	; 16
    56cc:	9f 93       	push	r25
    56ce:	8f 93       	push	r24
    56d0:	81 e0       	ldi	r24, 0x01	; 1
    56d2:	8f 93       	push	r24
    56d4:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_INVAL;
    56d8:	0f 90       	pop	r0
    56da:	0f 90       	pop	r0
    56dc:	0f 90       	pop	r0
    56de:	4e ef       	ldi	r20, 0xFE	; 254
    56e0:	5f ef       	ldi	r21, 0xFF	; 255
    56e2:	58 8b       	std	Y+16, r21	; 0x10
    56e4:	4f 87       	std	Y+15, r20	; 0x0f
    56e6:	19 c1       	rjmp	.+562    	; 0x591a <csp_can_tx+0x2c0>

	/* Calculate overhead */
	overhead = sizeof(csp_id_t) + sizeof(uint16_t);

	/* Insert destination node mac address into the CFP destination field */
	dest = csp_rtable_find_mac(packet->id.dst);
    56e8:	a9 85       	ldd	r26, Y+9	; 0x09
    56ea:	ba 85       	ldd	r27, Y+10	; 0x0a
    56ec:	1c 96       	adiw	r26, 0x0c	; 12
    56ee:	9c 91       	ld	r25, X
    56f0:	1c 97       	sbiw	r26, 0x0c	; 12
    56f2:	92 95       	swap	r25
    56f4:	9f 70       	andi	r25, 0x0F	; 15
    56f6:	1d 96       	adiw	r26, 0x0d	; 13
    56f8:	8c 91       	ld	r24, X
    56fa:	81 70       	andi	r24, 0x01	; 1
    56fc:	82 95       	swap	r24
    56fe:	80 7f       	andi	r24, 0xF0	; 240
    5700:	89 2b       	or	r24, r25
    5702:	d3 d4       	rcall	.+2470   	; 0x60aa <csp_rtable_find_mac>
	if (dest == CSP_NODE_MAC)
    5704:	8f 3f       	cpi	r24, 0xFF	; 255
    5706:	59 f4       	brne	.+22     	; 0x571e <csp_can_tx+0xc4>
		dest = packet->id.dst;
    5708:	e9 85       	ldd	r30, Y+9	; 0x09
    570a:	fa 85       	ldd	r31, Y+10	; 0x0a
    570c:	84 85       	ldd	r24, Z+12	; 0x0c
    570e:	98 2f       	mov	r25, r24
    5710:	92 95       	swap	r25
    5712:	9f 70       	andi	r25, 0x0F	; 15
    5714:	85 85       	ldd	r24, Z+13	; 0x0d
    5716:	81 70       	andi	r24, 0x01	; 1
    5718:	82 95       	swap	r24
    571a:	80 7f       	andi	r24, 0xF0	; 240
    571c:	89 2b       	or	r24, r25

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
	id |= CFP_MAKE_DST(dest);
    571e:	8f 71       	andi	r24, 0x1F	; 31
    5720:	c8 2e       	mov	r12, r24
    5722:	d1 2c       	mov	r13, r1
    5724:	e1 2c       	mov	r14, r1
    5726:	f1 2c       	mov	r15, r1
    5728:	0b 2e       	mov	r0, r27
    572a:	b3 e1       	ldi	r27, 0x13	; 19
    572c:	cc 0c       	add	r12, r12
    572e:	dd 1c       	adc	r13, r13
    5730:	ee 1c       	adc	r14, r14
    5732:	ff 1c       	adc	r15, r15
    5734:	ba 95       	dec	r27
    5736:	d1 f7       	brne	.-12     	; 0x572c <csp_can_tx+0xd2>
    5738:	b0 2d       	mov	r27, r0
	id |= CFP_MAKE_ID(ident);
    573a:	f3 e0       	ldi	r31, 0x03	; 3
    573c:	9f 22       	and	r9, r31
    573e:	09 2c       	mov	r0, r9
    5740:	00 0c       	add	r0, r0
    5742:	aa 08       	sbc	r10, r10
    5744:	bb 08       	sbc	r11, r11
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    5746:	a9 85       	ldd	r26, Y+9	; 0x09
    5748:	ba 85       	ldd	r27, Y+10	; 0x0a
    574a:	18 96       	adiw	r26, 0x08	; 8
    574c:	2d 91       	ld	r18, X+
    574e:	3c 91       	ld	r19, X
    5750:	19 97       	sbiw	r26, 0x09	; 9
    5752:	c9 01       	movw	r24, r18
    5754:	05 96       	adiw	r24, 0x05	; 5
    5756:	96 95       	lsr	r25
    5758:	87 95       	ror	r24
    575a:	96 95       	lsr	r25
    575c:	87 95       	ror	r24
    575e:	96 95       	lsr	r25
    5760:	87 95       	ror	r24
    5762:	90 e0       	ldi	r25, 0x00	; 0
    5764:	a0 e0       	ldi	r26, 0x00	; 0
    5766:	b0 e0       	ldi	r27, 0x00	; 0
    5768:	07 2e       	mov	r0, r23
    576a:	7a e0       	ldi	r23, 0x0A	; 10
    576c:	88 0f       	add	r24, r24
    576e:	99 1f       	adc	r25, r25
    5770:	aa 1f       	adc	r26, r26
    5772:	bb 1f       	adc	r27, r27
    5774:	7a 95       	dec	r23
    5776:	d1 f7       	brne	.-12     	; 0x576c <csp_can_tx+0x112>
    5778:	70 2d       	mov	r23, r0
	if (dest == CSP_NODE_MAC)
		dest = packet->id.dst;

	/* Create CAN identifier */
	can_id_t id = 0;
	id |= CFP_MAKE_SRC(packet->id.src);
    577a:	e9 85       	ldd	r30, Y+9	; 0x09
    577c:	fa 85       	ldd	r31, Y+10	; 0x0a
    577e:	45 85       	ldd	r20, Z+13	; 0x0d
    5780:	46 95       	lsr	r20
    5782:	4f 71       	andi	r20, 0x1F	; 31
	id |= CFP_MAKE_DST(dest);
	id |= CFP_MAKE_ID(ident);
	id |= CFP_MAKE_TYPE(CFP_BEGIN);
	id |= CFP_MAKE_REMAIN((packet->length + overhead - 1) / 8);
    5784:	24 01       	movw	r4, r8
    5786:	35 01       	movw	r6, r10
    5788:	74 2a       	or	r7, r20
    578a:	84 29       	or	r24, r4
    578c:	95 29       	or	r25, r5
    578e:	a6 29       	or	r26, r6
    5790:	b7 29       	or	r27, r7
    5792:	2c 01       	movw	r4, r24
    5794:	3d 01       	movw	r6, r26
    5796:	4c 28       	or	r4, r12
    5798:	5d 28       	or	r5, r13
    579a:	6e 28       	or	r6, r14
    579c:	7f 28       	or	r7, r15
    579e:	4b 86       	std	Y+11, r4	; 0x0b
    57a0:	5c 86       	std	Y+12, r5	; 0x0c
    57a2:	6d 86       	std	Y+13, r6	; 0x0d
    57a4:	7e 86       	std	Y+14, r7	; 0x0e

	/* Calculate first frame data bytes */
	avail = 8 - overhead;
	bytes = (packet->length <= avail) ? packet->length : avail;
    57a6:	39 01       	movw	r6, r18
    57a8:	23 30       	cpi	r18, 0x03	; 3
    57aa:	31 05       	cpc	r19, r1
    57ac:	20 f0       	brcs	.+8      	; 0x57b6 <csp_can_tx+0x15c>
    57ae:	68 94       	set
    57b0:	66 24       	eor	r6, r6
    57b2:	61 f8       	bld	r6, 1
    57b4:	71 2c       	mov	r7, r1

	/* Copy CSP headers and data */
	uint32_t csp_id_be = csp_hton32(packet->id.ext);
    57b6:	a9 85       	ldd	r26, Y+9	; 0x09
    57b8:	ba 85       	ldd	r27, Y+10	; 0x0a
    57ba:	1a 96       	adiw	r26, 0x0a	; 10
    57bc:	6d 91       	ld	r22, X+
    57be:	7d 91       	ld	r23, X+
    57c0:	8d 91       	ld	r24, X+
    57c2:	9c 91       	ld	r25, X
    57c4:	1d 97       	sbiw	r26, 0x0d	; 13
    57c6:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <csp_hton32>
    57ca:	1b 01       	movw	r2, r22
    57cc:	2c 01       	movw	r4, r24
	uint16_t csp_length_be = csp_hton16(packet->length);
    57ce:	e9 85       	ldd	r30, Y+9	; 0x09
    57d0:	fa 85       	ldd	r31, Y+10	; 0x0a
    57d2:	80 85       	ldd	r24, Z+8	; 0x08
    57d4:	91 85       	ldd	r25, Z+9	; 0x09
    57d6:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <csp_hton16>

	memcpy(frame_buf, &csp_id_be, sizeof(csp_id_be));
    57da:	29 82       	std	Y+1, r2	; 0x01
    57dc:	3a 82       	std	Y+2, r3	; 0x02
    57de:	4b 82       	std	Y+3, r4	; 0x03
    57e0:	5c 82       	std	Y+4, r5	; 0x04
	memcpy(frame_buf + sizeof(csp_id_be), &csp_length_be, sizeof(csp_length_be));
    57e2:	9e 83       	std	Y+6, r25	; 0x06
    57e4:	8d 83       	std	Y+5, r24	; 0x05
    57e6:	83 01       	movw	r16, r6
    57e8:	11 27       	eor	r17, r17
	memcpy(frame_buf + overhead, packet->data, bytes);
    57ea:	29 84       	ldd	r2, Y+9	; 0x09
    57ec:	3a 84       	ldd	r3, Y+10	; 0x0a
    57ee:	fe e0       	ldi	r31, 0x0E	; 14
    57f0:	2f 0e       	add	r2, r31
    57f2:	31 1c       	adc	r3, r1
    57f4:	a8 01       	movw	r20, r16
    57f6:	b1 01       	movw	r22, r2
    57f8:	ce 01       	movw	r24, r28
    57fa:	07 96       	adiw	r24, 0x07	; 7
    57fc:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>

	/* Increment tx counter */
	tx_count = bytes;

	/* Send first frame */
	if (can_send(id, frame_buf, overhead + bytes)) {
    5800:	26 e0       	ldi	r18, 0x06	; 6
    5802:	26 0d       	add	r18, r6
    5804:	ae 01       	movw	r20, r28
    5806:	4f 5f       	subi	r20, 0xFF	; 255
    5808:	5f 4f       	sbci	r21, 0xFF	; 255
    580a:	6b 85       	ldd	r22, Y+11	; 0x0b
    580c:	7c 85       	ldd	r23, Y+12	; 0x0c
    580e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5810:	9e 85       	ldd	r25, Y+14	; 0x0e
    5812:	0e 94 92 10 	call	0x2124	; 0x2124 <can_send>
    5816:	98 8b       	std	Y+16, r25	; 0x10
    5818:	8f 87       	std	Y+15, r24	; 0x0f
    581a:	89 2b       	or	r24, r25
    581c:	09 f4       	brne	.+2      	; 0x5820 <csp_can_tx+0x1c6>
    581e:	70 c0       	rjmp	.+224    	; 0x5900 <csp_can_tx+0x2a6>
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
    5820:	8b e3       	ldi	r24, 0x3B	; 59
    5822:	90 e1       	ldi	r25, 0x10	; 16
    5824:	9f 93       	push	r25
    5826:	8f 93       	push	r24
    5828:	81 e0       	ldi	r24, 0x01	; 1
    582a:	8f 93       	push	r24
    582c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_DRIVER;
    5830:	0f 90       	pop	r0
    5832:	0f 90       	pop	r0
    5834:	0f 90       	pop	r0
    5836:	45 ef       	ldi	r20, 0xF5	; 245
    5838:	5f ef       	ldi	r21, 0xFF	; 255
    583a:	58 8b       	std	Y+16, r21	; 0x10
    583c:	4f 87       	std	Y+15, r20	; 0x0f
    583e:	6d c0       	rjmp	.+218    	; 0x591a <csp_can_tx+0x2c0>
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
		/* Calculate frame data bytes */
		bytes = (packet->length - tx_count >= 8) ? 8 : packet->length - tx_count;
    5840:	80 1b       	sub	r24, r16
    5842:	91 0b       	sbc	r25, r17
    5844:	fc 01       	movw	r30, r24
    5846:	89 30       	cpi	r24, 0x09	; 9
    5848:	91 05       	cpc	r25, r1
    584a:	10 f0       	brcs	.+4      	; 0x5850 <csp_can_tx+0x1f6>
    584c:	e8 e0       	ldi	r30, 0x08	; 8
    584e:	f0 e0       	ldi	r31, 0x00	; 0

		/* Prepare identifier */
		can_id_t id = 0;
		id |= CFP_MAKE_SRC(packet->id.src);
    5850:	a9 85       	ldd	r26, Y+9	; 0x09
    5852:	ba 85       	ldd	r27, Y+10	; 0x0a
    5854:	1d 96       	adiw	r26, 0x0d	; 13
    5856:	2c 91       	ld	r18, X
    5858:	26 95       	lsr	r18
    585a:	2f 71       	andi	r18, 0x1F	; 31
		id |= CFP_MAKE_DST(dest);
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
    585c:	24 01       	movw	r4, r8
    585e:	35 01       	movw	r6, r10
    5860:	72 2a       	or	r7, r18
    5862:	68 94       	set
    5864:	62 f8       	bld	r6, 2
    5866:	4c 28       	or	r4, r12
    5868:	5d 28       	or	r5, r13
    586a:	6e 28       	or	r6, r14
    586c:	7f 28       	or	r7, r15
    586e:	9f 01       	movw	r18, r30
    5870:	33 27       	eor	r19, r19
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    5872:	a8 01       	movw	r20, r16
    5874:	42 0f       	add	r20, r18
    5876:	53 1f       	adc	r21, r19
    5878:	5c 87       	std	Y+12, r21	; 0x0c
    587a:	4b 87       	std	Y+11, r20	; 0x0b

		/* Send frame */
		if (can_send(id, packet->data + tx_count - bytes, bytes)) {
    587c:	a1 01       	movw	r20, r2
    587e:	40 0f       	add	r20, r16
    5880:	51 1f       	adc	r21, r17
    5882:	07 96       	adiw	r24, 0x07	; 7
    5884:	82 1b       	sub	r24, r18
    5886:	93 0b       	sbc	r25, r19
    5888:	96 95       	lsr	r25
    588a:	87 95       	ror	r24
    588c:	96 95       	lsr	r25
    588e:	87 95       	ror	r24
    5890:	96 95       	lsr	r25
    5892:	87 95       	ror	r24
    5894:	90 e0       	ldi	r25, 0x00	; 0
    5896:	a0 e0       	ldi	r26, 0x00	; 0
    5898:	b0 e0       	ldi	r27, 0x00	; 0
    589a:	07 2e       	mov	r0, r23
    589c:	7a e0       	ldi	r23, 0x0A	; 10
    589e:	88 0f       	add	r24, r24
    58a0:	99 1f       	adc	r25, r25
    58a2:	aa 1f       	adc	r26, r26
    58a4:	bb 1f       	adc	r27, r27
    58a6:	7a 95       	dec	r23
    58a8:	d1 f7       	brne	.-12     	; 0x589e <csp_can_tx+0x244>
    58aa:	70 2d       	mov	r23, r0
    58ac:	bc 01       	movw	r22, r24
    58ae:	cd 01       	movw	r24, r26
    58b0:	64 29       	or	r22, r4
    58b2:	75 29       	or	r23, r5
    58b4:	86 29       	or	r24, r6
    58b6:	97 29       	or	r25, r7
    58b8:	2e 2f       	mov	r18, r30
    58ba:	0e 94 92 10 	call	0x2124	; 0x2124 <can_send>
    58be:	89 2b       	or	r24, r25
    58c0:	e9 f0       	breq	.+58     	; 0x58fc <csp_can_tx+0x2a2>
			csp_log_warn("Failed to send CAN frame in Tx callback");
    58c2:	83 e1       	ldi	r24, 0x13	; 19
    58c4:	90 e1       	ldi	r25, 0x10	; 16
    58c6:	9f 93       	push	r25
    58c8:	8f 93       	push	r24
    58ca:	81 e0       	ldi	r24, 0x01	; 1
    58cc:	8f 93       	push	r24
    58ce:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_if_can.tx_error++;
    58d2:	e6 e1       	ldi	r30, 0x16	; 22
    58d4:	f2 e0       	ldi	r31, 0x02	; 2
    58d6:	81 89       	ldd	r24, Z+17	; 0x11
    58d8:	92 89       	ldd	r25, Z+18	; 0x12
    58da:	a3 89       	ldd	r26, Z+19	; 0x13
    58dc:	b4 89       	ldd	r27, Z+20	; 0x14
    58de:	01 96       	adiw	r24, 0x01	; 1
    58e0:	a1 1d       	adc	r26, r1
    58e2:	b1 1d       	adc	r27, r1
    58e4:	81 8b       	std	Z+17, r24	; 0x11
    58e6:	92 8b       	std	Z+18, r25	; 0x12
    58e8:	a3 8b       	std	Z+19, r26	; 0x13
    58ea:	b4 8b       	std	Z+20, r27	; 0x14
			return CSP_ERR_DRIVER;
    58ec:	0f 90       	pop	r0
    58ee:	0f 90       	pop	r0
    58f0:	0f 90       	pop	r0
    58f2:	65 ef       	ldi	r22, 0xF5	; 245
    58f4:	7f ef       	ldi	r23, 0xFF	; 255
    58f6:	78 8b       	std	Y+16, r23	; 0x10
    58f8:	6f 87       	std	Y+15, r22	; 0x0f
    58fa:	0f c0       	rjmp	.+30     	; 0x591a <csp_can_tx+0x2c0>
		id |= CFP_MAKE_ID(ident);
		id |= CFP_MAKE_TYPE(CFP_MORE);
		id |= CFP_MAKE_REMAIN((packet->length - tx_count - bytes + 7) / 8);

		/* Increment tx counter */
		tx_count += bytes;
    58fc:	0b 85       	ldd	r16, Y+11	; 0x0b
    58fe:	1c 85       	ldd	r17, Y+12	; 0x0c
		csp_log_warn("Failed to send CAN frame in csp_tx_can");
		return CSP_ERR_DRIVER;
	}

	/* Send next frames if not complete */
	while (tx_count < packet->length) {
    5900:	a9 85       	ldd	r26, Y+9	; 0x09
    5902:	ba 85       	ldd	r27, Y+10	; 0x0a
    5904:	18 96       	adiw	r26, 0x08	; 8
    5906:	8d 91       	ld	r24, X+
    5908:	9c 91       	ld	r25, X
    590a:	19 97       	sbiw	r26, 0x09	; 9
    590c:	08 17       	cp	r16, r24
    590e:	19 07       	cpc	r17, r25
    5910:	08 f4       	brcc	.+2      	; 0x5914 <csp_can_tx+0x2ba>
    5912:	96 cf       	rjmp	.-212    	; 0x5840 <csp_can_tx+0x1e6>
			csp_if_can.tx_error++;
			return CSP_ERR_DRIVER;
		}
	}

	csp_buffer_free(packet);
    5914:	cd 01       	movw	r24, r26
    5916:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>

	return CSP_ERR_NONE;
}
    591a:	8f 85       	ldd	r24, Y+15	; 0x0f
    591c:	98 89       	ldd	r25, Y+16	; 0x10
    591e:	60 96       	adiw	r28, 0x10	; 16
    5920:	0f b6       	in	r0, 0x3f	; 63
    5922:	f8 94       	cli
    5924:	de bf       	out	0x3e, r29	; 62
    5926:	0f be       	out	0x3f, r0	; 63
    5928:	cd bf       	out	0x3d, r28	; 61
    592a:	df 91       	pop	r29
    592c:	cf 91       	pop	r28
    592e:	1f 91       	pop	r17
    5930:	0f 91       	pop	r16
    5932:	ff 90       	pop	r15
    5934:	ef 90       	pop	r14
    5936:	df 90       	pop	r13
    5938:	cf 90       	pop	r12
    593a:	bf 90       	pop	r11
    593c:	af 90       	pop	r10
    593e:	9f 90       	pop	r9
    5940:	8f 90       	pop	r8
    5942:	7f 90       	pop	r7
    5944:	6f 90       	pop	r6
    5946:	5f 90       	pop	r5
    5948:	4f 90       	pop	r4
    594a:	3f 90       	pop	r3
    594c:	2f 90       	pop	r2
    594e:	08 95       	ret

00005950 <csp_can_rx_task>:

	return CSP_ERR_NONE;
}

static CSP_DEFINE_TASK(csp_can_rx_task)
{
    5950:	cf 93       	push	r28
    5952:	df 93       	push	r29
    5954:	cd b7       	in	r28, 0x3d	; 61
    5956:	de b7       	in	r29, 0x3e	; 62
    5958:	2d 97       	sbiw	r28, 0x0d	; 13
    595a:	0f b6       	in	r0, 0x3f	; 63
    595c:	f8 94       	cli
    595e:	de bf       	out	0x3e, r29	; 62
    5960:	0f be       	out	0x3f, r0	; 63
    5962:	cd bf       	out	0x3d, r28	; 61
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    5964:	0f 2e       	mov	r0, r31
    5966:	f9 e5       	ldi	r31, 0x59	; 89
    5968:	2f 2e       	mov	r2, r31
    596a:	f5 e0       	ldi	r31, 0x05	; 5
    596c:	3f 2e       	mov	r3, r31
    596e:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    5970:	0f 2e       	mov	r0, r31
    5972:	fc e9       	ldi	r31, 0x9C	; 156
    5974:	ef 2e       	mov	r14, r31
    5976:	f1 e1       	ldi	r31, 0x11	; 17
    5978:	ff 2e       	mov	r15, r31
    597a:	f0 2d       	mov	r31, r0
	can_frame_t frame;

	while (1) {
		//csp_log_info("%s %d\n",pcTaskGetName(NULL),uxTaskGetStackHighWaterMark2(NULL));
		
		ret = csp_queue_dequeue(csp_can_rx_queue, &frame, 1000);
    597c:	28 ee       	ldi	r18, 0xE8	; 232
    597e:	33 e0       	ldi	r19, 0x03	; 3
    5980:	40 e0       	ldi	r20, 0x00	; 0
    5982:	50 e0       	ldi	r21, 0x00	; 0
    5984:	be 01       	movw	r22, r28
    5986:	6f 5f       	subi	r22, 0xFF	; 255
    5988:	7f 4f       	sbci	r23, 0xFF	; 255
    598a:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <csp_can_rx_queue>
    598e:	90 91 04 06 	lds	r25, 0x0604	; 0x800604 <csp_can_rx_queue+0x1>
    5992:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <csp_queue_dequeue>
		if (ret != CSP_QUEUE_OK) {
    5996:	01 97       	sbiw	r24, 0x01	; 1
    5998:	91 f1       	breq	.+100    	; 0x59fe <csp_can_rx_task+0xae>
    599a:	09 e5       	ldi	r16, 0x59	; 89
    599c:	15 e0       	ldi	r17, 0x05	; 5
    599e:	0f 2e       	mov	r0, r31
    59a0:	f3 e0       	ldi	r31, 0x03	; 3
    59a2:	cf 2e       	mov	r12, r31
    59a4:	f6 e0       	ldi	r31, 0x06	; 6
    59a6:	df 2e       	mov	r13, r31
    59a8:	f0 2d       	mov	r31, r0
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
			csp_log_warn("CAN Buffer element timed out");
    59aa:	99 24       	eor	r9, r9
    59ac:	93 94       	inc	r9

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];

		/* Skip if not used */
		if (buf->state != BUF_USED)
    59ae:	d8 01       	movw	r26, r16
    59b0:	1c 96       	adiw	r26, 0x0c	; 12
    59b2:	8c 91       	ld	r24, X
    59b4:	81 30       	cpi	r24, 0x01	; 1
    59b6:	e9 f4       	brne	.+58     	; 0x59f2 <csp_can_rx_task+0xa2>
			continue;

		/* Check timeout */
		uint32_t now = csp_get_ms();
    59b8:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
		if (now - buf->last_used > PBUF_TIMEOUT_MS) {
    59bc:	f8 01       	movw	r30, r16
    59be:	45 84       	ldd	r4, Z+13	; 0x0d
    59c0:	56 84       	ldd	r5, Z+14	; 0x0e
    59c2:	67 84       	ldd	r6, Z+15	; 0x0f
    59c4:	70 88       	ldd	r7, Z+16	; 0x10
    59c6:	dc 01       	movw	r26, r24
    59c8:	cb 01       	movw	r24, r22
    59ca:	84 19       	sub	r24, r4
    59cc:	95 09       	sbc	r25, r5
    59ce:	a6 09       	sbc	r26, r6
    59d0:	b7 09       	sbc	r27, r7
    59d2:	81 3d       	cpi	r24, 0xD1	; 209
    59d4:	97 40       	sbci	r25, 0x07	; 7
    59d6:	a1 05       	cpc	r26, r1
    59d8:	b1 05       	cpc	r27, r1
    59da:	58 f0       	brcs	.+22     	; 0x59f2 <csp_can_rx_task+0xa2>
			csp_log_warn("CAN Buffer element timed out");
    59dc:	ff 92       	push	r15
    59de:	ef 92       	push	r14
    59e0:	9f 92       	push	r9
    59e2:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			/* Recycle packet buffer */
			csp_can_pbuf_free(buf);
    59e6:	80 2f       	mov	r24, r16
    59e8:	91 2f       	mov	r25, r17
    59ea:	18 de       	rcall	.-976    	; 0x561c <csp_can_pbuf_free>
    59ec:	0f 90       	pop	r0
    59ee:	0f 90       	pop	r0
    59f0:	0f 90       	pop	r0
    59f2:	0f 5e       	subi	r16, 0xEF	; 239
    59f4:	1f 4f       	sbci	r17, 0xFF	; 255
static void csp_can_pbuf_cleanup(void)
{
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    59f6:	c0 16       	cp	r12, r16
    59f8:	d1 06       	cpc	r13, r17
    59fa:	c9 f6       	brne	.-78     	; 0x59ae <csp_can_rx_task+0x5e>
    59fc:	bf cf       	rjmp	.-130    	; 0x597c <csp_can_rx_task+0x2c>
static int csp_can_process_frame(can_frame_t *frame)
{
	csp_can_pbuf_element_t *buf;
	uint8_t offset;

	can_id_t id = frame->id;
    59fe:	89 80       	ldd	r8, Y+1	; 0x01
    5a00:	9a 80       	ldd	r9, Y+2	; 0x02
    5a02:	ab 80       	ldd	r10, Y+3	; 0x03
    5a04:	bc 80       	ldd	r11, Y+4	; 0x04
    5a06:	ef e5       	ldi	r30, 0x5F	; 95
    5a08:	f5 e0       	ldi	r31, 0x05	; 5
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    5a0a:	80 e0       	ldi	r24, 0x00	; 0
    5a0c:	90 e0       	ldi	r25, 0x00	; 0
		buf = &csp_can_pbuf[i];

		if ((buf->state == BUF_USED) && ((buf->cfpid & mask) == (id & mask))) {
    5a0e:	26 81       	ldd	r18, Z+6	; 0x06
    5a10:	21 30       	cpi	r18, 0x01	; 1
    5a12:	d1 f5       	brne	.+116    	; 0x5a88 <csp_can_rx_task+0x138>
    5a14:	40 81       	ld	r20, Z
    5a16:	51 81       	ldd	r21, Z+1	; 0x01
    5a18:	62 81       	ldd	r22, Z+2	; 0x02
    5a1a:	73 81       	ldd	r23, Z+3	; 0x03
    5a1c:	48 25       	eor	r20, r8
    5a1e:	59 25       	eor	r21, r9
    5a20:	6a 25       	eor	r22, r10
    5a22:	7b 25       	eor	r23, r11
    5a24:	53 70       	andi	r21, 0x03	; 3
    5a26:	68 7f       	andi	r22, 0xF8	; 248
    5a28:	7f 71       	andi	r23, 0x1F	; 31
    5a2a:	45 2b       	or	r20, r21
    5a2c:	46 2b       	or	r20, r22
    5a2e:	47 2b       	or	r20, r23
    5a30:	59 f5       	brne	.+86     	; 0x5a88 <csp_can_rx_task+0x138>
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    5a32:	21 e1       	ldi	r18, 0x11	; 17
    5a34:	28 9f       	mul	r18, r24
    5a36:	80 01       	movw	r16, r0
    5a38:	29 9f       	mul	r18, r25
    5a3a:	10 0d       	add	r17, r0
    5a3c:	11 24       	eor	r1, r1
    5a3e:	07 5a       	subi	r16, 0xA7	; 167
    5a40:	1a 4f       	sbci	r17, 0xFA	; 250
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    5a42:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    5a46:	d8 01       	movw	r26, r16
    5a48:	1d 96       	adiw	r26, 0x0d	; 13
    5a4a:	6d 93       	st	X+, r22
    5a4c:	7d 93       	st	X+, r23
    5a4e:	8d 93       	st	X+, r24
    5a50:	9c 93       	st	X, r25
    5a52:	50 97       	sbiw	r26, 0x10	; 16
	}

	/* Reset frame data offset */
	offset = 0;

	switch (CFP_TYPE(id)) {
    5a54:	d5 01       	movw	r26, r10
    5a56:	c4 01       	movw	r24, r8
    5a58:	07 2e       	mov	r0, r23
    5a5a:	72 e1       	ldi	r23, 0x12	; 18
    5a5c:	b6 95       	lsr	r27
    5a5e:	a7 95       	ror	r26
    5a60:	97 95       	ror	r25
    5a62:	87 95       	ror	r24
    5a64:	7a 95       	dec	r23
    5a66:	d1 f7       	brne	.-12     	; 0x5a5c <csp_can_rx_task+0x10c>
    5a68:	70 2d       	mov	r23, r0
    5a6a:	ac 01       	movw	r20, r24
    5a6c:	bd 01       	movw	r22, r26
    5a6e:	41 70       	andi	r20, 0x01	; 1
    5a70:	55 27       	eor	r21, r21
    5a72:	66 27       	eor	r22, r22
    5a74:	77 27       	eor	r23, r23
    5a76:	80 ff       	sbrs	r24, 0
    5a78:	72 c0       	rjmp	.+228    	; 0x5b5e <csp_can_rx_task+0x20e>
    5a7a:	41 30       	cpi	r20, 0x01	; 1
    5a7c:	51 05       	cpc	r21, r1
    5a7e:	61 05       	cpc	r22, r1
    5a80:	71 05       	cpc	r23, r1
    5a82:	09 f4       	brne	.+2      	; 0x5a86 <csp_can_rx_task+0x136>
    5a84:	1f c1       	rjmp	.+574    	; 0x5cc4 <csp_can_rx_task+0x374>
    5a86:	b5 c1       	rjmp	.+874    	; 0x5df2 <csp_can_rx_task+0x4a2>
static csp_can_pbuf_element_t *csp_can_pbuf_find(uint32_t id, uint32_t mask)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    5a88:	01 96       	adiw	r24, 0x01	; 1
    5a8a:	71 96       	adiw	r30, 0x11	; 17
    5a8c:	8a 30       	cpi	r24, 0x0A	; 10
    5a8e:	91 05       	cpc	r25, r1
    5a90:	09 f0       	breq	.+2      	; 0x5a94 <csp_can_rx_task+0x144>
    5a92:	bd cf       	rjmp	.-134    	; 0x5a0e <csp_can_rx_task+0xbe>
	/* Bind incoming frame to a packet buffer */
	buf = csp_can_pbuf_find(id, CFP_ID_CONN_MASK);

	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
    5a94:	a2 fc       	sbrc	r10, 2
    5a96:	4a c0       	rjmp	.+148    	; 0x5b2c <csp_can_rx_task+0x1dc>
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    5a98:	f1 01       	movw	r30, r2
    5a9a:	84 85       	ldd	r24, Z+12	; 0x0c
    5a9c:	88 23       	and	r24, r24
    5a9e:	09 f4       	brne	.+2      	; 0x5aa2 <csp_can_rx_task+0x152>
    5aa0:	b6 c1       	rjmp	.+876    	; 0x5e0e <csp_can_rx_task+0x4be>
    5aa2:	e9 e5       	ldi	r30, 0x59	; 89
    5aa4:	f5 e0       	ldi	r31, 0x05	; 5
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    5aa6:	81 e0       	ldi	r24, 0x01	; 1
    5aa8:	90 e0       	ldi	r25, 0x00	; 0
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
    5aaa:	25 8d       	ldd	r18, Z+29	; 0x1d
    5aac:	21 11       	cpse	r18, r1
    5aae:	20 c0       	rjmp	.+64     	; 0x5af0 <csp_can_rx_task+0x1a0>
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    5ab0:	21 e1       	ldi	r18, 0x11	; 17
    5ab2:	28 9f       	mul	r18, r24
    5ab4:	80 01       	movw	r16, r0
    5ab6:	29 9f       	mul	r18, r25
    5ab8:	10 0d       	add	r17, r0
    5aba:	11 24       	eor	r1, r1
    5abc:	07 5a       	subi	r16, 0xA7	; 167
    5abe:	1a 4f       	sbci	r17, 0xFA	; 250
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    5ac0:	81 e0       	ldi	r24, 0x01	; 1
    5ac2:	d8 01       	movw	r26, r16
    5ac4:	1c 96       	adiw	r26, 0x0c	; 12
    5ac6:	8c 93       	st	X, r24
    5ac8:	1c 97       	sbiw	r26, 0x0c	; 12
			buf->cfpid = id;
    5aca:	f8 01       	movw	r30, r16
    5acc:	86 82       	std	Z+6, r8	; 0x06
    5ace:	97 82       	std	Z+7, r9	; 0x07
    5ad0:	a0 86       	std	Z+8, r10	; 0x08
    5ad2:	b1 86       	std	Z+9, r11	; 0x09
			buf->remain = 0;
    5ad4:	12 96       	adiw	r26, 0x02	; 2
    5ad6:	1d 92       	st	X+, r1
    5ad8:	1d 92       	st	X+, r1
    5ada:	1d 92       	st	X+, r1
    5adc:	1c 92       	st	X, r1
    5ade:	15 97       	sbiw	r26, 0x05	; 5
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    5ae0:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    5ae4:	f8 01       	movw	r30, r16
    5ae6:	65 87       	std	Z+13, r22	; 0x0d
    5ae8:	76 87       	std	Z+14, r23	; 0x0e
    5aea:	87 87       	std	Z+15, r24	; 0x0f
    5aec:	90 8b       	std	Z+16, r25	; 0x10
    5aee:	37 c0       	rjmp	.+110    	; 0x5b5e <csp_can_rx_task+0x20e>
static csp_can_pbuf_element_t *csp_can_pbuf_new(uint32_t id)
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    5af0:	01 96       	adiw	r24, 0x01	; 1
    5af2:	71 96       	adiw	r30, 0x11	; 17
    5af4:	8a 30       	cpi	r24, 0x0A	; 10
    5af6:	91 05       	cpc	r25, r1
    5af8:	c1 f6       	brne	.-80     	; 0x5aaa <csp_can_rx_task+0x15a>
	/* Check returned buffer */
	if (buf == NULL) {
		if (CFP_TYPE(id) == CFP_BEGIN) {
			buf = csp_can_pbuf_new(id);
			if (buf == NULL) {
				csp_log_warn("No available packet buffer for CAN");
    5afa:	29 e7       	ldi	r18, 0x79	; 121
    5afc:	31 e1       	ldi	r19, 0x11	; 17
    5afe:	3f 93       	push	r19
    5b00:	2f 93       	push	r18
    5b02:	81 e0       	ldi	r24, 0x01	; 1
    5b04:	8f 93       	push	r24
    5b06:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
				csp_if_can.rx_error++;
    5b0a:	e6 e1       	ldi	r30, 0x16	; 22
    5b0c:	f2 e0       	ldi	r31, 0x02	; 2
    5b0e:	85 89       	ldd	r24, Z+21	; 0x15
    5b10:	96 89       	ldd	r25, Z+22	; 0x16
    5b12:	a7 89       	ldd	r26, Z+23	; 0x17
    5b14:	b0 8d       	ldd	r27, Z+24	; 0x18
    5b16:	01 96       	adiw	r24, 0x01	; 1
    5b18:	a1 1d       	adc	r26, r1
    5b1a:	b1 1d       	adc	r27, r1
    5b1c:	85 8b       	std	Z+21, r24	; 0x15
    5b1e:	96 8b       	std	Z+22, r25	; 0x16
    5b20:	a7 8b       	std	Z+23, r26	; 0x17
    5b22:	b0 8f       	std	Z+24, r27	; 0x18
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
    5b28:	0f 90       	pop	r0
    5b2a:	28 cf       	rjmp	.-432    	; 0x597c <csp_can_rx_task+0x2c>
				return CSP_ERR_NOMEM;
			}
		} else {
			csp_log_warn("Out of order MORE frame received");
    5b2c:	a8 e5       	ldi	r26, 0x58	; 88
    5b2e:	b1 e1       	ldi	r27, 0x11	; 17
    5b30:	bf 93       	push	r27
    5b32:	af 93       	push	r26
    5b34:	81 e0       	ldi	r24, 0x01	; 1
    5b36:	8f 93       	push	r24
    5b38:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_if_can.frame++;
    5b3c:	e6 e1       	ldi	r30, 0x16	; 22
    5b3e:	f2 e0       	ldi	r31, 0x02	; 2
    5b40:	81 a1       	ldd	r24, Z+33	; 0x21
    5b42:	92 a1       	ldd	r25, Z+34	; 0x22
    5b44:	a3 a1       	ldd	r26, Z+35	; 0x23
    5b46:	b4 a1       	ldd	r27, Z+36	; 0x24
    5b48:	01 96       	adiw	r24, 0x01	; 1
    5b4a:	a1 1d       	adc	r26, r1
    5b4c:	b1 1d       	adc	r27, r1
    5b4e:	81 a3       	std	Z+33, r24	; 0x21
    5b50:	92 a3       	std	Z+34, r25	; 0x22
    5b52:	a3 a3       	std	Z+35, r26	; 0x23
    5b54:	b4 a3       	std	Z+36, r27	; 0x24
    5b56:	0f 90       	pop	r0
    5b58:	0f 90       	pop	r0
    5b5a:	0f 90       	pop	r0
    5b5c:	0f cf       	rjmp	.-482    	; 0x597c <csp_can_rx_task+0x2c>
	switch (CFP_TYPE(id)) {

	case CFP_BEGIN:

		/* Discard packet if DLC is less than CSP id + CSP length fields */
		if (frame->dlc < sizeof(csp_id_t) + sizeof(uint16_t)) {
    5b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b60:	86 30       	cpi	r24, 0x06	; 6
    5b62:	d8 f4       	brcc	.+54     	; 0x5b9a <csp_can_rx_task+0x24a>
			csp_log_warn("Short BEGIN frame received");
    5b64:	2d e3       	ldi	r18, 0x3D	; 61
    5b66:	31 e1       	ldi	r19, 0x11	; 17
    5b68:	3f 93       	push	r19
    5b6a:	2f 93       	push	r18
    5b6c:	81 e0       	ldi	r24, 0x01	; 1
    5b6e:	8f 93       	push	r24
    5b70:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_if_can.frame++;
    5b74:	e6 e1       	ldi	r30, 0x16	; 22
    5b76:	f2 e0       	ldi	r31, 0x02	; 2
    5b78:	81 a1       	ldd	r24, Z+33	; 0x21
    5b7a:	92 a1       	ldd	r25, Z+34	; 0x22
    5b7c:	a3 a1       	ldd	r26, Z+35	; 0x23
    5b7e:	b4 a1       	ldd	r27, Z+36	; 0x24
    5b80:	01 96       	adiw	r24, 0x01	; 1
    5b82:	a1 1d       	adc	r26, r1
    5b84:	b1 1d       	adc	r27, r1
    5b86:	81 a3       	std	Z+33, r24	; 0x21
    5b88:	92 a3       	std	Z+34, r25	; 0x22
    5b8a:	a3 a3       	std	Z+35, r26	; 0x23
    5b8c:	b4 a3       	std	Z+36, r27	; 0x24
			csp_can_pbuf_free(buf);
    5b8e:	c8 01       	movw	r24, r16
    5b90:	45 dd       	rcall	.-1398   	; 0x561c <csp_can_pbuf_free>
    5b92:	0f 90       	pop	r0
    5b94:	0f 90       	pop	r0
    5b96:	0f 90       	pop	r0
    5b98:	f1 ce       	rjmp	.-542    	; 0x597c <csp_can_rx_task+0x2c>
			break;
		}

		/* Check for incomplete frame */
		if (buf->packet != NULL) {
    5b9a:	d8 01       	movw	r26, r16
    5b9c:	1a 96       	adiw	r26, 0x0a	; 10
    5b9e:	8d 91       	ld	r24, X+
    5ba0:	9c 91       	ld	r25, X
    5ba2:	1b 97       	sbiw	r26, 0x0b	; 11
    5ba4:	89 2b       	or	r24, r25
    5ba6:	c9 f0       	breq	.+50     	; 0x5bda <csp_can_rx_task+0x28a>
			/* Reuse the buffer */
			csp_log_warn("Incomplete frame");
    5ba8:	ec e2       	ldi	r30, 0x2C	; 44
    5baa:	f1 e1       	ldi	r31, 0x11	; 17
    5bac:	ff 93       	push	r31
    5bae:	ef 93       	push	r30
    5bb0:	81 e0       	ldi	r24, 0x01	; 1
    5bb2:	8f 93       	push	r24
    5bb4:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_if_can.frame++;
    5bb8:	e6 e1       	ldi	r30, 0x16	; 22
    5bba:	f2 e0       	ldi	r31, 0x02	; 2
    5bbc:	81 a1       	ldd	r24, Z+33	; 0x21
    5bbe:	92 a1       	ldd	r25, Z+34	; 0x22
    5bc0:	a3 a1       	ldd	r26, Z+35	; 0x23
    5bc2:	b4 a1       	ldd	r27, Z+36	; 0x24
    5bc4:	01 96       	adiw	r24, 0x01	; 1
    5bc6:	a1 1d       	adc	r26, r1
    5bc8:	b1 1d       	adc	r27, r1
    5bca:	81 a3       	std	Z+33, r24	; 0x21
    5bcc:	92 a3       	std	Z+34, r25	; 0x22
    5bce:	a3 a3       	std	Z+35, r26	; 0x23
    5bd0:	b4 a3       	std	Z+36, r27	; 0x24
    5bd2:	0f 90       	pop	r0
    5bd4:	0f 90       	pop	r0
    5bd6:	0f 90       	pop	r0
    5bd8:	25 c0       	rjmp	.+74     	; 0x5c24 <csp_can_rx_task+0x2d4>
		} else {
			/* Allocate memory for frame */
			buf->packet = csp_buffer_get(CSP_CAN_MTU);
    5bda:	82 e3       	ldi	r24, 0x32	; 50
    5bdc:	90 e0       	ldi	r25, 0x00	; 0
    5bde:	0e 94 f9 19 	call	0x33f2	; 0x33f2 <csp_buffer_get>
    5be2:	d8 01       	movw	r26, r16
    5be4:	1b 96       	adiw	r26, 0x0b	; 11
    5be6:	9c 93       	st	X, r25
    5be8:	8e 93       	st	-X, r24
    5bea:	1a 97       	sbiw	r26, 0x0a	; 10
			if (buf->packet == NULL) {
    5bec:	89 2b       	or	r24, r25
    5bee:	d1 f4       	brne	.+52     	; 0x5c24 <csp_can_rx_task+0x2d4>
				csp_log_error("Failed to get buffer for CSP_BEGIN packet");
    5bf0:	e2 e0       	ldi	r30, 0x02	; 2
    5bf2:	f1 e1       	ldi	r31, 0x11	; 17
    5bf4:	ff 93       	push	r31
    5bf6:	ef 93       	push	r30
    5bf8:	1f 92       	push	r1
    5bfa:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
				csp_if_can.frame++;
    5bfe:	e6 e1       	ldi	r30, 0x16	; 22
    5c00:	f2 e0       	ldi	r31, 0x02	; 2
    5c02:	81 a1       	ldd	r24, Z+33	; 0x21
    5c04:	92 a1       	ldd	r25, Z+34	; 0x22
    5c06:	a3 a1       	ldd	r26, Z+35	; 0x23
    5c08:	b4 a1       	ldd	r27, Z+36	; 0x24
    5c0a:	01 96       	adiw	r24, 0x01	; 1
    5c0c:	a1 1d       	adc	r26, r1
    5c0e:	b1 1d       	adc	r27, r1
    5c10:	81 a3       	std	Z+33, r24	; 0x21
    5c12:	92 a3       	std	Z+34, r25	; 0x22
    5c14:	a3 a3       	std	Z+35, r26	; 0x23
				csp_can_pbuf_free(buf);
    5c16:	b4 a3       	std	Z+36, r27	; 0x24
    5c18:	c8 01       	movw	r24, r16
    5c1a:	00 dd       	rcall	.-1536   	; 0x561c <csp_can_pbuf_free>
    5c1c:	0f 90       	pop	r0
    5c1e:	0f 90       	pop	r0
    5c20:	0f 90       	pop	r0
    5c22:	ac ce       	rjmp	.-680    	; 0x597c <csp_can_rx_task+0x2c>
				break;
			}
		}

		/* Copy CSP identifier and length*/
		memcpy(&(buf->packet->id), frame->data, sizeof(csp_id_t));
    5c24:	d8 01       	movw	r26, r16
    5c26:	1a 96       	adiw	r26, 0x0a	; 10
    5c28:	ed 91       	ld	r30, X+
    5c2a:	fc 91       	ld	r31, X
    5c2c:	1b 97       	sbiw	r26, 0x0b	; 11
    5c2e:	8e 81       	ldd	r24, Y+6	; 0x06
    5c30:	9f 81       	ldd	r25, Y+7	; 0x07
    5c32:	93 87       	std	Z+11, r25	; 0x0b
    5c34:	82 87       	std	Z+10, r24	; 0x0a
    5c36:	88 85       	ldd	r24, Y+8	; 0x08
    5c38:	99 85       	ldd	r25, Y+9	; 0x09
    5c3a:	95 87       	std	Z+13, r25	; 0x0d
    5c3c:	84 87       	std	Z+12, r24	; 0x0c
		buf->packet->id.ext = csp_ntoh32(buf->packet->id.ext);
    5c3e:	1a 96       	adiw	r26, 0x0a	; 10
    5c40:	cd 90       	ld	r12, X+
    5c42:	dc 90       	ld	r13, X
    5c44:	1b 97       	sbiw	r26, 0x0b	; 11
    5c46:	f6 01       	movw	r30, r12
    5c48:	62 85       	ldd	r22, Z+10	; 0x0a
    5c4a:	73 85       	ldd	r23, Z+11	; 0x0b
    5c4c:	84 85       	ldd	r24, Z+12	; 0x0c
    5c4e:	95 85       	ldd	r25, Z+13	; 0x0d
    5c50:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <csp_ntoh32>
    5c54:	d6 01       	movw	r26, r12
    5c56:	1a 96       	adiw	r26, 0x0a	; 10
    5c58:	6d 93       	st	X+, r22
    5c5a:	7d 93       	st	X+, r23
    5c5c:	8d 93       	st	X+, r24
    5c5e:	9c 93       	st	X, r25
    5c60:	1d 97       	sbiw	r26, 0x0d	; 13
		memcpy(&(buf->packet->length), frame->data + sizeof(csp_id_t), sizeof(uint16_t));
    5c62:	d8 01       	movw	r26, r16
    5c64:	1a 96       	adiw	r26, 0x0a	; 10
    5c66:	ed 91       	ld	r30, X+
    5c68:	fc 91       	ld	r31, X
    5c6a:	1b 97       	sbiw	r26, 0x0b	; 11
    5c6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c70:	91 87       	std	Z+9, r25	; 0x09
    5c72:	80 87       	std	Z+8, r24	; 0x08
		buf->packet->length = csp_ntoh16(buf->packet->length);
    5c74:	1a 96       	adiw	r26, 0x0a	; 10
    5c76:	cd 90       	ld	r12, X+
    5c78:	dc 90       	ld	r13, X
    5c7a:	1b 97       	sbiw	r26, 0x0b	; 11
    5c7c:	f6 01       	movw	r30, r12
    5c7e:	80 85       	ldd	r24, Z+8	; 0x08
    5c80:	91 85       	ldd	r25, Z+9	; 0x09
    5c82:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <csp_ntoh16>
    5c86:	d6 01       	movw	r26, r12
    5c88:	19 96       	adiw	r26, 0x09	; 9
    5c8a:	9c 93       	st	X, r25
    5c8c:	8e 93       	st	-X, r24
    5c8e:	18 97       	sbiw	r26, 0x08	; 8

		/* Reset RX count */
		buf->rx_count = 0;
    5c90:	f8 01       	movw	r30, r16
    5c92:	11 82       	std	Z+1, r1	; 0x01
    5c94:	10 82       	st	Z, r1

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);

		/* Set remain field - increment to include begin packet */
		buf->remain = CFP_REMAIN(id) + 1;
    5c96:	d5 01       	movw	r26, r10
    5c98:	c4 01       	movw	r24, r8
    5c9a:	07 2e       	mov	r0, r23
    5c9c:	7a e0       	ldi	r23, 0x0A	; 10
    5c9e:	b6 95       	lsr	r27
    5ca0:	a7 95       	ror	r26
    5ca2:	97 95       	ror	r25
    5ca4:	87 95       	ror	r24
    5ca6:	7a 95       	dec	r23
    5ca8:	d1 f7       	brne	.-12     	; 0x5c9e <csp_can_rx_task+0x34e>
    5caa:	70 2d       	mov	r23, r0
    5cac:	99 27       	eor	r25, r25
    5cae:	aa 27       	eor	r26, r26
    5cb0:	bb 27       	eor	r27, r27
    5cb2:	01 96       	adiw	r24, 0x01	; 1
    5cb4:	a1 1d       	adc	r26, r1
    5cb6:	b1 1d       	adc	r27, r1
    5cb8:	82 83       	std	Z+2, r24	; 0x02
    5cba:	93 83       	std	Z+3, r25	; 0x03
    5cbc:	a4 83       	std	Z+4, r26	; 0x04
    5cbe:	b5 83       	std	Z+5, r27	; 0x05

		/* Reset RX count */
		buf->rx_count = 0;

		/* Set offset to prevent CSP header from being copied to CSP data */
		offset = sizeof(csp_id_t) + sizeof(uint16_t);
    5cc0:	26 e0       	ldi	r18, 0x06	; 6
    5cc2:	01 c0       	rjmp	.+2      	; 0x5cc6 <csp_can_rx_task+0x376>
			return CSP_ERR_INVAL;
		}
	}

	/* Reset frame data offset */
	offset = 0;
    5cc4:	20 e0       	ldi	r18, 0x00	; 0
		/* FALLTHROUGH */

	case CFP_MORE:

		/* Check 'remain' field match */
		if (CFP_REMAIN(id) != buf->remain - 1) {
    5cc6:	07 2e       	mov	r0, r23
    5cc8:	7a e0       	ldi	r23, 0x0A	; 10
    5cca:	b6 94       	lsr	r11
    5ccc:	a7 94       	ror	r10
    5cce:	97 94       	ror	r9
    5cd0:	87 94       	ror	r8
    5cd2:	7a 95       	dec	r23
    5cd4:	d1 f7       	brne	.-12     	; 0x5cca <csp_can_rx_task+0x37a>
    5cd6:	70 2d       	mov	r23, r0
    5cd8:	99 24       	eor	r9, r9
    5cda:	aa 24       	eor	r10, r10
    5cdc:	bb 24       	eor	r11, r11
    5cde:	f8 01       	movw	r30, r16
    5ce0:	82 81       	ldd	r24, Z+2	; 0x02
    5ce2:	93 81       	ldd	r25, Z+3	; 0x03
    5ce4:	a4 81       	ldd	r26, Z+4	; 0x04
    5ce6:	b5 81       	ldd	r27, Z+5	; 0x05
    5ce8:	01 97       	sbiw	r24, 0x01	; 1
    5cea:	a1 09       	sbc	r26, r1
    5cec:	b1 09       	sbc	r27, r1
    5cee:	88 16       	cp	r8, r24
    5cf0:	99 06       	cpc	r9, r25
    5cf2:	aa 06       	cpc	r10, r26
    5cf4:	bb 06       	cpc	r11, r27
    5cf6:	d1 f0       	breq	.+52     	; 0x5d2c <csp_can_rx_task+0x3dc>
			csp_log_error("CAN frame lost in CSP packet");
    5cf8:	25 ee       	ldi	r18, 0xE5	; 229
    5cfa:	30 e1       	ldi	r19, 0x10	; 16
    5cfc:	3f 93       	push	r19
    5cfe:	2f 93       	push	r18
    5d00:	1f 92       	push	r1
    5d02:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_can_pbuf_free(buf);
    5d06:	c8 01       	movw	r24, r16
    5d08:	89 dc       	rcall	.-1774   	; 0x561c <csp_can_pbuf_free>
			csp_if_can.frame++;
    5d0a:	e6 e1       	ldi	r30, 0x16	; 22
    5d0c:	f2 e0       	ldi	r31, 0x02	; 2
    5d0e:	81 a1       	ldd	r24, Z+33	; 0x21
    5d10:	92 a1       	ldd	r25, Z+34	; 0x22
    5d12:	a3 a1       	ldd	r26, Z+35	; 0x23
    5d14:	b4 a1       	ldd	r27, Z+36	; 0x24
    5d16:	01 96       	adiw	r24, 0x01	; 1
    5d18:	a1 1d       	adc	r26, r1
    5d1a:	b1 1d       	adc	r27, r1
    5d1c:	81 a3       	std	Z+33, r24	; 0x21
    5d1e:	92 a3       	std	Z+34, r25	; 0x22
    5d20:	a3 a3       	std	Z+35, r26	; 0x23
    5d22:	b4 a3       	std	Z+36, r27	; 0x24
    5d24:	0f 90       	pop	r0
    5d26:	0f 90       	pop	r0
    5d28:	0f 90       	pop	r0
    5d2a:	28 ce       	rjmp	.-944    	; 0x597c <csp_can_rx_task+0x2c>
			break;
		}

		/* Decrement remaining frames */
		buf->remain--;
    5d2c:	82 82       	std	Z+2, r8	; 0x02
    5d2e:	93 82       	std	Z+3, r9	; 0x03
    5d30:	a4 82       	std	Z+4, r10	; 0x04
    5d32:	b5 82       	std	Z+5, r11	; 0x05

		/* Check for overflow */
		if ((buf->rx_count + frame->dlc - offset) > buf->packet->length) {
    5d34:	80 81       	ld	r24, Z
    5d36:	91 81       	ldd	r25, Z+1	; 0x01
    5d38:	4d 81       	ldd	r20, Y+5	; 0x05
    5d3a:	62 2f       	mov	r22, r18
    5d3c:	70 e0       	ldi	r23, 0x00	; 0
    5d3e:	02 84       	ldd	r0, Z+10	; 0x0a
    5d40:	f3 85       	ldd	r31, Z+11	; 0x0b
    5d42:	e0 2d       	mov	r30, r0
    5d44:	dc 01       	movw	r26, r24
    5d46:	a4 0f       	add	r26, r20
    5d48:	b1 1d       	adc	r27, r1
    5d4a:	a6 1b       	sub	r26, r22
    5d4c:	b7 0b       	sbc	r27, r23
    5d4e:	c0 84       	ldd	r12, Z+8	; 0x08
    5d50:	d1 84       	ldd	r13, Z+9	; 0x09
    5d52:	ca 16       	cp	r12, r26
    5d54:	db 06       	cpc	r13, r27
    5d56:	d0 f4       	brcc	.+52     	; 0x5d8c <csp_can_rx_task+0x43c>
			csp_log_error("RX buffer overflow");
    5d58:	e2 ed       	ldi	r30, 0xD2	; 210
    5d5a:	f0 e1       	ldi	r31, 0x10	; 16
    5d5c:	ff 93       	push	r31
    5d5e:	ef 93       	push	r30
    5d60:	1f 92       	push	r1
    5d62:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_if_can.frame++;
    5d66:	e6 e1       	ldi	r30, 0x16	; 22
    5d68:	f2 e0       	ldi	r31, 0x02	; 2
    5d6a:	81 a1       	ldd	r24, Z+33	; 0x21
    5d6c:	92 a1       	ldd	r25, Z+34	; 0x22
    5d6e:	a3 a1       	ldd	r26, Z+35	; 0x23
    5d70:	b4 a1       	ldd	r27, Z+36	; 0x24
    5d72:	01 96       	adiw	r24, 0x01	; 1
    5d74:	a1 1d       	adc	r26, r1
    5d76:	b1 1d       	adc	r27, r1
    5d78:	81 a3       	std	Z+33, r24	; 0x21
    5d7a:	92 a3       	std	Z+34, r25	; 0x22
    5d7c:	a3 a3       	std	Z+35, r26	; 0x23
			csp_can_pbuf_free(buf);
    5d7e:	b4 a3       	std	Z+36, r27	; 0x24
    5d80:	c8 01       	movw	r24, r16
    5d82:	4c dc       	rcall	.-1896   	; 0x561c <csp_can_pbuf_free>
    5d84:	0f 90       	pop	r0
    5d86:	0f 90       	pop	r0
    5d88:	0f 90       	pop	r0
    5d8a:	f8 cd       	rjmp	.-1040   	; 0x597c <csp_can_rx_task+0x2c>
			break;
		}

		/* Copy dlc bytes into buffer */
		memcpy(&buf->packet->data[buf->rx_count], frame->data + offset, frame->dlc - offset);
    5d8c:	c2 2e       	mov	r12, r18
    5d8e:	d1 2c       	mov	r13, r1
    5d90:	0e 96       	adiw	r24, 0x0e	; 14
    5d92:	50 e0       	ldi	r21, 0x00	; 0
    5d94:	4c 19       	sub	r20, r12
    5d96:	5d 09       	sbc	r21, r13
    5d98:	a6 e0       	ldi	r26, 0x06	; 6
    5d9a:	b0 e0       	ldi	r27, 0x00	; 0
    5d9c:	ac 0f       	add	r26, r28
    5d9e:	bd 1f       	adc	r27, r29
    5da0:	6a 0f       	add	r22, r26
    5da2:	7b 1f       	adc	r23, r27
    5da4:	8e 0f       	add	r24, r30
    5da6:	9f 1f       	adc	r25, r31
    5da8:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>
		buf->rx_count += frame->dlc - offset;
    5dac:	8d 81       	ldd	r24, Y+5	; 0x05
    5dae:	90 e0       	ldi	r25, 0x00	; 0
    5db0:	8c 19       	sub	r24, r12
    5db2:	9d 09       	sbc	r25, r13
    5db4:	f8 01       	movw	r30, r16
    5db6:	20 81       	ld	r18, Z
    5db8:	31 81       	ldd	r19, Z+1	; 0x01
    5dba:	82 0f       	add	r24, r18
    5dbc:	93 1f       	adc	r25, r19
    5dbe:	91 83       	std	Z+1, r25	; 0x01
    5dc0:	80 83       	st	Z, r24

		/* Check if more data is expected */
		if (buf->rx_count != buf->packet->length)
    5dc2:	02 84       	ldd	r0, Z+10	; 0x0a
    5dc4:	f3 85       	ldd	r31, Z+11	; 0x0b
    5dc6:	e0 2d       	mov	r30, r0
    5dc8:	20 85       	ldd	r18, Z+8	; 0x08
    5dca:	31 85       	ldd	r19, Z+9	; 0x09
    5dcc:	82 17       	cp	r24, r18
    5dce:	93 07       	cpc	r25, r19
    5dd0:	09 f0       	breq	.+2      	; 0x5dd4 <csp_can_rx_task+0x484>
    5dd2:	d4 cd       	rjmp	.-1112   	; 0x597c <csp_can_rx_task+0x2c>
			break;

		/* Data is available */
		csp_new_packet(buf->packet, &csp_if_can, NULL);
    5dd4:	40 e0       	ldi	r20, 0x00	; 0
    5dd6:	50 e0       	ldi	r21, 0x00	; 0
    5dd8:	66 e1       	ldi	r22, 0x16	; 22
    5dda:	72 e0       	ldi	r23, 0x02	; 2
    5ddc:	cf 01       	movw	r24, r30
    5dde:	0e 94 8d 24 	call	0x491a	; 0x491a <csp_qfifo_write>

		/* Drop packet buffer reference */
		buf->packet = NULL;
    5de2:	d8 01       	movw	r26, r16
    5de4:	1b 96       	adiw	r26, 0x0b	; 11
    5de6:	1c 92       	st	X, r1
    5de8:	1e 92       	st	-X, r1

		/* Free packet buffer */
		csp_can_pbuf_free(buf);
    5dea:	1a 97       	sbiw	r26, 0x0a	; 10
    5dec:	c8 01       	movw	r24, r16
    5dee:	16 dc       	rcall	.-2004   	; 0x561c <csp_can_pbuf_free>
    5df0:	c5 cd       	rjmp	.-1142   	; 0x597c <csp_can_rx_task+0x2c>

		break;

	default:
		csp_log_warn("Received unknown CFP message type");
    5df2:	80 eb       	ldi	r24, 0xB0	; 176
    5df4:	90 e1       	ldi	r25, 0x10	; 16
    5df6:	9f 93       	push	r25
    5df8:	8f 93       	push	r24
    5dfa:	81 e0       	ldi	r24, 0x01	; 1
    5dfc:	8f 93       	push	r24
    5dfe:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		csp_can_pbuf_free(buf);
    5e02:	c8 01       	movw	r24, r16
    5e04:	0b dc       	rcall	.-2026   	; 0x561c <csp_can_pbuf_free>
    5e06:	0f 90       	pop	r0
    5e08:	0f 90       	pop	r0
    5e0a:	0f 90       	pop	r0
    5e0c:	b7 cd       	rjmp	.-1170   	; 0x597c <csp_can_rx_task+0x2c>
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		if (buf->state == BUF_FREE) {
			buf->state = BUF_USED;
    5e0e:	81 e0       	ldi	r24, 0x01	; 1
    5e10:	f1 01       	movw	r30, r2
    5e12:	84 87       	std	Z+12, r24	; 0x0c
			buf->cfpid = id;
    5e14:	86 82       	std	Z+6, r8	; 0x06
    5e16:	97 82       	std	Z+7, r9	; 0x07
    5e18:	a0 86       	std	Z+8, r10	; 0x08
    5e1a:	b1 86       	std	Z+9, r11	; 0x09
			buf->remain = 0;
    5e1c:	12 82       	std	Z+2, r1	; 0x02
    5e1e:	13 82       	std	Z+3, r1	; 0x03
    5e20:	14 82       	std	Z+4, r1	; 0x04
    5e22:	15 82       	std	Z+5, r1	; 0x05
	return CSP_ERR_NONE;
}

static void csp_can_pbuf_timestamp(csp_can_pbuf_element_t *buf)
{
	buf->last_used = csp_get_ms();
    5e24:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    5e28:	d1 01       	movw	r26, r2
    5e2a:	1d 96       	adiw	r26, 0x0d	; 13
    5e2c:	6d 93       	st	X+, r22
    5e2e:	7d 93       	st	X+, r23
    5e30:	8d 93       	st	X+, r24
    5e32:	9c 93       	st	X, r25
    5e34:	50 97       	sbiw	r26, 0x10	; 16
{
	int i;
	csp_can_pbuf_element_t *buf, *ret = NULL;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
    5e36:	81 01       	movw	r16, r2
    5e38:	92 ce       	rjmp	.-732    	; 0x5b5e <csp_can_rx_task+0x20e>

00005e3a <csp_can_rx_frame>:

	csp_thread_exit();
}

int csp_can_rx_frame(can_frame_t *frame, CSP_BASE_TYPE *task_woken)
{
    5e3a:	ab 01       	movw	r20, r22
	if (csp_queue_enqueue_isr(csp_can_rx_queue, frame, task_woken) != CSP_QUEUE_OK)
    5e3c:	bc 01       	movw	r22, r24
    5e3e:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <csp_can_rx_queue>
    5e42:	90 91 04 06 	lds	r25, 0x0604	; 0x800604 <csp_can_rx_queue+0x1>
    5e46:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <csp_queue_enqueue_isr>
    5e4a:	21 e0       	ldi	r18, 0x01	; 1
    5e4c:	30 e0       	ldi	r19, 0x00	; 0
    5e4e:	01 97       	sbiw	r24, 0x01	; 1
    5e50:	11 f4       	brne	.+4      	; 0x5e56 <csp_can_rx_frame+0x1c>
    5e52:	20 e0       	ldi	r18, 0x00	; 0
    5e54:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;
}
    5e56:	88 27       	eor	r24, r24
    5e58:	99 27       	eor	r25, r25
    5e5a:	82 1b       	sub	r24, r18
    5e5c:	93 0b       	sbc	r25, r19
    5e5e:	08 95       	ret

00005e60 <csp_can_init>:

	return CSP_ERR_NONE;
}

int csp_can_init(uint8_t mode, struct csp_can_config *conf)
{
    5e60:	8f 92       	push	r8
    5e62:	9f 92       	push	r9
    5e64:	af 92       	push	r10
    5e66:	bf 92       	push	r11
    5e68:	ef 92       	push	r14
    5e6a:	ff 92       	push	r15
    5e6c:	0f 93       	push	r16
    5e6e:	1f 93       	push	r17
    5e70:	cf 93       	push	r28
    5e72:	df 93       	push	r29
    5e74:	18 2f       	mov	r17, r24
    5e76:	eb 01       	movw	r28, r22
    5e78:	e9 e5       	ldi	r30, 0x59	; 89
    5e7a:	f5 e0       	ldi	r31, 0x05	; 5
    5e7c:	83 e0       	ldi	r24, 0x03	; 3
    5e7e:	96 e0       	ldi	r25, 0x06	; 6
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
		buf = &csp_can_pbuf[i];
		buf->rx_count = 0;
    5e80:	11 82       	std	Z+1, r1	; 0x01
    5e82:	10 82       	st	Z, r1
		buf->cfpid = 0;
    5e84:	16 82       	std	Z+6, r1	; 0x06
    5e86:	17 82       	std	Z+7, r1	; 0x07
    5e88:	10 86       	std	Z+8, r1	; 0x08
    5e8a:	11 86       	std	Z+9, r1	; 0x09
		buf->packet = NULL;
    5e8c:	13 86       	std	Z+11, r1	; 0x0b
    5e8e:	12 86       	std	Z+10, r1	; 0x0a
		buf->state = BUF_FREE;
    5e90:	14 86       	std	Z+12, r1	; 0x0c
		buf->last_used = 0;
    5e92:	15 86       	std	Z+13, r1	; 0x0d
    5e94:	16 86       	std	Z+14, r1	; 0x0e
    5e96:	17 86       	std	Z+15, r1	; 0x0f
    5e98:	10 8a       	std	Z+16, r1	; 0x10
		buf->remain = 0;
    5e9a:	12 82       	std	Z+2, r1	; 0x02
    5e9c:	13 82       	std	Z+3, r1	; 0x03
    5e9e:	14 82       	std	Z+4, r1	; 0x04
    5ea0:	15 82       	std	Z+5, r1	; 0x05
    5ea2:	71 96       	adiw	r30, 0x11	; 17
{
	/* Initialize packet buffers */
	int i;
	csp_can_pbuf_element_t *buf;

	for (i = 0; i < PBUF_ELEMENTS; i++) {
    5ea4:	e8 17       	cp	r30, r24
    5ea6:	f9 07       	cpc	r31, r25
    5ea8:	59 f7       	brne	.-42     	; 0x5e80 <csp_can_init+0x20>

/* Identification number */
static int csp_can_id_init(void)
{
	/* Init ID field to random number */
	srand((int)csp_get_ms());
    5eaa:	0e 94 4e 19 	call	0x329c	; 0x329c <csp_get_ms>
    5eae:	cb 01       	movw	r24, r22
    5eb0:	0e 94 89 44 	call	0x8912	; 0x8912 <srand>
	csp_can_id = rand() & ((1 << CFP_ID_SIZE) - 1);
    5eb4:	0e 94 86 44 	call	0x890c	; 0x890c <rand>
    5eb8:	93 70       	andi	r25, 0x03	; 3
    5eba:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <csp_can_id+0x1>
    5ebe:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <csp_can_id>

	if (csp_bin_sem_create(&csp_can_id_sem) == CSP_SEMAPHORE_OK) {
    5ec2:	87 e0       	ldi	r24, 0x07	; 7
    5ec4:	96 e0       	ldi	r25, 0x06	; 6
    5ec6:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <csp_bin_sem_create>
    5eca:	01 97       	sbiw	r24, 0x01	; 1
    5ecc:	09 f4       	brne	.+2      	; 0x5ed0 <csp_can_init+0x70>
    5ece:	97 c0       	rjmp	.+302    	; 0x5ffe <csp_can_init+0x19e>
		return CSP_ERR_NONE;
	} else {
		csp_log_error("Could not initialize CFP id semaphore");
    5ed0:	8a e8       	ldi	r24, 0x8A	; 138
    5ed2:	90 e1       	ldi	r25, 0x10	; 16
    5ed4:	9f 93       	push	r25
    5ed6:	8f 93       	push	r24
    5ed8:	1f 92       	push	r1
    5eda:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_NOMEM;
	}

	/* Initialize CFP identifier */
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
    5ede:	83 e2       	ldi	r24, 0x23	; 35
    5ee0:	92 e1       	ldi	r25, 0x12	; 18
    5ee2:	9f 93       	push	r25
    5ee4:	8f 93       	push	r24
    5ee6:	1f 92       	push	r1
    5ee8:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_NOMEM;
    5eec:	0f 90       	pop	r0
    5eee:	0f 90       	pop	r0
    5ef0:	0f 90       	pop	r0
    5ef2:	0f 90       	pop	r0
    5ef4:	0f 90       	pop	r0
    5ef6:	0f 90       	pop	r0
    5ef8:	8f ef       	ldi	r24, 0xFF	; 255
    5efa:	9f ef       	ldi	r25, 0xFF	; 255
    5efc:	83 c0       	rjmp	.+262    	; 0x6004 <csp_can_init+0x1a4>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
    5efe:	11 30       	cpi	r17, 0x01	; 1
    5f00:	69 f0       	breq	.+26     	; 0x5f1c <csp_can_init+0xbc>
		mask = 0;
	} else {
		csp_log_error("Unknown CAN mode");
    5f02:	82 e1       	ldi	r24, 0x12	; 18
    5f04:	92 e1       	ldi	r25, 0x12	; 18
    5f06:	9f 93       	push	r25
    5f08:	8f 93       	push	r24
    5f0a:	1f 92       	push	r1
    5f0c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_INVAL;
    5f10:	0f 90       	pop	r0
    5f12:	0f 90       	pop	r0
    5f14:	0f 90       	pop	r0
    5f16:	8e ef       	ldi	r24, 0xFE	; 254
    5f18:	9f ef       	ldi	r25, 0xFF	; 255
    5f1a:	74 c0       	rjmp	.+232    	; 0x6004 <csp_can_init+0x1a4>
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
	} else if (mode == CSP_CAN_PROMISC) {
		mask = 0;
    5f1c:	81 2c       	mov	r8, r1
    5f1e:	91 2c       	mov	r9, r1
    5f20:	54 01       	movw	r10, r8
    5f22:	07 c0       	rjmp	.+14     	; 0x5f32 <csp_can_init+0xd2>
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
		mask = CFP_MAKE_DST((1 << CFP_HOST_SIZE) - 1);
    5f24:	0f 2e       	mov	r0, r31
    5f26:	81 2c       	mov	r8, r1
    5f28:	91 2c       	mov	r9, r1
    5f2a:	f8 ef       	ldi	r31, 0xF8	; 248
    5f2c:	af 2e       	mov	r10, r31
    5f2e:	b1 2c       	mov	r11, r1
    5f30:	f0 2d       	mov	r31, r0
	} else {
		csp_log_error("Unknown CAN mode");
		return CSP_ERR_INVAL;
	}

	csp_can_rx_queue = csp_queue_create(CSP_CAN_RX_QUEUE_SIZE, sizeof(can_frame_t));
    5f32:	6d e0       	ldi	r22, 0x0D	; 13
    5f34:	70 e0       	ldi	r23, 0x00	; 0
    5f36:	80 e2       	ldi	r24, 0x20	; 32
    5f38:	90 e0       	ldi	r25, 0x00	; 0
    5f3a:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <csp_queue_create>
    5f3e:	90 93 04 06 	sts	0x0604, r25	; 0x800604 <csp_can_rx_queue+0x1>
    5f42:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <csp_can_rx_queue>
	if (!csp_can_rx_queue) {
    5f46:	89 2b       	or	r24, r25
    5f48:	69 f4       	brne	.+26     	; 0x5f64 <csp_can_init+0x104>
		csp_log_error("Failed to create CAN RX queue");
    5f4a:	84 ef       	ldi	r24, 0xF4	; 244
    5f4c:	91 e1       	ldi	r25, 0x11	; 17
    5f4e:	9f 93       	push	r25
    5f50:	8f 93       	push	r24
    5f52:	1f 92       	push	r1
    5f54:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_NOMEM;
    5f58:	0f 90       	pop	r0
    5f5a:	0f 90       	pop	r0
    5f5c:	0f 90       	pop	r0
    5f5e:	8f ef       	ldi	r24, 0xFF	; 255
    5f60:	9f ef       	ldi	r25, 0xFF	; 255
    5f62:	50 c0       	rjmp	.+160    	; 0x6004 <csp_can_init+0x1a4>
	}

	ret = csp_thread_create(csp_can_rx_task, "CAN", 200 , NULL, 3, &csp_can_rx_task_h); //6000/sizeof(int)
    5f64:	0f 2e       	mov	r0, r31
    5f66:	f5 e0       	ldi	r31, 0x05	; 5
    5f68:	ef 2e       	mov	r14, r31
    5f6a:	f6 e0       	ldi	r31, 0x06	; 6
    5f6c:	ff 2e       	mov	r15, r31
    5f6e:	f0 2d       	mov	r31, r0
    5f70:	03 e0       	ldi	r16, 0x03	; 3
    5f72:	10 e0       	ldi	r17, 0x00	; 0
    5f74:	20 e0       	ldi	r18, 0x00	; 0
    5f76:	30 e0       	ldi	r19, 0x00	; 0
    5f78:	48 ec       	ldi	r20, 0xC8	; 200
    5f7a:	50 e0       	ldi	r21, 0x00	; 0
    5f7c:	62 ec       	ldi	r22, 0xC2	; 194
    5f7e:	72 e0       	ldi	r23, 0x02	; 2
    5f80:	88 ea       	ldi	r24, 0xA8	; 168
    5f82:	9c e2       	ldi	r25, 0x2C	; 44
    5f84:	0e 94 3b 19 	call	0x3276	; 0x3276 <csp_thread_create>
	if (ret != 0) {
    5f88:	89 2b       	or	r24, r25
    5f8a:	69 f0       	breq	.+26     	; 0x5fa6 <csp_can_init+0x146>
		csp_log_error("Failed to init CAN RX task");
    5f8c:	89 ed       	ldi	r24, 0xD9	; 217
    5f8e:	91 e1       	ldi	r25, 0x11	; 17
    5f90:	9f 93       	push	r25
    5f92:	8f 93       	push	r24
    5f94:	1f 92       	push	r1
    5f96:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_NOMEM;
    5f9a:	0f 90       	pop	r0
    5f9c:	0f 90       	pop	r0
    5f9e:	0f 90       	pop	r0
    5fa0:	8f ef       	ldi	r24, 0xFF	; 255
    5fa2:	9f ef       	ldi	r25, 0xFF	; 255
    5fa4:	2f c0       	rjmp	.+94     	; 0x6004 <csp_can_init+0x1a4>
	}

	/* Initialize CAN driver */

	int driverror=can_init(CFP_MAKE_DST(csp_get_address()), mask, conf);
    5fa6:	0e 94 6f 21 	call	0x42de	; 0x42de <csp_get_address>
    5faa:	8f 71       	andi	r24, 0x1F	; 31
    5fac:	90 e0       	ldi	r25, 0x00	; 0
    5fae:	a0 e0       	ldi	r26, 0x00	; 0
    5fb0:	b0 e0       	ldi	r27, 0x00	; 0
    5fb2:	bc 01       	movw	r22, r24
    5fb4:	cd 01       	movw	r24, r26
    5fb6:	05 2e       	mov	r0, r21
    5fb8:	53 e1       	ldi	r21, 0x13	; 19
    5fba:	66 0f       	add	r22, r22
    5fbc:	77 1f       	adc	r23, r23
    5fbe:	88 1f       	adc	r24, r24
    5fc0:	99 1f       	adc	r25, r25
    5fc2:	5a 95       	dec	r21
    5fc4:	d1 f7       	brne	.-12     	; 0x5fba <csp_can_init+0x15a>
    5fc6:	50 2d       	mov	r21, r0
    5fc8:	8e 01       	movw	r16, r28
    5fca:	a5 01       	movw	r20, r10
    5fcc:	94 01       	movw	r18, r8
    5fce:	0e 94 24 10 	call	0x2048	; 0x2048 <can_init>
	//printf("test = %d",driverror);
	if (driverror!=0){
    5fd2:	89 2b       	or	r24, r25
    5fd4:	69 f0       	breq	.+26     	; 0x5ff0 <csp_can_init+0x190>
		csp_log_error("Failed to initialize CAN driver");
    5fd6:	89 eb       	ldi	r24, 0xB9	; 185
    5fd8:	91 e1       	ldi	r25, 0x11	; 17
    5fda:	9f 93       	push	r25
    5fdc:	8f 93       	push	r24
    5fde:	1f 92       	push	r1
    5fe0:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_DRIVER;
    5fe4:	0f 90       	pop	r0
    5fe6:	0f 90       	pop	r0
    5fe8:	0f 90       	pop	r0
    5fea:	85 ef       	ldi	r24, 0xF5	; 245
    5fec:	9f ef       	ldi	r25, 0xFF	; 255
    5fee:	0a c0       	rjmp	.+20     	; 0x6004 <csp_can_init+0x1a4>
	}

	/* Register interface */
	csp_iflist_add(&csp_if_can);
    5ff0:	86 e1       	ldi	r24, 0x16	; 22
    5ff2:	92 e0       	ldi	r25, 0x02	; 2
    5ff4:	0e 94 9b 20 	call	0x4136	; 0x4136 <csp_iflist_add>

	return CSP_ERR_NONE;
    5ff8:	80 e0       	ldi	r24, 0x00	; 0
    5ffa:	90 e0       	ldi	r25, 0x00	; 0
    5ffc:	03 c0       	rjmp	.+6      	; 0x6004 <csp_can_init+0x1a4>
	if (csp_can_id_init() != 0) {
		csp_log_error("Failed to initialize CAN identification number");
		return CSP_ERR_NOMEM;
	}

	if (mode == CSP_CAN_MASKED) {
    5ffe:	11 11       	cpse	r17, r1
    6000:	7e cf       	rjmp	.-260    	; 0x5efe <csp_can_init+0x9e>
    6002:	90 cf       	rjmp	.-224    	; 0x5f24 <csp_can_init+0xc4>

	/* Register interface */
	csp_iflist_add(&csp_if_can);

	return CSP_ERR_NONE;
}
    6004:	df 91       	pop	r29
    6006:	cf 91       	pop	r28
    6008:	1f 91       	pop	r17
    600a:	0f 91       	pop	r16
    600c:	ff 90       	pop	r15
    600e:	ef 90       	pop	r14
    6010:	bf 90       	pop	r11
    6012:	af 90       	pop	r10
    6014:	9f 90       	pop	r9
    6016:	8f 90       	pop	r8
    6018:	08 95       	ret

0000601a <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
static int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    601a:	0f 93       	push	r16
    601c:	1f 93       	push	r17
    601e:	cf 93       	push	r28
    6020:	df 93       	push	r29
    6022:	8b 01       	movw	r16, r22

	/* Drop packet silently if not destined for us. This allows
	 * blackhole routing addresses by setting their nexthop to
	 * the loopback interface.
	 */
	if (packet->id.dst != csp_get_address()) {
    6024:	fb 01       	movw	r30, r22
    6026:	c4 85       	ldd	r28, Z+12	; 0x0c
    6028:	8c 2f       	mov	r24, r28
    602a:	82 95       	swap	r24
    602c:	8f 70       	andi	r24, 0x0F	; 15
    602e:	c5 85       	ldd	r28, Z+13	; 0x0d
    6030:	c1 70       	andi	r28, 0x01	; 1
    6032:	c2 95       	swap	r28
    6034:	c0 7f       	andi	r28, 0xF0	; 240
    6036:	c8 2b       	or	r28, r24
    6038:	d0 e0       	ldi	r29, 0x00	; 0
    603a:	0e 94 6f 21 	call	0x42de	; 0x42de <csp_get_address>
    603e:	90 e0       	ldi	r25, 0x00	; 0
    6040:	c8 17       	cp	r28, r24
    6042:	d9 07       	cpc	r29, r25
    6044:	21 f0       	breq	.+8      	; 0x604e <csp_lo_tx+0x34>
		/* Consume and drop packet */
		csp_buffer_free(packet);
    6046:	c8 01       	movw	r24, r16
    6048:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
		return CSP_ERR_NONE;
    604c:	07 c0       	rjmp	.+14     	; 0x605c <csp_lo_tx+0x42>
	}

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_qfifo_write(packet, &csp_if_lo, NULL);
    604e:	40 e0       	ldi	r20, 0x00	; 0
    6050:	50 e0       	ldi	r21, 0x00	; 0
    6052:	69 e4       	ldi	r22, 0x49	; 73
    6054:	72 e0       	ldi	r23, 0x02	; 2
    6056:	c8 01       	movw	r24, r16
    6058:	0e 94 8d 24 	call	0x491a	; 0x491a <csp_qfifo_write>

	return CSP_ERR_NONE;

}
    605c:	80 e0       	ldi	r24, 0x00	; 0
    605e:	90 e0       	ldi	r25, 0x00	; 0
    6060:	df 91       	pop	r29
    6062:	cf 91       	pop	r28
    6064:	1f 91       	pop	r17
    6066:	0f 91       	pop	r16
    6068:	08 95       	ret

0000606a <csp_rtable_find_iface>:
void csp_route_table_load(uint8_t route_table_in[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(routes, route_table_in, sizeof(routes[0]) * CSP_ROUTE_COUNT);
}

void csp_route_table_save(uint8_t route_table_out[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(route_table_out, routes, sizeof(routes[0]) * CSP_ROUTE_COUNT);
    606a:	90 e0       	ldi	r25, 0x00	; 0
    606c:	fc 01       	movw	r30, r24
    606e:	ee 0f       	add	r30, r30
    6070:	ff 1f       	adc	r31, r31
    6072:	e8 0f       	add	r30, r24
    6074:	f9 1f       	adc	r31, r25
    6076:	e5 5f       	subi	r30, 0xF5	; 245
    6078:	f9 4f       	sbci	r31, 0xF9	; 249
    607a:	20 81       	ld	r18, Z
    607c:	31 81       	ldd	r19, Z+1	; 0x01
    607e:	23 2b       	or	r18, r19
    6080:	49 f0       	breq	.+18     	; 0x6094 <csp_rtable_find_iface+0x2a>
    6082:	fc 01       	movw	r30, r24
    6084:	ee 0f       	add	r30, r30
    6086:	ff 1f       	adc	r31, r31
    6088:	8e 0f       	add	r24, r30
    608a:	9f 1f       	adc	r25, r31
    608c:	fc 01       	movw	r30, r24
    608e:	e5 5f       	subi	r30, 0xF5	; 245
    6090:	f9 4f       	sbci	r31, 0xF9	; 249
    6092:	08 c0       	rjmp	.+16     	; 0x60a4 <csp_rtable_find_iface+0x3a>
    6094:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <routes+0x60>
    6098:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <routes+0x61>
    609c:	00 97       	sbiw	r24, 0x00	; 0
    609e:	21 f0       	breq	.+8      	; 0x60a8 <csp_rtable_find_iface+0x3e>
    60a0:	eb e6       	ldi	r30, 0x6B	; 107
    60a2:	f6 e0       	ldi	r31, 0x06	; 6
    60a4:	80 81       	ld	r24, Z
    60a6:	91 81       	ldd	r25, Z+1	; 0x01
    60a8:	08 95       	ret

000060aa <csp_rtable_find_mac>:
    60aa:	90 e0       	ldi	r25, 0x00	; 0
    60ac:	fc 01       	movw	r30, r24
    60ae:	ee 0f       	add	r30, r30
    60b0:	ff 1f       	adc	r31, r31
    60b2:	e8 0f       	add	r30, r24
    60b4:	f9 1f       	adc	r31, r25
    60b6:	e5 5f       	subi	r30, 0xF5	; 245
    60b8:	f9 4f       	sbci	r31, 0xF9	; 249
    60ba:	20 81       	ld	r18, Z
    60bc:	31 81       	ldd	r19, Z+1	; 0x01
    60be:	23 2b       	or	r18, r19
    60c0:	49 f0       	breq	.+18     	; 0x60d4 <csp_rtable_find_mac+0x2a>
    60c2:	fc 01       	movw	r30, r24
    60c4:	ee 0f       	add	r30, r30
    60c6:	ff 1f       	adc	r31, r31
    60c8:	8e 0f       	add	r24, r30
    60ca:	9f 1f       	adc	r25, r31
    60cc:	fc 01       	movw	r30, r24
    60ce:	e5 5f       	subi	r30, 0xF5	; 245
    60d0:	f9 4f       	sbci	r31, 0xF9	; 249
    60d2:	08 c0       	rjmp	.+16     	; 0x60e4 <csp_rtable_find_mac+0x3a>
    60d4:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <routes+0x60>
    60d8:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <routes+0x61>
    60dc:	89 2b       	or	r24, r25
    60de:	21 f0       	breq	.+8      	; 0x60e8 <csp_rtable_find_mac+0x3e>
    60e0:	eb e6       	ldi	r30, 0x6B	; 107
    60e2:	f6 e0       	ldi	r31, 0x06	; 6
    60e4:	82 81       	ldd	r24, Z+2	; 0x02
    60e6:	08 95       	ret
    60e8:	8f ef       	ldi	r24, 0xFF	; 255
    60ea:	08 95       	ret

000060ec <csp_rtable_set>:
}

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {
    60ec:	0f 93       	push	r16
    60ee:	1f 93       	push	r17
    60f0:	cf 93       	push	r28
    60f2:	df 93       	push	r29

	/* Don't add nothing */
	if (ifc == NULL)
    60f4:	41 15       	cp	r20, r1
    60f6:	51 05       	cpc	r21, r1
    60f8:	41 f1       	breq	.+80     	; 0x614a <csp_rtable_set+0x5e>
    60fa:	d2 2f       	mov	r29, r18
    60fc:	8a 01       	movw	r16, r20
    60fe:	c8 2f       	mov	r28, r24
	 * NOTE: For future implementations, interfaces should call
	 * csp_route_add_if in its csp_if_<name>_init function, instead
	 * of registering at first route_set, in order to make the interface
	 * available to network based (CMP) route configuration.
	 */
	csp_iflist_add(ifc);
    6100:	ca 01       	movw	r24, r20
    6102:	0e 94 9b 20 	call	0x4136	; 0x4136 <csp_iflist_add>

	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
    6106:	c1 32       	cpi	r28, 0x21	; 33
    6108:	78 f4       	brcc	.+30     	; 0x6128 <csp_rtable_set+0x3c>
		routes[node].interface = ifc;
    610a:	8c 2f       	mov	r24, r28
    610c:	90 e0       	ldi	r25, 0x00	; 0
    610e:	fc 01       	movw	r30, r24
    6110:	ee 0f       	add	r30, r30
    6112:	ff 1f       	adc	r31, r31
    6114:	e8 0f       	add	r30, r24
    6116:	f9 1f       	adc	r31, r25
    6118:	e5 5f       	subi	r30, 0xF5	; 245
    611a:	f9 4f       	sbci	r31, 0xF9	; 249
    611c:	11 83       	std	Z+1, r17	; 0x01
    611e:	00 83       	st	Z, r16
		routes[node].mac = mac;
    6120:	d2 83       	std	Z+2, r29	; 0x02
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;
    6122:	80 e0       	ldi	r24, 0x00	; 0
    6124:	90 e0       	ldi	r25, 0x00	; 0
    6126:	13 c0       	rjmp	.+38     	; 0x614e <csp_rtable_set+0x62>
	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
    6128:	1f 92       	push	r1
    612a:	cf 93       	push	r28
    612c:	8e e8       	ldi	r24, 0x8E	; 142
    612e:	92 e1       	ldi	r25, 0x12	; 18
    6130:	9f 93       	push	r25
    6132:	8f 93       	push	r24
    6134:	1f 92       	push	r1
    6136:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		return CSP_ERR_INVAL;
    613a:	0f 90       	pop	r0
    613c:	0f 90       	pop	r0
    613e:	0f 90       	pop	r0
    6140:	0f 90       	pop	r0
    6142:	0f 90       	pop	r0
    6144:	8e ef       	ldi	r24, 0xFE	; 254
    6146:	9f ef       	ldi	r25, 0xFF	; 255
    6148:	02 c0       	rjmp	.+4      	; 0x614e <csp_rtable_set+0x62>

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {

	/* Don't add nothing */
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    614a:	8e ef       	ldi	r24, 0xFE	; 254
    614c:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;

}
    614e:	df 91       	pop	r29
    6150:	cf 91       	pop	r28
    6152:	1f 91       	pop	r17
    6154:	0f 91       	pop	r16
    6156:	08 95       	ret

00006158 <csp_rtable_print>:

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
    6158:	ef 92       	push	r14
    615a:	ff 92       	push	r15
    615c:	0f 93       	push	r16
    615e:	1f 93       	push	r17
    6160:	cf 93       	push	r28
    6162:	df 93       	push	r29
	int i;
	printf("Node  Interface  Address\r\n");
    6164:	83 e7       	ldi	r24, 0x73	; 115
    6166:	92 e1       	ldi	r25, 0x12	; 18
    6168:	9f 93       	push	r25
    616a:	8f 93       	push	r24
    616c:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
    6170:	0b e0       	ldi	r16, 0x0B	; 11
    6172:	16 e0       	ldi	r17, 0x06	; 6
    6174:	0f 90       	pop	r0
    6176:	0f 90       	pop	r0
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    6178:	c0 e0       	ldi	r28, 0x00	; 0
    617a:	d0 e0       	ldi	r29, 0x00	; 0
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
    617c:	0f 2e       	mov	r0, r31
    617e:	f3 e6       	ldi	r31, 0x63	; 99
    6180:	ef 2e       	mov	r14, r31
    6182:	f2 e1       	ldi	r31, 0x12	; 18
    6184:	ff 2e       	mov	r15, r31
    6186:	f0 2d       	mov	r31, r0
#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
		if (routes[i].interface != NULL)
    6188:	d8 01       	movw	r26, r16
    618a:	ed 91       	ld	r30, X+
    618c:	fc 91       	ld	r31, X
    618e:	11 97       	sbiw	r26, 0x01	; 1
    6190:	30 97       	sbiw	r30, 0x00	; 0
    6192:	d9 f0       	breq	.+54     	; 0x61ca <csp_rtable_print+0x72>
			printf("%4u  %-9s  %u\r\n", i,
    6194:	12 96       	adiw	r26, 0x02	; 2
    6196:	8c 91       	ld	r24, X
    6198:	8f 3f       	cpi	r24, 0xFF	; 255
    619a:	11 f0       	breq	.+4      	; 0x61a0 <csp_rtable_print+0x48>
    619c:	90 e0       	ldi	r25, 0x00	; 0
    619e:	01 c0       	rjmp	.+2      	; 0x61a2 <csp_rtable_print+0x4a>
    61a0:	ce 01       	movw	r24, r28
    61a2:	9f 93       	push	r25
    61a4:	8f 93       	push	r24
    61a6:	81 81       	ldd	r24, Z+1	; 0x01
    61a8:	8f 93       	push	r24
    61aa:	80 81       	ld	r24, Z
    61ac:	8f 93       	push	r24
    61ae:	df 93       	push	r29
    61b0:	cf 93       	push	r28
    61b2:	ff 92       	push	r15
    61b4:	ef 92       	push	r14
    61b6:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>
    61ba:	ad b7       	in	r26, 0x3d	; 61
    61bc:	be b7       	in	r27, 0x3e	; 62
    61be:	18 96       	adiw	r26, 0x08	; 8
    61c0:	0f b6       	in	r0, 0x3f	; 63
    61c2:	f8 94       	cli
    61c4:	be bf       	out	0x3e, r27	; 62
    61c6:	0f be       	out	0x3f, r0	; 63
    61c8:	ad bf       	out	0x3d, r26	; 61

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    61ca:	21 96       	adiw	r28, 0x01	; 1
    61cc:	0d 5f       	subi	r16, 0xFD	; 253
    61ce:	1f 4f       	sbci	r17, 0xFF	; 255
    61d0:	c0 32       	cpi	r28, 0x20	; 32
    61d2:	d1 05       	cpc	r29, r1
    61d4:	c9 f6       	brne	.-78     	; 0x6188 <csp_rtable_print+0x30>
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
				routes[i].interface->name,
				routes[i].mac == CSP_NODE_MAC ? i : routes[i].mac);
	printf("   *  %-9s  %u\r\n", routes[CSP_DEFAULT_ROUTE].interface->name, routes[CSP_DEFAULT_ROUTE].mac);
    61d6:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <routes+0x62>
    61da:	1f 92       	push	r1
    61dc:	8f 93       	push	r24
    61de:	e0 91 6b 06 	lds	r30, 0x066B	; 0x80066b <routes+0x60>
    61e2:	f0 91 6c 06 	lds	r31, 0x066C	; 0x80066c <routes+0x61>
    61e6:	81 81       	ldd	r24, Z+1	; 0x01
    61e8:	8f 93       	push	r24
    61ea:	80 81       	ld	r24, Z
    61ec:	8f 93       	push	r24
    61ee:	82 e5       	ldi	r24, 0x52	; 82
    61f0:	92 e1       	ldi	r25, 0x12	; 18
    61f2:	9f 93       	push	r25
    61f4:	8f 93       	push	r24
    61f6:	0e 94 3d 45 	call	0x8a7a	; 0x8a7a <printf_P>

}
    61fa:	0f 90       	pop	r0
    61fc:	0f 90       	pop	r0
    61fe:	0f 90       	pop	r0
    6200:	0f 90       	pop	r0
    6202:	0f 90       	pop	r0
    6204:	0f 90       	pop	r0
    6206:	df 91       	pop	r29
    6208:	cf 91       	pop	r28
    620a:	1f 91       	pop	r17
    620c:	0f 91       	pop	r16
    620e:	ff 90       	pop	r15
    6210:	ef 90       	pop	r14
    6212:	08 95       	ret

00006214 <csp_udp_new_packet>:
#include <csp/arch/csp_queue.h>
#include <csp/csp_port.h>
#include <csp/csp_conn.h>
#include <csp/transport/csp_transport.h>

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    6214:	0f 93       	push	r16
    6216:	1f 93       	push	r17
    6218:	cf 93       	push	r28
    621a:	df 93       	push	r29
    621c:	1f 92       	push	r1
    621e:	1f 92       	push	r1
    6220:	cd b7       	in	r28, 0x3d	; 61
    6222:	de b7       	in	r29, 0x3e	; 62
    6224:	9a 83       	std	Y+2, r25	; 0x02
    6226:	89 83       	std	Y+1, r24	; 0x01
    6228:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    622a:	0e 94 4d 1b 	call	0x369a	; 0x369a <csp_conn_enqueue_packet>
    622e:	99 23       	and	r25, r25
    6230:	74 f4       	brge	.+28     	; 0x624e <csp_udp_new_packet+0x3a>
		csp_log_error("Connection buffer queue full!");
    6232:	8b ed       	ldi	r24, 0xDB	; 219
    6234:	92 e1       	ldi	r25, 0x12	; 18
    6236:	9f 93       	push	r25
    6238:	8f 93       	push	r24
    623a:	1f 92       	push	r1
    623c:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
		csp_buffer_free(packet);
    6240:	c8 01       	movw	r24, r16
    6242:	0e 94 aa 1a 	call	0x3554	; 0x3554 <csp_buffer_free>
		return;
    6246:	0f 90       	pop	r0
    6248:	0f 90       	pop	r0
    624a:	0f 90       	pop	r0
    624c:	24 c0       	rjmp	.+72     	; 0x6296 <csp_udp_new_packet+0x82>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    624e:	e9 81       	ldd	r30, Y+1	; 0x01
    6250:	fa 81       	ldd	r31, Y+2	; 0x02
    6252:	86 85       	ldd	r24, Z+14	; 0x0e
    6254:	97 85       	ldd	r25, Z+15	; 0x0f
    6256:	00 97       	sbiw	r24, 0x00	; 0
    6258:	f1 f0       	breq	.+60     	; 0x6296 <csp_udp_new_packet+0x82>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    625a:	20 e0       	ldi	r18, 0x00	; 0
    625c:	30 e0       	ldi	r19, 0x00	; 0
    625e:	a9 01       	movw	r20, r18
    6260:	be 01       	movw	r22, r28
    6262:	6f 5f       	subi	r22, 0xFF	; 255
    6264:	7f 4f       	sbci	r23, 0xFF	; 255
    6266:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <csp_queue_enqueue>
    626a:	01 97       	sbiw	r24, 0x01	; 1
    626c:	81 f0       	breq	.+32     	; 0x628e <csp_udp_new_packet+0x7a>
			csp_log_warn("Warning socket connection queue full");
    626e:	86 eb       	ldi	r24, 0xB6	; 182
    6270:	92 e1       	ldi	r25, 0x12	; 18
    6272:	9f 93       	push	r25
    6274:	8f 93       	push	r24
    6276:	81 e0       	ldi	r24, 0x01	; 1
    6278:	8f 93       	push	r24
    627a:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <do_csp_debug>
			csp_close(conn);
    627e:	89 81       	ldd	r24, Y+1	; 0x01
    6280:	9a 81       	ldd	r25, Y+2	; 0x02
    6282:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <csp_close>
			return;
    6286:	0f 90       	pop	r0
    6288:	0f 90       	pop	r0
    628a:	0f 90       	pop	r0
    628c:	04 c0       	rjmp	.+8      	; 0x6296 <csp_udp_new_packet+0x82>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    628e:	e9 81       	ldd	r30, Y+1	; 0x01
    6290:	fa 81       	ldd	r31, Y+2	; 0x02
    6292:	17 86       	std	Z+15, r1	; 0x0f
    6294:	16 86       	std	Z+14, r1	; 0x0e
	}

}
    6296:	0f 90       	pop	r0
    6298:	0f 90       	pop	r0
    629a:	df 91       	pop	r29
    629c:	cf 91       	pop	r28
    629e:	1f 91       	pop	r17
    62a0:	0f 91       	pop	r16
    62a2:	08 95       	ret

000062a4 <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    62a4:	cf 93       	push	r28
    62a6:	df 93       	push	r29
    62a8:	dc 01       	movw	r26, r24
    62aa:	ea e7       	ldi	r30, 0x7A	; 122
    62ac:	f6 e0       	ldi	r31, 0x06	; 6
    62ae:	01 c0       	rjmp	.+2      	; 0x62b2 <prvInsertBlockIntoFreeList+0xe>
    62b0:	f9 01       	movw	r30, r18
    62b2:	20 81       	ld	r18, Z
    62b4:	31 81       	ldd	r19, Z+1	; 0x01
    62b6:	2a 17       	cp	r18, r26
    62b8:	3b 07       	cpc	r19, r27
    62ba:	d0 f3       	brcs	.-12     	; 0x62b0 <prvInsertBlockIntoFreeList+0xc>
    62bc:	82 81       	ldd	r24, Z+2	; 0x02
    62be:	93 81       	ldd	r25, Z+3	; 0x03
    62c0:	af 01       	movw	r20, r30
    62c2:	48 0f       	add	r20, r24
    62c4:	59 1f       	adc	r21, r25
    62c6:	a4 17       	cp	r26, r20
    62c8:	b5 07       	cpc	r27, r21
    62ca:	49 f4       	brne	.+18     	; 0x62de <prvInsertBlockIntoFreeList+0x3a>
    62cc:	12 96       	adiw	r26, 0x02	; 2
    62ce:	4d 91       	ld	r20, X+
    62d0:	5c 91       	ld	r21, X
    62d2:	13 97       	sbiw	r26, 0x03	; 3
    62d4:	84 0f       	add	r24, r20
    62d6:	95 1f       	adc	r25, r21
    62d8:	93 83       	std	Z+3, r25	; 0x03
    62da:	82 83       	std	Z+2, r24	; 0x02
    62dc:	df 01       	movw	r26, r30
    62de:	12 96       	adiw	r26, 0x02	; 2
    62e0:	8d 91       	ld	r24, X+
    62e2:	9c 91       	ld	r25, X
    62e4:	13 97       	sbiw	r26, 0x03	; 3
    62e6:	ed 01       	movw	r28, r26
    62e8:	c8 0f       	add	r28, r24
    62ea:	d9 1f       	adc	r29, r25
    62ec:	2c 17       	cp	r18, r28
    62ee:	3d 07       	cpc	r19, r29
    62f0:	d9 f4       	brne	.+54     	; 0x6328 <prvInsertBlockIntoFreeList+0x84>
    62f2:	20 91 78 06 	lds	r18, 0x0678	; 0x800678 <pxEnd>
    62f6:	30 91 79 06 	lds	r19, 0x0679	; 0x800679 <pxEnd+0x1>
    62fa:	c2 17       	cp	r28, r18
    62fc:	d3 07       	cpc	r29, r19
    62fe:	81 f0       	breq	.+32     	; 0x6320 <prvInsertBlockIntoFreeList+0x7c>
    6300:	2a 81       	ldd	r18, Y+2	; 0x02
    6302:	3b 81       	ldd	r19, Y+3	; 0x03
    6304:	82 0f       	add	r24, r18
    6306:	93 1f       	adc	r25, r19
    6308:	13 96       	adiw	r26, 0x03	; 3
    630a:	9c 93       	st	X, r25
    630c:	8e 93       	st	-X, r24
    630e:	12 97       	sbiw	r26, 0x02	; 2
    6310:	c0 81       	ld	r28, Z
    6312:	d1 81       	ldd	r29, Z+1	; 0x01
    6314:	88 81       	ld	r24, Y
    6316:	99 81       	ldd	r25, Y+1	; 0x01
    6318:	11 96       	adiw	r26, 0x01	; 1
    631a:	9c 93       	st	X, r25
    631c:	8e 93       	st	-X, r24
    631e:	07 c0       	rjmp	.+14     	; 0x632e <prvInsertBlockIntoFreeList+0x8a>
    6320:	11 96       	adiw	r26, 0x01	; 1
    6322:	dc 93       	st	X, r29
    6324:	ce 93       	st	-X, r28
    6326:	03 c0       	rjmp	.+6      	; 0x632e <prvInsertBlockIntoFreeList+0x8a>
    6328:	11 96       	adiw	r26, 0x01	; 1
    632a:	3c 93       	st	X, r19
    632c:	2e 93       	st	-X, r18
    632e:	ae 17       	cp	r26, r30
    6330:	bf 07       	cpc	r27, r31
    6332:	11 f0       	breq	.+4      	; 0x6338 <prvInsertBlockIntoFreeList+0x94>
    6334:	b1 83       	std	Z+1, r27	; 0x01
    6336:	a0 83       	st	Z, r26
    6338:	df 91       	pop	r29
    633a:	cf 91       	pop	r28
    633c:	08 95       	ret

0000633e <vPortFree>:
    633e:	cf 93       	push	r28
    6340:	df 93       	push	r29
    6342:	00 97       	sbiw	r24, 0x00	; 0
    6344:	51 f1       	breq	.+84     	; 0x639a <vPortFree+0x5c>
    6346:	fc 01       	movw	r30, r24
    6348:	34 97       	sbiw	r30, 0x04	; 4
    634a:	22 81       	ldd	r18, Z+2	; 0x02
    634c:	33 81       	ldd	r19, Z+3	; 0x03
    634e:	40 91 72 06 	lds	r20, 0x0672	; 0x800672 <xBlockAllocatedBit>
    6352:	50 91 73 06 	lds	r21, 0x0673	; 0x800673 <xBlockAllocatedBit+0x1>
    6356:	b9 01       	movw	r22, r18
    6358:	64 23       	and	r22, r20
    635a:	75 23       	and	r23, r21
    635c:	67 2b       	or	r22, r23
    635e:	e9 f0       	breq	.+58     	; 0x639a <vPortFree+0x5c>
    6360:	60 81       	ld	r22, Z
    6362:	71 81       	ldd	r23, Z+1	; 0x01
    6364:	67 2b       	or	r22, r23
    6366:	c9 f4       	brne	.+50     	; 0x639a <vPortFree+0x5c>
    6368:	ef 01       	movw	r28, r30
    636a:	40 95       	com	r20
    636c:	50 95       	com	r21
    636e:	24 23       	and	r18, r20
    6370:	35 23       	and	r19, r21
    6372:	33 83       	std	Z+3, r19	; 0x03
    6374:	22 83       	std	Z+2, r18	; 0x02
    6376:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
    637a:	20 91 76 06 	lds	r18, 0x0676	; 0x800676 <xFreeBytesRemaining>
    637e:	30 91 77 06 	lds	r19, 0x0677	; 0x800677 <xFreeBytesRemaining+0x1>
    6382:	8a 81       	ldd	r24, Y+2	; 0x02
    6384:	9b 81       	ldd	r25, Y+3	; 0x03
    6386:	82 0f       	add	r24, r18
    6388:	93 1f       	adc	r25, r19
    638a:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <xFreeBytesRemaining+0x1>
    638e:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <xFreeBytesRemaining>
    6392:	ce 01       	movw	r24, r28
    6394:	87 df       	rcall	.-242    	; 0x62a4 <prvInsertBlockIntoFreeList>
    6396:	0e 94 57 3b 	call	0x76ae	; 0x76ae <xTaskResumeAll>
    639a:	df 91       	pop	r29
    639c:	cf 91       	pop	r28
    639e:	08 95       	ret

000063a0 <vApplicationMallocFailedHook>:
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
void vApplicationMallocFailedHook(void) {
	printf("outmem");
    63a0:	82 ed       	ldi	r24, 0xD2	; 210
    63a2:	92 e0       	ldi	r25, 0x02	; 2
    63a4:	9f 93       	push	r25
    63a6:	8f 93       	push	r24
    63a8:	0e 94 2a 45 	call	0x8a54	; 0x8a54 <printf>
	FORCERESET
    63ac:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
    63b0:	89 ed       	ldi	r24, 0xD9	; 217
    63b2:	92 e0       	ldi	r25, 0x02	; 2
    63b4:	0e 94 64 45 	call	0x8ac8	; 0x8ac8 <puts>
    63b8:	0f 90       	pop	r0
    63ba:	0f 90       	pop	r0
    63bc:	ff cf       	rjmp	.-2      	; 0x63bc <vApplicationMallocFailedHook+0x1c>

000063be <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    63be:	cf 92       	push	r12
    63c0:	df 92       	push	r13
    63c2:	ef 92       	push	r14
    63c4:	ff 92       	push	r15
    63c6:	0f 93       	push	r16
    63c8:	1f 93       	push	r17
    63ca:	cf 93       	push	r28
    63cc:	df 93       	push	r29
    63ce:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    63d0:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    63d4:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <pxEnd>
    63d8:	90 91 79 06 	lds	r25, 0x0679	; 0x800679 <pxEnd+0x1>
    63dc:	89 2b       	or	r24, r25
    63de:	41 f5       	brne	.+80     	; 0x6430 <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    63e0:	ea e7       	ldi	r30, 0x7A	; 122
    63e2:	f6 e0       	ldi	r31, 0x06	; 6
    63e4:	ae e7       	ldi	r26, 0x7E	; 126
    63e6:	b6 e0       	ldi	r27, 0x06	; 6
    63e8:	b1 83       	std	Z+1, r27	; 0x01
    63ea:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    63ec:	13 82       	std	Z+3, r1	; 0x03
    63ee:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    63f0:	ee ed       	ldi	r30, 0xDE	; 222
    63f2:	ff e1       	ldi	r31, 0x1F	; 31
    63f4:	f0 93 79 06 	sts	0x0679, r31	; 0x800679 <pxEnd+0x1>
    63f8:	e0 93 78 06 	sts	0x0678, r30	; 0x800678 <pxEnd>
	pxEnd->xBlockSize = 0;
    63fc:	13 82       	std	Z+3, r1	; 0x03
    63fe:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    6400:	11 82       	std	Z+1, r1	; 0x01
    6402:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    6404:	80 e6       	ldi	r24, 0x60	; 96
    6406:	99 e1       	ldi	r25, 0x19	; 25
    6408:	13 96       	adiw	r26, 0x03	; 3
    640a:	9c 93       	st	X, r25
    640c:	8e 93       	st	-X, r24
    640e:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    6410:	ed 93       	st	X+, r30
    6412:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    6414:	90 93 75 06 	sts	0x0675, r25	; 0x800675 <xMinimumEverFreeBytesRemaining+0x1>
    6418:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    641c:	90 93 77 06 	sts	0x0677, r25	; 0x800677 <xFreeBytesRemaining+0x1>
    6420:	80 93 76 06 	sts	0x0676, r24	; 0x800676 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    6424:	80 e0       	ldi	r24, 0x00	; 0
    6426:	90 e8       	ldi	r25, 0x80	; 128
    6428:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <xBlockAllocatedBit+0x1>
    642c:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    6430:	e0 90 72 06 	lds	r14, 0x0672	; 0x800672 <xBlockAllocatedBit>
    6434:	f0 90 73 06 	lds	r15, 0x0673	; 0x800673 <xBlockAllocatedBit+0x1>
    6438:	c7 01       	movw	r24, r14
    643a:	8c 23       	and	r24, r28
    643c:	9d 23       	and	r25, r29
    643e:	89 2b       	or	r24, r25
    6440:	09 f0       	breq	.+2      	; 0x6444 <pvPortMalloc+0x86>
    6442:	62 c0       	rjmp	.+196    	; 0x6508 <pvPortMalloc+0x14a>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    6444:	20 97       	sbiw	r28, 0x00	; 0
    6446:	09 f4       	brne	.+2      	; 0x644a <pvPortMalloc+0x8c>
    6448:	62 c0       	rjmp	.+196    	; 0x650e <pvPortMalloc+0x150>
			{
				xWantedSize += xHeapStructSize;
    644a:	ae 01       	movw	r20, r28
    644c:	4c 5f       	subi	r20, 0xFC	; 252
    644e:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    6450:	09 f4       	brne	.+2      	; 0x6454 <pvPortMalloc+0x96>
    6452:	5a c0       	rjmp	.+180    	; 0x6508 <pvPortMalloc+0x14a>
    6454:	00 91 76 06 	lds	r16, 0x0676	; 0x800676 <xFreeBytesRemaining>
    6458:	10 91 77 06 	lds	r17, 0x0677	; 0x800677 <xFreeBytesRemaining+0x1>
    645c:	04 17       	cp	r16, r20
    645e:	15 07       	cpc	r17, r21
    6460:	08 f4       	brcc	.+2      	; 0x6464 <pvPortMalloc+0xa6>
    6462:	52 c0       	rjmp	.+164    	; 0x6508 <pvPortMalloc+0x14a>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    6464:	c0 91 7a 06 	lds	r28, 0x067A	; 0x80067a <xStart>
    6468:	d0 91 7b 06 	lds	r29, 0x067B	; 0x80067b <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    646c:	ea e7       	ldi	r30, 0x7A	; 122
    646e:	f6 e0       	ldi	r31, 0x06	; 6
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    6470:	02 c0       	rjmp	.+4      	; 0x6476 <pvPortMalloc+0xb8>
    6472:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    6474:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    6476:	2a 81       	ldd	r18, Y+2	; 0x02
    6478:	3b 81       	ldd	r19, Y+3	; 0x03
    647a:	24 17       	cp	r18, r20
    647c:	35 07       	cpc	r19, r21
    647e:	28 f4       	brcc	.+10     	; 0x648a <pvPortMalloc+0xcc>
    6480:	28 81       	ld	r18, Y
    6482:	39 81       	ldd	r19, Y+1	; 0x01
    6484:	21 15       	cp	r18, r1
    6486:	31 05       	cpc	r19, r1
    6488:	a1 f7       	brne	.-24     	; 0x6472 <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    648a:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <pxEnd>
    648e:	90 91 79 06 	lds	r25, 0x0679	; 0x800679 <pxEnd+0x1>
    6492:	c8 17       	cp	r28, r24
    6494:	d9 07       	cpc	r29, r25
    6496:	c1 f1       	breq	.+112    	; 0x6508 <pvPortMalloc+0x14a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    6498:	c0 80       	ld	r12, Z
    649a:	d1 80       	ldd	r13, Z+1	; 0x01
    649c:	84 e0       	ldi	r24, 0x04	; 4
    649e:	c8 0e       	add	r12, r24
    64a0:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    64a2:	88 81       	ld	r24, Y
    64a4:	99 81       	ldd	r25, Y+1	; 0x01
    64a6:	91 83       	std	Z+1, r25	; 0x01
    64a8:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    64aa:	2a 81       	ldd	r18, Y+2	; 0x02
    64ac:	3b 81       	ldd	r19, Y+3	; 0x03
    64ae:	24 1b       	sub	r18, r20
    64b0:	35 0b       	sbc	r19, r21
    64b2:	29 30       	cpi	r18, 0x09	; 9
    64b4:	31 05       	cpc	r19, r1
    64b6:	48 f0       	brcs	.+18     	; 0x64ca <pvPortMalloc+0x10c>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    64b8:	ce 01       	movw	r24, r28
    64ba:	84 0f       	add	r24, r20
    64bc:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    64be:	fc 01       	movw	r30, r24
    64c0:	33 83       	std	Z+3, r19	; 0x03
    64c2:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    64c4:	5b 83       	std	Y+3, r21	; 0x03
    64c6:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    64c8:	ed de       	rcall	.-550    	; 0x62a4 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    64ca:	8a 81       	ldd	r24, Y+2	; 0x02
    64cc:	9b 81       	ldd	r25, Y+3	; 0x03
    64ce:	08 1b       	sub	r16, r24
    64d0:	19 0b       	sbc	r17, r25
    64d2:	10 93 77 06 	sts	0x0677, r17	; 0x800677 <xFreeBytesRemaining+0x1>
    64d6:	00 93 76 06 	sts	0x0676, r16	; 0x800676 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    64da:	20 91 74 06 	lds	r18, 0x0674	; 0x800674 <xMinimumEverFreeBytesRemaining>
    64de:	30 91 75 06 	lds	r19, 0x0675	; 0x800675 <xMinimumEverFreeBytesRemaining+0x1>
    64e2:	02 17       	cp	r16, r18
    64e4:	13 07       	cpc	r17, r19
    64e6:	20 f4       	brcc	.+8      	; 0x64f0 <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    64e8:	10 93 75 06 	sts	0x0675, r17	; 0x800675 <xMinimumEverFreeBytesRemaining+0x1>
    64ec:	00 93 74 06 	sts	0x0674, r16	; 0x800674 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    64f0:	e8 2a       	or	r14, r24
    64f2:	f9 2a       	or	r15, r25
    64f4:	fb 82       	std	Y+3, r15	; 0x03
    64f6:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    64f8:	19 82       	std	Y+1, r1	; 0x01
    64fa:	18 82       	st	Y, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    64fc:	0e 94 57 3b 	call	0x76ae	; 0x76ae <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    6500:	c1 14       	cp	r12, r1
    6502:	d1 04       	cpc	r13, r1
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    6504:	39 f4       	brne	.+14     	; 0x6514 <pvPortMalloc+0x156>
    6506:	4c df       	rcall	.-360    	; 0x63a0 <vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    6508:	0e 94 57 3b 	call	0x76ae	; 0x76ae <xTaskResumeAll>
    650c:	fc cf       	rjmp	.-8      	; 0x6506 <pvPortMalloc+0x148>
    650e:	0e 94 57 3b 	call	0x76ae	; 0x76ae <xTaskResumeAll>
    6512:	f9 cf       	rjmp	.-14     	; 0x6506 <pvPortMalloc+0x148>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    6514:	c6 01       	movw	r24, r12
    6516:	df 91       	pop	r29
    6518:	cf 91       	pop	r28
    651a:	1f 91       	pop	r17
    651c:	0f 91       	pop	r16
    651e:	ff 90       	pop	r15
    6520:	ef 90       	pop	r14
    6522:	df 90       	pop	r13
    6524:	cf 90       	pop	r12
    6526:	08 95       	ret

00006528 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    6528:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    652a:	03 96       	adiw	r24, 0x03	; 3
    652c:	92 83       	std	Z+2, r25	; 0x02
    652e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    6530:	2f ef       	ldi	r18, 0xFF	; 255
    6532:	3f ef       	ldi	r19, 0xFF	; 255
    6534:	34 83       	std	Z+4, r19	; 0x04
    6536:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    6538:	96 83       	std	Z+6, r25	; 0x06
    653a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    653c:	90 87       	std	Z+8, r25	; 0x08
    653e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    6540:	10 82       	st	Z, r1
    6542:	08 95       	ret

00006544 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    6544:	fc 01       	movw	r30, r24
    6546:	11 86       	std	Z+9, r1	; 0x09
    6548:	10 86       	std	Z+8, r1	; 0x08
    654a:	08 95       	ret

0000654c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    654c:	cf 93       	push	r28
    654e:	df 93       	push	r29
    6550:	9c 01       	movw	r18, r24
    6552:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    6554:	dc 01       	movw	r26, r24
    6556:	11 96       	adiw	r26, 0x01	; 1
    6558:	cd 91       	ld	r28, X+
    655a:	dc 91       	ld	r29, X
    655c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    655e:	d3 83       	std	Z+3, r29	; 0x03
    6560:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    6562:	8c 81       	ldd	r24, Y+4	; 0x04
    6564:	9d 81       	ldd	r25, Y+5	; 0x05
    6566:	95 83       	std	Z+5, r25	; 0x05
    6568:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    656a:	8c 81       	ldd	r24, Y+4	; 0x04
    656c:	9d 81       	ldd	r25, Y+5	; 0x05
    656e:	dc 01       	movw	r26, r24
    6570:	13 96       	adiw	r26, 0x03	; 3
    6572:	7c 93       	st	X, r23
    6574:	6e 93       	st	-X, r22
    6576:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    6578:	7d 83       	std	Y+5, r23	; 0x05
    657a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    657c:	31 87       	std	Z+9, r19	; 0x09
    657e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    6580:	f9 01       	movw	r30, r18
    6582:	80 81       	ld	r24, Z
    6584:	8f 5f       	subi	r24, 0xFF	; 255
    6586:	80 83       	st	Z, r24
}
    6588:	df 91       	pop	r29
    658a:	cf 91       	pop	r28
    658c:	08 95       	ret

0000658e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    658e:	cf 93       	push	r28
    6590:	df 93       	push	r29
    6592:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    6594:	48 81       	ld	r20, Y
    6596:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    6598:	4f 3f       	cpi	r20, 0xFF	; 255
    659a:	2f ef       	ldi	r18, 0xFF	; 255
    659c:	52 07       	cpc	r21, r18
    659e:	21 f4       	brne	.+8      	; 0x65a8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    65a0:	fc 01       	movw	r30, r24
    65a2:	a7 81       	ldd	r26, Z+7	; 0x07
    65a4:	b0 85       	ldd	r27, Z+8	; 0x08
    65a6:	0d c0       	rjmp	.+26     	; 0x65c2 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    65a8:	dc 01       	movw	r26, r24
    65aa:	13 96       	adiw	r26, 0x03	; 3
    65ac:	01 c0       	rjmp	.+2      	; 0x65b0 <vListInsert+0x22>
    65ae:	df 01       	movw	r26, r30
    65b0:	12 96       	adiw	r26, 0x02	; 2
    65b2:	ed 91       	ld	r30, X+
    65b4:	fc 91       	ld	r31, X
    65b6:	13 97       	sbiw	r26, 0x03	; 3
    65b8:	20 81       	ld	r18, Z
    65ba:	31 81       	ldd	r19, Z+1	; 0x01
    65bc:	42 17       	cp	r20, r18
    65be:	53 07       	cpc	r21, r19
    65c0:	b0 f7       	brcc	.-20     	; 0x65ae <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    65c2:	12 96       	adiw	r26, 0x02	; 2
    65c4:	ed 91       	ld	r30, X+
    65c6:	fc 91       	ld	r31, X
    65c8:	13 97       	sbiw	r26, 0x03	; 3
    65ca:	fb 83       	std	Y+3, r31	; 0x03
    65cc:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    65ce:	d5 83       	std	Z+5, r29	; 0x05
    65d0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    65d2:	bd 83       	std	Y+5, r27	; 0x05
    65d4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    65d6:	13 96       	adiw	r26, 0x03	; 3
    65d8:	dc 93       	st	X, r29
    65da:	ce 93       	st	-X, r28
    65dc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    65de:	99 87       	std	Y+9, r25	; 0x09
    65e0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    65e2:	fc 01       	movw	r30, r24
    65e4:	20 81       	ld	r18, Z
    65e6:	2f 5f       	subi	r18, 0xFF	; 255
    65e8:	20 83       	st	Z, r18
}
    65ea:	df 91       	pop	r29
    65ec:	cf 91       	pop	r28
    65ee:	08 95       	ret

000065f0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    65f0:	cf 93       	push	r28
    65f2:	df 93       	push	r29
    65f4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    65f6:	a0 85       	ldd	r26, Z+8	; 0x08
    65f8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    65fa:	c2 81       	ldd	r28, Z+2	; 0x02
    65fc:	d3 81       	ldd	r29, Z+3	; 0x03
    65fe:	84 81       	ldd	r24, Z+4	; 0x04
    6600:	95 81       	ldd	r25, Z+5	; 0x05
    6602:	9d 83       	std	Y+5, r25	; 0x05
    6604:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    6606:	c4 81       	ldd	r28, Z+4	; 0x04
    6608:	d5 81       	ldd	r29, Z+5	; 0x05
    660a:	82 81       	ldd	r24, Z+2	; 0x02
    660c:	93 81       	ldd	r25, Z+3	; 0x03
    660e:	9b 83       	std	Y+3, r25	; 0x03
    6610:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    6612:	11 96       	adiw	r26, 0x01	; 1
    6614:	8d 91       	ld	r24, X+
    6616:	9c 91       	ld	r25, X
    6618:	12 97       	sbiw	r26, 0x02	; 2
    661a:	e8 17       	cp	r30, r24
    661c:	f9 07       	cpc	r31, r25
    661e:	31 f4       	brne	.+12     	; 0x662c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    6620:	84 81       	ldd	r24, Z+4	; 0x04
    6622:	95 81       	ldd	r25, Z+5	; 0x05
    6624:	12 96       	adiw	r26, 0x02	; 2
    6626:	9c 93       	st	X, r25
    6628:	8e 93       	st	-X, r24
    662a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    662c:	11 86       	std	Z+9, r1	; 0x09
    662e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    6630:	8c 91       	ld	r24, X
    6632:	81 50       	subi	r24, 0x01	; 1
    6634:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    6636:	8c 91       	ld	r24, X
}
    6638:	df 91       	pop	r29
    663a:	cf 91       	pop	r28
    663c:	08 95       	ret

0000663e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    663e:	31 e1       	ldi	r19, 0x11	; 17
    6640:	fc 01       	movw	r30, r24
    6642:	30 83       	st	Z, r19
    6644:	31 97       	sbiw	r30, 0x01	; 1
    6646:	22 e2       	ldi	r18, 0x22	; 34
    6648:	20 83       	st	Z, r18
    664a:	31 97       	sbiw	r30, 0x01	; 1
    664c:	a3 e3       	ldi	r26, 0x33	; 51
    664e:	a0 83       	st	Z, r26
    6650:	31 97       	sbiw	r30, 0x01	; 1
    6652:	60 83       	st	Z, r22
    6654:	31 97       	sbiw	r30, 0x01	; 1
    6656:	70 83       	st	Z, r23
    6658:	31 97       	sbiw	r30, 0x01	; 1
    665a:	10 82       	st	Z, r1
    665c:	31 97       	sbiw	r30, 0x01	; 1
    665e:	10 82       	st	Z, r1
    6660:	31 97       	sbiw	r30, 0x01	; 1
    6662:	60 e8       	ldi	r22, 0x80	; 128
    6664:	60 83       	st	Z, r22
    6666:	31 97       	sbiw	r30, 0x01	; 1
    6668:	10 82       	st	Z, r1
    666a:	31 97       	sbiw	r30, 0x01	; 1
    666c:	10 82       	st	Z, r1
    666e:	31 97       	sbiw	r30, 0x01	; 1
    6670:	10 82       	st	Z, r1
    6672:	31 97       	sbiw	r30, 0x01	; 1
    6674:	62 e0       	ldi	r22, 0x02	; 2
    6676:	60 83       	st	Z, r22
    6678:	31 97       	sbiw	r30, 0x01	; 1
    667a:	63 e0       	ldi	r22, 0x03	; 3
    667c:	60 83       	st	Z, r22
    667e:	31 97       	sbiw	r30, 0x01	; 1
    6680:	64 e0       	ldi	r22, 0x04	; 4
    6682:	60 83       	st	Z, r22
    6684:	31 97       	sbiw	r30, 0x01	; 1
    6686:	65 e0       	ldi	r22, 0x05	; 5
    6688:	60 83       	st	Z, r22
    668a:	31 97       	sbiw	r30, 0x01	; 1
    668c:	66 e0       	ldi	r22, 0x06	; 6
    668e:	60 83       	st	Z, r22
    6690:	31 97       	sbiw	r30, 0x01	; 1
    6692:	67 e0       	ldi	r22, 0x07	; 7
    6694:	60 83       	st	Z, r22
    6696:	31 97       	sbiw	r30, 0x01	; 1
    6698:	68 e0       	ldi	r22, 0x08	; 8
    669a:	60 83       	st	Z, r22
    669c:	31 97       	sbiw	r30, 0x01	; 1
    669e:	69 e0       	ldi	r22, 0x09	; 9
    66a0:	60 83       	st	Z, r22
    66a2:	31 97       	sbiw	r30, 0x01	; 1
    66a4:	60 e1       	ldi	r22, 0x10	; 16
    66a6:	60 83       	st	Z, r22
    66a8:	31 97       	sbiw	r30, 0x01	; 1
    66aa:	30 83       	st	Z, r19
    66ac:	31 97       	sbiw	r30, 0x01	; 1
    66ae:	32 e1       	ldi	r19, 0x12	; 18
    66b0:	30 83       	st	Z, r19
    66b2:	31 97       	sbiw	r30, 0x01	; 1
    66b4:	33 e1       	ldi	r19, 0x13	; 19
    66b6:	30 83       	st	Z, r19
    66b8:	31 97       	sbiw	r30, 0x01	; 1
    66ba:	34 e1       	ldi	r19, 0x14	; 20
    66bc:	30 83       	st	Z, r19
    66be:	31 97       	sbiw	r30, 0x01	; 1
    66c0:	35 e1       	ldi	r19, 0x15	; 21
    66c2:	30 83       	st	Z, r19
    66c4:	31 97       	sbiw	r30, 0x01	; 1
    66c6:	36 e1       	ldi	r19, 0x16	; 22
    66c8:	30 83       	st	Z, r19
    66ca:	31 97       	sbiw	r30, 0x01	; 1
    66cc:	37 e1       	ldi	r19, 0x17	; 23
    66ce:	30 83       	st	Z, r19
    66d0:	31 97       	sbiw	r30, 0x01	; 1
    66d2:	38 e1       	ldi	r19, 0x18	; 24
    66d4:	30 83       	st	Z, r19
    66d6:	31 97       	sbiw	r30, 0x01	; 1
    66d8:	39 e1       	ldi	r19, 0x19	; 25
    66da:	30 83       	st	Z, r19
    66dc:	31 97       	sbiw	r30, 0x01	; 1
    66de:	30 e2       	ldi	r19, 0x20	; 32
    66e0:	30 83       	st	Z, r19
    66e2:	31 97       	sbiw	r30, 0x01	; 1
    66e4:	31 e2       	ldi	r19, 0x21	; 33
    66e6:	30 83       	st	Z, r19
    66e8:	31 97       	sbiw	r30, 0x01	; 1
    66ea:	20 83       	st	Z, r18
    66ec:	31 97       	sbiw	r30, 0x01	; 1
    66ee:	23 e2       	ldi	r18, 0x23	; 35
    66f0:	20 83       	st	Z, r18
    66f2:	31 97       	sbiw	r30, 0x01	; 1
    66f4:	40 83       	st	Z, r20
    66f6:	31 97       	sbiw	r30, 0x01	; 1
    66f8:	50 83       	st	Z, r21
    66fa:	31 97       	sbiw	r30, 0x01	; 1
    66fc:	26 e2       	ldi	r18, 0x26	; 38
    66fe:	20 83       	st	Z, r18
    6700:	31 97       	sbiw	r30, 0x01	; 1
    6702:	27 e2       	ldi	r18, 0x27	; 39
    6704:	20 83       	st	Z, r18
    6706:	31 97       	sbiw	r30, 0x01	; 1
    6708:	28 e2       	ldi	r18, 0x28	; 40
    670a:	20 83       	st	Z, r18
    670c:	31 97       	sbiw	r30, 0x01	; 1
    670e:	29 e2       	ldi	r18, 0x29	; 41
    6710:	20 83       	st	Z, r18
    6712:	31 97       	sbiw	r30, 0x01	; 1
    6714:	20 e3       	ldi	r18, 0x30	; 48
    6716:	20 83       	st	Z, r18
    6718:	31 97       	sbiw	r30, 0x01	; 1
    671a:	21 e3       	ldi	r18, 0x31	; 49
    671c:	20 83       	st	Z, r18
    671e:	89 97       	sbiw	r24, 0x29	; 41
    6720:	08 95       	ret

00006722 <xPortStartScheduler>:
    6722:	89 e0       	ldi	r24, 0x09	; 9
    6724:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7c0089>
    6728:	83 ec       	ldi	r24, 0xC3	; 195
    672a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7c0088>
    672e:	8b e0       	ldi	r24, 0x0B	; 11
    6730:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
    6734:	ef e6       	ldi	r30, 0x6F	; 111
    6736:	f0 e0       	ldi	r31, 0x00	; 0
    6738:	80 81       	ld	r24, Z
    673a:	82 60       	ori	r24, 0x02	; 2
    673c:	80 83       	st	Z, r24
    673e:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    6742:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    6746:	cd 91       	ld	r28, X+
    6748:	cd bf       	out	0x3d, r28	; 61
    674a:	dd 91       	ld	r29, X+
    674c:	de bf       	out	0x3e, r29	; 62
    674e:	ff 91       	pop	r31
    6750:	ef 91       	pop	r30
    6752:	df 91       	pop	r29
    6754:	cf 91       	pop	r28
    6756:	bf 91       	pop	r27
    6758:	af 91       	pop	r26
    675a:	9f 91       	pop	r25
    675c:	8f 91       	pop	r24
    675e:	7f 91       	pop	r23
    6760:	6f 91       	pop	r22
    6762:	5f 91       	pop	r21
    6764:	4f 91       	pop	r20
    6766:	3f 91       	pop	r19
    6768:	2f 91       	pop	r18
    676a:	1f 91       	pop	r17
    676c:	0f 91       	pop	r16
    676e:	ff 90       	pop	r15
    6770:	ef 90       	pop	r14
    6772:	df 90       	pop	r13
    6774:	cf 90       	pop	r12
    6776:	bf 90       	pop	r11
    6778:	af 90       	pop	r10
    677a:	9f 90       	pop	r9
    677c:	8f 90       	pop	r8
    677e:	7f 90       	pop	r7
    6780:	6f 90       	pop	r6
    6782:	5f 90       	pop	r5
    6784:	4f 90       	pop	r4
    6786:	3f 90       	pop	r3
    6788:	2f 90       	pop	r2
    678a:	1f 90       	pop	r1
    678c:	0f 90       	pop	r0
    678e:	0c be       	out	0x3c, r0	; 60
    6790:	0f 90       	pop	r0
    6792:	0b be       	out	0x3b, r0	; 59
    6794:	0f 90       	pop	r0
    6796:	0f be       	out	0x3f, r0	; 63
    6798:	0f 90       	pop	r0
    679a:	08 95       	ret
    679c:	81 e0       	ldi	r24, 0x01	; 1
    679e:	08 95       	ret

000067a0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    67a0:	0f 92       	push	r0
    67a2:	0f b6       	in	r0, 0x3f	; 63
    67a4:	f8 94       	cli
    67a6:	0f 92       	push	r0
    67a8:	0b b6       	in	r0, 0x3b	; 59
    67aa:	0f 92       	push	r0
    67ac:	0c b6       	in	r0, 0x3c	; 60
    67ae:	0f 92       	push	r0
    67b0:	1f 92       	push	r1
    67b2:	11 24       	eor	r1, r1
    67b4:	2f 92       	push	r2
    67b6:	3f 92       	push	r3
    67b8:	4f 92       	push	r4
    67ba:	5f 92       	push	r5
    67bc:	6f 92       	push	r6
    67be:	7f 92       	push	r7
    67c0:	8f 92       	push	r8
    67c2:	9f 92       	push	r9
    67c4:	af 92       	push	r10
    67c6:	bf 92       	push	r11
    67c8:	cf 92       	push	r12
    67ca:	df 92       	push	r13
    67cc:	ef 92       	push	r14
    67ce:	ff 92       	push	r15
    67d0:	0f 93       	push	r16
    67d2:	1f 93       	push	r17
    67d4:	2f 93       	push	r18
    67d6:	3f 93       	push	r19
    67d8:	4f 93       	push	r20
    67da:	5f 93       	push	r21
    67dc:	6f 93       	push	r22
    67de:	7f 93       	push	r23
    67e0:	8f 93       	push	r24
    67e2:	9f 93       	push	r25
    67e4:	af 93       	push	r26
    67e6:	bf 93       	push	r27
    67e8:	cf 93       	push	r28
    67ea:	df 93       	push	r29
    67ec:	ef 93       	push	r30
    67ee:	ff 93       	push	r31
    67f0:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    67f4:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    67f8:	0d b6       	in	r0, 0x3d	; 61
    67fa:	0d 92       	st	X+, r0
    67fc:	0e b6       	in	r0, 0x3e	; 62
    67fe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    6800:	0e 94 cd 3f 	call	0x7f9a	; 0x7f9a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    6804:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    6808:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    680c:	cd 91       	ld	r28, X+
    680e:	cd bf       	out	0x3d, r28	; 61
    6810:	dd 91       	ld	r29, X+
    6812:	de bf       	out	0x3e, r29	; 62
    6814:	ff 91       	pop	r31
    6816:	ef 91       	pop	r30
    6818:	df 91       	pop	r29
    681a:	cf 91       	pop	r28
    681c:	bf 91       	pop	r27
    681e:	af 91       	pop	r26
    6820:	9f 91       	pop	r25
    6822:	8f 91       	pop	r24
    6824:	7f 91       	pop	r23
    6826:	6f 91       	pop	r22
    6828:	5f 91       	pop	r21
    682a:	4f 91       	pop	r20
    682c:	3f 91       	pop	r19
    682e:	2f 91       	pop	r18
    6830:	1f 91       	pop	r17
    6832:	0f 91       	pop	r16
    6834:	ff 90       	pop	r15
    6836:	ef 90       	pop	r14
    6838:	df 90       	pop	r13
    683a:	cf 90       	pop	r12
    683c:	bf 90       	pop	r11
    683e:	af 90       	pop	r10
    6840:	9f 90       	pop	r9
    6842:	8f 90       	pop	r8
    6844:	7f 90       	pop	r7
    6846:	6f 90       	pop	r6
    6848:	5f 90       	pop	r5
    684a:	4f 90       	pop	r4
    684c:	3f 90       	pop	r3
    684e:	2f 90       	pop	r2
    6850:	1f 90       	pop	r1
    6852:	0f 90       	pop	r0
    6854:	0c be       	out	0x3c, r0	; 60
    6856:	0f 90       	pop	r0
    6858:	0b be       	out	0x3b, r0	; 59
    685a:	0f 90       	pop	r0
    685c:	0f be       	out	0x3f, r0	; 63
    685e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    6860:	08 95       	ret

00006862 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    6862:	0f 92       	push	r0
    6864:	0f b6       	in	r0, 0x3f	; 63
    6866:	f8 94       	cli
    6868:	0f 92       	push	r0
    686a:	0b b6       	in	r0, 0x3b	; 59
    686c:	0f 92       	push	r0
    686e:	0c b6       	in	r0, 0x3c	; 60
    6870:	0f 92       	push	r0
    6872:	1f 92       	push	r1
    6874:	11 24       	eor	r1, r1
    6876:	2f 92       	push	r2
    6878:	3f 92       	push	r3
    687a:	4f 92       	push	r4
    687c:	5f 92       	push	r5
    687e:	6f 92       	push	r6
    6880:	7f 92       	push	r7
    6882:	8f 92       	push	r8
    6884:	9f 92       	push	r9
    6886:	af 92       	push	r10
    6888:	bf 92       	push	r11
    688a:	cf 92       	push	r12
    688c:	df 92       	push	r13
    688e:	ef 92       	push	r14
    6890:	ff 92       	push	r15
    6892:	0f 93       	push	r16
    6894:	1f 93       	push	r17
    6896:	2f 93       	push	r18
    6898:	3f 93       	push	r19
    689a:	4f 93       	push	r20
    689c:	5f 93       	push	r21
    689e:	6f 93       	push	r22
    68a0:	7f 93       	push	r23
    68a2:	8f 93       	push	r24
    68a4:	9f 93       	push	r25
    68a6:	af 93       	push	r26
    68a8:	bf 93       	push	r27
    68aa:	cf 93       	push	r28
    68ac:	df 93       	push	r29
    68ae:	ef 93       	push	r30
    68b0:	ff 93       	push	r31
    68b2:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    68b6:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    68ba:	0d b6       	in	r0, 0x3d	; 61
    68bc:	0d 92       	st	X+, r0
    68be:	0e b6       	in	r0, 0x3e	; 62
    68c0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    68c2:	53 d6       	rcall	.+3238   	; 0x756a <xTaskIncrementTick>
    68c4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    68c6:	0e 94 cd 3f 	call	0x7f9a	; 0x7f9a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    68ca:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    68ce:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    68d2:	cd 91       	ld	r28, X+
    68d4:	cd bf       	out	0x3d, r28	; 61
    68d6:	dd 91       	ld	r29, X+
    68d8:	de bf       	out	0x3e, r29	; 62
    68da:	ff 91       	pop	r31
    68dc:	ef 91       	pop	r30
    68de:	df 91       	pop	r29
    68e0:	cf 91       	pop	r28
    68e2:	bf 91       	pop	r27
    68e4:	af 91       	pop	r26
    68e6:	9f 91       	pop	r25
    68e8:	8f 91       	pop	r24
    68ea:	7f 91       	pop	r23
    68ec:	6f 91       	pop	r22
    68ee:	5f 91       	pop	r21
    68f0:	4f 91       	pop	r20
    68f2:	3f 91       	pop	r19
    68f4:	2f 91       	pop	r18
    68f6:	1f 91       	pop	r17
    68f8:	0f 91       	pop	r16
    68fa:	ff 90       	pop	r15
    68fc:	ef 90       	pop	r14
    68fe:	df 90       	pop	r13
    6900:	cf 90       	pop	r12
    6902:	bf 90       	pop	r11
    6904:	af 90       	pop	r10
    6906:	9f 90       	pop	r9
    6908:	8f 90       	pop	r8
    690a:	7f 90       	pop	r7
    690c:	6f 90       	pop	r6
    690e:	5f 90       	pop	r5
    6910:	4f 90       	pop	r4
    6912:	3f 90       	pop	r3
    6914:	2f 90       	pop	r2
    6916:	1f 90       	pop	r1
    6918:	0f 90       	pop	r0
    691a:	0c be       	out	0x3c, r0	; 60
    691c:	0f 90       	pop	r0
    691e:	0b be       	out	0x3b, r0	; 59
    6920:	0f 90       	pop	r0
    6922:	0f be       	out	0x3f, r0	; 63
    6924:	0f 90       	pop	r0

	asm volatile ( "ret" );
    6926:	08 95       	ret

00006928 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    6928:	9c df       	rcall	.-200    	; 0x6862 <vPortYieldFromTick>
		asm volatile ( "reti" );
    692a:	18 95       	reti

0000692c <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    692c:	0f b6       	in	r0, 0x3f	; 63
    692e:	f8 94       	cli
    6930:	0f 92       	push	r0
    6932:	fc 01       	movw	r30, r24
    6934:	92 8d       	ldd	r25, Z+26	; 0x1a
    6936:	0f 90       	pop	r0
    6938:	0f be       	out	0x3f, r0	; 63
    693a:	81 e0       	ldi	r24, 0x01	; 1
    693c:	91 11       	cpse	r25, r1
    693e:	80 e0       	ldi	r24, 0x00	; 0
    6940:	08 95       	ret

00006942 <prvCopyDataToQueue>:
    6942:	0f 93       	push	r16
    6944:	1f 93       	push	r17
    6946:	cf 93       	push	r28
    6948:	df 93       	push	r29
    694a:	ec 01       	movw	r28, r24
    694c:	04 2f       	mov	r16, r20
    694e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    6950:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6952:	41 11       	cpse	r20, r1
    6954:	0c c0       	rjmp	.+24     	; 0x696e <prvCopyDataToQueue+0x2c>
    6956:	88 81       	ld	r24, Y
    6958:	99 81       	ldd	r25, Y+1	; 0x01
    695a:	89 2b       	or	r24, r25
    695c:	09 f0       	breq	.+2      	; 0x6960 <prvCopyDataToQueue+0x1e>
    695e:	42 c0       	rjmp	.+132    	; 0x69e4 <prvCopyDataToQueue+0xa2>
    6960:	8c 81       	ldd	r24, Y+4	; 0x04
    6962:	9d 81       	ldd	r25, Y+5	; 0x05
    6964:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <xTaskPriorityDisinherit>
    6968:	1d 82       	std	Y+5, r1	; 0x05
    696a:	1c 82       	std	Y+4, r1	; 0x04
    696c:	42 c0       	rjmp	.+132    	; 0x69f2 <prvCopyDataToQueue+0xb0>
    696e:	01 11       	cpse	r16, r1
    6970:	17 c0       	rjmp	.+46     	; 0x69a0 <prvCopyDataToQueue+0x5e>
    6972:	50 e0       	ldi	r21, 0x00	; 0
    6974:	8a 81       	ldd	r24, Y+2	; 0x02
    6976:	9b 81       	ldd	r25, Y+3	; 0x03
    6978:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>
    697c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    697e:	8a 81       	ldd	r24, Y+2	; 0x02
    6980:	9b 81       	ldd	r25, Y+3	; 0x03
    6982:	82 0f       	add	r24, r18
    6984:	91 1d       	adc	r25, r1
    6986:	9b 83       	std	Y+3, r25	; 0x03
    6988:	8a 83       	std	Y+2, r24	; 0x02
    698a:	2c 81       	ldd	r18, Y+4	; 0x04
    698c:	3d 81       	ldd	r19, Y+5	; 0x05
    698e:	82 17       	cp	r24, r18
    6990:	93 07       	cpc	r25, r19
    6992:	50 f1       	brcs	.+84     	; 0x69e8 <prvCopyDataToQueue+0xa6>
    6994:	88 81       	ld	r24, Y
    6996:	99 81       	ldd	r25, Y+1	; 0x01
    6998:	9b 83       	std	Y+3, r25	; 0x03
    699a:	8a 83       	std	Y+2, r24	; 0x02
    699c:	80 e0       	ldi	r24, 0x00	; 0
    699e:	29 c0       	rjmp	.+82     	; 0x69f2 <prvCopyDataToQueue+0xb0>
    69a0:	50 e0       	ldi	r21, 0x00	; 0
    69a2:	8e 81       	ldd	r24, Y+6	; 0x06
    69a4:	9f 81       	ldd	r25, Y+7	; 0x07
    69a6:	0e 94 a1 44 	call	0x8942	; 0x8942 <memcpy>
    69aa:	8c 8d       	ldd	r24, Y+28	; 0x1c
    69ac:	90 e0       	ldi	r25, 0x00	; 0
    69ae:	91 95       	neg	r25
    69b0:	81 95       	neg	r24
    69b2:	91 09       	sbc	r25, r1
    69b4:	2e 81       	ldd	r18, Y+6	; 0x06
    69b6:	3f 81       	ldd	r19, Y+7	; 0x07
    69b8:	28 0f       	add	r18, r24
    69ba:	39 1f       	adc	r19, r25
    69bc:	3f 83       	std	Y+7, r19	; 0x07
    69be:	2e 83       	std	Y+6, r18	; 0x06
    69c0:	48 81       	ld	r20, Y
    69c2:	59 81       	ldd	r21, Y+1	; 0x01
    69c4:	24 17       	cp	r18, r20
    69c6:	35 07       	cpc	r19, r21
    69c8:	30 f4       	brcc	.+12     	; 0x69d6 <prvCopyDataToQueue+0x94>
    69ca:	2c 81       	ldd	r18, Y+4	; 0x04
    69cc:	3d 81       	ldd	r19, Y+5	; 0x05
    69ce:	82 0f       	add	r24, r18
    69d0:	93 1f       	adc	r25, r19
    69d2:	9f 83       	std	Y+7, r25	; 0x07
    69d4:	8e 83       	std	Y+6, r24	; 0x06
    69d6:	02 30       	cpi	r16, 0x02	; 2
    69d8:	49 f4       	brne	.+18     	; 0x69ec <prvCopyDataToQueue+0xaa>
    69da:	11 23       	and	r17, r17
    69dc:	49 f0       	breq	.+18     	; 0x69f0 <prvCopyDataToQueue+0xae>
    69de:	11 50       	subi	r17, 0x01	; 1
    69e0:	80 e0       	ldi	r24, 0x00	; 0
    69e2:	07 c0       	rjmp	.+14     	; 0x69f2 <prvCopyDataToQueue+0xb0>
    69e4:	80 e0       	ldi	r24, 0x00	; 0
    69e6:	05 c0       	rjmp	.+10     	; 0x69f2 <prvCopyDataToQueue+0xb0>
    69e8:	80 e0       	ldi	r24, 0x00	; 0
    69ea:	03 c0       	rjmp	.+6      	; 0x69f2 <prvCopyDataToQueue+0xb0>
    69ec:	80 e0       	ldi	r24, 0x00	; 0
    69ee:	01 c0       	rjmp	.+2      	; 0x69f2 <prvCopyDataToQueue+0xb0>
    69f0:	80 e0       	ldi	r24, 0x00	; 0
    69f2:	1f 5f       	subi	r17, 0xFF	; 255
    69f4:	1a 8f       	std	Y+26, r17	; 0x1a
    69f6:	df 91       	pop	r29
    69f8:	cf 91       	pop	r28
    69fa:	1f 91       	pop	r17
    69fc:	0f 91       	pop	r16
    69fe:	08 95       	ret

00006a00 <prvCopyDataFromQueue>:
    6a00:	fc 01       	movw	r30, r24
    6a02:	44 8d       	ldd	r20, Z+28	; 0x1c
    6a04:	44 23       	and	r20, r20
    6a06:	a9 f0       	breq	.+42     	; 0x6a32 <prvCopyDataFromQueue+0x32>
    6a08:	50 e0       	ldi	r21, 0x00	; 0
    6a0a:	26 81       	ldd	r18, Z+6	; 0x06
    6a0c:	37 81       	ldd	r19, Z+7	; 0x07
    6a0e:	24 0f       	add	r18, r20
    6a10:	35 1f       	adc	r19, r21
    6a12:	37 83       	std	Z+7, r19	; 0x07
    6a14:	26 83       	std	Z+6, r18	; 0x06
    6a16:	84 81       	ldd	r24, Z+4	; 0x04
    6a18:	95 81       	ldd	r25, Z+5	; 0x05
    6a1a:	28 17       	cp	r18, r24
    6a1c:	39 07       	cpc	r19, r25
    6a1e:	20 f0       	brcs	.+8      	; 0x6a28 <prvCopyDataFromQueue+0x28>
    6a20:	80 81       	ld	r24, Z
    6a22:	91 81       	ldd	r25, Z+1	; 0x01
    6a24:	97 83       	std	Z+7, r25	; 0x07
    6a26:	86 83       	std	Z+6, r24	; 0x06
    6a28:	cb 01       	movw	r24, r22
    6a2a:	66 81       	ldd	r22, Z+6	; 0x06
    6a2c:	77 81       	ldd	r23, Z+7	; 0x07
    6a2e:	0c 94 a1 44 	jmp	0x8942	; 0x8942 <memcpy>
    6a32:	08 95       	ret

00006a34 <prvUnlockQueue>:
    6a34:	ef 92       	push	r14
    6a36:	ff 92       	push	r15
    6a38:	0f 93       	push	r16
    6a3a:	1f 93       	push	r17
    6a3c:	cf 93       	push	r28
    6a3e:	8c 01       	movw	r16, r24
    6a40:	0f b6       	in	r0, 0x3f	; 63
    6a42:	f8 94       	cli
    6a44:	0f 92       	push	r0
    6a46:	fc 01       	movw	r30, r24
    6a48:	c6 8d       	ldd	r28, Z+30	; 0x1e
    6a4a:	1c 16       	cp	r1, r28
    6a4c:	9c f4       	brge	.+38     	; 0x6a74 <prvUnlockQueue+0x40>
    6a4e:	81 89       	ldd	r24, Z+17	; 0x11
    6a50:	81 11       	cpse	r24, r1
    6a52:	06 c0       	rjmp	.+12     	; 0x6a60 <prvUnlockQueue+0x2c>
    6a54:	0f c0       	rjmp	.+30     	; 0x6a74 <prvUnlockQueue+0x40>
    6a56:	f8 01       	movw	r30, r16
    6a58:	81 89       	ldd	r24, Z+17	; 0x11
    6a5a:	81 11       	cpse	r24, r1
    6a5c:	05 c0       	rjmp	.+10     	; 0x6a68 <prvUnlockQueue+0x34>
    6a5e:	0a c0       	rjmp	.+20     	; 0x6a74 <prvUnlockQueue+0x40>
    6a60:	78 01       	movw	r14, r16
    6a62:	f1 e1       	ldi	r31, 0x11	; 17
    6a64:	ef 0e       	add	r14, r31
    6a66:	f1 1c       	adc	r15, r1
    6a68:	c7 01       	movw	r24, r14
    6a6a:	d7 d6       	rcall	.+3502   	; 0x781a <xTaskRemoveFromEventList>
    6a6c:	81 11       	cpse	r24, r1
    6a6e:	5d d7       	rcall	.+3770   	; 0x792a <vTaskMissedYield>
    6a70:	c1 50       	subi	r28, 0x01	; 1
    6a72:	89 f7       	brne	.-30     	; 0x6a56 <prvUnlockQueue+0x22>
    6a74:	8f ef       	ldi	r24, 0xFF	; 255
    6a76:	f8 01       	movw	r30, r16
    6a78:	86 8f       	std	Z+30, r24	; 0x1e
    6a7a:	0f 90       	pop	r0
    6a7c:	0f be       	out	0x3f, r0	; 63
    6a7e:	0f b6       	in	r0, 0x3f	; 63
    6a80:	f8 94       	cli
    6a82:	0f 92       	push	r0
    6a84:	c5 8d       	ldd	r28, Z+29	; 0x1d
    6a86:	1c 16       	cp	r1, r28
    6a88:	9c f4       	brge	.+38     	; 0x6ab0 <prvUnlockQueue+0x7c>
    6a8a:	80 85       	ldd	r24, Z+8	; 0x08
    6a8c:	81 11       	cpse	r24, r1
    6a8e:	06 c0       	rjmp	.+12     	; 0x6a9c <prvUnlockQueue+0x68>
    6a90:	0f c0       	rjmp	.+30     	; 0x6ab0 <prvUnlockQueue+0x7c>
    6a92:	f8 01       	movw	r30, r16
    6a94:	80 85       	ldd	r24, Z+8	; 0x08
    6a96:	81 11       	cpse	r24, r1
    6a98:	05 c0       	rjmp	.+10     	; 0x6aa4 <prvUnlockQueue+0x70>
    6a9a:	0a c0       	rjmp	.+20     	; 0x6ab0 <prvUnlockQueue+0x7c>
    6a9c:	78 01       	movw	r14, r16
    6a9e:	f8 e0       	ldi	r31, 0x08	; 8
    6aa0:	ef 0e       	add	r14, r31
    6aa2:	f1 1c       	adc	r15, r1
    6aa4:	c7 01       	movw	r24, r14
    6aa6:	b9 d6       	rcall	.+3442   	; 0x781a <xTaskRemoveFromEventList>
    6aa8:	81 11       	cpse	r24, r1
    6aaa:	3f d7       	rcall	.+3710   	; 0x792a <vTaskMissedYield>
    6aac:	c1 50       	subi	r28, 0x01	; 1
    6aae:	89 f7       	brne	.-30     	; 0x6a92 <prvUnlockQueue+0x5e>
    6ab0:	8f ef       	ldi	r24, 0xFF	; 255
    6ab2:	f8 01       	movw	r30, r16
    6ab4:	85 8f       	std	Z+29, r24	; 0x1d
    6ab6:	0f 90       	pop	r0
    6ab8:	0f be       	out	0x3f, r0	; 63
    6aba:	cf 91       	pop	r28
    6abc:	1f 91       	pop	r17
    6abe:	0f 91       	pop	r16
    6ac0:	ff 90       	pop	r15
    6ac2:	ef 90       	pop	r14
    6ac4:	08 95       	ret

00006ac6 <xQueueGenericReset>:
    6ac6:	cf 93       	push	r28
    6ac8:	df 93       	push	r29
    6aca:	ec 01       	movw	r28, r24
    6acc:	0f b6       	in	r0, 0x3f	; 63
    6ace:	f8 94       	cli
    6ad0:	0f 92       	push	r0
    6ad2:	e8 81       	ld	r30, Y
    6ad4:	f9 81       	ldd	r31, Y+1	; 0x01
    6ad6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6ad8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    6ada:	90 e0       	ldi	r25, 0x00	; 0
    6adc:	30 e0       	ldi	r19, 0x00	; 0
    6ade:	82 9f       	mul	r24, r18
    6ae0:	a0 01       	movw	r20, r0
    6ae2:	83 9f       	mul	r24, r19
    6ae4:	50 0d       	add	r21, r0
    6ae6:	92 9f       	mul	r25, r18
    6ae8:	50 0d       	add	r21, r0
    6aea:	11 24       	eor	r1, r1
    6aec:	4e 0f       	add	r20, r30
    6aee:	5f 1f       	adc	r21, r31
    6af0:	5d 83       	std	Y+5, r21	; 0x05
    6af2:	4c 83       	std	Y+4, r20	; 0x04
    6af4:	1a 8e       	std	Y+26, r1	; 0x1a
    6af6:	fb 83       	std	Y+3, r31	; 0x03
    6af8:	ea 83       	std	Y+2, r30	; 0x02
    6afa:	01 97       	sbiw	r24, 0x01	; 1
    6afc:	82 9f       	mul	r24, r18
    6afe:	a0 01       	movw	r20, r0
    6b00:	83 9f       	mul	r24, r19
    6b02:	50 0d       	add	r21, r0
    6b04:	92 9f       	mul	r25, r18
    6b06:	50 0d       	add	r21, r0
    6b08:	11 24       	eor	r1, r1
    6b0a:	cf 01       	movw	r24, r30
    6b0c:	84 0f       	add	r24, r20
    6b0e:	95 1f       	adc	r25, r21
    6b10:	9f 83       	std	Y+7, r25	; 0x07
    6b12:	8e 83       	std	Y+6, r24	; 0x06
    6b14:	8f ef       	ldi	r24, 0xFF	; 255
    6b16:	8d 8f       	std	Y+29, r24	; 0x1d
    6b18:	8e 8f       	std	Y+30, r24	; 0x1e
    6b1a:	61 11       	cpse	r22, r1
    6b1c:	0a c0       	rjmp	.+20     	; 0x6b32 <xQueueGenericReset+0x6c>
    6b1e:	88 85       	ldd	r24, Y+8	; 0x08
    6b20:	88 23       	and	r24, r24
    6b22:	69 f0       	breq	.+26     	; 0x6b3e <xQueueGenericReset+0x78>
    6b24:	ce 01       	movw	r24, r28
    6b26:	08 96       	adiw	r24, 0x08	; 8
    6b28:	78 d6       	rcall	.+3312   	; 0x781a <xTaskRemoveFromEventList>
    6b2a:	88 23       	and	r24, r24
    6b2c:	41 f0       	breq	.+16     	; 0x6b3e <xQueueGenericReset+0x78>
    6b2e:	38 de       	rcall	.-912    	; 0x67a0 <vPortYield>
    6b30:	06 c0       	rjmp	.+12     	; 0x6b3e <xQueueGenericReset+0x78>
    6b32:	ce 01       	movw	r24, r28
    6b34:	08 96       	adiw	r24, 0x08	; 8
    6b36:	f8 dc       	rcall	.-1552   	; 0x6528 <vListInitialise>
    6b38:	ce 01       	movw	r24, r28
    6b3a:	41 96       	adiw	r24, 0x11	; 17
    6b3c:	f5 dc       	rcall	.-1558   	; 0x6528 <vListInitialise>
    6b3e:	0f 90       	pop	r0
    6b40:	0f be       	out	0x3f, r0	; 63
    6b42:	81 e0       	ldi	r24, 0x01	; 1
    6b44:	df 91       	pop	r29
    6b46:	cf 91       	pop	r28
    6b48:	08 95       	ret

00006b4a <xQueueGenericCreate>:
    6b4a:	ff 92       	push	r15
    6b4c:	0f 93       	push	r16
    6b4e:	1f 93       	push	r17
    6b50:	cf 93       	push	r28
    6b52:	df 93       	push	r29
    6b54:	08 2f       	mov	r16, r24
    6b56:	16 2f       	mov	r17, r22
    6b58:	f4 2e       	mov	r15, r20
    6b5a:	66 23       	and	r22, r22
    6b5c:	b9 f0       	breq	.+46     	; 0x6b8c <xQueueGenericCreate+0x42>
    6b5e:	86 9f       	mul	r24, r22
    6b60:	c0 01       	movw	r24, r0
    6b62:	11 24       	eor	r1, r1
    6b64:	81 96       	adiw	r24, 0x21	; 33
    6b66:	2b dc       	rcall	.-1962   	; 0x63be <pvPortMalloc>
    6b68:	ec 01       	movw	r28, r24
    6b6a:	00 97       	sbiw	r24, 0x00	; 0
    6b6c:	41 f4       	brne	.+16     	; 0x6b7e <xQueueGenericCreate+0x34>
    6b6e:	14 c0       	rjmp	.+40     	; 0x6b98 <xQueueGenericCreate+0x4e>
    6b70:	0b 8f       	std	Y+27, r16	; 0x1b
    6b72:	1c 8f       	std	Y+28, r17	; 0x1c
    6b74:	61 e0       	ldi	r22, 0x01	; 1
    6b76:	ce 01       	movw	r24, r28
    6b78:	a6 df       	rcall	.-180    	; 0x6ac6 <xQueueGenericReset>
    6b7a:	f8 a2       	std	Y+32, r15	; 0x20
    6b7c:	0d c0       	rjmp	.+26     	; 0x6b98 <xQueueGenericCreate+0x4e>
    6b7e:	81 96       	adiw	r24, 0x21	; 33
    6b80:	99 83       	std	Y+1, r25	; 0x01
    6b82:	88 83       	st	Y, r24
    6b84:	f5 cf       	rjmp	.-22     	; 0x6b70 <xQueueGenericCreate+0x26>
    6b86:	d9 83       	std	Y+1, r29	; 0x01
    6b88:	c8 83       	st	Y, r28
    6b8a:	f2 cf       	rjmp	.-28     	; 0x6b70 <xQueueGenericCreate+0x26>
    6b8c:	81 e2       	ldi	r24, 0x21	; 33
    6b8e:	90 e0       	ldi	r25, 0x00	; 0
    6b90:	16 dc       	rcall	.-2004   	; 0x63be <pvPortMalloc>
    6b92:	ec 01       	movw	r28, r24
    6b94:	89 2b       	or	r24, r25
    6b96:	b9 f7       	brne	.-18     	; 0x6b86 <xQueueGenericCreate+0x3c>
    6b98:	ce 01       	movw	r24, r28
    6b9a:	df 91       	pop	r29
    6b9c:	cf 91       	pop	r28
    6b9e:	1f 91       	pop	r17
    6ba0:	0f 91       	pop	r16
    6ba2:	ff 90       	pop	r15
    6ba4:	08 95       	ret

00006ba6 <xQueueGenericSend>:
    6ba6:	9f 92       	push	r9
    6ba8:	af 92       	push	r10
    6baa:	bf 92       	push	r11
    6bac:	cf 92       	push	r12
    6bae:	df 92       	push	r13
    6bb0:	ef 92       	push	r14
    6bb2:	ff 92       	push	r15
    6bb4:	0f 93       	push	r16
    6bb6:	1f 93       	push	r17
    6bb8:	cf 93       	push	r28
    6bba:	df 93       	push	r29
    6bbc:	00 d0       	rcall	.+0      	; 0x6bbe <xQueueGenericSend+0x18>
    6bbe:	1f 92       	push	r1
    6bc0:	1f 92       	push	r1
    6bc2:	cd b7       	in	r28, 0x3d	; 61
    6bc4:	de b7       	in	r29, 0x3e	; 62
    6bc6:	8c 01       	movw	r16, r24
    6bc8:	6b 01       	movw	r12, r22
    6bca:	5d 83       	std	Y+5, r21	; 0x05
    6bcc:	4c 83       	std	Y+4, r20	; 0x04
    6bce:	a2 2e       	mov	r10, r18
    6bd0:	b1 2c       	mov	r11, r1
    6bd2:	99 24       	eor	r9, r9
    6bd4:	93 94       	inc	r9
    6bd6:	7c 01       	movw	r14, r24
    6bd8:	88 e0       	ldi	r24, 0x08	; 8
    6bda:	e8 0e       	add	r14, r24
    6bdc:	f1 1c       	adc	r15, r1
    6bde:	0f b6       	in	r0, 0x3f	; 63
    6be0:	f8 94       	cli
    6be2:	0f 92       	push	r0
    6be4:	f8 01       	movw	r30, r16
    6be6:	92 8d       	ldd	r25, Z+26	; 0x1a
    6be8:	83 8d       	ldd	r24, Z+27	; 0x1b
    6bea:	98 17       	cp	r25, r24
    6bec:	18 f0       	brcs	.+6      	; 0x6bf4 <xQueueGenericSend+0x4e>
    6bee:	f2 e0       	ldi	r31, 0x02	; 2
    6bf0:	af 12       	cpse	r10, r31
    6bf2:	15 c0       	rjmp	.+42     	; 0x6c1e <xQueueGenericSend+0x78>
    6bf4:	4a 2d       	mov	r20, r10
    6bf6:	b6 01       	movw	r22, r12
    6bf8:	c8 01       	movw	r24, r16
    6bfa:	a3 de       	rcall	.-698    	; 0x6942 <prvCopyDataToQueue>
    6bfc:	f8 01       	movw	r30, r16
    6bfe:	91 89       	ldd	r25, Z+17	; 0x11
    6c00:	99 23       	and	r25, r25
    6c02:	39 f0       	breq	.+14     	; 0x6c12 <xQueueGenericSend+0x6c>
    6c04:	c8 01       	movw	r24, r16
    6c06:	41 96       	adiw	r24, 0x11	; 17
    6c08:	08 d6       	rcall	.+3088   	; 0x781a <xTaskRemoveFromEventList>
    6c0a:	88 23       	and	r24, r24
    6c0c:	21 f0       	breq	.+8      	; 0x6c16 <xQueueGenericSend+0x70>
    6c0e:	c8 dd       	rcall	.-1136   	; 0x67a0 <vPortYield>
    6c10:	02 c0       	rjmp	.+4      	; 0x6c16 <xQueueGenericSend+0x70>
    6c12:	81 11       	cpse	r24, r1
    6c14:	c5 dd       	rcall	.-1142   	; 0x67a0 <vPortYield>
    6c16:	0f 90       	pop	r0
    6c18:	0f be       	out	0x3f, r0	; 63
    6c1a:	81 e0       	ldi	r24, 0x01	; 1
    6c1c:	45 c0       	rjmp	.+138    	; 0x6ca8 <xQueueGenericSend+0x102>
    6c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    6c20:	9d 81       	ldd	r25, Y+5	; 0x05
    6c22:	89 2b       	or	r24, r25
    6c24:	21 f4       	brne	.+8      	; 0x6c2e <xQueueGenericSend+0x88>
    6c26:	0f 90       	pop	r0
    6c28:	0f be       	out	0x3f, r0	; 63
    6c2a:	80 e0       	ldi	r24, 0x00	; 0
    6c2c:	3d c0       	rjmp	.+122    	; 0x6ca8 <xQueueGenericSend+0x102>
    6c2e:	b1 10       	cpse	r11, r1
    6c30:	04 c0       	rjmp	.+8      	; 0x6c3a <xQueueGenericSend+0x94>
    6c32:	ce 01       	movw	r24, r28
    6c34:	01 96       	adiw	r24, 0x01	; 1
    6c36:	39 d6       	rcall	.+3186   	; 0x78aa <vTaskInternalSetTimeOutState>
    6c38:	b9 2c       	mov	r11, r9
    6c3a:	0f 90       	pop	r0
    6c3c:	0f be       	out	0x3f, r0	; 63
    6c3e:	7a d4       	rcall	.+2292   	; 0x7534 <vTaskSuspendAll>
    6c40:	0f b6       	in	r0, 0x3f	; 63
    6c42:	f8 94       	cli
    6c44:	0f 92       	push	r0
    6c46:	f8 01       	movw	r30, r16
    6c48:	85 8d       	ldd	r24, Z+29	; 0x1d
    6c4a:	8f 3f       	cpi	r24, 0xFF	; 255
    6c4c:	09 f4       	brne	.+2      	; 0x6c50 <xQueueGenericSend+0xaa>
    6c4e:	15 8e       	std	Z+29, r1	; 0x1d
    6c50:	f8 01       	movw	r30, r16
    6c52:	86 8d       	ldd	r24, Z+30	; 0x1e
    6c54:	8f 3f       	cpi	r24, 0xFF	; 255
    6c56:	09 f4       	brne	.+2      	; 0x6c5a <xQueueGenericSend+0xb4>
    6c58:	16 8e       	std	Z+30, r1	; 0x1e
    6c5a:	0f 90       	pop	r0
    6c5c:	0f be       	out	0x3f, r0	; 63
    6c5e:	be 01       	movw	r22, r28
    6c60:	6c 5f       	subi	r22, 0xFC	; 252
    6c62:	7f 4f       	sbci	r23, 0xFF	; 255
    6c64:	ce 01       	movw	r24, r28
    6c66:	01 96       	adiw	r24, 0x01	; 1
    6c68:	2b d6       	rcall	.+3158   	; 0x78c0 <xTaskCheckForTimeOut>
    6c6a:	81 11       	cpse	r24, r1
    6c6c:	19 c0       	rjmp	.+50     	; 0x6ca0 <xQueueGenericSend+0xfa>
    6c6e:	0f b6       	in	r0, 0x3f	; 63
    6c70:	f8 94       	cli
    6c72:	0f 92       	push	r0
    6c74:	f8 01       	movw	r30, r16
    6c76:	92 8d       	ldd	r25, Z+26	; 0x1a
    6c78:	0f 90       	pop	r0
    6c7a:	0f be       	out	0x3f, r0	; 63
    6c7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    6c7e:	98 13       	cpse	r25, r24
    6c80:	0b c0       	rjmp	.+22     	; 0x6c98 <xQueueGenericSend+0xf2>
    6c82:	6c 81       	ldd	r22, Y+4	; 0x04
    6c84:	7d 81       	ldd	r23, Y+5	; 0x05
    6c86:	c7 01       	movw	r24, r14
    6c88:	9f d5       	rcall	.+2878   	; 0x77c8 <vTaskPlaceOnEventList>
    6c8a:	c8 01       	movw	r24, r16
    6c8c:	d3 de       	rcall	.-602    	; 0x6a34 <prvUnlockQueue>
    6c8e:	0f d5       	rcall	.+2590   	; 0x76ae <xTaskResumeAll>
    6c90:	81 11       	cpse	r24, r1
    6c92:	a5 cf       	rjmp	.-182    	; 0x6bde <xQueueGenericSend+0x38>
    6c94:	85 dd       	rcall	.-1270   	; 0x67a0 <vPortYield>
    6c96:	a3 cf       	rjmp	.-186    	; 0x6bde <xQueueGenericSend+0x38>
    6c98:	c8 01       	movw	r24, r16
    6c9a:	cc de       	rcall	.-616    	; 0x6a34 <prvUnlockQueue>
    6c9c:	08 d5       	rcall	.+2576   	; 0x76ae <xTaskResumeAll>
    6c9e:	9f cf       	rjmp	.-194    	; 0x6bde <xQueueGenericSend+0x38>
    6ca0:	c8 01       	movw	r24, r16
    6ca2:	c8 de       	rcall	.-624    	; 0x6a34 <prvUnlockQueue>
    6ca4:	04 d5       	rcall	.+2568   	; 0x76ae <xTaskResumeAll>
    6ca6:	80 e0       	ldi	r24, 0x00	; 0
    6ca8:	0f 90       	pop	r0
    6caa:	0f 90       	pop	r0
    6cac:	0f 90       	pop	r0
    6cae:	0f 90       	pop	r0
    6cb0:	0f 90       	pop	r0
    6cb2:	df 91       	pop	r29
    6cb4:	cf 91       	pop	r28
    6cb6:	1f 91       	pop	r17
    6cb8:	0f 91       	pop	r16
    6cba:	ff 90       	pop	r15
    6cbc:	ef 90       	pop	r14
    6cbe:	df 90       	pop	r13
    6cc0:	cf 90       	pop	r12
    6cc2:	bf 90       	pop	r11
    6cc4:	af 90       	pop	r10
    6cc6:	9f 90       	pop	r9
    6cc8:	08 95       	ret

00006cca <xQueueCreateMutex>:
    6cca:	cf 93       	push	r28
    6ccc:	df 93       	push	r29
    6cce:	48 2f       	mov	r20, r24
    6cd0:	60 e0       	ldi	r22, 0x00	; 0
    6cd2:	81 e0       	ldi	r24, 0x01	; 1
    6cd4:	3a df       	rcall	.-396    	; 0x6b4a <xQueueGenericCreate>
    6cd6:	ec 01       	movw	r28, r24
    6cd8:	00 97       	sbiw	r24, 0x00	; 0
    6cda:	59 f0       	breq	.+22     	; 0x6cf2 <xQueueCreateMutex+0x28>
    6cdc:	1d 82       	std	Y+5, r1	; 0x05
    6cde:	1c 82       	std	Y+4, r1	; 0x04
    6ce0:	19 82       	std	Y+1, r1	; 0x01
    6ce2:	18 82       	st	Y, r1
    6ce4:	1e 82       	std	Y+6, r1	; 0x06
    6ce6:	20 e0       	ldi	r18, 0x00	; 0
    6ce8:	40 e0       	ldi	r20, 0x00	; 0
    6cea:	50 e0       	ldi	r21, 0x00	; 0
    6cec:	60 e0       	ldi	r22, 0x00	; 0
    6cee:	70 e0       	ldi	r23, 0x00	; 0
    6cf0:	5a df       	rcall	.-332    	; 0x6ba6 <xQueueGenericSend>
    6cf2:	ce 01       	movw	r24, r28
    6cf4:	df 91       	pop	r29
    6cf6:	cf 91       	pop	r28
    6cf8:	08 95       	ret

00006cfa <xQueueGenericSendFromISR>:
    6cfa:	ef 92       	push	r14
    6cfc:	ff 92       	push	r15
    6cfe:	0f 93       	push	r16
    6d00:	1f 93       	push	r17
    6d02:	cf 93       	push	r28
    6d04:	df 93       	push	r29
    6d06:	8a 01       	movw	r16, r20
    6d08:	fc 01       	movw	r30, r24
    6d0a:	52 8d       	ldd	r21, Z+26	; 0x1a
    6d0c:	33 8d       	ldd	r19, Z+27	; 0x1b
    6d0e:	53 17       	cp	r21, r19
    6d10:	10 f0       	brcs	.+4      	; 0x6d16 <xQueueGenericSendFromISR+0x1c>
    6d12:	22 30       	cpi	r18, 0x02	; 2
    6d14:	e1 f4       	brne	.+56     	; 0x6d4e <xQueueGenericSendFromISR+0x54>
    6d16:	42 2f       	mov	r20, r18
    6d18:	78 01       	movw	r14, r16
    6d1a:	ec 01       	movw	r28, r24
    6d1c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    6d1e:	11 de       	rcall	.-990    	; 0x6942 <prvCopyDataToQueue>
    6d20:	1f 3f       	cpi	r17, 0xFF	; 255
    6d22:	79 f4       	brne	.+30     	; 0x6d42 <xQueueGenericSendFromISR+0x48>
    6d24:	89 89       	ldd	r24, Y+17	; 0x11
    6d26:	88 23       	and	r24, r24
    6d28:	a1 f0       	breq	.+40     	; 0x6d52 <xQueueGenericSendFromISR+0x58>
    6d2a:	ce 01       	movw	r24, r28
    6d2c:	41 96       	adiw	r24, 0x11	; 17
    6d2e:	75 d5       	rcall	.+2794   	; 0x781a <xTaskRemoveFromEventList>
    6d30:	88 23       	and	r24, r24
    6d32:	89 f0       	breq	.+34     	; 0x6d56 <xQueueGenericSendFromISR+0x5c>
    6d34:	e1 14       	cp	r14, r1
    6d36:	f1 04       	cpc	r15, r1
    6d38:	81 f0       	breq	.+32     	; 0x6d5a <xQueueGenericSendFromISR+0x60>
    6d3a:	81 e0       	ldi	r24, 0x01	; 1
    6d3c:	f7 01       	movw	r30, r14
    6d3e:	80 83       	st	Z, r24
    6d40:	0d c0       	rjmp	.+26     	; 0x6d5c <xQueueGenericSendFromISR+0x62>
    6d42:	ff 24       	eor	r15, r15
    6d44:	f3 94       	inc	r15
    6d46:	f1 0e       	add	r15, r17
    6d48:	fe 8e       	std	Y+30, r15	; 0x1e
    6d4a:	81 e0       	ldi	r24, 0x01	; 1
    6d4c:	07 c0       	rjmp	.+14     	; 0x6d5c <xQueueGenericSendFromISR+0x62>
    6d4e:	80 e0       	ldi	r24, 0x00	; 0
    6d50:	05 c0       	rjmp	.+10     	; 0x6d5c <xQueueGenericSendFromISR+0x62>
    6d52:	81 e0       	ldi	r24, 0x01	; 1
    6d54:	03 c0       	rjmp	.+6      	; 0x6d5c <xQueueGenericSendFromISR+0x62>
    6d56:	81 e0       	ldi	r24, 0x01	; 1
    6d58:	01 c0       	rjmp	.+2      	; 0x6d5c <xQueueGenericSendFromISR+0x62>
    6d5a:	81 e0       	ldi	r24, 0x01	; 1
    6d5c:	df 91       	pop	r29
    6d5e:	cf 91       	pop	r28
    6d60:	1f 91       	pop	r17
    6d62:	0f 91       	pop	r16
    6d64:	ff 90       	pop	r15
    6d66:	ef 90       	pop	r14
    6d68:	08 95       	ret

00006d6a <xQueueReceive>:
    6d6a:	9f 92       	push	r9
    6d6c:	af 92       	push	r10
    6d6e:	bf 92       	push	r11
    6d70:	cf 92       	push	r12
    6d72:	df 92       	push	r13
    6d74:	ef 92       	push	r14
    6d76:	ff 92       	push	r15
    6d78:	0f 93       	push	r16
    6d7a:	1f 93       	push	r17
    6d7c:	cf 93       	push	r28
    6d7e:	df 93       	push	r29
    6d80:	00 d0       	rcall	.+0      	; 0x6d82 <xQueueReceive+0x18>
    6d82:	1f 92       	push	r1
    6d84:	1f 92       	push	r1
    6d86:	cd b7       	in	r28, 0x3d	; 61
    6d88:	de b7       	in	r29, 0x3e	; 62
    6d8a:	8c 01       	movw	r16, r24
    6d8c:	5b 01       	movw	r10, r22
    6d8e:	5d 83       	std	Y+5, r21	; 0x05
    6d90:	4c 83       	std	Y+4, r20	; 0x04
    6d92:	e1 2c       	mov	r14, r1
    6d94:	99 24       	eor	r9, r9
    6d96:	93 94       	inc	r9
    6d98:	6c 01       	movw	r12, r24
    6d9a:	81 e1       	ldi	r24, 0x11	; 17
    6d9c:	c8 0e       	add	r12, r24
    6d9e:	d1 1c       	adc	r13, r1
    6da0:	0f b6       	in	r0, 0x3f	; 63
    6da2:	f8 94       	cli
    6da4:	0f 92       	push	r0
    6da6:	f8 01       	movw	r30, r16
    6da8:	f2 8c       	ldd	r15, Z+26	; 0x1a
    6daa:	ff 20       	and	r15, r15
    6dac:	91 f0       	breq	.+36     	; 0x6dd2 <xQueueReceive+0x68>
    6dae:	b5 01       	movw	r22, r10
    6db0:	c8 01       	movw	r24, r16
    6db2:	26 de       	rcall	.-948    	; 0x6a00 <prvCopyDataFromQueue>
    6db4:	fa 94       	dec	r15
    6db6:	f8 01       	movw	r30, r16
    6db8:	f2 8e       	std	Z+26, r15	; 0x1a
    6dba:	80 85       	ldd	r24, Z+8	; 0x08
    6dbc:	88 23       	and	r24, r24
    6dbe:	29 f0       	breq	.+10     	; 0x6dca <xQueueReceive+0x60>
    6dc0:	c8 01       	movw	r24, r16
    6dc2:	08 96       	adiw	r24, 0x08	; 8
    6dc4:	2a d5       	rcall	.+2644   	; 0x781a <xTaskRemoveFromEventList>
    6dc6:	81 11       	cpse	r24, r1
    6dc8:	eb dc       	rcall	.-1578   	; 0x67a0 <vPortYield>
    6dca:	0f 90       	pop	r0
    6dcc:	0f be       	out	0x3f, r0	; 63
    6dce:	81 e0       	ldi	r24, 0x01	; 1
    6dd0:	44 c0       	rjmp	.+136    	; 0x6e5a <xQueueReceive+0xf0>
    6dd2:	8c 81       	ldd	r24, Y+4	; 0x04
    6dd4:	9d 81       	ldd	r25, Y+5	; 0x05
    6dd6:	89 2b       	or	r24, r25
    6dd8:	21 f4       	brne	.+8      	; 0x6de2 <xQueueReceive+0x78>
    6dda:	0f 90       	pop	r0
    6ddc:	0f be       	out	0x3f, r0	; 63
    6dde:	80 e0       	ldi	r24, 0x00	; 0
    6de0:	3c c0       	rjmp	.+120    	; 0x6e5a <xQueueReceive+0xf0>
    6de2:	e1 10       	cpse	r14, r1
    6de4:	04 c0       	rjmp	.+8      	; 0x6dee <xQueueReceive+0x84>
    6de6:	ce 01       	movw	r24, r28
    6de8:	01 96       	adiw	r24, 0x01	; 1
    6dea:	5f d5       	rcall	.+2750   	; 0x78aa <vTaskInternalSetTimeOutState>
    6dec:	e9 2c       	mov	r14, r9
    6dee:	0f 90       	pop	r0
    6df0:	0f be       	out	0x3f, r0	; 63
    6df2:	a0 d3       	rcall	.+1856   	; 0x7534 <vTaskSuspendAll>
    6df4:	0f b6       	in	r0, 0x3f	; 63
    6df6:	f8 94       	cli
    6df8:	0f 92       	push	r0
    6dfa:	f8 01       	movw	r30, r16
    6dfc:	85 8d       	ldd	r24, Z+29	; 0x1d
    6dfe:	8f 3f       	cpi	r24, 0xFF	; 255
    6e00:	09 f4       	brne	.+2      	; 0x6e04 <xQueueReceive+0x9a>
    6e02:	15 8e       	std	Z+29, r1	; 0x1d
    6e04:	f8 01       	movw	r30, r16
    6e06:	86 8d       	ldd	r24, Z+30	; 0x1e
    6e08:	8f 3f       	cpi	r24, 0xFF	; 255
    6e0a:	09 f4       	brne	.+2      	; 0x6e0e <xQueueReceive+0xa4>
    6e0c:	16 8e       	std	Z+30, r1	; 0x1e
    6e0e:	0f 90       	pop	r0
    6e10:	0f be       	out	0x3f, r0	; 63
    6e12:	be 01       	movw	r22, r28
    6e14:	6c 5f       	subi	r22, 0xFC	; 252
    6e16:	7f 4f       	sbci	r23, 0xFF	; 255
    6e18:	ce 01       	movw	r24, r28
    6e1a:	01 96       	adiw	r24, 0x01	; 1
    6e1c:	51 d5       	rcall	.+2722   	; 0x78c0 <xTaskCheckForTimeOut>
    6e1e:	81 11       	cpse	r24, r1
    6e20:	13 c0       	rjmp	.+38     	; 0x6e48 <xQueueReceive+0xde>
    6e22:	c8 01       	movw	r24, r16
    6e24:	83 dd       	rcall	.-1274   	; 0x692c <prvIsQueueEmpty>
    6e26:	88 23       	and	r24, r24
    6e28:	59 f0       	breq	.+22     	; 0x6e40 <xQueueReceive+0xd6>
    6e2a:	6c 81       	ldd	r22, Y+4	; 0x04
    6e2c:	7d 81       	ldd	r23, Y+5	; 0x05
    6e2e:	c6 01       	movw	r24, r12
    6e30:	cb d4       	rcall	.+2454   	; 0x77c8 <vTaskPlaceOnEventList>
    6e32:	c8 01       	movw	r24, r16
    6e34:	ff dd       	rcall	.-1026   	; 0x6a34 <prvUnlockQueue>
    6e36:	3b d4       	rcall	.+2166   	; 0x76ae <xTaskResumeAll>
    6e38:	81 11       	cpse	r24, r1
    6e3a:	b2 cf       	rjmp	.-156    	; 0x6da0 <xQueueReceive+0x36>
    6e3c:	b1 dc       	rcall	.-1694   	; 0x67a0 <vPortYield>
    6e3e:	b0 cf       	rjmp	.-160    	; 0x6da0 <xQueueReceive+0x36>
    6e40:	c8 01       	movw	r24, r16
    6e42:	f8 dd       	rcall	.-1040   	; 0x6a34 <prvUnlockQueue>
    6e44:	34 d4       	rcall	.+2152   	; 0x76ae <xTaskResumeAll>
    6e46:	ac cf       	rjmp	.-168    	; 0x6da0 <xQueueReceive+0x36>
    6e48:	c8 01       	movw	r24, r16
    6e4a:	f4 dd       	rcall	.-1048   	; 0x6a34 <prvUnlockQueue>
    6e4c:	30 d4       	rcall	.+2144   	; 0x76ae <xTaskResumeAll>
    6e4e:	c8 01       	movw	r24, r16
    6e50:	6d dd       	rcall	.-1318   	; 0x692c <prvIsQueueEmpty>
    6e52:	88 23       	and	r24, r24
    6e54:	09 f4       	brne	.+2      	; 0x6e58 <xQueueReceive+0xee>
    6e56:	a4 cf       	rjmp	.-184    	; 0x6da0 <xQueueReceive+0x36>
    6e58:	80 e0       	ldi	r24, 0x00	; 0
    6e5a:	0f 90       	pop	r0
    6e5c:	0f 90       	pop	r0
    6e5e:	0f 90       	pop	r0
    6e60:	0f 90       	pop	r0
    6e62:	0f 90       	pop	r0
    6e64:	df 91       	pop	r29
    6e66:	cf 91       	pop	r28
    6e68:	1f 91       	pop	r17
    6e6a:	0f 91       	pop	r16
    6e6c:	ff 90       	pop	r15
    6e6e:	ef 90       	pop	r14
    6e70:	df 90       	pop	r13
    6e72:	cf 90       	pop	r12
    6e74:	bf 90       	pop	r11
    6e76:	af 90       	pop	r10
    6e78:	9f 90       	pop	r9
    6e7a:	08 95       	ret

00006e7c <xQueueSemaphoreTake>:
    6e7c:	bf 92       	push	r11
    6e7e:	cf 92       	push	r12
    6e80:	df 92       	push	r13
    6e82:	ef 92       	push	r14
    6e84:	ff 92       	push	r15
    6e86:	0f 93       	push	r16
    6e88:	1f 93       	push	r17
    6e8a:	cf 93       	push	r28
    6e8c:	df 93       	push	r29
    6e8e:	00 d0       	rcall	.+0      	; 0x6e90 <xQueueSemaphoreTake+0x14>
    6e90:	1f 92       	push	r1
    6e92:	1f 92       	push	r1
    6e94:	cd b7       	in	r28, 0x3d	; 61
    6e96:	de b7       	in	r29, 0x3e	; 62
    6e98:	8c 01       	movw	r16, r24
    6e9a:	7d 83       	std	Y+5, r23	; 0x05
    6e9c:	6c 83       	std	Y+4, r22	; 0x04
    6e9e:	b1 2c       	mov	r11, r1
    6ea0:	d1 2c       	mov	r13, r1
    6ea2:	cc 24       	eor	r12, r12
    6ea4:	c3 94       	inc	r12
    6ea6:	7c 01       	movw	r14, r24
    6ea8:	81 e1       	ldi	r24, 0x11	; 17
    6eaa:	e8 0e       	add	r14, r24
    6eac:	f1 1c       	adc	r15, r1
    6eae:	0f b6       	in	r0, 0x3f	; 63
    6eb0:	f8 94       	cli
    6eb2:	0f 92       	push	r0
    6eb4:	d8 01       	movw	r26, r16
    6eb6:	5a 96       	adiw	r26, 0x1a	; 26
    6eb8:	8c 91       	ld	r24, X
    6eba:	5a 97       	sbiw	r26, 0x1a	; 26
    6ebc:	88 23       	and	r24, r24
    6ebe:	d9 f0       	breq	.+54     	; 0x6ef6 <xQueueSemaphoreTake+0x7a>
    6ec0:	81 50       	subi	r24, 0x01	; 1
    6ec2:	5a 96       	adiw	r26, 0x1a	; 26
    6ec4:	8c 93       	st	X, r24
    6ec6:	5a 97       	sbiw	r26, 0x1a	; 26
    6ec8:	8d 91       	ld	r24, X+
    6eca:	9c 91       	ld	r25, X
    6ecc:	89 2b       	or	r24, r25
    6ece:	29 f4       	brne	.+10     	; 0x6eda <xQueueSemaphoreTake+0x5e>
    6ed0:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <pvTaskIncrementMutexHeldCount>
    6ed4:	f8 01       	movw	r30, r16
    6ed6:	95 83       	std	Z+5, r25	; 0x05
    6ed8:	84 83       	std	Z+4, r24	; 0x04
    6eda:	d8 01       	movw	r26, r16
    6edc:	18 96       	adiw	r26, 0x08	; 8
    6ede:	8c 91       	ld	r24, X
    6ee0:	88 23       	and	r24, r24
    6ee2:	29 f0       	breq	.+10     	; 0x6eee <xQueueSemaphoreTake+0x72>
    6ee4:	c8 01       	movw	r24, r16
    6ee6:	08 96       	adiw	r24, 0x08	; 8
    6ee8:	98 d4       	rcall	.+2352   	; 0x781a <xTaskRemoveFromEventList>
    6eea:	81 11       	cpse	r24, r1
    6eec:	59 dc       	rcall	.-1870   	; 0x67a0 <vPortYield>
    6eee:	0f 90       	pop	r0
    6ef0:	0f be       	out	0x3f, r0	; 63
    6ef2:	81 e0       	ldi	r24, 0x01	; 1
    6ef4:	70 c0       	rjmp	.+224    	; 0x6fd6 <xQueueSemaphoreTake+0x15a>
    6ef6:	8c 81       	ldd	r24, Y+4	; 0x04
    6ef8:	9d 81       	ldd	r25, Y+5	; 0x05
    6efa:	89 2b       	or	r24, r25
    6efc:	21 f4       	brne	.+8      	; 0x6f06 <xQueueSemaphoreTake+0x8a>
    6efe:	0f 90       	pop	r0
    6f00:	0f be       	out	0x3f, r0	; 63
    6f02:	80 e0       	ldi	r24, 0x00	; 0
    6f04:	68 c0       	rjmp	.+208    	; 0x6fd6 <xQueueSemaphoreTake+0x15a>
    6f06:	d1 10       	cpse	r13, r1
    6f08:	04 c0       	rjmp	.+8      	; 0x6f12 <xQueueSemaphoreTake+0x96>
    6f0a:	ce 01       	movw	r24, r28
    6f0c:	01 96       	adiw	r24, 0x01	; 1
    6f0e:	cd d4       	rcall	.+2458   	; 0x78aa <vTaskInternalSetTimeOutState>
    6f10:	dc 2c       	mov	r13, r12
    6f12:	0f 90       	pop	r0
    6f14:	0f be       	out	0x3f, r0	; 63
    6f16:	0e d3       	rcall	.+1564   	; 0x7534 <vTaskSuspendAll>
    6f18:	0f b6       	in	r0, 0x3f	; 63
    6f1a:	f8 94       	cli
    6f1c:	0f 92       	push	r0
    6f1e:	f8 01       	movw	r30, r16
    6f20:	85 8d       	ldd	r24, Z+29	; 0x1d
    6f22:	8f 3f       	cpi	r24, 0xFF	; 255
    6f24:	09 f4       	brne	.+2      	; 0x6f28 <xQueueSemaphoreTake+0xac>
    6f26:	15 8e       	std	Z+29, r1	; 0x1d
    6f28:	d8 01       	movw	r26, r16
    6f2a:	5e 96       	adiw	r26, 0x1e	; 30
    6f2c:	8c 91       	ld	r24, X
    6f2e:	5e 97       	sbiw	r26, 0x1e	; 30
    6f30:	8f 3f       	cpi	r24, 0xFF	; 255
    6f32:	11 f4       	brne	.+4      	; 0x6f38 <xQueueSemaphoreTake+0xbc>
    6f34:	5e 96       	adiw	r26, 0x1e	; 30
    6f36:	1c 92       	st	X, r1
    6f38:	0f 90       	pop	r0
    6f3a:	0f be       	out	0x3f, r0	; 63
    6f3c:	be 01       	movw	r22, r28
    6f3e:	6c 5f       	subi	r22, 0xFC	; 252
    6f40:	7f 4f       	sbci	r23, 0xFF	; 255
    6f42:	ce 01       	movw	r24, r28
    6f44:	01 96       	adiw	r24, 0x01	; 1
    6f46:	bc d4       	rcall	.+2424   	; 0x78c0 <xTaskCheckForTimeOut>
    6f48:	81 11       	cpse	r24, r1
    6f4a:	21 c0       	rjmp	.+66     	; 0x6f8e <xQueueSemaphoreTake+0x112>
    6f4c:	c8 01       	movw	r24, r16
    6f4e:	ee dc       	rcall	.-1572   	; 0x692c <prvIsQueueEmpty>
    6f50:	88 23       	and	r24, r24
    6f52:	c9 f0       	breq	.+50     	; 0x6f86 <xQueueSemaphoreTake+0x10a>
    6f54:	f8 01       	movw	r30, r16
    6f56:	80 81       	ld	r24, Z
    6f58:	91 81       	ldd	r25, Z+1	; 0x01
    6f5a:	89 2b       	or	r24, r25
    6f5c:	49 f4       	brne	.+18     	; 0x6f70 <xQueueSemaphoreTake+0xf4>
    6f5e:	0f b6       	in	r0, 0x3f	; 63
    6f60:	f8 94       	cli
    6f62:	0f 92       	push	r0
    6f64:	84 81       	ldd	r24, Z+4	; 0x04
    6f66:	95 81       	ldd	r25, Z+5	; 0x05
    6f68:	3c d6       	rcall	.+3192   	; 0x7be2 <xTaskPriorityInherit>
    6f6a:	b8 2e       	mov	r11, r24
    6f6c:	0f 90       	pop	r0
    6f6e:	0f be       	out	0x3f, r0	; 63
    6f70:	6c 81       	ldd	r22, Y+4	; 0x04
    6f72:	7d 81       	ldd	r23, Y+5	; 0x05
    6f74:	c7 01       	movw	r24, r14
    6f76:	28 d4       	rcall	.+2128   	; 0x77c8 <vTaskPlaceOnEventList>
    6f78:	c8 01       	movw	r24, r16
    6f7a:	5c dd       	rcall	.-1352   	; 0x6a34 <prvUnlockQueue>
    6f7c:	98 d3       	rcall	.+1840   	; 0x76ae <xTaskResumeAll>
    6f7e:	81 11       	cpse	r24, r1
    6f80:	96 cf       	rjmp	.-212    	; 0x6eae <xQueueSemaphoreTake+0x32>
    6f82:	0e dc       	rcall	.-2020   	; 0x67a0 <vPortYield>
    6f84:	94 cf       	rjmp	.-216    	; 0x6eae <xQueueSemaphoreTake+0x32>
    6f86:	c8 01       	movw	r24, r16
    6f88:	55 dd       	rcall	.-1366   	; 0x6a34 <prvUnlockQueue>
    6f8a:	91 d3       	rcall	.+1826   	; 0x76ae <xTaskResumeAll>
    6f8c:	90 cf       	rjmp	.-224    	; 0x6eae <xQueueSemaphoreTake+0x32>
    6f8e:	c8 01       	movw	r24, r16
    6f90:	51 dd       	rcall	.-1374   	; 0x6a34 <prvUnlockQueue>
    6f92:	8d d3       	rcall	.+1818   	; 0x76ae <xTaskResumeAll>
    6f94:	c8 01       	movw	r24, r16
    6f96:	ca dc       	rcall	.-1644   	; 0x692c <prvIsQueueEmpty>
    6f98:	88 23       	and	r24, r24
    6f9a:	09 f4       	brne	.+2      	; 0x6f9e <xQueueSemaphoreTake+0x122>
    6f9c:	88 cf       	rjmp	.-240    	; 0x6eae <xQueueSemaphoreTake+0x32>
    6f9e:	bb 20       	and	r11, r11
    6fa0:	c9 f0       	breq	.+50     	; 0x6fd4 <xQueueSemaphoreTake+0x158>
    6fa2:	0f b6       	in	r0, 0x3f	; 63
    6fa4:	f8 94       	cli
    6fa6:	0f 92       	push	r0
    6fa8:	f8 01       	movw	r30, r16
    6faa:	81 89       	ldd	r24, Z+17	; 0x11
    6fac:	88 23       	and	r24, r24
    6fae:	39 f0       	breq	.+14     	; 0x6fbe <xQueueSemaphoreTake+0x142>
    6fb0:	06 88       	ldd	r0, Z+22	; 0x16
    6fb2:	f7 89       	ldd	r31, Z+23	; 0x17
    6fb4:	e0 2d       	mov	r30, r0
    6fb6:	80 81       	ld	r24, Z
    6fb8:	64 e0       	ldi	r22, 0x04	; 4
    6fba:	68 1b       	sub	r22, r24
    6fbc:	01 c0       	rjmp	.+2      	; 0x6fc0 <xQueueSemaphoreTake+0x144>
    6fbe:	60 e0       	ldi	r22, 0x00	; 0
    6fc0:	d8 01       	movw	r26, r16
    6fc2:	14 96       	adiw	r26, 0x04	; 4
    6fc4:	8d 91       	ld	r24, X+
    6fc6:	9c 91       	ld	r25, X
    6fc8:	15 97       	sbiw	r26, 0x05	; 5
    6fca:	bd d6       	rcall	.+3450   	; 0x7d46 <vTaskPriorityDisinheritAfterTimeout>
    6fcc:	0f 90       	pop	r0
    6fce:	0f be       	out	0x3f, r0	; 63
    6fd0:	80 e0       	ldi	r24, 0x00	; 0
    6fd2:	01 c0       	rjmp	.+2      	; 0x6fd6 <xQueueSemaphoreTake+0x15a>
    6fd4:	80 e0       	ldi	r24, 0x00	; 0
    6fd6:	0f 90       	pop	r0
    6fd8:	0f 90       	pop	r0
    6fda:	0f 90       	pop	r0
    6fdc:	0f 90       	pop	r0
    6fde:	0f 90       	pop	r0
    6fe0:	df 91       	pop	r29
    6fe2:	cf 91       	pop	r28
    6fe4:	1f 91       	pop	r17
    6fe6:	0f 91       	pop	r16
    6fe8:	ff 90       	pop	r15
    6fea:	ef 90       	pop	r14
    6fec:	df 90       	pop	r13
    6fee:	cf 90       	pop	r12
    6ff0:	bf 90       	pop	r11
    6ff2:	08 95       	ret

00006ff4 <uxQueueMessagesWaiting>:
    6ff4:	0f b6       	in	r0, 0x3f	; 63
    6ff6:	f8 94       	cli
    6ff8:	0f 92       	push	r0
    6ffa:	fc 01       	movw	r30, r24
    6ffc:	82 8d       	ldd	r24, Z+26	; 0x1a
    6ffe:	0f 90       	pop	r0
    7000:	0f be       	out	0x3f, r0	; 63
    7002:	08 95       	ret

00007004 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    7004:	cf 93       	push	r28
    7006:	df 93       	push	r29
    7008:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    700a:	0f b6       	in	r0, 0x3f	; 63
    700c:	f8 94       	cli
    700e:	0f 92       	push	r0
    7010:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7012:	8f 3f       	cpi	r24, 0xFF	; 255
    7014:	09 f4       	brne	.+2      	; 0x7018 <vQueueWaitForMessageRestricted+0x14>
    7016:	1d 8e       	std	Y+29, r1	; 0x1d
    7018:	8e 8d       	ldd	r24, Y+30	; 0x1e
    701a:	8f 3f       	cpi	r24, 0xFF	; 255
    701c:	09 f4       	brne	.+2      	; 0x7020 <vQueueWaitForMessageRestricted+0x1c>
    701e:	1e 8e       	std	Y+30, r1	; 0x1e
    7020:	0f 90       	pop	r0
    7022:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    7024:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7026:	81 11       	cpse	r24, r1
    7028:	03 c0       	rjmp	.+6      	; 0x7030 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    702a:	ce 01       	movw	r24, r28
    702c:	41 96       	adiw	r24, 0x11	; 17
    702e:	dd d3       	rcall	.+1978   	; 0x77ea <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    7030:	ce 01       	movw	r24, r28
    7032:	00 dd       	rcall	.-1536   	; 0x6a34 <prvUnlockQueue>
	}
    7034:	df 91       	pop	r29
    7036:	cf 91       	pop	r28
    7038:	08 95       	ret

0000703a <prvResetNextTaskUnblockTime>:
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
    703a:	e0 91 0e 20 	lds	r30, 0x200E	; 0x80200e <pxDelayedTaskList>
    703e:	f0 91 0f 20 	lds	r31, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    7042:	80 81       	ld	r24, Z
    7044:	81 11       	cpse	r24, r1
    7046:	07 c0       	rjmp	.+14     	; 0x7056 <prvResetNextTaskUnblockTime+0x1c>
    7048:	8f ef       	ldi	r24, 0xFF	; 255
    704a:	9f ef       	ldi	r25, 0xFF	; 255
    704c:	90 93 e6 1f 	sts	0x1FE6, r25	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    7050:	80 93 e5 1f 	sts	0x1FE5, r24	; 0x801fe5 <xNextTaskUnblockTime>
    7054:	08 95       	ret
    7056:	e0 91 0e 20 	lds	r30, 0x200E	; 0x80200e <pxDelayedTaskList>
    705a:	f0 91 0f 20 	lds	r31, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    705e:	05 80       	ldd	r0, Z+5	; 0x05
    7060:	f6 81       	ldd	r31, Z+6	; 0x06
    7062:	e0 2d       	mov	r30, r0
    7064:	06 80       	ldd	r0, Z+6	; 0x06
    7066:	f7 81       	ldd	r31, Z+7	; 0x07
    7068:	e0 2d       	mov	r30, r0
    706a:	82 81       	ldd	r24, Z+2	; 0x02
    706c:	93 81       	ldd	r25, Z+3	; 0x03
    706e:	90 93 e6 1f 	sts	0x1FE6, r25	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    7072:	80 93 e5 1f 	sts	0x1FE5, r24	; 0x801fe5 <xNextTaskUnblockTime>
    7076:	08 95       	ret

00007078 <prvIdleTask>:
    7078:	0a ef       	ldi	r16, 0xFA	; 250
    707a:	1f e1       	ldi	r17, 0x1F	; 31
    707c:	0f 2e       	mov	r0, r31
    707e:	f2 e2       	ldi	r31, 0x22	; 34
    7080:	ef 2e       	mov	r14, r31
    7082:	f0 e2       	ldi	r31, 0x20	; 32
    7084:	ff 2e       	mov	r15, r31
    7086:	f0 2d       	mov	r31, r0
    7088:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <uxDeletedTasksWaitingCleanUp>
    708c:	88 23       	and	r24, r24
    708e:	11 f1       	breq	.+68     	; 0x70d4 <prvIdleTask+0x5c>
    7090:	0f b6       	in	r0, 0x3f	; 63
    7092:	f8 94       	cli
    7094:	0f 92       	push	r0
    7096:	d8 01       	movw	r26, r16
    7098:	15 96       	adiw	r26, 0x05	; 5
    709a:	ed 91       	ld	r30, X+
    709c:	fc 91       	ld	r31, X
    709e:	16 97       	sbiw	r26, 0x06	; 6
    70a0:	c6 81       	ldd	r28, Z+6	; 0x06
    70a2:	d7 81       	ldd	r29, Z+7	; 0x07
    70a4:	ce 01       	movw	r24, r28
    70a6:	02 96       	adiw	r24, 0x02	; 2
    70a8:	a3 da       	rcall	.-2746   	; 0x65f0 <uxListRemove>
    70aa:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    70ae:	81 50       	subi	r24, 0x01	; 1
    70b0:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <uxCurrentNumberOfTasks>
    70b4:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <uxDeletedTasksWaitingCleanUp>
    70b8:	81 50       	subi	r24, 0x01	; 1
    70ba:	80 93 f9 1f 	sts	0x1FF9, r24	; 0x801ff9 <uxDeletedTasksWaitingCleanUp>
    70be:	0f 90       	pop	r0
    70c0:	0f be       	out	0x3f, r0	; 63
    70c2:	8f 89       	ldd	r24, Y+23	; 0x17
    70c4:	98 8d       	ldd	r25, Y+24	; 0x18
    70c6:	3b d9       	rcall	.-3466   	; 0x633e <vPortFree>
    70c8:	ce 01       	movw	r24, r28
    70ca:	39 d9       	rcall	.-3470   	; 0x633e <vPortFree>
    70cc:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <uxDeletedTasksWaitingCleanUp>
    70d0:	81 11       	cpse	r24, r1
    70d2:	de cf       	rjmp	.-68     	; 0x7090 <prvIdleTask+0x18>
    70d4:	f7 01       	movw	r30, r14
    70d6:	80 81       	ld	r24, Z
    70d8:	82 30       	cpi	r24, 0x02	; 2
    70da:	b0 f2       	brcs	.-84     	; 0x7088 <prvIdleTask+0x10>
    70dc:	61 db       	rcall	.-2366   	; 0x67a0 <vPortYield>
    70de:	d4 cf       	rjmp	.-88     	; 0x7088 <prvIdleTask+0x10>

000070e0 <prvAddCurrentTaskToDelayedList>:
    70e0:	ff 92       	push	r15
    70e2:	0f 93       	push	r16
    70e4:	1f 93       	push	r17
    70e6:	cf 93       	push	r28
    70e8:	df 93       	push	r29
    70ea:	ec 01       	movw	r28, r24
    70ec:	f6 2e       	mov	r15, r22
    70ee:	00 91 ed 1f 	lds	r16, 0x1FED	; 0x801fed <xTickCount>
    70f2:	10 91 ee 1f 	lds	r17, 0x1FEE	; 0x801fee <xTickCount+0x1>
    70f6:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    70fa:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    70fe:	02 96       	adiw	r24, 0x02	; 2
    7100:	77 da       	rcall	.-2834   	; 0x65f0 <uxListRemove>
    7102:	cf 3f       	cpi	r28, 0xFF	; 255
    7104:	8f ef       	ldi	r24, 0xFF	; 255
    7106:	d8 07       	cpc	r29, r24
    7108:	61 f4       	brne	.+24     	; 0x7122 <prvAddCurrentTaskToDelayedList+0x42>
    710a:	ff 20       	and	r15, r15
    710c:	51 f0       	breq	.+20     	; 0x7122 <prvAddCurrentTaskToDelayedList+0x42>
    710e:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    7112:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7116:	6e 5f       	subi	r22, 0xFE	; 254
    7118:	7f 4f       	sbci	r23, 0xFF	; 255
    711a:	80 ef       	ldi	r24, 0xF0	; 240
    711c:	9f e1       	ldi	r25, 0x1F	; 31
    711e:	16 da       	rcall	.-3028   	; 0x654c <vListInsertEnd>
    7120:	2d c0       	rjmp	.+90     	; 0x717c <prvAddCurrentTaskToDelayedList+0x9c>
    7122:	c0 0f       	add	r28, r16
    7124:	d1 1f       	adc	r29, r17
    7126:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    712a:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    712e:	d3 83       	std	Z+3, r29	; 0x03
    7130:	c2 83       	std	Z+2, r28	; 0x02
    7132:	c0 17       	cp	r28, r16
    7134:	d1 07       	cpc	r29, r17
    7136:	60 f4       	brcc	.+24     	; 0x7150 <prvAddCurrentTaskToDelayedList+0x70>
    7138:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    713c:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7140:	80 91 0c 20 	lds	r24, 0x200C	; 0x80200c <pxOverflowDelayedTaskList>
    7144:	90 91 0d 20 	lds	r25, 0x200D	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    7148:	6e 5f       	subi	r22, 0xFE	; 254
    714a:	7f 4f       	sbci	r23, 0xFF	; 255
    714c:	20 da       	rcall	.-3008   	; 0x658e <vListInsert>
    714e:	16 c0       	rjmp	.+44     	; 0x717c <prvAddCurrentTaskToDelayedList+0x9c>
    7150:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    7154:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7158:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <pxDelayedTaskList>
    715c:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    7160:	6e 5f       	subi	r22, 0xFE	; 254
    7162:	7f 4f       	sbci	r23, 0xFF	; 255
    7164:	14 da       	rcall	.-3032   	; 0x658e <vListInsert>
    7166:	80 91 e5 1f 	lds	r24, 0x1FE5	; 0x801fe5 <xNextTaskUnblockTime>
    716a:	90 91 e6 1f 	lds	r25, 0x1FE6	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    716e:	c8 17       	cp	r28, r24
    7170:	d9 07       	cpc	r29, r25
    7172:	20 f4       	brcc	.+8      	; 0x717c <prvAddCurrentTaskToDelayedList+0x9c>
    7174:	d0 93 e6 1f 	sts	0x1FE6, r29	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    7178:	c0 93 e5 1f 	sts	0x1FE5, r28	; 0x801fe5 <xNextTaskUnblockTime>
    717c:	df 91       	pop	r29
    717e:	cf 91       	pop	r28
    7180:	1f 91       	pop	r17
    7182:	0f 91       	pop	r16
    7184:	ff 90       	pop	r15
    7186:	08 95       	ret

00007188 <xTaskCreate>:
    7188:	4f 92       	push	r4
    718a:	5f 92       	push	r5
    718c:	6f 92       	push	r6
    718e:	7f 92       	push	r7
    7190:	8f 92       	push	r8
    7192:	9f 92       	push	r9
    7194:	af 92       	push	r10
    7196:	bf 92       	push	r11
    7198:	cf 92       	push	r12
    719a:	df 92       	push	r13
    719c:	ef 92       	push	r14
    719e:	ff 92       	push	r15
    71a0:	0f 93       	push	r16
    71a2:	cf 93       	push	r28
    71a4:	df 93       	push	r29
    71a6:	4c 01       	movw	r8, r24
    71a8:	6b 01       	movw	r12, r22
    71aa:	5a 01       	movw	r10, r20
    71ac:	29 01       	movw	r4, r18
    71ae:	ca 01       	movw	r24, r20
    71b0:	06 d9       	rcall	.-3572   	; 0x63be <pvPortMalloc>
    71b2:	3c 01       	movw	r6, r24
    71b4:	89 2b       	or	r24, r25
    71b6:	09 f4       	brne	.+2      	; 0x71ba <xTaskCreate+0x32>
    71b8:	ec c0       	rjmp	.+472    	; 0x7392 <xTaskCreate+0x20a>
    71ba:	8c e3       	ldi	r24, 0x3C	; 60
    71bc:	90 e0       	ldi	r25, 0x00	; 0
    71be:	ff d8       	rcall	.-3586   	; 0x63be <pvPortMalloc>
    71c0:	ec 01       	movw	r28, r24
    71c2:	89 2b       	or	r24, r25
    71c4:	99 f0       	breq	.+38     	; 0x71ec <xTaskCreate+0x64>
    71c6:	78 8e       	std	Y+24, r7	; 0x18
    71c8:	6f 8a       	std	Y+23, r6	; 0x17
    71ca:	a5 01       	movw	r20, r10
    71cc:	65 ea       	ldi	r22, 0xA5	; 165
    71ce:	70 e0       	ldi	r23, 0x00	; 0
    71d0:	c3 01       	movw	r24, r6
    71d2:	0e 94 aa 44 	call	0x8954	; 0x8954 <memset>
    71d6:	81 e0       	ldi	r24, 0x01	; 1
    71d8:	a8 1a       	sub	r10, r24
    71da:	b1 08       	sbc	r11, r1
    71dc:	8f 89       	ldd	r24, Y+23	; 0x17
    71de:	98 8d       	ldd	r25, Y+24	; 0x18
    71e0:	a8 0e       	add	r10, r24
    71e2:	b9 1e       	adc	r11, r25
    71e4:	c1 14       	cp	r12, r1
    71e6:	d1 04       	cpc	r13, r1
    71e8:	21 f4       	brne	.+8      	; 0x71f2 <xTaskCreate+0x6a>
    71ea:	1f c0       	rjmp	.+62     	; 0x722a <xTaskCreate+0xa2>
    71ec:	c3 01       	movw	r24, r6
    71ee:	a7 d8       	rcall	.-3762   	; 0x633e <vPortFree>
    71f0:	d0 c0       	rjmp	.+416    	; 0x7392 <xTaskCreate+0x20a>
    71f2:	d6 01       	movw	r26, r12
    71f4:	8c 91       	ld	r24, X
    71f6:	89 8f       	std	Y+25, r24	; 0x19
    71f8:	8c 91       	ld	r24, X
    71fa:	88 23       	and	r24, r24
    71fc:	a1 f0       	breq	.+40     	; 0x7226 <xTaskCreate+0x9e>
    71fe:	ae 01       	movw	r20, r28
    7200:	46 5e       	subi	r20, 0xE6	; 230
    7202:	5f 4f       	sbci	r21, 0xFF	; 255
    7204:	f6 01       	movw	r30, r12
    7206:	31 96       	adiw	r30, 0x01	; 1
    7208:	b0 e1       	ldi	r27, 0x10	; 16
    720a:	cb 0e       	add	r12, r27
    720c:	d1 1c       	adc	r13, r1
    720e:	cf 01       	movw	r24, r30
    7210:	21 91       	ld	r18, Z+
    7212:	da 01       	movw	r26, r20
    7214:	2d 93       	st	X+, r18
    7216:	ad 01       	movw	r20, r26
    7218:	dc 01       	movw	r26, r24
    721a:	8c 91       	ld	r24, X
    721c:	88 23       	and	r24, r24
    721e:	19 f0       	breq	.+6      	; 0x7226 <xTaskCreate+0x9e>
    7220:	ec 15       	cp	r30, r12
    7222:	fd 05       	cpc	r31, r13
    7224:	a1 f7       	brne	.-24     	; 0x720e <xTaskCreate+0x86>
    7226:	18 a6       	std	Y+40, r1	; 0x28
    7228:	01 c0       	rjmp	.+2      	; 0x722c <xTaskCreate+0xa4>
    722a:	19 8e       	std	Y+25, r1	; 0x19
    722c:	04 30       	cpi	r16, 0x04	; 4
    722e:	08 f0       	brcs	.+2      	; 0x7232 <xTaskCreate+0xaa>
    7230:	03 e0       	ldi	r16, 0x03	; 3
    7232:	0e 8b       	std	Y+22, r16	; 0x16
    7234:	0b a7       	std	Y+43, r16	; 0x2b
    7236:	1c a6       	std	Y+44, r1	; 0x2c
    7238:	6e 01       	movw	r12, r28
    723a:	b2 e0       	ldi	r27, 0x02	; 2
    723c:	cb 0e       	add	r12, r27
    723e:	d1 1c       	adc	r13, r1
    7240:	c6 01       	movw	r24, r12
    7242:	80 d9       	rcall	.-3328   	; 0x6544 <vListInitialiseItem>
    7244:	ce 01       	movw	r24, r28
    7246:	0c 96       	adiw	r24, 0x0c	; 12
    7248:	7d d9       	rcall	.-3334   	; 0x6544 <vListInitialiseItem>
    724a:	d9 87       	std	Y+9, r29	; 0x09
    724c:	c8 87       	std	Y+8, r28	; 0x08
    724e:	84 e0       	ldi	r24, 0x04	; 4
    7250:	90 e0       	ldi	r25, 0x00	; 0
    7252:	80 1b       	sub	r24, r16
    7254:	91 09       	sbc	r25, r1
    7256:	9d 87       	std	Y+13, r25	; 0x0d
    7258:	8c 87       	std	Y+12, r24	; 0x0c
    725a:	db 8b       	std	Y+19, r29	; 0x13
    725c:	ca 8b       	std	Y+18, r28	; 0x12
    725e:	1e a6       	std	Y+46, r1	; 0x2e
    7260:	1d a6       	std	Y+45, r1	; 0x2d
    7262:	18 aa       	std	Y+48, r1	; 0x30
    7264:	1f a6       	std	Y+47, r1	; 0x2f
    7266:	1a aa       	std	Y+50, r1	; 0x32
    7268:	19 aa       	std	Y+49, r1	; 0x31
    726a:	1c aa       	std	Y+52, r1	; 0x34
    726c:	1b aa       	std	Y+51, r1	; 0x33
    726e:	1e aa       	std	Y+54, r1	; 0x36
    7270:	1d aa       	std	Y+53, r1	; 0x35
    7272:	1f aa       	std	Y+55, r1	; 0x37
    7274:	18 ae       	std	Y+56, r1	; 0x38
    7276:	19 ae       	std	Y+57, r1	; 0x39
    7278:	1a ae       	std	Y+58, r1	; 0x3a
    727a:	1b ae       	std	Y+59, r1	; 0x3b
    727c:	a2 01       	movw	r20, r4
    727e:	b4 01       	movw	r22, r8
    7280:	c5 01       	movw	r24, r10
    7282:	dd d9       	rcall	.-3142   	; 0x663e <pxPortInitialiseStack>
    7284:	99 83       	std	Y+1, r25	; 0x01
    7286:	88 83       	st	Y, r24
    7288:	e1 14       	cp	r14, r1
    728a:	f1 04       	cpc	r15, r1
    728c:	19 f0       	breq	.+6      	; 0x7294 <xTaskCreate+0x10c>
    728e:	f7 01       	movw	r30, r14
    7290:	d1 83       	std	Z+1, r29	; 0x01
    7292:	c0 83       	st	Z, r28
    7294:	0f b6       	in	r0, 0x3f	; 63
    7296:	f8 94       	cli
    7298:	0f 92       	push	r0
    729a:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    729e:	8f 5f       	subi	r24, 0xFF	; 255
    72a0:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <uxCurrentNumberOfTasks>
    72a4:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    72a8:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    72ac:	89 2b       	or	r24, r25
    72ae:	89 f5       	brne	.+98     	; 0x7312 <xTaskCreate+0x18a>
    72b0:	d0 93 47 20 	sts	0x2047, r29	; 0x802047 <pxCurrentTCB+0x1>
    72b4:	c0 93 46 20 	sts	0x2046, r28	; 0x802046 <pxCurrentTCB>
    72b8:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    72bc:	81 30       	cpi	r24, 0x01	; 1
    72be:	09 f0       	breq	.+2      	; 0x72c2 <xTaskCreate+0x13a>
    72c0:	38 c0       	rjmp	.+112    	; 0x7332 <xTaskCreate+0x1aa>
    72c2:	82 e2       	ldi	r24, 0x22	; 34
    72c4:	90 e2       	ldi	r25, 0x20	; 32
    72c6:	30 d9       	rcall	.-3488   	; 0x6528 <vListInitialise>
    72c8:	8b e2       	ldi	r24, 0x2B	; 43
    72ca:	90 e2       	ldi	r25, 0x20	; 32
    72cc:	2d d9       	rcall	.-3494   	; 0x6528 <vListInitialise>
    72ce:	84 e3       	ldi	r24, 0x34	; 52
    72d0:	90 e2       	ldi	r25, 0x20	; 32
    72d2:	2a d9       	rcall	.-3500   	; 0x6528 <vListInitialise>
    72d4:	8d e3       	ldi	r24, 0x3D	; 61
    72d6:	90 e2       	ldi	r25, 0x20	; 32
    72d8:	27 d9       	rcall	.-3506   	; 0x6528 <vListInitialise>
    72da:	89 e1       	ldi	r24, 0x19	; 25
    72dc:	90 e2       	ldi	r25, 0x20	; 32
    72de:	24 d9       	rcall	.-3512   	; 0x6528 <vListInitialise>
    72e0:	80 e1       	ldi	r24, 0x10	; 16
    72e2:	90 e2       	ldi	r25, 0x20	; 32
    72e4:	21 d9       	rcall	.-3518   	; 0x6528 <vListInitialise>
    72e6:	83 e0       	ldi	r24, 0x03	; 3
    72e8:	90 e2       	ldi	r25, 0x20	; 32
    72ea:	1e d9       	rcall	.-3524   	; 0x6528 <vListInitialise>
    72ec:	8a ef       	ldi	r24, 0xFA	; 250
    72ee:	9f e1       	ldi	r25, 0x1F	; 31
    72f0:	1b d9       	rcall	.-3530   	; 0x6528 <vListInitialise>
    72f2:	80 ef       	ldi	r24, 0xF0	; 240
    72f4:	9f e1       	ldi	r25, 0x1F	; 31
    72f6:	18 d9       	rcall	.-3536   	; 0x6528 <vListInitialise>
    72f8:	89 e1       	ldi	r24, 0x19	; 25
    72fa:	90 e2       	ldi	r25, 0x20	; 32
    72fc:	90 93 0f 20 	sts	0x200F, r25	; 0x80200f <pxDelayedTaskList+0x1>
    7300:	80 93 0e 20 	sts	0x200E, r24	; 0x80200e <pxDelayedTaskList>
    7304:	80 e1       	ldi	r24, 0x10	; 16
    7306:	90 e2       	ldi	r25, 0x20	; 32
    7308:	90 93 0d 20 	sts	0x200D, r25	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    730c:	80 93 0c 20 	sts	0x200C, r24	; 0x80200c <pxOverflowDelayedTaskList>
    7310:	10 c0       	rjmp	.+32     	; 0x7332 <xTaskCreate+0x1aa>
    7312:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xSchedulerRunning>
    7316:	81 11       	cpse	r24, r1
    7318:	0c c0       	rjmp	.+24     	; 0x7332 <xTaskCreate+0x1aa>
    731a:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    731e:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7322:	96 89       	ldd	r25, Z+22	; 0x16
    7324:	8e 89       	ldd	r24, Y+22	; 0x16
    7326:	89 17       	cp	r24, r25
    7328:	20 f0       	brcs	.+8      	; 0x7332 <xTaskCreate+0x1aa>
    732a:	d0 93 47 20 	sts	0x2047, r29	; 0x802047 <pxCurrentTCB+0x1>
    732e:	c0 93 46 20 	sts	0x2046, r28	; 0x802046 <pxCurrentTCB>
    7332:	80 91 e7 1f 	lds	r24, 0x1FE7	; 0x801fe7 <uxTaskNumber>
    7336:	8f 5f       	subi	r24, 0xFF	; 255
    7338:	80 93 e7 1f 	sts	0x1FE7, r24	; 0x801fe7 <uxTaskNumber>
    733c:	89 a7       	std	Y+41, r24	; 0x29
    733e:	8e 89       	ldd	r24, Y+22	; 0x16
    7340:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7344:	98 17       	cp	r25, r24
    7346:	10 f4       	brcc	.+4      	; 0x734c <xTaskCreate+0x1c4>
    7348:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    734c:	90 e0       	ldi	r25, 0x00	; 0
    734e:	9c 01       	movw	r18, r24
    7350:	22 0f       	add	r18, r18
    7352:	33 1f       	adc	r19, r19
    7354:	22 0f       	add	r18, r18
    7356:	33 1f       	adc	r19, r19
    7358:	22 0f       	add	r18, r18
    735a:	33 1f       	adc	r19, r19
    735c:	82 0f       	add	r24, r18
    735e:	93 1f       	adc	r25, r19
    7360:	b6 01       	movw	r22, r12
    7362:	8e 5d       	subi	r24, 0xDE	; 222
    7364:	9f 4d       	sbci	r25, 0xDF	; 223
    7366:	f2 d8       	rcall	.-3612   	; 0x654c <vListInsertEnd>
    7368:	0f 90       	pop	r0
    736a:	0f be       	out	0x3f, r0	; 63
    736c:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xSchedulerRunning>
    7370:	88 23       	and	r24, r24
    7372:	59 f0       	breq	.+22     	; 0x738a <xTaskCreate+0x202>
    7374:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7378:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    737c:	96 89       	ldd	r25, Z+22	; 0x16
    737e:	8e 89       	ldd	r24, Y+22	; 0x16
    7380:	98 17       	cp	r25, r24
    7382:	28 f4       	brcc	.+10     	; 0x738e <xTaskCreate+0x206>
    7384:	0d da       	rcall	.-3046   	; 0x67a0 <vPortYield>
    7386:	81 e0       	ldi	r24, 0x01	; 1
    7388:	05 c0       	rjmp	.+10     	; 0x7394 <xTaskCreate+0x20c>
    738a:	81 e0       	ldi	r24, 0x01	; 1
    738c:	03 c0       	rjmp	.+6      	; 0x7394 <xTaskCreate+0x20c>
    738e:	81 e0       	ldi	r24, 0x01	; 1
    7390:	01 c0       	rjmp	.+2      	; 0x7394 <xTaskCreate+0x20c>
    7392:	8f ef       	ldi	r24, 0xFF	; 255
    7394:	df 91       	pop	r29
    7396:	cf 91       	pop	r28
    7398:	0f 91       	pop	r16
    739a:	ff 90       	pop	r15
    739c:	ef 90       	pop	r14
    739e:	df 90       	pop	r13
    73a0:	cf 90       	pop	r12
    73a2:	bf 90       	pop	r11
    73a4:	af 90       	pop	r10
    73a6:	9f 90       	pop	r9
    73a8:	8f 90       	pop	r8
    73aa:	7f 90       	pop	r7
    73ac:	6f 90       	pop	r6
    73ae:	5f 90       	pop	r5
    73b0:	4f 90       	pop	r4
    73b2:	08 95       	ret

000073b4 <eTaskGetState>:
    73b4:	20 91 46 20 	lds	r18, 0x2046	; 0x802046 <pxCurrentTCB>
    73b8:	30 91 47 20 	lds	r19, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    73bc:	82 17       	cp	r24, r18
    73be:	93 07       	cpc	r25, r19
    73c0:	61 f1       	breq	.+88     	; 0x741a <eTaskGetState+0x66>
    73c2:	0f b6       	in	r0, 0x3f	; 63
    73c4:	f8 94       	cli
    73c6:	0f 92       	push	r0
    73c8:	fc 01       	movw	r30, r24
    73ca:	22 85       	ldd	r18, Z+10	; 0x0a
    73cc:	33 85       	ldd	r19, Z+11	; 0x0b
    73ce:	40 91 0e 20 	lds	r20, 0x200E	; 0x80200e <pxDelayedTaskList>
    73d2:	50 91 0f 20 	lds	r21, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    73d6:	60 91 0c 20 	lds	r22, 0x200C	; 0x80200c <pxOverflowDelayedTaskList>
    73da:	70 91 0d 20 	lds	r23, 0x200D	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    73de:	0f 90       	pop	r0
    73e0:	0f be       	out	0x3f, r0	; 63
    73e2:	24 17       	cp	r18, r20
    73e4:	35 07       	cpc	r19, r21
    73e6:	d9 f0       	breq	.+54     	; 0x741e <eTaskGetState+0x6a>
    73e8:	26 17       	cp	r18, r22
    73ea:	37 07       	cpc	r19, r23
    73ec:	d1 f0       	breq	.+52     	; 0x7422 <eTaskGetState+0x6e>
    73ee:	ff e1       	ldi	r31, 0x1F	; 31
    73f0:	20 3f       	cpi	r18, 0xF0	; 240
    73f2:	3f 07       	cpc	r19, r31
    73f4:	51 f4       	brne	.+20     	; 0x740a <eTaskGetState+0x56>
    73f6:	fc 01       	movw	r30, r24
    73f8:	24 89       	ldd	r18, Z+20	; 0x14
    73fa:	35 89       	ldd	r19, Z+21	; 0x15
    73fc:	23 2b       	or	r18, r19
    73fe:	99 f4       	brne	.+38     	; 0x7426 <eTaskGetState+0x72>
    7400:	83 ad       	ldd	r24, Z+59	; 0x3b
    7402:	81 30       	cpi	r24, 0x01	; 1
    7404:	91 f0       	breq	.+36     	; 0x742a <eTaskGetState+0x76>
    7406:	83 e0       	ldi	r24, 0x03	; 3
    7408:	08 95       	ret
    740a:	ff e1       	ldi	r31, 0x1F	; 31
    740c:	2a 3f       	cpi	r18, 0xFA	; 250
    740e:	3f 07       	cpc	r19, r31
    7410:	71 f0       	breq	.+28     	; 0x742e <eTaskGetState+0x7a>
    7412:	23 2b       	or	r18, r19
    7414:	71 f0       	breq	.+28     	; 0x7432 <eTaskGetState+0x7e>
    7416:	81 e0       	ldi	r24, 0x01	; 1
    7418:	08 95       	ret
    741a:	80 e0       	ldi	r24, 0x00	; 0
    741c:	08 95       	ret
    741e:	82 e0       	ldi	r24, 0x02	; 2
    7420:	08 95       	ret
    7422:	82 e0       	ldi	r24, 0x02	; 2
    7424:	08 95       	ret
    7426:	82 e0       	ldi	r24, 0x02	; 2
    7428:	08 95       	ret
    742a:	82 e0       	ldi	r24, 0x02	; 2
    742c:	08 95       	ret
    742e:	84 e0       	ldi	r24, 0x04	; 4
    7430:	08 95       	ret
    7432:	84 e0       	ldi	r24, 0x04	; 4
    7434:	08 95       	ret

00007436 <xTaskResumeFromISR>:
    7436:	ef 92       	push	r14
    7438:	ff 92       	push	r15
    743a:	1f 93       	push	r17
    743c:	cf 93       	push	r28
    743e:	df 93       	push	r29
    7440:	fc 01       	movw	r30, r24
    7442:	22 85       	ldd	r18, Z+10	; 0x0a
    7444:	33 85       	ldd	r19, Z+11	; 0x0b
    7446:	20 5f       	subi	r18, 0xF0	; 240
    7448:	3f 41       	sbci	r19, 0x1F	; 31
    744a:	09 f0       	breq	.+2      	; 0x744e <xTaskResumeFromISR+0x18>
    744c:	3c c0       	rjmp	.+120    	; 0x74c6 <xTaskResumeFromISR+0x90>
    744e:	fc 01       	movw	r30, r24
    7450:	24 89       	ldd	r18, Z+20	; 0x14
    7452:	35 89       	ldd	r19, Z+21	; 0x15
    7454:	f0 e2       	ldi	r31, 0x20	; 32
    7456:	23 30       	cpi	r18, 0x03	; 3
    7458:	3f 07       	cpc	r19, r31
    745a:	b9 f1       	breq	.+110    	; 0x74ca <xTaskResumeFromISR+0x94>
    745c:	23 2b       	or	r18, r19
    745e:	b9 f5       	brne	.+110    	; 0x74ce <xTaskResumeFromISR+0x98>
    7460:	ec 01       	movw	r28, r24
    7462:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    7466:	81 11       	cpse	r24, r1
    7468:	26 c0       	rjmp	.+76     	; 0x74b6 <xTaskResumeFromISR+0x80>
    746a:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    746e:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7472:	11 e0       	ldi	r17, 0x01	; 1
    7474:	9e 89       	ldd	r25, Y+22	; 0x16
    7476:	86 89       	ldd	r24, Z+22	; 0x16
    7478:	98 17       	cp	r25, r24
    747a:	08 f4       	brcc	.+2      	; 0x747e <xTaskResumeFromISR+0x48>
    747c:	10 e0       	ldi	r17, 0x00	; 0
    747e:	7e 01       	movw	r14, r28
    7480:	42 e0       	ldi	r20, 0x02	; 2
    7482:	e4 0e       	add	r14, r20
    7484:	f1 1c       	adc	r15, r1
    7486:	c7 01       	movw	r24, r14
    7488:	b3 d8       	rcall	.-3738   	; 0x65f0 <uxListRemove>
    748a:	8e 89       	ldd	r24, Y+22	; 0x16
    748c:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7490:	98 17       	cp	r25, r24
    7492:	10 f4       	brcc	.+4      	; 0x7498 <xTaskResumeFromISR+0x62>
    7494:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    7498:	90 e0       	ldi	r25, 0x00	; 0
    749a:	9c 01       	movw	r18, r24
    749c:	22 0f       	add	r18, r18
    749e:	33 1f       	adc	r19, r19
    74a0:	22 0f       	add	r18, r18
    74a2:	33 1f       	adc	r19, r19
    74a4:	22 0f       	add	r18, r18
    74a6:	33 1f       	adc	r19, r19
    74a8:	82 0f       	add	r24, r18
    74aa:	93 1f       	adc	r25, r19
    74ac:	b7 01       	movw	r22, r14
    74ae:	8e 5d       	subi	r24, 0xDE	; 222
    74b0:	9f 4d       	sbci	r25, 0xDF	; 223
    74b2:	4c d8       	rcall	.-3944   	; 0x654c <vListInsertEnd>
    74b4:	0d c0       	rjmp	.+26     	; 0x74d0 <xTaskResumeFromISR+0x9a>
    74b6:	be 01       	movw	r22, r28
    74b8:	64 5f       	subi	r22, 0xF4	; 244
    74ba:	7f 4f       	sbci	r23, 0xFF	; 255
    74bc:	83 e0       	ldi	r24, 0x03	; 3
    74be:	90 e2       	ldi	r25, 0x20	; 32
    74c0:	45 d8       	rcall	.-3958   	; 0x654c <vListInsertEnd>
    74c2:	10 e0       	ldi	r17, 0x00	; 0
    74c4:	05 c0       	rjmp	.+10     	; 0x74d0 <xTaskResumeFromISR+0x9a>
    74c6:	10 e0       	ldi	r17, 0x00	; 0
    74c8:	03 c0       	rjmp	.+6      	; 0x74d0 <xTaskResumeFromISR+0x9a>
    74ca:	10 e0       	ldi	r17, 0x00	; 0
    74cc:	01 c0       	rjmp	.+2      	; 0x74d0 <xTaskResumeFromISR+0x9a>
    74ce:	10 e0       	ldi	r17, 0x00	; 0
    74d0:	81 2f       	mov	r24, r17
    74d2:	df 91       	pop	r29
    74d4:	cf 91       	pop	r28
    74d6:	1f 91       	pop	r17
    74d8:	ff 90       	pop	r15
    74da:	ef 90       	pop	r14
    74dc:	08 95       	ret

000074de <vTaskStartScheduler>:
    74de:	ef 92       	push	r14
    74e0:	ff 92       	push	r15
    74e2:	0f 93       	push	r16
    74e4:	0f 2e       	mov	r0, r31
    74e6:	f3 ee       	ldi	r31, 0xE3	; 227
    74e8:	ef 2e       	mov	r14, r31
    74ea:	ff e1       	ldi	r31, 0x1F	; 31
    74ec:	ff 2e       	mov	r15, r31
    74ee:	f0 2d       	mov	r31, r0
    74f0:	00 e0       	ldi	r16, 0x00	; 0
    74f2:	20 e0       	ldi	r18, 0x00	; 0
    74f4:	30 e0       	ldi	r19, 0x00	; 0
    74f6:	44 e6       	ldi	r20, 0x64	; 100
    74f8:	50 e0       	ldi	r21, 0x00	; 0
    74fa:	65 ee       	ldi	r22, 0xE5	; 229
    74fc:	72 e0       	ldi	r23, 0x02	; 2
    74fe:	8c e3       	ldi	r24, 0x3C	; 60
    7500:	98 e3       	ldi	r25, 0x38	; 56
    7502:	42 de       	rcall	.-892    	; 0x7188 <xTaskCreate>
    7504:	81 30       	cpi	r24, 0x01	; 1
    7506:	91 f4       	brne	.+36     	; 0x752c <vTaskStartScheduler+0x4e>
    7508:	8d d6       	rcall	.+3354   	; 0x8224 <xTimerCreateTimerTask>
    750a:	81 30       	cpi	r24, 0x01	; 1
    750c:	79 f4       	brne	.+30     	; 0x752c <vTaskStartScheduler+0x4e>
    750e:	f8 94       	cli
    7510:	8f ef       	ldi	r24, 0xFF	; 255
    7512:	9f ef       	ldi	r25, 0xFF	; 255
    7514:	90 93 e6 1f 	sts	0x1FE6, r25	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    7518:	80 93 e5 1f 	sts	0x1FE5, r24	; 0x801fe5 <xNextTaskUnblockTime>
    751c:	81 e0       	ldi	r24, 0x01	; 1
    751e:	80 93 eb 1f 	sts	0x1FEB, r24	; 0x801feb <xSchedulerRunning>
    7522:	10 92 ee 1f 	sts	0x1FEE, r1	; 0x801fee <xTickCount+0x1>
    7526:	10 92 ed 1f 	sts	0x1FED, r1	; 0x801fed <xTickCount>
    752a:	fb d8       	rcall	.-3594   	; 0x6722 <xPortStartScheduler>
    752c:	0f 91       	pop	r16
    752e:	ff 90       	pop	r15
    7530:	ef 90       	pop	r14
    7532:	08 95       	ret

00007534 <vTaskSuspendAll>:
    7534:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    7538:	8f 5f       	subi	r24, 0xFF	; 255
    753a:	80 93 e2 1f 	sts	0x1FE2, r24	; 0x801fe2 <uxSchedulerSuspended>
    753e:	08 95       	ret

00007540 <xTaskGetTickCount>:
    7540:	0f b6       	in	r0, 0x3f	; 63
    7542:	f8 94       	cli
    7544:	0f 92       	push	r0
    7546:	80 91 ed 1f 	lds	r24, 0x1FED	; 0x801fed <xTickCount>
    754a:	90 91 ee 1f 	lds	r25, 0x1FEE	; 0x801fee <xTickCount+0x1>
    754e:	0f 90       	pop	r0
    7550:	0f be       	out	0x3f, r0	; 63
    7552:	08 95       	ret

00007554 <uxTaskGetNumberOfTasks>:
    7554:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    7558:	08 95       	ret

0000755a <pcTaskGetName>:
    755a:	00 97       	sbiw	r24, 0x00	; 0
    755c:	21 f4       	brne	.+8      	; 0x7566 <pcTaskGetName+0xc>
    755e:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    7562:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7566:	49 96       	adiw	r24, 0x19	; 25
    7568:	08 95       	ret

0000756a <xTaskIncrementTick>:
    756a:	cf 92       	push	r12
    756c:	df 92       	push	r13
    756e:	ef 92       	push	r14
    7570:	ff 92       	push	r15
    7572:	0f 93       	push	r16
    7574:	1f 93       	push	r17
    7576:	cf 93       	push	r28
    7578:	df 93       	push	r29
    757a:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    757e:	81 11       	cpse	r24, r1
    7580:	80 c0       	rjmp	.+256    	; 0x7682 <xTaskIncrementTick+0x118>
    7582:	e0 90 ed 1f 	lds	r14, 0x1FED	; 0x801fed <xTickCount>
    7586:	f0 90 ee 1f 	lds	r15, 0x1FEE	; 0x801fee <xTickCount+0x1>
    758a:	8f ef       	ldi	r24, 0xFF	; 255
    758c:	e8 1a       	sub	r14, r24
    758e:	f8 0a       	sbc	r15, r24
    7590:	f0 92 ee 1f 	sts	0x1FEE, r15	; 0x801fee <xTickCount+0x1>
    7594:	e0 92 ed 1f 	sts	0x1FED, r14	; 0x801fed <xTickCount>
    7598:	e1 14       	cp	r14, r1
    759a:	f1 04       	cpc	r15, r1
    759c:	b1 f4       	brne	.+44     	; 0x75ca <xTaskIncrementTick+0x60>
    759e:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <pxDelayedTaskList>
    75a2:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    75a6:	20 91 0c 20 	lds	r18, 0x200C	; 0x80200c <pxOverflowDelayedTaskList>
    75aa:	30 91 0d 20 	lds	r19, 0x200D	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    75ae:	30 93 0f 20 	sts	0x200F, r19	; 0x80200f <pxDelayedTaskList+0x1>
    75b2:	20 93 0e 20 	sts	0x200E, r18	; 0x80200e <pxDelayedTaskList>
    75b6:	90 93 0d 20 	sts	0x200D, r25	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    75ba:	80 93 0c 20 	sts	0x200C, r24	; 0x80200c <pxOverflowDelayedTaskList>
    75be:	80 91 e8 1f 	lds	r24, 0x1FE8	; 0x801fe8 <xNumOfOverflows>
    75c2:	8f 5f       	subi	r24, 0xFF	; 255
    75c4:	80 93 e8 1f 	sts	0x1FE8, r24	; 0x801fe8 <xNumOfOverflows>
    75c8:	38 dd       	rcall	.-1424   	; 0x703a <prvResetNextTaskUnblockTime>
    75ca:	80 91 e5 1f 	lds	r24, 0x1FE5	; 0x801fe5 <xNextTaskUnblockTime>
    75ce:	90 91 e6 1f 	lds	r25, 0x1FE6	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    75d2:	e8 16       	cp	r14, r24
    75d4:	f9 06       	cpc	r15, r25
    75d6:	10 f4       	brcc	.+4      	; 0x75dc <xTaskIncrementTick+0x72>
    75d8:	d1 2c       	mov	r13, r1
    75da:	59 c0       	rjmp	.+178    	; 0x768e <xTaskIncrementTick+0x124>
    75dc:	d1 2c       	mov	r13, r1
    75de:	cc 24       	eor	r12, r12
    75e0:	c3 94       	inc	r12
    75e2:	e0 91 0e 20 	lds	r30, 0x200E	; 0x80200e <pxDelayedTaskList>
    75e6:	f0 91 0f 20 	lds	r31, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    75ea:	80 81       	ld	r24, Z
    75ec:	81 11       	cpse	r24, r1
    75ee:	07 c0       	rjmp	.+14     	; 0x75fe <xTaskIncrementTick+0x94>
    75f0:	8f ef       	ldi	r24, 0xFF	; 255
    75f2:	9f ef       	ldi	r25, 0xFF	; 255
    75f4:	90 93 e6 1f 	sts	0x1FE6, r25	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    75f8:	80 93 e5 1f 	sts	0x1FE5, r24	; 0x801fe5 <xNextTaskUnblockTime>
    75fc:	48 c0       	rjmp	.+144    	; 0x768e <xTaskIncrementTick+0x124>
    75fe:	e0 91 0e 20 	lds	r30, 0x200E	; 0x80200e <pxDelayedTaskList>
    7602:	f0 91 0f 20 	lds	r31, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    7606:	05 80       	ldd	r0, Z+5	; 0x05
    7608:	f6 81       	ldd	r31, Z+6	; 0x06
    760a:	e0 2d       	mov	r30, r0
    760c:	c6 81       	ldd	r28, Z+6	; 0x06
    760e:	d7 81       	ldd	r29, Z+7	; 0x07
    7610:	8a 81       	ldd	r24, Y+2	; 0x02
    7612:	9b 81       	ldd	r25, Y+3	; 0x03
    7614:	e8 16       	cp	r14, r24
    7616:	f9 06       	cpc	r15, r25
    7618:	28 f4       	brcc	.+10     	; 0x7624 <xTaskIncrementTick+0xba>
    761a:	90 93 e6 1f 	sts	0x1FE6, r25	; 0x801fe6 <xNextTaskUnblockTime+0x1>
    761e:	80 93 e5 1f 	sts	0x1FE5, r24	; 0x801fe5 <xNextTaskUnblockTime>
    7622:	35 c0       	rjmp	.+106    	; 0x768e <xTaskIncrementTick+0x124>
    7624:	8e 01       	movw	r16, r28
    7626:	0e 5f       	subi	r16, 0xFE	; 254
    7628:	1f 4f       	sbci	r17, 0xFF	; 255
    762a:	c8 01       	movw	r24, r16
    762c:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7630:	8c 89       	ldd	r24, Y+20	; 0x14
    7632:	9d 89       	ldd	r25, Y+21	; 0x15
    7634:	89 2b       	or	r24, r25
    7636:	21 f0       	breq	.+8      	; 0x7640 <xTaskIncrementTick+0xd6>
    7638:	ce 01       	movw	r24, r28
    763a:	0c 96       	adiw	r24, 0x0c	; 12
    763c:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7640:	8e 89       	ldd	r24, Y+22	; 0x16
    7642:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7646:	98 17       	cp	r25, r24
    7648:	10 f4       	brcc	.+4      	; 0x764e <xTaskIncrementTick+0xe4>
    764a:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    764e:	90 e0       	ldi	r25, 0x00	; 0
    7650:	9c 01       	movw	r18, r24
    7652:	22 0f       	add	r18, r18
    7654:	33 1f       	adc	r19, r19
    7656:	22 0f       	add	r18, r18
    7658:	33 1f       	adc	r19, r19
    765a:	22 0f       	add	r18, r18
    765c:	33 1f       	adc	r19, r19
    765e:	82 0f       	add	r24, r18
    7660:	93 1f       	adc	r25, r19
    7662:	b8 01       	movw	r22, r16
    7664:	8e 5d       	subi	r24, 0xDE	; 222
    7666:	9f 4d       	sbci	r25, 0xDF	; 223
    7668:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    766c:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7670:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7674:	9e 89       	ldd	r25, Y+22	; 0x16
    7676:	86 89       	ldd	r24, Z+22	; 0x16
    7678:	98 17       	cp	r25, r24
    767a:	08 f4       	brcc	.+2      	; 0x767e <xTaskIncrementTick+0x114>
    767c:	b2 cf       	rjmp	.-156    	; 0x75e2 <xTaskIncrementTick+0x78>
    767e:	dc 2c       	mov	r13, r12
    7680:	b0 cf       	rjmp	.-160    	; 0x75e2 <xTaskIncrementTick+0x78>
    7682:	80 91 ea 1f 	lds	r24, 0x1FEA	; 0x801fea <uxPendedTicks>
    7686:	8f 5f       	subi	r24, 0xFF	; 255
    7688:	80 93 ea 1f 	sts	0x1FEA, r24	; 0x801fea <uxPendedTicks>
    768c:	d1 2c       	mov	r13, r1
    768e:	80 91 e9 1f 	lds	r24, 0x1FE9	; 0x801fe9 <xYieldPending>
    7692:	88 23       	and	r24, r24
    7694:	11 f0       	breq	.+4      	; 0x769a <xTaskIncrementTick+0x130>
    7696:	dd 24       	eor	r13, r13
    7698:	d3 94       	inc	r13
    769a:	8d 2d       	mov	r24, r13
    769c:	df 91       	pop	r29
    769e:	cf 91       	pop	r28
    76a0:	1f 91       	pop	r17
    76a2:	0f 91       	pop	r16
    76a4:	ff 90       	pop	r15
    76a6:	ef 90       	pop	r14
    76a8:	df 90       	pop	r13
    76aa:	cf 90       	pop	r12
    76ac:	08 95       	ret

000076ae <xTaskResumeAll>:
    76ae:	df 92       	push	r13
    76b0:	ef 92       	push	r14
    76b2:	ff 92       	push	r15
    76b4:	0f 93       	push	r16
    76b6:	1f 93       	push	r17
    76b8:	cf 93       	push	r28
    76ba:	df 93       	push	r29
    76bc:	0f b6       	in	r0, 0x3f	; 63
    76be:	f8 94       	cli
    76c0:	0f 92       	push	r0
    76c2:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    76c6:	81 50       	subi	r24, 0x01	; 1
    76c8:	80 93 e2 1f 	sts	0x1FE2, r24	; 0x801fe2 <uxSchedulerSuspended>
    76cc:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    76d0:	81 11       	cpse	r24, r1
    76d2:	5c c0       	rjmp	.+184    	; 0x778c <xTaskResumeAll+0xde>
    76d4:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    76d8:	81 11       	cpse	r24, r1
    76da:	33 c0       	rjmp	.+102    	; 0x7742 <xTaskResumeAll+0x94>
    76dc:	5a c0       	rjmp	.+180    	; 0x7792 <xTaskResumeAll+0xe4>
    76de:	d7 01       	movw	r26, r14
    76e0:	15 96       	adiw	r26, 0x05	; 5
    76e2:	ed 91       	ld	r30, X+
    76e4:	fc 91       	ld	r31, X
    76e6:	16 97       	sbiw	r26, 0x06	; 6
    76e8:	c6 81       	ldd	r28, Z+6	; 0x06
    76ea:	d7 81       	ldd	r29, Z+7	; 0x07
    76ec:	ce 01       	movw	r24, r28
    76ee:	0c 96       	adiw	r24, 0x0c	; 12
    76f0:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    76f4:	8e 01       	movw	r16, r28
    76f6:	0e 5f       	subi	r16, 0xFE	; 254
    76f8:	1f 4f       	sbci	r17, 0xFF	; 255
    76fa:	c8 01       	movw	r24, r16
    76fc:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7700:	8e 89       	ldd	r24, Y+22	; 0x16
    7702:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7706:	98 17       	cp	r25, r24
    7708:	10 f4       	brcc	.+4      	; 0x770e <xTaskResumeAll+0x60>
    770a:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    770e:	90 e0       	ldi	r25, 0x00	; 0
    7710:	9c 01       	movw	r18, r24
    7712:	22 0f       	add	r18, r18
    7714:	33 1f       	adc	r19, r19
    7716:	22 0f       	add	r18, r18
    7718:	33 1f       	adc	r19, r19
    771a:	22 0f       	add	r18, r18
    771c:	33 1f       	adc	r19, r19
    771e:	82 0f       	add	r24, r18
    7720:	93 1f       	adc	r25, r19
    7722:	b8 01       	movw	r22, r16
    7724:	8e 5d       	subi	r24, 0xDE	; 222
    7726:	9f 4d       	sbci	r25, 0xDF	; 223
    7728:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    772c:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7730:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7734:	9e 89       	ldd	r25, Y+22	; 0x16
    7736:	86 89       	ldd	r24, Z+22	; 0x16
    7738:	98 17       	cp	r25, r24
    773a:	68 f0       	brcs	.+26     	; 0x7756 <xTaskResumeAll+0xa8>
    773c:	d0 92 e9 1f 	sts	0x1FE9, r13	; 0x801fe9 <xYieldPending>
    7740:	0a c0       	rjmp	.+20     	; 0x7756 <xTaskResumeAll+0xa8>
    7742:	c0 e0       	ldi	r28, 0x00	; 0
    7744:	d0 e0       	ldi	r29, 0x00	; 0
    7746:	0f 2e       	mov	r0, r31
    7748:	f3 e0       	ldi	r31, 0x03	; 3
    774a:	ef 2e       	mov	r14, r31
    774c:	f0 e2       	ldi	r31, 0x20	; 32
    774e:	ff 2e       	mov	r15, r31
    7750:	f0 2d       	mov	r31, r0
    7752:	dd 24       	eor	r13, r13
    7754:	d3 94       	inc	r13
    7756:	f7 01       	movw	r30, r14
    7758:	80 81       	ld	r24, Z
    775a:	81 11       	cpse	r24, r1
    775c:	c0 cf       	rjmp	.-128    	; 0x76de <xTaskResumeAll+0x30>
    775e:	cd 2b       	or	r28, r29
    7760:	09 f0       	breq	.+2      	; 0x7764 <xTaskResumeAll+0xb6>
    7762:	6b dc       	rcall	.-1834   	; 0x703a <prvResetNextTaskUnblockTime>
    7764:	c0 91 ea 1f 	lds	r28, 0x1FEA	; 0x801fea <uxPendedTicks>
    7768:	cc 23       	and	r28, r28
    776a:	49 f0       	breq	.+18     	; 0x777e <xTaskResumeAll+0xd0>
    776c:	d1 e0       	ldi	r29, 0x01	; 1
    776e:	fd de       	rcall	.-518    	; 0x756a <xTaskIncrementTick>
    7770:	81 11       	cpse	r24, r1
    7772:	d0 93 e9 1f 	sts	0x1FE9, r29	; 0x801fe9 <xYieldPending>
    7776:	c1 50       	subi	r28, 0x01	; 1
    7778:	d1 f7       	brne	.-12     	; 0x776e <xTaskResumeAll+0xc0>
    777a:	10 92 ea 1f 	sts	0x1FEA, r1	; 0x801fea <uxPendedTicks>
    777e:	80 91 e9 1f 	lds	r24, 0x1FE9	; 0x801fe9 <xYieldPending>
    7782:	88 23       	and	r24, r24
    7784:	29 f0       	breq	.+10     	; 0x7790 <xTaskResumeAll+0xe2>
    7786:	0c d8       	rcall	.-4072   	; 0x67a0 <vPortYield>
    7788:	81 e0       	ldi	r24, 0x01	; 1
    778a:	03 c0       	rjmp	.+6      	; 0x7792 <xTaskResumeAll+0xe4>
    778c:	80 e0       	ldi	r24, 0x00	; 0
    778e:	01 c0       	rjmp	.+2      	; 0x7792 <xTaskResumeAll+0xe4>
    7790:	80 e0       	ldi	r24, 0x00	; 0
    7792:	0f 90       	pop	r0
    7794:	0f be       	out	0x3f, r0	; 63
    7796:	df 91       	pop	r29
    7798:	cf 91       	pop	r28
    779a:	1f 91       	pop	r17
    779c:	0f 91       	pop	r16
    779e:	ff 90       	pop	r15
    77a0:	ef 90       	pop	r14
    77a2:	df 90       	pop	r13
    77a4:	08 95       	ret

000077a6 <vTaskDelay>:
    77a6:	cf 93       	push	r28
    77a8:	df 93       	push	r29
    77aa:	ec 01       	movw	r28, r24
    77ac:	89 2b       	or	r24, r25
    77ae:	39 f0       	breq	.+14     	; 0x77be <vTaskDelay+0x18>
    77b0:	c1 de       	rcall	.-638    	; 0x7534 <vTaskSuspendAll>
    77b2:	60 e0       	ldi	r22, 0x00	; 0
    77b4:	ce 01       	movw	r24, r28
    77b6:	94 dc       	rcall	.-1752   	; 0x70e0 <prvAddCurrentTaskToDelayedList>
    77b8:	7a df       	rcall	.-268    	; 0x76ae <xTaskResumeAll>
    77ba:	81 11       	cpse	r24, r1
    77bc:	02 c0       	rjmp	.+4      	; 0x77c2 <vTaskDelay+0x1c>
    77be:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <vPortYield>
    77c2:	df 91       	pop	r29
    77c4:	cf 91       	pop	r28
    77c6:	08 95       	ret

000077c8 <vTaskPlaceOnEventList>:
    77c8:	cf 93       	push	r28
    77ca:	df 93       	push	r29
    77cc:	eb 01       	movw	r28, r22
    77ce:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    77d2:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    77d6:	64 5f       	subi	r22, 0xF4	; 244
    77d8:	7f 4f       	sbci	r23, 0xFF	; 255
    77da:	0e 94 c7 32 	call	0x658e	; 0x658e <vListInsert>
    77de:	61 e0       	ldi	r22, 0x01	; 1
    77e0:	ce 01       	movw	r24, r28
    77e2:	7e dc       	rcall	.-1796   	; 0x70e0 <prvAddCurrentTaskToDelayedList>
    77e4:	df 91       	pop	r29
    77e6:	cf 91       	pop	r28
    77e8:	08 95       	ret

000077ea <vTaskPlaceOnEventListRestricted>:
    77ea:	0f 93       	push	r16
    77ec:	1f 93       	push	r17
    77ee:	cf 93       	push	r28
    77f0:	8b 01       	movw	r16, r22
    77f2:	c4 2f       	mov	r28, r20
    77f4:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    77f8:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    77fc:	64 5f       	subi	r22, 0xF4	; 244
    77fe:	7f 4f       	sbci	r23, 0xFF	; 255
    7800:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    7804:	cc 23       	and	r28, r28
    7806:	11 f0       	breq	.+4      	; 0x780c <vTaskPlaceOnEventListRestricted+0x22>
    7808:	0f ef       	ldi	r16, 0xFF	; 255
    780a:	1f ef       	ldi	r17, 0xFF	; 255
    780c:	6c 2f       	mov	r22, r28
    780e:	c8 01       	movw	r24, r16
    7810:	67 dc       	rcall	.-1842   	; 0x70e0 <prvAddCurrentTaskToDelayedList>
    7812:	cf 91       	pop	r28
    7814:	1f 91       	pop	r17
    7816:	0f 91       	pop	r16
    7818:	08 95       	ret

0000781a <xTaskRemoveFromEventList>:
    781a:	0f 93       	push	r16
    781c:	1f 93       	push	r17
    781e:	cf 93       	push	r28
    7820:	df 93       	push	r29
    7822:	dc 01       	movw	r26, r24
    7824:	15 96       	adiw	r26, 0x05	; 5
    7826:	ed 91       	ld	r30, X+
    7828:	fc 91       	ld	r31, X
    782a:	16 97       	sbiw	r26, 0x06	; 6
    782c:	c6 81       	ldd	r28, Z+6	; 0x06
    782e:	d7 81       	ldd	r29, Z+7	; 0x07
    7830:	8e 01       	movw	r16, r28
    7832:	04 5f       	subi	r16, 0xF4	; 244
    7834:	1f 4f       	sbci	r17, 0xFF	; 255
    7836:	c8 01       	movw	r24, r16
    7838:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    783c:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    7840:	81 11       	cpse	r24, r1
    7842:	1c c0       	rjmp	.+56     	; 0x787c <xTaskRemoveFromEventList+0x62>
    7844:	0a 50       	subi	r16, 0x0A	; 10
    7846:	11 09       	sbc	r17, r1
    7848:	c8 01       	movw	r24, r16
    784a:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    784e:	8e 89       	ldd	r24, Y+22	; 0x16
    7850:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7854:	98 17       	cp	r25, r24
    7856:	10 f4       	brcc	.+4      	; 0x785c <xTaskRemoveFromEventList+0x42>
    7858:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    785c:	90 e0       	ldi	r25, 0x00	; 0
    785e:	9c 01       	movw	r18, r24
    7860:	22 0f       	add	r18, r18
    7862:	33 1f       	adc	r19, r19
    7864:	22 0f       	add	r18, r18
    7866:	33 1f       	adc	r19, r19
    7868:	22 0f       	add	r18, r18
    786a:	33 1f       	adc	r19, r19
    786c:	82 0f       	add	r24, r18
    786e:	93 1f       	adc	r25, r19
    7870:	b8 01       	movw	r22, r16
    7872:	8e 5d       	subi	r24, 0xDE	; 222
    7874:	9f 4d       	sbci	r25, 0xDF	; 223
    7876:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    787a:	05 c0       	rjmp	.+10     	; 0x7886 <xTaskRemoveFromEventList+0x6c>
    787c:	b8 01       	movw	r22, r16
    787e:	83 e0       	ldi	r24, 0x03	; 3
    7880:	90 e2       	ldi	r25, 0x20	; 32
    7882:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    7886:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    788a:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    788e:	9e 89       	ldd	r25, Y+22	; 0x16
    7890:	86 89       	ldd	r24, Z+22	; 0x16
    7892:	89 17       	cp	r24, r25
    7894:	20 f4       	brcc	.+8      	; 0x789e <xTaskRemoveFromEventList+0x84>
    7896:	81 e0       	ldi	r24, 0x01	; 1
    7898:	80 93 e9 1f 	sts	0x1FE9, r24	; 0x801fe9 <xYieldPending>
    789c:	01 c0       	rjmp	.+2      	; 0x78a0 <xTaskRemoveFromEventList+0x86>
    789e:	80 e0       	ldi	r24, 0x00	; 0
    78a0:	df 91       	pop	r29
    78a2:	cf 91       	pop	r28
    78a4:	1f 91       	pop	r17
    78a6:	0f 91       	pop	r16
    78a8:	08 95       	ret

000078aa <vTaskInternalSetTimeOutState>:
    78aa:	20 91 e8 1f 	lds	r18, 0x1FE8	; 0x801fe8 <xNumOfOverflows>
    78ae:	fc 01       	movw	r30, r24
    78b0:	20 83       	st	Z, r18
    78b2:	20 91 ed 1f 	lds	r18, 0x1FED	; 0x801fed <xTickCount>
    78b6:	30 91 ee 1f 	lds	r19, 0x1FEE	; 0x801fee <xTickCount+0x1>
    78ba:	32 83       	std	Z+2, r19	; 0x02
    78bc:	21 83       	std	Z+1, r18	; 0x01
    78be:	08 95       	ret

000078c0 <xTaskCheckForTimeOut>:
    78c0:	cf 93       	push	r28
    78c2:	df 93       	push	r29
    78c4:	0f b6       	in	r0, 0x3f	; 63
    78c6:	f8 94       	cli
    78c8:	0f 92       	push	r0
    78ca:	20 91 ed 1f 	lds	r18, 0x1FED	; 0x801fed <xTickCount>
    78ce:	30 91 ee 1f 	lds	r19, 0x1FEE	; 0x801fee <xTickCount+0x1>
    78d2:	db 01       	movw	r26, r22
    78d4:	4d 91       	ld	r20, X+
    78d6:	5c 91       	ld	r21, X
    78d8:	4f 3f       	cpi	r20, 0xFF	; 255
    78da:	bf ef       	ldi	r27, 0xFF	; 255
    78dc:	5b 07       	cpc	r21, r27
    78de:	e9 f0       	breq	.+58     	; 0x791a <xTaskCheckForTimeOut+0x5a>
    78e0:	ec 01       	movw	r28, r24
    78e2:	e9 81       	ldd	r30, Y+1	; 0x01
    78e4:	fa 81       	ldd	r31, Y+2	; 0x02
    78e6:	a0 91 e8 1f 	lds	r26, 0x1FE8	; 0x801fe8 <xNumOfOverflows>
    78ea:	b8 81       	ld	r27, Y
    78ec:	ba 17       	cp	r27, r26
    78ee:	19 f0       	breq	.+6      	; 0x78f6 <xTaskCheckForTimeOut+0x36>
    78f0:	2e 17       	cp	r18, r30
    78f2:	3f 07       	cpc	r19, r31
    78f4:	a0 f4       	brcc	.+40     	; 0x791e <xTaskCheckForTimeOut+0x5e>
    78f6:	2e 1b       	sub	r18, r30
    78f8:	3f 0b       	sbc	r19, r31
    78fa:	24 17       	cp	r18, r20
    78fc:	35 07       	cpc	r19, r21
    78fe:	40 f4       	brcc	.+16     	; 0x7910 <xTaskCheckForTimeOut+0x50>
    7900:	fb 01       	movw	r30, r22
    7902:	42 1b       	sub	r20, r18
    7904:	53 0b       	sbc	r21, r19
    7906:	51 83       	std	Z+1, r21	; 0x01
    7908:	40 83       	st	Z, r20
    790a:	cf df       	rcall	.-98     	; 0x78aa <vTaskInternalSetTimeOutState>
    790c:	80 e0       	ldi	r24, 0x00	; 0
    790e:	08 c0       	rjmp	.+16     	; 0x7920 <xTaskCheckForTimeOut+0x60>
    7910:	fb 01       	movw	r30, r22
    7912:	11 82       	std	Z+1, r1	; 0x01
    7914:	10 82       	st	Z, r1
    7916:	81 e0       	ldi	r24, 0x01	; 1
    7918:	03 c0       	rjmp	.+6      	; 0x7920 <xTaskCheckForTimeOut+0x60>
    791a:	80 e0       	ldi	r24, 0x00	; 0
    791c:	01 c0       	rjmp	.+2      	; 0x7920 <xTaskCheckForTimeOut+0x60>
    791e:	81 e0       	ldi	r24, 0x01	; 1
    7920:	0f 90       	pop	r0
    7922:	0f be       	out	0x3f, r0	; 63
    7924:	df 91       	pop	r29
    7926:	cf 91       	pop	r28
    7928:	08 95       	ret

0000792a <vTaskMissedYield>:
    792a:	81 e0       	ldi	r24, 0x01	; 1
    792c:	80 93 e9 1f 	sts	0x1FE9, r24	; 0x801fe9 <xYieldPending>
    7930:	08 95       	ret

00007932 <vTaskGetInfo>:
    7932:	ff 92       	push	r15
    7934:	0f 93       	push	r16
    7936:	1f 93       	push	r17
    7938:	cf 93       	push	r28
    793a:	df 93       	push	r29
    793c:	8c 01       	movw	r16, r24
    793e:	eb 01       	movw	r28, r22
    7940:	f4 2e       	mov	r15, r20
    7942:	89 2b       	or	r24, r25
    7944:	21 f4       	brne	.+8      	; 0x794e <vTaskGetInfo+0x1c>
    7946:	00 91 46 20 	lds	r16, 0x2046	; 0x802046 <pxCurrentTCB>
    794a:	10 91 47 20 	lds	r17, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    794e:	19 83       	std	Y+1, r17	; 0x01
    7950:	08 83       	st	Y, r16
    7952:	c8 01       	movw	r24, r16
    7954:	49 96       	adiw	r24, 0x19	; 25
    7956:	9b 83       	std	Y+3, r25	; 0x03
    7958:	8a 83       	std	Y+2, r24	; 0x02
    795a:	d8 01       	movw	r26, r16
    795c:	56 96       	adiw	r26, 0x16	; 22
    795e:	8c 91       	ld	r24, X
    7960:	56 97       	sbiw	r26, 0x16	; 22
    7962:	8e 83       	std	Y+6, r24	; 0x06
    7964:	57 96       	adiw	r26, 0x17	; 23
    7966:	8d 91       	ld	r24, X+
    7968:	9c 91       	ld	r25, X
    796a:	58 97       	sbiw	r26, 0x18	; 24
    796c:	9d 87       	std	Y+13, r25	; 0x0d
    796e:	8c 87       	std	Y+12, r24	; 0x0c
    7970:	99 96       	adiw	r26, 0x29	; 41
    7972:	8c 91       	ld	r24, X
    7974:	99 97       	sbiw	r26, 0x29	; 41
    7976:	8c 83       	std	Y+4, r24	; 0x04
    7978:	9b 96       	adiw	r26, 0x2b	; 43
    797a:	8c 91       	ld	r24, X
    797c:	8f 83       	std	Y+7, r24	; 0x07
    797e:	18 86       	std	Y+8, r1	; 0x08
    7980:	19 86       	std	Y+9, r1	; 0x09
    7982:	1a 86       	std	Y+10, r1	; 0x0a
    7984:	1b 86       	std	Y+11, r1	; 0x0b
    7986:	25 30       	cpi	r18, 0x05	; 5
    7988:	b1 f0       	breq	.+44     	; 0x79b6 <vTaskGetInfo+0x84>
    798a:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    798e:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7992:	08 17       	cp	r16, r24
    7994:	19 07       	cpc	r17, r25
    7996:	11 f4       	brne	.+4      	; 0x799c <vTaskGetInfo+0x6a>
    7998:	1d 82       	std	Y+5, r1	; 0x05
    799a:	10 c0       	rjmp	.+32     	; 0x79bc <vTaskGetInfo+0x8a>
    799c:	2d 83       	std	Y+5, r18	; 0x05
    799e:	23 30       	cpi	r18, 0x03	; 3
    79a0:	69 f4       	brne	.+26     	; 0x79bc <vTaskGetInfo+0x8a>
    79a2:	c8 dd       	rcall	.-1136   	; 0x7534 <vTaskSuspendAll>
    79a4:	f8 01       	movw	r30, r16
    79a6:	84 89       	ldd	r24, Z+20	; 0x14
    79a8:	95 89       	ldd	r25, Z+21	; 0x15
    79aa:	89 2b       	or	r24, r25
    79ac:	11 f0       	breq	.+4      	; 0x79b2 <vTaskGetInfo+0x80>
    79ae:	82 e0       	ldi	r24, 0x02	; 2
    79b0:	8d 83       	std	Y+5, r24	; 0x05
    79b2:	7d de       	rcall	.-774    	; 0x76ae <xTaskResumeAll>
    79b4:	03 c0       	rjmp	.+6      	; 0x79bc <vTaskGetInfo+0x8a>
    79b6:	c8 01       	movw	r24, r16
    79b8:	fd dc       	rcall	.-1542   	; 0x73b4 <eTaskGetState>
    79ba:	8d 83       	std	Y+5, r24	; 0x05
    79bc:	ff 20       	and	r15, r15
    79be:	c9 f0       	breq	.+50     	; 0x79f2 <vTaskGetInfo+0xc0>
    79c0:	d8 01       	movw	r26, r16
    79c2:	57 96       	adiw	r26, 0x17	; 23
    79c4:	ed 91       	ld	r30, X+
    79c6:	fc 91       	ld	r31, X
    79c8:	58 97       	sbiw	r26, 0x18	; 24
    79ca:	80 81       	ld	r24, Z
    79cc:	85 3a       	cpi	r24, 0xA5	; 165
    79ce:	59 f4       	brne	.+22     	; 0x79e6 <vTaskGetInfo+0xb4>
    79d0:	31 96       	adiw	r30, 0x01	; 1
    79d2:	80 e0       	ldi	r24, 0x00	; 0
    79d4:	90 e0       	ldi	r25, 0x00	; 0
    79d6:	dc 01       	movw	r26, r24
    79d8:	01 96       	adiw	r24, 0x01	; 1
    79da:	a1 1d       	adc	r26, r1
    79dc:	b1 1d       	adc	r27, r1
    79de:	21 91       	ld	r18, Z+
    79e0:	25 3a       	cpi	r18, 0xA5	; 165
    79e2:	d1 f3       	breq	.-12     	; 0x79d8 <vTaskGetInfo+0xa6>
    79e4:	03 c0       	rjmp	.+6      	; 0x79ec <vTaskGetInfo+0xba>
    79e6:	80 e0       	ldi	r24, 0x00	; 0
    79e8:	90 e0       	ldi	r25, 0x00	; 0
    79ea:	dc 01       	movw	r26, r24
    79ec:	9f 87       	std	Y+15, r25	; 0x0f
    79ee:	8e 87       	std	Y+14, r24	; 0x0e
    79f0:	02 c0       	rjmp	.+4      	; 0x79f6 <vTaskGetInfo+0xc4>
    79f2:	1f 86       	std	Y+15, r1	; 0x0f
    79f4:	1e 86       	std	Y+14, r1	; 0x0e
    79f6:	df 91       	pop	r29
    79f8:	cf 91       	pop	r28
    79fa:	1f 91       	pop	r17
    79fc:	0f 91       	pop	r16
    79fe:	ff 90       	pop	r15
    7a00:	08 95       	ret

00007a02 <prvListTasksWithinSingleList>:
    7a02:	8f 92       	push	r8
    7a04:	9f 92       	push	r9
    7a06:	af 92       	push	r10
    7a08:	bf 92       	push	r11
    7a0a:	cf 92       	push	r12
    7a0c:	df 92       	push	r13
    7a0e:	ef 92       	push	r14
    7a10:	ff 92       	push	r15
    7a12:	0f 93       	push	r16
    7a14:	1f 93       	push	r17
    7a16:	cf 93       	push	r28
    7a18:	df 93       	push	r29
    7a1a:	6c 01       	movw	r12, r24
    7a1c:	eb 01       	movw	r28, r22
    7a1e:	98 81       	ld	r25, Y
    7a20:	99 23       	and	r25, r25
    7a22:	c1 f1       	breq	.+112    	; 0x7a94 <prvListTasksWithinSingleList+0x92>
    7a24:	e9 81       	ldd	r30, Y+1	; 0x01
    7a26:	fa 81       	ldd	r31, Y+2	; 0x02
    7a28:	02 80       	ldd	r0, Z+2	; 0x02
    7a2a:	f3 81       	ldd	r31, Z+3	; 0x03
    7a2c:	e0 2d       	mov	r30, r0
    7a2e:	fa 83       	std	Y+2, r31	; 0x02
    7a30:	e9 83       	std	Y+1, r30	; 0x01
    7a32:	5b 01       	movw	r10, r22
    7a34:	83 e0       	ldi	r24, 0x03	; 3
    7a36:	a8 0e       	add	r10, r24
    7a38:	b1 1c       	adc	r11, r1
    7a3a:	ea 15       	cp	r30, r10
    7a3c:	fb 05       	cpc	r31, r11
    7a3e:	21 f4       	brne	.+8      	; 0x7a48 <prvListTasksWithinSingleList+0x46>
    7a40:	82 81       	ldd	r24, Z+2	; 0x02
    7a42:	93 81       	ldd	r25, Z+3	; 0x03
    7a44:	9a 83       	std	Y+2, r25	; 0x02
    7a46:	89 83       	std	Y+1, r24	; 0x01
    7a48:	04 2f       	mov	r16, r20
    7a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    7a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    7a4e:	86 80       	ldd	r8, Z+6	; 0x06
    7a50:	97 80       	ldd	r9, Z+7	; 0x07
    7a52:	10 e0       	ldi	r17, 0x00	; 0
    7a54:	e9 81       	ldd	r30, Y+1	; 0x01
    7a56:	fa 81       	ldd	r31, Y+2	; 0x02
    7a58:	82 81       	ldd	r24, Z+2	; 0x02
    7a5a:	93 81       	ldd	r25, Z+3	; 0x03
    7a5c:	9a 83       	std	Y+2, r25	; 0x02
    7a5e:	89 83       	std	Y+1, r24	; 0x01
    7a60:	a8 16       	cp	r10, r24
    7a62:	b9 06       	cpc	r11, r25
    7a64:	21 f4       	brne	.+8      	; 0x7a6e <prvListTasksWithinSingleList+0x6c>
    7a66:	8d 81       	ldd	r24, Y+5	; 0x05
    7a68:	9e 81       	ldd	r25, Y+6	; 0x06
    7a6a:	9a 83       	std	Y+2, r25	; 0x02
    7a6c:	89 83       	std	Y+1, r24	; 0x01
    7a6e:	e9 81       	ldd	r30, Y+1	; 0x01
    7a70:	fa 81       	ldd	r31, Y+2	; 0x02
    7a72:	e6 80       	ldd	r14, Z+6	; 0x06
    7a74:	f7 80       	ldd	r15, Z+7	; 0x07
    7a76:	b6 01       	movw	r22, r12
    7a78:	80 e1       	ldi	r24, 0x10	; 16
    7a7a:	18 9f       	mul	r17, r24
    7a7c:	60 0d       	add	r22, r0
    7a7e:	71 1d       	adc	r23, r1
    7a80:	11 24       	eor	r1, r1
    7a82:	20 2f       	mov	r18, r16
    7a84:	41 e0       	ldi	r20, 0x01	; 1
    7a86:	c7 01       	movw	r24, r14
    7a88:	54 df       	rcall	.-344    	; 0x7932 <vTaskGetInfo>
    7a8a:	1f 5f       	subi	r17, 0xFF	; 255
    7a8c:	8e 14       	cp	r8, r14
    7a8e:	9f 04       	cpc	r9, r15
    7a90:	09 f7       	brne	.-62     	; 0x7a54 <prvListTasksWithinSingleList+0x52>
    7a92:	01 c0       	rjmp	.+2      	; 0x7a96 <prvListTasksWithinSingleList+0x94>
    7a94:	10 e0       	ldi	r17, 0x00	; 0
    7a96:	81 2f       	mov	r24, r17
    7a98:	df 91       	pop	r29
    7a9a:	cf 91       	pop	r28
    7a9c:	1f 91       	pop	r17
    7a9e:	0f 91       	pop	r16
    7aa0:	ff 90       	pop	r15
    7aa2:	ef 90       	pop	r14
    7aa4:	df 90       	pop	r13
    7aa6:	cf 90       	pop	r12
    7aa8:	bf 90       	pop	r11
    7aaa:	af 90       	pop	r10
    7aac:	9f 90       	pop	r9
    7aae:	8f 90       	pop	r8
    7ab0:	08 95       	ret

00007ab2 <uxTaskGetSystemState>:
    7ab2:	ef 92       	push	r14
    7ab4:	ff 92       	push	r15
    7ab6:	0f 93       	push	r16
    7ab8:	1f 93       	push	r17
    7aba:	cf 93       	push	r28
    7abc:	df 93       	push	r29
    7abe:	7c 01       	movw	r14, r24
    7ac0:	c6 2f       	mov	r28, r22
    7ac2:	8a 01       	movw	r16, r20
    7ac4:	37 dd       	rcall	.-1426   	; 0x7534 <vTaskSuspendAll>
    7ac6:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    7aca:	c8 17       	cp	r28, r24
    7acc:	08 f4       	brcc	.+2      	; 0x7ad0 <uxTaskGetSystemState+0x1e>
    7ace:	54 c0       	rjmp	.+168    	; 0x7b78 <uxTaskGetSystemState+0xc6>
    7ad0:	d4 e0       	ldi	r29, 0x04	; 4
    7ad2:	c0 e0       	ldi	r28, 0x00	; 0
    7ad4:	d1 50       	subi	r29, 0x01	; 1
    7ad6:	6d 2f       	mov	r22, r29
    7ad8:	70 e0       	ldi	r23, 0x00	; 0
    7ada:	cb 01       	movw	r24, r22
    7adc:	88 0f       	add	r24, r24
    7ade:	99 1f       	adc	r25, r25
    7ae0:	88 0f       	add	r24, r24
    7ae2:	99 1f       	adc	r25, r25
    7ae4:	88 0f       	add	r24, r24
    7ae6:	99 1f       	adc	r25, r25
    7ae8:	68 0f       	add	r22, r24
    7aea:	79 1f       	adc	r23, r25
    7aec:	6e 5d       	subi	r22, 0xDE	; 222
    7aee:	7f 4d       	sbci	r23, 0xDF	; 223
    7af0:	41 e0       	ldi	r20, 0x01	; 1
    7af2:	c7 01       	movw	r24, r14
    7af4:	20 e1       	ldi	r18, 0x10	; 16
    7af6:	c2 9f       	mul	r28, r18
    7af8:	80 0d       	add	r24, r0
    7afa:	91 1d       	adc	r25, r1
    7afc:	11 24       	eor	r1, r1
    7afe:	81 df       	rcall	.-254    	; 0x7a02 <prvListTasksWithinSingleList>
    7b00:	c8 0f       	add	r28, r24
    7b02:	d1 11       	cpse	r29, r1
    7b04:	e7 cf       	rjmp	.-50     	; 0x7ad4 <uxTaskGetSystemState+0x22>
    7b06:	60 91 0e 20 	lds	r22, 0x200E	; 0x80200e <pxDelayedTaskList>
    7b0a:	70 91 0f 20 	lds	r23, 0x200F	; 0x80200f <pxDelayedTaskList+0x1>
    7b0e:	42 e0       	ldi	r20, 0x02	; 2
    7b10:	c7 01       	movw	r24, r14
    7b12:	e0 e1       	ldi	r30, 0x10	; 16
    7b14:	ce 9f       	mul	r28, r30
    7b16:	80 0d       	add	r24, r0
    7b18:	91 1d       	adc	r25, r1
    7b1a:	11 24       	eor	r1, r1
    7b1c:	72 df       	rcall	.-284    	; 0x7a02 <prvListTasksWithinSingleList>
    7b1e:	c8 0f       	add	r28, r24
    7b20:	60 91 0c 20 	lds	r22, 0x200C	; 0x80200c <pxOverflowDelayedTaskList>
    7b24:	70 91 0d 20 	lds	r23, 0x200D	; 0x80200d <pxOverflowDelayedTaskList+0x1>
    7b28:	42 e0       	ldi	r20, 0x02	; 2
    7b2a:	c7 01       	movw	r24, r14
    7b2c:	f0 e1       	ldi	r31, 0x10	; 16
    7b2e:	cf 9f       	mul	r28, r31
    7b30:	80 0d       	add	r24, r0
    7b32:	91 1d       	adc	r25, r1
    7b34:	11 24       	eor	r1, r1
    7b36:	65 df       	rcall	.-310    	; 0x7a02 <prvListTasksWithinSingleList>
    7b38:	c8 0f       	add	r28, r24
    7b3a:	44 e0       	ldi	r20, 0x04	; 4
    7b3c:	6a ef       	ldi	r22, 0xFA	; 250
    7b3e:	7f e1       	ldi	r23, 0x1F	; 31
    7b40:	c7 01       	movw	r24, r14
    7b42:	20 e1       	ldi	r18, 0x10	; 16
    7b44:	c2 9f       	mul	r28, r18
    7b46:	80 0d       	add	r24, r0
    7b48:	91 1d       	adc	r25, r1
    7b4a:	11 24       	eor	r1, r1
    7b4c:	5a df       	rcall	.-332    	; 0x7a02 <prvListTasksWithinSingleList>
    7b4e:	c8 0f       	add	r28, r24
    7b50:	43 e0       	ldi	r20, 0x03	; 3
    7b52:	60 ef       	ldi	r22, 0xF0	; 240
    7b54:	7f e1       	ldi	r23, 0x1F	; 31
    7b56:	c7 01       	movw	r24, r14
    7b58:	e0 e1       	ldi	r30, 0x10	; 16
    7b5a:	ce 9f       	mul	r28, r30
    7b5c:	80 0d       	add	r24, r0
    7b5e:	91 1d       	adc	r25, r1
    7b60:	11 24       	eor	r1, r1
    7b62:	4f df       	rcall	.-354    	; 0x7a02 <prvListTasksWithinSingleList>
    7b64:	c8 0f       	add	r28, r24
    7b66:	01 15       	cp	r16, r1
    7b68:	11 05       	cpc	r17, r1
    7b6a:	39 f0       	breq	.+14     	; 0x7b7a <uxTaskGetSystemState+0xc8>
    7b6c:	f8 01       	movw	r30, r16
    7b6e:	10 82       	st	Z, r1
    7b70:	11 82       	std	Z+1, r1	; 0x01
    7b72:	12 82       	std	Z+2, r1	; 0x02
    7b74:	13 82       	std	Z+3, r1	; 0x03
    7b76:	01 c0       	rjmp	.+2      	; 0x7b7a <uxTaskGetSystemState+0xc8>
    7b78:	c0 e0       	ldi	r28, 0x00	; 0
    7b7a:	99 dd       	rcall	.-1230   	; 0x76ae <xTaskResumeAll>
    7b7c:	8c 2f       	mov	r24, r28
    7b7e:	df 91       	pop	r29
    7b80:	cf 91       	pop	r28
    7b82:	1f 91       	pop	r17
    7b84:	0f 91       	pop	r16
    7b86:	ff 90       	pop	r15
    7b88:	ef 90       	pop	r14
    7b8a:	08 95       	ret

00007b8c <uxTaskGetStackHighWaterMark2>:
    7b8c:	00 97       	sbiw	r24, 0x00	; 0
    7b8e:	21 f4       	brne	.+8      	; 0x7b98 <uxTaskGetStackHighWaterMark2+0xc>
    7b90:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    7b94:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7b98:	dc 01       	movw	r26, r24
    7b9a:	57 96       	adiw	r26, 0x17	; 23
    7b9c:	ed 91       	ld	r30, X+
    7b9e:	fc 91       	ld	r31, X
    7ba0:	58 97       	sbiw	r26, 0x18	; 24
    7ba2:	80 81       	ld	r24, Z
    7ba4:	85 3a       	cpi	r24, 0xA5	; 165
    7ba6:	59 f4       	brne	.+22     	; 0x7bbe <uxTaskGetStackHighWaterMark2+0x32>
    7ba8:	31 96       	adiw	r30, 0x01	; 1
    7baa:	80 e0       	ldi	r24, 0x00	; 0
    7bac:	90 e0       	ldi	r25, 0x00	; 0
    7bae:	dc 01       	movw	r26, r24
    7bb0:	01 96       	adiw	r24, 0x01	; 1
    7bb2:	a1 1d       	adc	r26, r1
    7bb4:	b1 1d       	adc	r27, r1
    7bb6:	21 91       	ld	r18, Z+
    7bb8:	25 3a       	cpi	r18, 0xA5	; 165
    7bba:	d1 f3       	breq	.-12     	; 0x7bb0 <uxTaskGetStackHighWaterMark2+0x24>
    7bbc:	08 95       	ret
    7bbe:	80 e0       	ldi	r24, 0x00	; 0
    7bc0:	90 e0       	ldi	r25, 0x00	; 0
    7bc2:	dc 01       	movw	r26, r24
    7bc4:	08 95       	ret

00007bc6 <xTaskGetSchedulerState>:
    7bc6:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xSchedulerRunning>
    7bca:	88 23       	and	r24, r24
    7bcc:	31 f0       	breq	.+12     	; 0x7bda <xTaskGetSchedulerState+0x14>
    7bce:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
    7bd2:	88 23       	and	r24, r24
    7bd4:	21 f0       	breq	.+8      	; 0x7bde <xTaskGetSchedulerState+0x18>
    7bd6:	80 e0       	ldi	r24, 0x00	; 0
    7bd8:	08 95       	ret
    7bda:	81 e0       	ldi	r24, 0x01	; 1
    7bdc:	08 95       	ret
    7bde:	82 e0       	ldi	r24, 0x02	; 2
    7be0:	08 95       	ret

00007be2 <xTaskPriorityInherit>:
    7be2:	0f 93       	push	r16
    7be4:	1f 93       	push	r17
    7be6:	cf 93       	push	r28
    7be8:	df 93       	push	r29
    7bea:	fc 01       	movw	r30, r24
    7bec:	89 2b       	or	r24, r25
    7bee:	09 f4       	brne	.+2      	; 0x7bf2 <xTaskPriorityInherit+0x10>
    7bf0:	64 c0       	rjmp	.+200    	; 0x7cba <xTaskPriorityInherit+0xd8>
    7bf2:	26 89       	ldd	r18, Z+22	; 0x16
    7bf4:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    7bf8:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7bfc:	56 96       	adiw	r26, 0x16	; 22
    7bfe:	8c 91       	ld	r24, X
    7c00:	28 17       	cp	r18, r24
    7c02:	08 f0       	brcs	.+2      	; 0x7c06 <xTaskPriorityInherit+0x24>
    7c04:	4e c0       	rjmp	.+156    	; 0x7ca2 <xTaskPriorityInherit+0xc0>
    7c06:	84 85       	ldd	r24, Z+12	; 0x0c
    7c08:	95 85       	ldd	r25, Z+13	; 0x0d
    7c0a:	99 23       	and	r25, r25
    7c0c:	64 f0       	brlt	.+24     	; 0x7c26 <xTaskPriorityInherit+0x44>
    7c0e:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    7c12:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7c16:	56 96       	adiw	r26, 0x16	; 22
    7c18:	3c 91       	ld	r19, X
    7c1a:	84 e0       	ldi	r24, 0x04	; 4
    7c1c:	90 e0       	ldi	r25, 0x00	; 0
    7c1e:	83 1b       	sub	r24, r19
    7c20:	91 09       	sbc	r25, r1
    7c22:	95 87       	std	Z+13, r25	; 0x0d
    7c24:	84 87       	std	Z+12, r24	; 0x0c
    7c26:	30 e0       	ldi	r19, 0x00	; 0
    7c28:	c9 01       	movw	r24, r18
    7c2a:	88 0f       	add	r24, r24
    7c2c:	99 1f       	adc	r25, r25
    7c2e:	88 0f       	add	r24, r24
    7c30:	99 1f       	adc	r25, r25
    7c32:	88 0f       	add	r24, r24
    7c34:	99 1f       	adc	r25, r25
    7c36:	28 0f       	add	r18, r24
    7c38:	39 1f       	adc	r19, r25
    7c3a:	2e 5d       	subi	r18, 0xDE	; 222
    7c3c:	3f 4d       	sbci	r19, 0xDF	; 223
    7c3e:	82 85       	ldd	r24, Z+10	; 0x0a
    7c40:	93 85       	ldd	r25, Z+11	; 0x0b
    7c42:	82 17       	cp	r24, r18
    7c44:	93 07       	cpc	r25, r19
    7c46:	21 f5       	brne	.+72     	; 0x7c90 <xTaskPriorityInherit+0xae>
    7c48:	8f 01       	movw	r16, r30
    7c4a:	ef 01       	movw	r28, r30
    7c4c:	22 96       	adiw	r28, 0x02	; 2
    7c4e:	ce 01       	movw	r24, r28
    7c50:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7c54:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7c58:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7c5c:	86 89       	ldd	r24, Z+22	; 0x16
    7c5e:	f8 01       	movw	r30, r16
    7c60:	86 8b       	std	Z+22, r24	; 0x16
    7c62:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7c66:	98 17       	cp	r25, r24
    7c68:	10 f4       	brcc	.+4      	; 0x7c6e <xTaskPriorityInherit+0x8c>
    7c6a:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    7c6e:	90 e0       	ldi	r25, 0x00	; 0
    7c70:	9c 01       	movw	r18, r24
    7c72:	22 0f       	add	r18, r18
    7c74:	33 1f       	adc	r19, r19
    7c76:	22 0f       	add	r18, r18
    7c78:	33 1f       	adc	r19, r19
    7c7a:	22 0f       	add	r18, r18
    7c7c:	33 1f       	adc	r19, r19
    7c7e:	82 0f       	add	r24, r18
    7c80:	93 1f       	adc	r25, r19
    7c82:	be 01       	movw	r22, r28
    7c84:	8e 5d       	subi	r24, 0xDE	; 222
    7c86:	9f 4d       	sbci	r25, 0xDF	; 223
    7c88:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    7c8c:	81 e0       	ldi	r24, 0x01	; 1
    7c8e:	16 c0       	rjmp	.+44     	; 0x7cbc <xTaskPriorityInherit+0xda>
    7c90:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    7c94:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7c98:	56 96       	adiw	r26, 0x16	; 22
    7c9a:	8c 91       	ld	r24, X
    7c9c:	86 8b       	std	Z+22, r24	; 0x16
    7c9e:	81 e0       	ldi	r24, 0x01	; 1
    7ca0:	0d c0       	rjmp	.+26     	; 0x7cbc <xTaskPriorityInherit+0xda>
    7ca2:	a0 91 46 20 	lds	r26, 0x2046	; 0x802046 <pxCurrentTCB>
    7ca6:	b0 91 47 20 	lds	r27, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7caa:	81 e0       	ldi	r24, 0x01	; 1
    7cac:	23 a5       	ldd	r18, Z+43	; 0x2b
    7cae:	56 96       	adiw	r26, 0x16	; 22
    7cb0:	9c 91       	ld	r25, X
    7cb2:	29 17       	cp	r18, r25
    7cb4:	18 f0       	brcs	.+6      	; 0x7cbc <xTaskPriorityInherit+0xda>
    7cb6:	80 e0       	ldi	r24, 0x00	; 0
    7cb8:	01 c0       	rjmp	.+2      	; 0x7cbc <xTaskPriorityInherit+0xda>
    7cba:	80 e0       	ldi	r24, 0x00	; 0
    7cbc:	df 91       	pop	r29
    7cbe:	cf 91       	pop	r28
    7cc0:	1f 91       	pop	r17
    7cc2:	0f 91       	pop	r16
    7cc4:	08 95       	ret

00007cc6 <xTaskPriorityDisinherit>:
    7cc6:	0f 93       	push	r16
    7cc8:	1f 93       	push	r17
    7cca:	cf 93       	push	r28
    7ccc:	df 93       	push	r29
    7cce:	fc 01       	movw	r30, r24
    7cd0:	89 2b       	or	r24, r25
    7cd2:	79 f1       	breq	.+94     	; 0x7d32 <xTaskPriorityDisinherit+0x6c>
    7cd4:	84 a5       	ldd	r24, Z+44	; 0x2c
    7cd6:	81 50       	subi	r24, 0x01	; 1
    7cd8:	84 a7       	std	Z+44, r24	; 0x2c
    7cda:	26 89       	ldd	r18, Z+22	; 0x16
    7cdc:	93 a5       	ldd	r25, Z+43	; 0x2b
    7cde:	29 17       	cp	r18, r25
    7ce0:	51 f1       	breq	.+84     	; 0x7d36 <xTaskPriorityDisinherit+0x70>
    7ce2:	81 11       	cpse	r24, r1
    7ce4:	2a c0       	rjmp	.+84     	; 0x7d3a <xTaskPriorityDisinherit+0x74>
    7ce6:	ef 01       	movw	r28, r30
    7ce8:	8f 01       	movw	r16, r30
    7cea:	0e 5f       	subi	r16, 0xFE	; 254
    7cec:	1f 4f       	sbci	r17, 0xFF	; 255
    7cee:	c8 01       	movw	r24, r16
    7cf0:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7cf4:	8b a5       	ldd	r24, Y+43	; 0x2b
    7cf6:	8e 8b       	std	Y+22, r24	; 0x16
    7cf8:	24 e0       	ldi	r18, 0x04	; 4
    7cfa:	30 e0       	ldi	r19, 0x00	; 0
    7cfc:	28 1b       	sub	r18, r24
    7cfe:	31 09       	sbc	r19, r1
    7d00:	3d 87       	std	Y+13, r19	; 0x0d
    7d02:	2c 87       	std	Y+12, r18	; 0x0c
    7d04:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7d08:	98 17       	cp	r25, r24
    7d0a:	10 f4       	brcc	.+4      	; 0x7d10 <xTaskPriorityDisinherit+0x4a>
    7d0c:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    7d10:	90 e0       	ldi	r25, 0x00	; 0
    7d12:	9c 01       	movw	r18, r24
    7d14:	22 0f       	add	r18, r18
    7d16:	33 1f       	adc	r19, r19
    7d18:	22 0f       	add	r18, r18
    7d1a:	33 1f       	adc	r19, r19
    7d1c:	22 0f       	add	r18, r18
    7d1e:	33 1f       	adc	r19, r19
    7d20:	82 0f       	add	r24, r18
    7d22:	93 1f       	adc	r25, r19
    7d24:	b8 01       	movw	r22, r16
    7d26:	8e 5d       	subi	r24, 0xDE	; 222
    7d28:	9f 4d       	sbci	r25, 0xDF	; 223
    7d2a:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    7d2e:	81 e0       	ldi	r24, 0x01	; 1
    7d30:	05 c0       	rjmp	.+10     	; 0x7d3c <xTaskPriorityDisinherit+0x76>
    7d32:	80 e0       	ldi	r24, 0x00	; 0
    7d34:	03 c0       	rjmp	.+6      	; 0x7d3c <xTaskPriorityDisinherit+0x76>
    7d36:	80 e0       	ldi	r24, 0x00	; 0
    7d38:	01 c0       	rjmp	.+2      	; 0x7d3c <xTaskPriorityDisinherit+0x76>
    7d3a:	80 e0       	ldi	r24, 0x00	; 0
    7d3c:	df 91       	pop	r29
    7d3e:	cf 91       	pop	r28
    7d40:	1f 91       	pop	r17
    7d42:	0f 91       	pop	r16
    7d44:	08 95       	ret

00007d46 <vTaskPriorityDisinheritAfterTimeout>:
    7d46:	0f 93       	push	r16
    7d48:	1f 93       	push	r17
    7d4a:	cf 93       	push	r28
    7d4c:	df 93       	push	r29
    7d4e:	fc 01       	movw	r30, r24
    7d50:	89 2b       	or	r24, r25
    7d52:	09 f4       	brne	.+2      	; 0x7d56 <vTaskPriorityDisinheritAfterTimeout+0x10>
    7d54:	43 c0       	rjmp	.+134    	; 0x7ddc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7d56:	93 a5       	ldd	r25, Z+43	; 0x2b
    7d58:	96 17       	cp	r25, r22
    7d5a:	08 f4       	brcc	.+2      	; 0x7d5e <vTaskPriorityDisinheritAfterTimeout+0x18>
    7d5c:	96 2f       	mov	r25, r22
    7d5e:	86 89       	ldd	r24, Z+22	; 0x16
    7d60:	89 17       	cp	r24, r25
    7d62:	e1 f1       	breq	.+120    	; 0x7ddc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7d64:	24 a5       	ldd	r18, Z+44	; 0x2c
    7d66:	21 30       	cpi	r18, 0x01	; 1
    7d68:	c9 f5       	brne	.+114    	; 0x7ddc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7d6a:	96 8b       	std	Z+22, r25	; 0x16
    7d6c:	24 85       	ldd	r18, Z+12	; 0x0c
    7d6e:	35 85       	ldd	r19, Z+13	; 0x0d
    7d70:	33 23       	and	r19, r19
    7d72:	34 f0       	brlt	.+12     	; 0x7d80 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    7d74:	24 e0       	ldi	r18, 0x04	; 4
    7d76:	30 e0       	ldi	r19, 0x00	; 0
    7d78:	29 1b       	sub	r18, r25
    7d7a:	31 09       	sbc	r19, r1
    7d7c:	35 87       	std	Z+13, r19	; 0x0d
    7d7e:	24 87       	std	Z+12, r18	; 0x0c
    7d80:	90 e0       	ldi	r25, 0x00	; 0
    7d82:	9c 01       	movw	r18, r24
    7d84:	22 0f       	add	r18, r18
    7d86:	33 1f       	adc	r19, r19
    7d88:	22 0f       	add	r18, r18
    7d8a:	33 1f       	adc	r19, r19
    7d8c:	22 0f       	add	r18, r18
    7d8e:	33 1f       	adc	r19, r19
    7d90:	82 0f       	add	r24, r18
    7d92:	93 1f       	adc	r25, r19
    7d94:	8e 5d       	subi	r24, 0xDE	; 222
    7d96:	9f 4d       	sbci	r25, 0xDF	; 223
    7d98:	22 85       	ldd	r18, Z+10	; 0x0a
    7d9a:	33 85       	ldd	r19, Z+11	; 0x0b
    7d9c:	28 17       	cp	r18, r24
    7d9e:	39 07       	cpc	r19, r25
    7da0:	e9 f4       	brne	.+58     	; 0x7ddc <vTaskPriorityDisinheritAfterTimeout+0x96>
    7da2:	ef 01       	movw	r28, r30
    7da4:	8f 01       	movw	r16, r30
    7da6:	0e 5f       	subi	r16, 0xFE	; 254
    7da8:	1f 4f       	sbci	r17, 0xFF	; 255
    7daa:	c8 01       	movw	r24, r16
    7dac:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
    7db0:	8e 89       	ldd	r24, Y+22	; 0x16
    7db2:	90 91 ec 1f 	lds	r25, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    7db6:	98 17       	cp	r25, r24
    7db8:	10 f4       	brcc	.+4      	; 0x7dbe <vTaskPriorityDisinheritAfterTimeout+0x78>
    7dba:	80 93 ec 1f 	sts	0x1FEC, r24	; 0x801fec <uxTopReadyPriority>
    7dbe:	90 e0       	ldi	r25, 0x00	; 0
    7dc0:	9c 01       	movw	r18, r24
    7dc2:	22 0f       	add	r18, r18
    7dc4:	33 1f       	adc	r19, r19
    7dc6:	22 0f       	add	r18, r18
    7dc8:	33 1f       	adc	r19, r19
    7dca:	22 0f       	add	r18, r18
    7dcc:	33 1f       	adc	r19, r19
    7dce:	82 0f       	add	r24, r18
    7dd0:	93 1f       	adc	r25, r19
    7dd2:	b8 01       	movw	r22, r16
    7dd4:	8e 5d       	subi	r24, 0xDE	; 222
    7dd6:	9f 4d       	sbci	r25, 0xDF	; 223
    7dd8:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>
    7ddc:	df 91       	pop	r29
    7dde:	cf 91       	pop	r28
    7de0:	1f 91       	pop	r17
    7de2:	0f 91       	pop	r16
    7de4:	08 95       	ret

00007de6 <vTaskList>:
    7de6:	3f 92       	push	r3
    7de8:	4f 92       	push	r4
    7dea:	5f 92       	push	r5
    7dec:	6f 92       	push	r6
    7dee:	7f 92       	push	r7
    7df0:	8f 92       	push	r8
    7df2:	9f 92       	push	r9
    7df4:	af 92       	push	r10
    7df6:	bf 92       	push	r11
    7df8:	cf 92       	push	r12
    7dfa:	df 92       	push	r13
    7dfc:	ef 92       	push	r14
    7dfe:	ff 92       	push	r15
    7e00:	0f 93       	push	r16
    7e02:	1f 93       	push	r17
    7e04:	cf 93       	push	r28
    7e06:	df 93       	push	r29
    7e08:	ec 01       	movw	r28, r24
    7e0a:	18 82       	st	Y, r1
    7e0c:	10 91 ef 1f 	lds	r17, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    7e10:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    7e14:	20 e1       	ldi	r18, 0x10	; 16
    7e16:	82 9f       	mul	r24, r18
    7e18:	c0 01       	movw	r24, r0
    7e1a:	11 24       	eor	r1, r1
    7e1c:	0e 94 df 31 	call	0x63be	; 0x63be <pvPortMalloc>
    7e20:	6c 01       	movw	r12, r24
    7e22:	00 97       	sbiw	r24, 0x00	; 0
    7e24:	09 f4       	brne	.+2      	; 0x7e28 <vTaskList+0x42>
    7e26:	85 c0       	rjmp	.+266    	; 0x7f32 <vTaskList+0x14c>
    7e28:	40 e0       	ldi	r20, 0x00	; 0
    7e2a:	50 e0       	ldi	r21, 0x00	; 0
    7e2c:	61 2f       	mov	r22, r17
    7e2e:	41 de       	rcall	.-894    	; 0x7ab2 <uxTaskGetSystemState>
    7e30:	68 2e       	mov	r6, r24
    7e32:	88 23       	and	r24, r24
    7e34:	09 f4       	brne	.+2      	; 0x7e38 <vTaskList+0x52>
    7e36:	7a c0       	rjmp	.+244    	; 0x7f2c <vTaskList+0x146>
    7e38:	86 01       	movw	r16, r12
    7e3a:	81 2c       	mov	r8, r1
    7e3c:	31 2c       	mov	r3, r1
    7e3e:	68 94       	set
    7e40:	99 24       	eor	r9, r9
    7e42:	95 f8       	bld	r9, 5
    7e44:	0f 2e       	mov	r0, r31
    7e46:	ff e0       	ldi	r31, 0x0F	; 15
    7e48:	4f 2e       	mov	r4, r31
    7e4a:	f0 2d       	mov	r31, r0
    7e4c:	51 2c       	mov	r5, r1
    7e4e:	0f 2e       	mov	r0, r31
    7e50:	fa ee       	ldi	r31, 0xEA	; 234
    7e52:	ef 2e       	mov	r14, r31
    7e54:	f2 e0       	ldi	r31, 0x02	; 2
    7e56:	ff 2e       	mov	r15, r31
    7e58:	f0 2d       	mov	r31, r0
    7e5a:	58 01       	movw	r10, r16
    7e5c:	f8 01       	movw	r30, r16
    7e5e:	85 81       	ldd	r24, Z+5	; 0x05
    7e60:	82 30       	cpi	r24, 0x02	; 2
    7e62:	81 f0       	breq	.+32     	; 0x7e84 <vTaskList+0x9e>
    7e64:	28 f4       	brcc	.+10     	; 0x7e70 <vTaskList+0x8a>
    7e66:	88 23       	and	r24, r24
    7e68:	f1 f0       	breq	.+60     	; 0x7ea6 <vTaskList+0xc0>
    7e6a:	81 30       	cpi	r24, 0x01	; 1
    7e6c:	31 f0       	breq	.+12     	; 0x7e7a <vTaskList+0x94>
    7e6e:	19 c0       	rjmp	.+50     	; 0x7ea2 <vTaskList+0xbc>
    7e70:	83 30       	cpi	r24, 0x03	; 3
    7e72:	69 f0       	breq	.+26     	; 0x7e8e <vTaskList+0xa8>
    7e74:	84 30       	cpi	r24, 0x04	; 4
    7e76:	81 f0       	breq	.+32     	; 0x7e98 <vTaskList+0xb2>
    7e78:	14 c0       	rjmp	.+40     	; 0x7ea2 <vTaskList+0xbc>
    7e7a:	0f 2e       	mov	r0, r31
    7e7c:	f2 e5       	ldi	r31, 0x52	; 82
    7e7e:	7f 2e       	mov	r7, r31
    7e80:	f0 2d       	mov	r31, r0
    7e82:	15 c0       	rjmp	.+42     	; 0x7eae <vTaskList+0xc8>
    7e84:	0f 2e       	mov	r0, r31
    7e86:	f2 e4       	ldi	r31, 0x42	; 66
    7e88:	7f 2e       	mov	r7, r31
    7e8a:	f0 2d       	mov	r31, r0
    7e8c:	10 c0       	rjmp	.+32     	; 0x7eae <vTaskList+0xc8>
    7e8e:	0f 2e       	mov	r0, r31
    7e90:	f3 e5       	ldi	r31, 0x53	; 83
    7e92:	7f 2e       	mov	r7, r31
    7e94:	f0 2d       	mov	r31, r0
    7e96:	0b c0       	rjmp	.+22     	; 0x7eae <vTaskList+0xc8>
    7e98:	0f 2e       	mov	r0, r31
    7e9a:	f4 e4       	ldi	r31, 0x44	; 68
    7e9c:	7f 2e       	mov	r7, r31
    7e9e:	f0 2d       	mov	r31, r0
    7ea0:	06 c0       	rjmp	.+12     	; 0x7eae <vTaskList+0xc8>
    7ea2:	73 2c       	mov	r7, r3
    7ea4:	04 c0       	rjmp	.+8      	; 0x7eae <vTaskList+0xc8>
    7ea6:	0f 2e       	mov	r0, r31
    7ea8:	f8 e5       	ldi	r31, 0x58	; 88
    7eaa:	7f 2e       	mov	r7, r31
    7eac:	f0 2d       	mov	r31, r0
    7eae:	f5 01       	movw	r30, r10
    7eb0:	62 81       	ldd	r22, Z+2	; 0x02
    7eb2:	73 81       	ldd	r23, Z+3	; 0x03
    7eb4:	ce 01       	movw	r24, r28
    7eb6:	55 d5       	rcall	.+2730   	; 0x8962 <strcpy>
    7eb8:	fe 01       	movw	r30, r28
    7eba:	01 90       	ld	r0, Z+
    7ebc:	00 20       	and	r0, r0
    7ebe:	e9 f7       	brne	.-6      	; 0x7eba <vTaskList+0xd4>
    7ec0:	31 97       	sbiw	r30, 0x01	; 1
    7ec2:	ec 1b       	sub	r30, r28
    7ec4:	fd 0b       	sbc	r31, r29
    7ec6:	ef 30       	cpi	r30, 0x0F	; 15
    7ec8:	f1 05       	cpc	r31, r1
    7eca:	50 f4       	brcc	.+20     	; 0x7ee0 <vTaskList+0xfa>
    7ecc:	ec 0f       	add	r30, r28
    7ece:	fd 1f       	adc	r31, r29
    7ed0:	ce 01       	movw	r24, r28
    7ed2:	0f 96       	adiw	r24, 0x0f	; 15
    7ed4:	91 92       	st	Z+, r9
    7ed6:	e8 17       	cp	r30, r24
    7ed8:	f9 07       	cpc	r31, r25
    7eda:	e1 f7       	brne	.-8      	; 0x7ed4 <vTaskList+0xee>
    7edc:	e4 2d       	mov	r30, r4
    7ede:	f5 2d       	mov	r31, r5
    7ee0:	ce 0f       	add	r28, r30
    7ee2:	df 1f       	adc	r29, r31
    7ee4:	18 82       	st	Y, r1
    7ee6:	f5 01       	movw	r30, r10
    7ee8:	84 81       	ldd	r24, Z+4	; 0x04
    7eea:	1f 92       	push	r1
    7eec:	8f 93       	push	r24
    7eee:	87 85       	ldd	r24, Z+15	; 0x0f
    7ef0:	8f 93       	push	r24
    7ef2:	86 85       	ldd	r24, Z+14	; 0x0e
    7ef4:	8f 93       	push	r24
    7ef6:	86 81       	ldd	r24, Z+6	; 0x06
    7ef8:	1f 92       	push	r1
    7efa:	8f 93       	push	r24
    7efc:	1f 92       	push	r1
    7efe:	7f 92       	push	r7
    7f00:	ff 92       	push	r15
    7f02:	ef 92       	push	r14
    7f04:	df 93       	push	r29
    7f06:	cf 93       	push	r28
    7f08:	4b d6       	rcall	.+3222   	; 0x8ba0 <sprintf>
    7f0a:	09 90       	ld	r0, Y+
    7f0c:	00 20       	and	r0, r0
    7f0e:	e9 f7       	brne	.-6      	; 0x7f0a <vTaskList+0x124>
    7f10:	21 97       	sbiw	r28, 0x01	; 1
    7f12:	83 94       	inc	r8
    7f14:	00 5f       	subi	r16, 0xF0	; 240
    7f16:	1f 4f       	sbci	r17, 0xFF	; 255
    7f18:	8d b7       	in	r24, 0x3d	; 61
    7f1a:	9e b7       	in	r25, 0x3e	; 62
    7f1c:	0c 96       	adiw	r24, 0x0c	; 12
    7f1e:	0f b6       	in	r0, 0x3f	; 63
    7f20:	f8 94       	cli
    7f22:	9e bf       	out	0x3e, r25	; 62
    7f24:	0f be       	out	0x3f, r0	; 63
    7f26:	8d bf       	out	0x3d, r24	; 61
    7f28:	68 10       	cpse	r6, r8
    7f2a:	97 cf       	rjmp	.-210    	; 0x7e5a <vTaskList+0x74>
    7f2c:	c6 01       	movw	r24, r12
    7f2e:	0e 94 9f 31 	call	0x633e	; 0x633e <vPortFree>
    7f32:	df 91       	pop	r29
    7f34:	cf 91       	pop	r28
    7f36:	1f 91       	pop	r17
    7f38:	0f 91       	pop	r16
    7f3a:	ff 90       	pop	r15
    7f3c:	ef 90       	pop	r14
    7f3e:	df 90       	pop	r13
    7f40:	cf 90       	pop	r12
    7f42:	bf 90       	pop	r11
    7f44:	af 90       	pop	r10
    7f46:	9f 90       	pop	r9
    7f48:	8f 90       	pop	r8
    7f4a:	7f 90       	pop	r7
    7f4c:	6f 90       	pop	r6
    7f4e:	5f 90       	pop	r5
    7f50:	4f 90       	pop	r4
    7f52:	3f 90       	pop	r3
    7f54:	08 95       	ret

00007f56 <pvTaskIncrementMutexHeldCount>:
    7f56:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    7f5a:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7f5e:	89 2b       	or	r24, r25
    7f60:	39 f0       	breq	.+14     	; 0x7f70 <pvTaskIncrementMutexHeldCount+0x1a>
    7f62:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7f66:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7f6a:	84 a5       	ldd	r24, Z+44	; 0x2c
    7f6c:	8f 5f       	subi	r24, 0xFF	; 255
    7f6e:	84 a7       	std	Z+44, r24	; 0x2c
    7f70:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    7f74:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7f78:	08 95       	ret

00007f7a <vApplicationStackOverflowHook>:
	#endif

#endif

extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
	printf("ov %s",pcTaskName);
    7f7a:	7f 93       	push	r23
    7f7c:	6f 93       	push	r22
    7f7e:	89 ef       	ldi	r24, 0xF9	; 249
    7f80:	92 e0       	ldi	r25, 0x02	; 2
    7f82:	9f 93       	push	r25
    7f84:	8f 93       	push	r24
    7f86:	66 d5       	rcall	.+2764   	; 0x8a54 <printf>
	FORCERESET
    7f88:	d5 da       	rcall	.-2646   	; 0x7534 <vTaskSuspendAll>
    7f8a:	89 ed       	ldi	r24, 0xD9	; 217
    7f8c:	92 e0       	ldi	r25, 0x02	; 2
    7f8e:	9c d5       	rcall	.+2872   	; 0x8ac8 <puts>
    7f90:	0f 90       	pop	r0
    7f92:	0f 90       	pop	r0
    7f94:	0f 90       	pop	r0
    7f96:	0f 90       	pop	r0
    7f98:	ff cf       	rjmp	.-2      	; 0x7f98 <vApplicationStackOverflowHook+0x1e>

00007f9a <vTaskSwitchContext>:
    7f9a:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <uxSchedulerSuspended>
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    7f9e:	88 23       	and	r24, r24
    7fa0:	21 f0       	breq	.+8      	; 0x7faa <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    7fa2:	81 e0       	ldi	r24, 0x01	; 1
    7fa4:	80 93 e9 1f 	sts	0x1FE9, r24	; 0x801fe9 <xYieldPending>
    7fa8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    7faa:	10 92 e9 1f 	sts	0x1FE9, r1	; 0x801fe9 <xYieldPending>
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    7fae:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <pxCurrentTCB>
    7fb2:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    7fb6:	07 88       	ldd	r0, Z+23	; 0x17
    7fb8:	f0 8d       	ldd	r31, Z+24	; 0x18
    7fba:	e0 2d       	mov	r30, r0
    7fbc:	80 81       	ld	r24, Z
    7fbe:	91 81       	ldd	r25, Z+1	; 0x01
    7fc0:	a2 81       	ldd	r26, Z+2	; 0x02
    7fc2:	b3 81       	ldd	r27, Z+3	; 0x03
    7fc4:	85 3a       	cpi	r24, 0xA5	; 165
    7fc6:	95 4a       	sbci	r25, 0xA5	; 165
    7fc8:	a5 4a       	sbci	r26, 0xA5	; 165
    7fca:	b5 4a       	sbci	r27, 0xA5	; 165
    7fcc:	d9 f4       	brne	.+54     	; 0x8004 <vTaskSwitchContext+0x6a>
    7fce:	84 81       	ldd	r24, Z+4	; 0x04
    7fd0:	95 81       	ldd	r25, Z+5	; 0x05
    7fd2:	a6 81       	ldd	r26, Z+6	; 0x06
    7fd4:	b7 81       	ldd	r27, Z+7	; 0x07
    7fd6:	85 3a       	cpi	r24, 0xA5	; 165
    7fd8:	95 4a       	sbci	r25, 0xA5	; 165
    7fda:	a5 4a       	sbci	r26, 0xA5	; 165
    7fdc:	b5 4a       	sbci	r27, 0xA5	; 165
    7fde:	91 f4       	brne	.+36     	; 0x8004 <vTaskSwitchContext+0x6a>
    7fe0:	80 85       	ldd	r24, Z+8	; 0x08
    7fe2:	91 85       	ldd	r25, Z+9	; 0x09
    7fe4:	a2 85       	ldd	r26, Z+10	; 0x0a
    7fe6:	b3 85       	ldd	r27, Z+11	; 0x0b
    7fe8:	85 3a       	cpi	r24, 0xA5	; 165
    7fea:	95 4a       	sbci	r25, 0xA5	; 165
    7fec:	a5 4a       	sbci	r26, 0xA5	; 165
    7fee:	b5 4a       	sbci	r27, 0xA5	; 165
    7ff0:	49 f4       	brne	.+18     	; 0x8004 <vTaskSwitchContext+0x6a>
    7ff2:	84 85       	ldd	r24, Z+12	; 0x0c
    7ff4:	95 85       	ldd	r25, Z+13	; 0x0d
    7ff6:	a6 85       	ldd	r26, Z+14	; 0x0e
    7ff8:	b7 85       	ldd	r27, Z+15	; 0x0f
    7ffa:	85 3a       	cpi	r24, 0xA5	; 165
    7ffc:	95 4a       	sbci	r25, 0xA5	; 165
    7ffe:	a5 4a       	sbci	r26, 0xA5	; 165
    8000:	b5 4a       	sbci	r27, 0xA5	; 165
    8002:	59 f0       	breq	.+22     	; 0x801a <vTaskSwitchContext+0x80>
    8004:	60 91 46 20 	lds	r22, 0x2046	; 0x802046 <pxCurrentTCB>
    8008:	70 91 47 20 	lds	r23, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    800c:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    8010:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    8014:	67 5e       	subi	r22, 0xE7	; 231
    8016:	7f 4f       	sbci	r23, 0xFF	; 255
    8018:	b0 df       	rcall	.-160    	; 0x7f7a <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    801a:	20 91 ec 1f 	lds	r18, 0x1FEC	; 0x801fec <uxTopReadyPriority>
    801e:	82 2f       	mov	r24, r18
    8020:	90 e0       	ldi	r25, 0x00	; 0
    8022:	fc 01       	movw	r30, r24
    8024:	ee 0f       	add	r30, r30
    8026:	ff 1f       	adc	r31, r31
    8028:	ee 0f       	add	r30, r30
    802a:	ff 1f       	adc	r31, r31
    802c:	ee 0f       	add	r30, r30
    802e:	ff 1f       	adc	r31, r31
    8030:	e8 0f       	add	r30, r24
    8032:	f9 1f       	adc	r31, r25
    8034:	ee 5d       	subi	r30, 0xDE	; 222
    8036:	ff 4d       	sbci	r31, 0xDF	; 223
    8038:	30 81       	ld	r19, Z
    803a:	31 11       	cpse	r19, r1
    803c:	11 c0       	rjmp	.+34     	; 0x8060 <vTaskSwitchContext+0xc6>
    803e:	21 50       	subi	r18, 0x01	; 1
    8040:	82 2f       	mov	r24, r18
    8042:	90 e0       	ldi	r25, 0x00	; 0
    8044:	fc 01       	movw	r30, r24
    8046:	ee 0f       	add	r30, r30
    8048:	ff 1f       	adc	r31, r31
    804a:	ee 0f       	add	r30, r30
    804c:	ff 1f       	adc	r31, r31
    804e:	ee 0f       	add	r30, r30
    8050:	ff 1f       	adc	r31, r31
    8052:	e8 0f       	add	r30, r24
    8054:	f9 1f       	adc	r31, r25
    8056:	ee 5d       	subi	r30, 0xDE	; 222
    8058:	ff 4d       	sbci	r31, 0xDF	; 223
    805a:	30 81       	ld	r19, Z
    805c:	33 23       	and	r19, r19
    805e:	79 f3       	breq	.-34     	; 0x803e <vTaskSwitchContext+0xa4>
    8060:	ac 01       	movw	r20, r24
    8062:	44 0f       	add	r20, r20
    8064:	55 1f       	adc	r21, r21
    8066:	44 0f       	add	r20, r20
    8068:	55 1f       	adc	r21, r21
    806a:	44 0f       	add	r20, r20
    806c:	55 1f       	adc	r21, r21
    806e:	48 0f       	add	r20, r24
    8070:	59 1f       	adc	r21, r25
    8072:	da 01       	movw	r26, r20
    8074:	ae 5d       	subi	r26, 0xDE	; 222
    8076:	bf 4d       	sbci	r27, 0xDF	; 223
    8078:	11 96       	adiw	r26, 0x01	; 1
    807a:	ed 91       	ld	r30, X+
    807c:	fc 91       	ld	r31, X
    807e:	12 97       	sbiw	r26, 0x02	; 2
    8080:	02 80       	ldd	r0, Z+2	; 0x02
    8082:	f3 81       	ldd	r31, Z+3	; 0x03
    8084:	e0 2d       	mov	r30, r0
    8086:	12 96       	adiw	r26, 0x02	; 2
    8088:	fc 93       	st	X, r31
    808a:	ee 93       	st	-X, r30
    808c:	11 97       	sbiw	r26, 0x01	; 1
    808e:	4b 5d       	subi	r20, 0xDB	; 219
    8090:	5f 4d       	sbci	r21, 0xDF	; 223
    8092:	e4 17       	cp	r30, r20
    8094:	f5 07       	cpc	r31, r21
    8096:	29 f4       	brne	.+10     	; 0x80a2 <vTaskSwitchContext+0x108>
    8098:	42 81       	ldd	r20, Z+2	; 0x02
    809a:	53 81       	ldd	r21, Z+3	; 0x03
    809c:	fd 01       	movw	r30, r26
    809e:	52 83       	std	Z+2, r21	; 0x02
    80a0:	41 83       	std	Z+1, r20	; 0x01
    80a2:	fc 01       	movw	r30, r24
    80a4:	ee 0f       	add	r30, r30
    80a6:	ff 1f       	adc	r31, r31
    80a8:	ee 0f       	add	r30, r30
    80aa:	ff 1f       	adc	r31, r31
    80ac:	ee 0f       	add	r30, r30
    80ae:	ff 1f       	adc	r31, r31
    80b0:	8e 0f       	add	r24, r30
    80b2:	9f 1f       	adc	r25, r31
    80b4:	fc 01       	movw	r30, r24
    80b6:	ee 5d       	subi	r30, 0xDE	; 222
    80b8:	ff 4d       	sbci	r31, 0xDF	; 223
    80ba:	01 80       	ldd	r0, Z+1	; 0x01
    80bc:	f2 81       	ldd	r31, Z+2	; 0x02
    80be:	e0 2d       	mov	r30, r0
    80c0:	86 81       	ldd	r24, Z+6	; 0x06
    80c2:	97 81       	ldd	r25, Z+7	; 0x07
    80c4:	90 93 47 20 	sts	0x2047, r25	; 0x802047 <pxCurrentTCB+0x1>
    80c8:	80 93 46 20 	sts	0x2046, r24	; 0x802046 <pxCurrentTCB>
    80cc:	20 93 ec 1f 	sts	0x1FEC, r18	; 0x801fec <uxTopReadyPriority>
    80d0:	08 95       	ret

000080d2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    80d2:	0f 93       	push	r16
    80d4:	1f 93       	push	r17
    80d6:	cf 93       	push	r28
    80d8:	df 93       	push	r29
    80da:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    80dc:	0f b6       	in	r0, 0x3f	; 63
    80de:	f8 94       	cli
    80e0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    80e2:	89 2b       	or	r24, r25
    80e4:	21 f4       	brne	.+8      	; 0x80ee <vTaskSuspend+0x1c>
    80e6:	c0 91 46 20 	lds	r28, 0x2046	; 0x802046 <pxCurrentTCB>
    80ea:	d0 91 47 20 	lds	r29, 0x2047	; 0x802047 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80ee:	8e 01       	movw	r16, r28
    80f0:	0e 5f       	subi	r16, 0xFE	; 254
    80f2:	1f 4f       	sbci	r17, 0xFF	; 255
    80f4:	c8 01       	movw	r24, r16
    80f6:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    80fa:	8c 89       	ldd	r24, Y+20	; 0x14
    80fc:	9d 89       	ldd	r25, Y+21	; 0x15
    80fe:	89 2b       	or	r24, r25
    8100:	21 f0       	breq	.+8      	; 0x810a <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    8102:	ce 01       	movw	r24, r28
    8104:	0c 96       	adiw	r24, 0x0c	; 12
    8106:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    810a:	b8 01       	movw	r22, r16
    810c:	80 ef       	ldi	r24, 0xF0	; 240
    810e:	9f e1       	ldi	r25, 0x1F	; 31
    8110:	0e 94 a6 32 	call	0x654c	; 0x654c <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    8114:	8b ad       	ldd	r24, Y+59	; 0x3b
    8116:	81 30       	cpi	r24, 0x01	; 1
    8118:	09 f4       	brne	.+2      	; 0x811c <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    811a:	1b ae       	std	Y+59, r1	; 0x3b
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    811c:	0f 90       	pop	r0
    811e:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    8120:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xSchedulerRunning>
    8124:	88 23       	and	r24, r24
    8126:	39 f0       	breq	.+14     	; 0x8136 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    8128:	0f b6       	in	r0, 0x3f	; 63
    812a:	f8 94       	cli
    812c:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    812e:	0e 94 1d 38 	call	0x703a	; 0x703a <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    8132:	0f 90       	pop	r0
    8134:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    8136:	80 91 46 20 	lds	r24, 0x2046	; 0x802046 <pxCurrentTCB>
    813a:	90 91 47 20 	lds	r25, 0x2047	; 0x802047 <pxCurrentTCB+0x1>
    813e:	c8 17       	cp	r28, r24
    8140:	d9 07       	cpc	r29, r25
    8142:	99 f4       	brne	.+38     	; 0x816a <vTaskSuspend+0x98>
		{
			if( xSchedulerRunning != pdFALSE )
    8144:	80 91 eb 1f 	lds	r24, 0x1FEB	; 0x801feb <xSchedulerRunning>
    8148:	88 23       	and	r24, r24
    814a:	19 f0       	breq	.+6      	; 0x8152 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    814c:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <vPortYield>
    8150:	0c c0       	rjmp	.+24     	; 0x816a <vTaskSuspend+0x98>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    8152:	90 91 f0 1f 	lds	r25, 0x1FF0	; 0x801ff0 <xSuspendedTaskList>
    8156:	80 91 ef 1f 	lds	r24, 0x1FEF	; 0x801fef <uxCurrentNumberOfTasks>
    815a:	98 13       	cpse	r25, r24
    815c:	05 c0       	rjmp	.+10     	; 0x8168 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    815e:	10 92 47 20 	sts	0x2047, r1	; 0x802047 <pxCurrentTCB+0x1>
    8162:	10 92 46 20 	sts	0x2046, r1	; 0x802046 <pxCurrentTCB>
    8166:	01 c0       	rjmp	.+2      	; 0x816a <vTaskSuspend+0x98>
				}
				else
				{
					vTaskSwitchContext();
    8168:	18 df       	rcall	.-464    	; 0x7f9a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    816a:	df 91       	pop	r29
    816c:	cf 91       	pop	r28
    816e:	1f 91       	pop	r17
    8170:	0f 91       	pop	r16
    8172:	08 95       	ret

00008174 <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    8174:	fc 01       	movw	r30, r24
    8176:	73 83       	std	Z+3, r23	; 0x03
    8178:	62 83       	std	Z+2, r22	; 0x02
    817a:	91 87       	std	Z+9, r25	; 0x09
    817c:	80 87       	std	Z+8, r24	; 0x08
    817e:	46 17       	cp	r20, r22
    8180:	57 07       	cpc	r21, r23
    8182:	90 f0       	brcs	.+36     	; 0x81a8 <prvInsertTimerInActiveList+0x34>
    8184:	42 1b       	sub	r20, r18
    8186:	53 0b       	sbc	r21, r19
    8188:	84 85       	ldd	r24, Z+12	; 0x0c
    818a:	95 85       	ldd	r25, Z+13	; 0x0d
    818c:	48 17       	cp	r20, r24
    818e:	59 07       	cpc	r21, r25
    8190:	e0 f4       	brcc	.+56     	; 0x81ca <prvInsertTimerInActiveList+0x56>
    8192:	bf 01       	movw	r22, r30
    8194:	6e 5f       	subi	r22, 0xFE	; 254
    8196:	7f 4f       	sbci	r23, 0xFF	; 255
    8198:	80 91 4e 20 	lds	r24, 0x204E	; 0x80204e <pxOverflowTimerList>
    819c:	90 91 4f 20 	lds	r25, 0x204F	; 0x80204f <pxOverflowTimerList+0x1>
    81a0:	0e 94 c7 32 	call	0x658e	; 0x658e <vListInsert>
    81a4:	80 e0       	ldi	r24, 0x00	; 0
    81a6:	08 95       	ret
    81a8:	42 17       	cp	r20, r18
    81aa:	53 07       	cpc	r21, r19
    81ac:	18 f4       	brcc	.+6      	; 0x81b4 <prvInsertTimerInActiveList+0x40>
    81ae:	62 17       	cp	r22, r18
    81b0:	73 07       	cpc	r23, r19
    81b2:	68 f4       	brcc	.+26     	; 0x81ce <prvInsertTimerInActiveList+0x5a>
    81b4:	bf 01       	movw	r22, r30
    81b6:	6e 5f       	subi	r22, 0xFE	; 254
    81b8:	7f 4f       	sbci	r23, 0xFF	; 255
    81ba:	80 91 50 20 	lds	r24, 0x2050	; 0x802050 <pxCurrentTimerList>
    81be:	90 91 51 20 	lds	r25, 0x2051	; 0x802051 <pxCurrentTimerList+0x1>
    81c2:	0e 94 c7 32 	call	0x658e	; 0x658e <vListInsert>
    81c6:	80 e0       	ldi	r24, 0x00	; 0
    81c8:	08 95       	ret
    81ca:	81 e0       	ldi	r24, 0x01	; 1
    81cc:	08 95       	ret
    81ce:	81 e0       	ldi	r24, 0x01	; 1
    81d0:	08 95       	ret

000081d2 <prvCheckForValidListAndQueue>:
    81d2:	0f b6       	in	r0, 0x3f	; 63
    81d4:	f8 94       	cli
    81d6:	0f 92       	push	r0
    81d8:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    81dc:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    81e0:	89 2b       	or	r24, r25
    81e2:	e9 f4       	brne	.+58     	; 0x821e <prvCheckForValidListAndQueue+0x4c>
    81e4:	8b e5       	ldi	r24, 0x5B	; 91
    81e6:	90 e2       	ldi	r25, 0x20	; 32
    81e8:	0e 94 94 32 	call	0x6528	; 0x6528 <vListInitialise>
    81ec:	82 e5       	ldi	r24, 0x52	; 82
    81ee:	90 e2       	ldi	r25, 0x20	; 32
    81f0:	0e 94 94 32 	call	0x6528	; 0x6528 <vListInitialise>
    81f4:	8b e5       	ldi	r24, 0x5B	; 91
    81f6:	90 e2       	ldi	r25, 0x20	; 32
    81f8:	90 93 51 20 	sts	0x2051, r25	; 0x802051 <pxCurrentTimerList+0x1>
    81fc:	80 93 50 20 	sts	0x2050, r24	; 0x802050 <pxCurrentTimerList>
    8200:	82 e5       	ldi	r24, 0x52	; 82
    8202:	90 e2       	ldi	r25, 0x20	; 32
    8204:	90 93 4f 20 	sts	0x204F, r25	; 0x80204f <pxOverflowTimerList+0x1>
    8208:	80 93 4e 20 	sts	0x204E, r24	; 0x80204e <pxOverflowTimerList>
    820c:	40 e0       	ldi	r20, 0x00	; 0
    820e:	65 e0       	ldi	r22, 0x05	; 5
    8210:	84 e1       	ldi	r24, 0x14	; 20
    8212:	0e 94 a5 35 	call	0x6b4a	; 0x6b4a <xQueueGenericCreate>
    8216:	90 93 4d 20 	sts	0x204D, r25	; 0x80204d <xTimerQueue+0x1>
    821a:	80 93 4c 20 	sts	0x204C, r24	; 0x80204c <xTimerQueue>
    821e:	0f 90       	pop	r0
    8220:	0f be       	out	0x3f, r0	; 63
    8222:	08 95       	ret

00008224 <xTimerCreateTimerTask>:
    8224:	ef 92       	push	r14
    8226:	ff 92       	push	r15
    8228:	0f 93       	push	r16
    822a:	d3 df       	rcall	.-90     	; 0x81d2 <prvCheckForValidListAndQueue>
    822c:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    8230:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    8234:	89 2b       	or	r24, r25
    8236:	91 f0       	breq	.+36     	; 0x825c <xTimerCreateTimerTask+0x38>
    8238:	0f 2e       	mov	r0, r31
    823a:	fa e4       	ldi	r31, 0x4A	; 74
    823c:	ef 2e       	mov	r14, r31
    823e:	f0 e2       	ldi	r31, 0x20	; 32
    8240:	ff 2e       	mov	r15, r31
    8242:	f0 2d       	mov	r31, r0
    8244:	03 e0       	ldi	r16, 0x03	; 3
    8246:	20 e0       	ldi	r18, 0x00	; 0
    8248:	30 e0       	ldi	r19, 0x00	; 0
    824a:	48 e7       	ldi	r20, 0x78	; 120
    824c:	50 e0       	ldi	r21, 0x00	; 0
    824e:	6f ef       	ldi	r22, 0xFF	; 255
    8250:	72 e0       	ldi	r23, 0x02	; 2
    8252:	88 ee       	ldi	r24, 0xE8	; 232
    8254:	91 e4       	ldi	r25, 0x41	; 65
    8256:	0e 94 c4 38 	call	0x7188	; 0x7188 <xTaskCreate>
    825a:	01 c0       	rjmp	.+2      	; 0x825e <xTimerCreateTimerTask+0x3a>
    825c:	80 e0       	ldi	r24, 0x00	; 0
    825e:	0f 91       	pop	r16
    8260:	ff 90       	pop	r15
    8262:	ef 90       	pop	r14
    8264:	08 95       	ret

00008266 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    8266:	0f 93       	push	r16
    8268:	1f 93       	push	r17
    826a:	cf 93       	push	r28
    826c:	df 93       	push	r29
    826e:	00 d0       	rcall	.+0      	; 0x8270 <xTimerGenericCommand+0xa>
    8270:	1f 92       	push	r1
    8272:	1f 92       	push	r1
    8274:	cd b7       	in	r28, 0x3d	; 61
    8276:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    8278:	e0 91 4c 20 	lds	r30, 0x204C	; 0x80204c <xTimerQueue>
    827c:	f0 91 4d 20 	lds	r31, 0x204D	; 0x80204d <xTimerQueue+0x1>
    8280:	30 97       	sbiw	r30, 0x00	; 0
    8282:	69 f1       	breq	.+90     	; 0x82de <xTimerGenericCommand+0x78>
    8284:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    8286:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    8288:	5b 83       	std	Y+3, r21	; 0x03
    828a:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    828c:	9d 83       	std	Y+5, r25	; 0x05
    828e:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    8290:	66 30       	cpi	r22, 0x06	; 6
    8292:	e4 f4       	brge	.+56     	; 0x82cc <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    8294:	98 dc       	rcall	.-1744   	; 0x7bc6 <xTaskGetSchedulerState>
    8296:	82 30       	cpi	r24, 0x02	; 2
    8298:	61 f4       	brne	.+24     	; 0x82b2 <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    829a:	20 e0       	ldi	r18, 0x00	; 0
    829c:	a8 01       	movw	r20, r16
    829e:	be 01       	movw	r22, r28
    82a0:	6f 5f       	subi	r22, 0xFF	; 255
    82a2:	7f 4f       	sbci	r23, 0xFF	; 255
    82a4:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    82a8:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    82ac:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <xQueueGenericSend>
    82b0:	17 c0       	rjmp	.+46     	; 0x82e0 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    82b2:	20 e0       	ldi	r18, 0x00	; 0
    82b4:	40 e0       	ldi	r20, 0x00	; 0
    82b6:	50 e0       	ldi	r21, 0x00	; 0
    82b8:	be 01       	movw	r22, r28
    82ba:	6f 5f       	subi	r22, 0xFF	; 255
    82bc:	7f 4f       	sbci	r23, 0xFF	; 255
    82be:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    82c2:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    82c6:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <xQueueGenericSend>
    82ca:	0a c0       	rjmp	.+20     	; 0x82e0 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    82cc:	20 e0       	ldi	r18, 0x00	; 0
    82ce:	ad 01       	movw	r20, r26
    82d0:	be 01       	movw	r22, r28
    82d2:	6f 5f       	subi	r22, 0xFF	; 255
    82d4:	7f 4f       	sbci	r23, 0xFF	; 255
    82d6:	cf 01       	movw	r24, r30
    82d8:	0e 94 7d 36 	call	0x6cfa	; 0x6cfa <xQueueGenericSendFromISR>
    82dc:	01 c0       	rjmp	.+2      	; 0x82e0 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    82de:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    82e0:	0f 90       	pop	r0
    82e2:	0f 90       	pop	r0
    82e4:	0f 90       	pop	r0
    82e6:	0f 90       	pop	r0
    82e8:	0f 90       	pop	r0
    82ea:	df 91       	pop	r29
    82ec:	cf 91       	pop	r28
    82ee:	1f 91       	pop	r17
    82f0:	0f 91       	pop	r16
    82f2:	08 95       	ret

000082f4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    82f4:	af 92       	push	r10
    82f6:	bf 92       	push	r11
    82f8:	cf 92       	push	r12
    82fa:	df 92       	push	r13
    82fc:	ef 92       	push	r14
    82fe:	ff 92       	push	r15
    8300:	0f 93       	push	r16
    8302:	1f 93       	push	r17
    8304:	cf 93       	push	r28
    8306:	df 93       	push	r29
    8308:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    830a:	1a d9       	rcall	.-3532   	; 0x7540 <xTaskGetTickCount>
    830c:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    830e:	80 91 48 20 	lds	r24, 0x2048	; 0x802048 <xLastTime.2399>
    8312:	90 91 49 20 	lds	r25, 0x2049	; 0x802049 <xLastTime.2399+0x1>
    8316:	e8 16       	cp	r14, r24
    8318:	f9 06       	cpc	r15, r25
    831a:	08 f0       	brcs	.+2      	; 0x831e <prvSampleTimeNow+0x2a>
    831c:	47 c0       	rjmp	.+142    	; 0x83ac <prvSampleTimeNow+0xb8>
    831e:	2f c0       	rjmp	.+94     	; 0x837e <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    8320:	05 80       	ldd	r0, Z+5	; 0x05
    8322:	f6 81       	ldd	r31, Z+6	; 0x06
    8324:	e0 2d       	mov	r30, r0
    8326:	a0 80       	ld	r10, Z
    8328:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    832a:	c6 81       	ldd	r28, Z+6	; 0x06
    832c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    832e:	8e 01       	movw	r16, r28
    8330:	0e 5f       	subi	r16, 0xFE	; 254
    8332:	1f 4f       	sbci	r17, 0xFF	; 255
    8334:	c8 01       	movw	r24, r16
    8336:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    833a:	e8 89       	ldd	r30, Y+16	; 0x10
    833c:	f9 89       	ldd	r31, Y+17	; 0x11
    833e:	ce 01       	movw	r24, r28
    8340:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    8342:	8b 89       	ldd	r24, Y+19	; 0x13
    8344:	82 ff       	sbrs	r24, 2
    8346:	1b c0       	rjmp	.+54     	; 0x837e <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    8348:	8c 85       	ldd	r24, Y+12	; 0x0c
    834a:	9d 85       	ldd	r25, Y+13	; 0x0d
    834c:	8a 0d       	add	r24, r10
    834e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    8350:	a8 16       	cp	r10, r24
    8352:	b9 06       	cpc	r11, r25
    8354:	60 f4       	brcc	.+24     	; 0x836e <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    8356:	9b 83       	std	Y+3, r25	; 0x03
    8358:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    835a:	d9 87       	std	Y+9, r29	; 0x09
    835c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    835e:	b8 01       	movw	r22, r16
    8360:	80 91 50 20 	lds	r24, 0x2050	; 0x802050 <pxCurrentTimerList>
    8364:	90 91 51 20 	lds	r25, 0x2051	; 0x802051 <pxCurrentTimerList+0x1>
    8368:	0e 94 c7 32 	call	0x658e	; 0x658e <vListInsert>
    836c:	08 c0       	rjmp	.+16     	; 0x837e <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    836e:	00 e0       	ldi	r16, 0x00	; 0
    8370:	10 e0       	ldi	r17, 0x00	; 0
    8372:	20 e0       	ldi	r18, 0x00	; 0
    8374:	30 e0       	ldi	r19, 0x00	; 0
    8376:	a5 01       	movw	r20, r10
    8378:	60 e0       	ldi	r22, 0x00	; 0
    837a:	ce 01       	movw	r24, r28
    837c:	74 df       	rcall	.-280    	; 0x8266 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    837e:	e0 91 50 20 	lds	r30, 0x2050	; 0x802050 <pxCurrentTimerList>
    8382:	f0 91 51 20 	lds	r31, 0x2051	; 0x802051 <pxCurrentTimerList+0x1>
    8386:	80 81       	ld	r24, Z
    8388:	81 11       	cpse	r24, r1
    838a:	ca cf       	rjmp	.-108    	; 0x8320 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    838c:	80 91 4e 20 	lds	r24, 0x204E	; 0x80204e <pxOverflowTimerList>
    8390:	90 91 4f 20 	lds	r25, 0x204F	; 0x80204f <pxOverflowTimerList+0x1>
    8394:	90 93 51 20 	sts	0x2051, r25	; 0x802051 <pxCurrentTimerList+0x1>
    8398:	80 93 50 20 	sts	0x2050, r24	; 0x802050 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    839c:	f0 93 4f 20 	sts	0x204F, r31	; 0x80204f <pxOverflowTimerList+0x1>
    83a0:	e0 93 4e 20 	sts	0x204E, r30	; 0x80204e <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    83a4:	81 e0       	ldi	r24, 0x01	; 1
    83a6:	f6 01       	movw	r30, r12
    83a8:	80 83       	st	Z, r24
    83aa:	02 c0       	rjmp	.+4      	; 0x83b0 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    83ac:	f6 01       	movw	r30, r12
    83ae:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    83b0:	f0 92 49 20 	sts	0x2049, r15	; 0x802049 <xLastTime.2399+0x1>
    83b4:	e0 92 48 20 	sts	0x2048, r14	; 0x802048 <xLastTime.2399>

	return xTimeNow;
}
    83b8:	c7 01       	movw	r24, r14
    83ba:	df 91       	pop	r29
    83bc:	cf 91       	pop	r28
    83be:	1f 91       	pop	r17
    83c0:	0f 91       	pop	r16
    83c2:	ff 90       	pop	r15
    83c4:	ef 90       	pop	r14
    83c6:	df 90       	pop	r13
    83c8:	cf 90       	pop	r12
    83ca:	bf 90       	pop	r11
    83cc:	af 90       	pop	r10
    83ce:	08 95       	ret

000083d0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    83d0:	cf 93       	push	r28
    83d2:	df 93       	push	r29
    83d4:	00 d0       	rcall	.+0      	; 0x83d6 <prvTimerTask+0x6>
    83d6:	00 d0       	rcall	.+0      	; 0x83d8 <prvTimerTask+0x8>
    83d8:	cd b7       	in	r28, 0x3d	; 61
    83da:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    83dc:	ce 01       	movw	r24, r28
    83de:	01 96       	adiw	r24, 0x01	; 1
    83e0:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    83e2:	44 24       	eor	r4, r4
    83e4:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    83e6:	e1 2c       	mov	r14, r1
    83e8:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    83ea:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    83ec:	c8 2e       	mov	r12, r24
    83ee:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    83f0:	e0 91 50 20 	lds	r30, 0x2050	; 0x802050 <pxCurrentTimerList>
    83f4:	f0 91 51 20 	lds	r31, 0x2051	; 0x802051 <pxCurrentTimerList+0x1>
    83f8:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    83fa:	88 23       	and	r24, r24
    83fc:	09 f4       	brne	.+2      	; 0x8400 <prvTimerTask+0x30>
    83fe:	d1 c0       	rjmp	.+418    	; 0x85a2 <prvTimerTask+0x1d2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    8400:	05 80       	ldd	r0, Z+5	; 0x05
    8402:	f6 81       	ldd	r31, Z+6	; 0x06
    8404:	e0 2d       	mov	r30, r0
    8406:	a0 80       	ld	r10, Z
    8408:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    840a:	94 d8       	rcall	.-3800   	; 0x7534 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    840c:	c4 01       	movw	r24, r8
    840e:	72 df       	rcall	.-284    	; 0x82f4 <prvSampleTimeNow>
    8410:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    8412:	89 81       	ldd	r24, Y+1	; 0x01
    8414:	81 11       	cpse	r24, r1
    8416:	47 c0       	rjmp	.+142    	; 0x84a6 <prvTimerTask+0xd6>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    8418:	0a 15       	cp	r16, r10
    841a:	1b 05       	cpc	r17, r11
			{
				( void ) xTaskResumeAll();
    841c:	a0 f1       	brcs	.+104    	; 0x8486 <prvTimerTask+0xb6>
    841e:	47 d9       	rcall	.-3442   	; 0x76ae <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    8420:	e0 91 50 20 	lds	r30, 0x2050	; 0x802050 <pxCurrentTimerList>
    8424:	f0 91 51 20 	lds	r31, 0x2051	; 0x802051 <pxCurrentTimerList+0x1>
    8428:	05 80       	ldd	r0, Z+5	; 0x05
    842a:	f6 81       	ldd	r31, Z+6	; 0x06
    842c:	e0 2d       	mov	r30, r0
    842e:	66 80       	ldd	r6, Z+6	; 0x06
    8430:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    8432:	c3 01       	movw	r24, r6
    8434:	02 96       	adiw	r24, 0x02	; 2
    8436:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    843a:	d3 01       	movw	r26, r6
    843c:	53 96       	adiw	r26, 0x13	; 19
    843e:	8c 91       	ld	r24, X
    8440:	53 97       	sbiw	r26, 0x13	; 19
    8442:	82 ff       	sbrs	r24, 2
    8444:	15 c0       	rjmp	.+42     	; 0x8470 <prvTimerTask+0xa0>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    8446:	1c 96       	adiw	r26, 0x0c	; 12
    8448:	6d 91       	ld	r22, X+
    844a:	7c 91       	ld	r23, X
    844c:	1d 97       	sbiw	r26, 0x0d	; 13
    844e:	6a 0d       	add	r22, r10
    8450:	7b 1d       	adc	r23, r11
    8452:	95 01       	movw	r18, r10
    8454:	a8 01       	movw	r20, r16
    8456:	c3 01       	movw	r24, r6
    8458:	8d de       	rcall	.-742    	; 0x8174 <prvInsertTimerInActiveList>
    845a:	88 23       	and	r24, r24
    845c:	61 f0       	breq	.+24     	; 0x8476 <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    845e:	0e 2d       	mov	r16, r14
    8460:	1f 2d       	mov	r17, r15
    8462:	2e 2d       	mov	r18, r14
    8464:	3f 2d       	mov	r19, r15
    8466:	a5 01       	movw	r20, r10
    8468:	65 2d       	mov	r22, r5
    846a:	c3 01       	movw	r24, r6
    846c:	fc de       	rcall	.-520    	; 0x8266 <xTimerGenericCommand>
    846e:	03 c0       	rjmp	.+6      	; 0x8476 <prvTimerTask+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8470:	8e 7f       	andi	r24, 0xFE	; 254
    8472:	f3 01       	movw	r30, r6
    8474:	83 8b       	std	Z+19, r24	; 0x13
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    8476:	d3 01       	movw	r26, r6
    8478:	50 96       	adiw	r26, 0x10	; 16
    847a:	ed 91       	ld	r30, X+
    847c:	fc 91       	ld	r31, X
    847e:	51 97       	sbiw	r26, 0x11	; 17
    8480:	c3 01       	movw	r24, r6
    8482:	19 95       	eicall
    8484:	81 c0       	rjmp	.+258    	; 0x8588 <prvTimerTask+0x1b8>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    8486:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    8488:	b5 01       	movw	r22, r10
    848a:	60 1b       	sub	r22, r16
    848c:	71 0b       	sbc	r23, r17
    848e:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    8492:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    8496:	0e 94 02 38 	call	0x7004	; 0x7004 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    849a:	09 d9       	rcall	.-3566   	; 0x76ae <xTaskResumeAll>
    849c:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    849e:	74 c0       	rjmp	.+232    	; 0x8588 <prvTimerTask+0x1b8>
    84a0:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    84a4:	71 c0       	rjmp	.+226    	; 0x8588 <prvTimerTask+0x1b8>
    84a6:	03 d9       	rcall	.-3578   	; 0x76ae <xTaskResumeAll>
    84a8:	6f c0       	rjmp	.+222    	; 0x8588 <prvTimerTask+0x1b8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    84aa:	89 81       	ldd	r24, Y+1	; 0x01
    84ac:	88 23       	and	r24, r24
    84ae:	0c f4       	brge	.+2      	; 0x84b2 <prvTimerTask+0xe2>
    84b0:	6b c0       	rjmp	.+214    	; 0x8588 <prvTimerTask+0x1b8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    84b2:	ac 80       	ldd	r10, Y+4	; 0x04
    84b4:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    84b6:	f5 01       	movw	r30, r10
    84b8:	82 85       	ldd	r24, Z+10	; 0x0a
    84ba:	93 85       	ldd	r25, Z+11	; 0x0b
    84bc:	89 2b       	or	r24, r25
    84be:	21 f0       	breq	.+8      	; 0x84c8 <prvTimerTask+0xf8>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    84c0:	c5 01       	movw	r24, r10
    84c2:	02 96       	adiw	r24, 0x02	; 2
    84c4:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    84c8:	ce 01       	movw	r24, r28
    84ca:	06 96       	adiw	r24, 0x06	; 6
    84cc:	13 df       	rcall	.-474    	; 0x82f4 <prvSampleTimeNow>
    84ce:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    84d0:	e9 81       	ldd	r30, Y+1	; 0x01
    84d2:	0e 2e       	mov	r0, r30
    84d4:	00 0c       	add	r0, r0
    84d6:	ff 0b       	sbc	r31, r31
    84d8:	ea 30       	cpi	r30, 0x0A	; 10
    84da:	f1 05       	cpc	r31, r1
    84dc:	08 f0       	brcs	.+2      	; 0x84e0 <prvTimerTask+0x110>
    84de:	54 c0       	rjmp	.+168    	; 0x8588 <prvTimerTask+0x1b8>
    84e0:	88 27       	eor	r24, r24
    84e2:	eb 54       	subi	r30, 0x4B	; 75
    84e4:	ff 4f       	sbci	r31, 0xFF	; 255
    84e6:	8f 4f       	sbci	r24, 0xFF	; 255
    84e8:	a9 c1       	rjmp	.+850    	; 0x883c <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    84ea:	d5 01       	movw	r26, r10
    84ec:	53 96       	adiw	r26, 0x13	; 19
    84ee:	8c 91       	ld	r24, X
    84f0:	53 97       	sbiw	r26, 0x13	; 19
    84f2:	81 60       	ori	r24, 0x01	; 1
    84f4:	53 96       	adiw	r26, 0x13	; 19
    84f6:	8c 93       	st	X, r24
    84f8:	53 97       	sbiw	r26, 0x13	; 19
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    84fa:	2a 81       	ldd	r18, Y+2	; 0x02
    84fc:	3b 81       	ldd	r19, Y+3	; 0x03
    84fe:	1c 96       	adiw	r26, 0x0c	; 12
    8500:	6d 91       	ld	r22, X+
    8502:	7c 91       	ld	r23, X
    8504:	1d 97       	sbiw	r26, 0x0d	; 13
    8506:	62 0f       	add	r22, r18
    8508:	73 1f       	adc	r23, r19
    850a:	c5 01       	movw	r24, r10
    850c:	33 de       	rcall	.-922    	; 0x8174 <prvInsertTimerInActiveList>
    850e:	88 23       	and	r24, r24
    8510:	d9 f1       	breq	.+118    	; 0x8588 <prvTimerTask+0x1b8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    8512:	d5 01       	movw	r26, r10
    8514:	50 96       	adiw	r26, 0x10	; 16
    8516:	ed 91       	ld	r30, X+
    8518:	fc 91       	ld	r31, X
    851a:	51 97       	sbiw	r26, 0x11	; 17
    851c:	c5 01       	movw	r24, r10
    851e:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    8520:	f5 01       	movw	r30, r10
    8522:	83 89       	ldd	r24, Z+19	; 0x13
    8524:	82 ff       	sbrs	r24, 2
    8526:	30 c0       	rjmp	.+96     	; 0x8588 <prvTimerTask+0x1b8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    8528:	4a 81       	ldd	r20, Y+2	; 0x02
    852a:	5b 81       	ldd	r21, Y+3	; 0x03
    852c:	84 85       	ldd	r24, Z+12	; 0x0c
    852e:	95 85       	ldd	r25, Z+13	; 0x0d
    8530:	48 0f       	add	r20, r24
    8532:	59 1f       	adc	r21, r25
    8534:	0e 2d       	mov	r16, r14
    8536:	1f 2d       	mov	r17, r15
    8538:	2e 2d       	mov	r18, r14
    853a:	3f 2d       	mov	r19, r15
    853c:	65 2d       	mov	r22, r5
    853e:	c5 01       	movw	r24, r10
    8540:	92 de       	rcall	.-732    	; 0x8266 <xTimerGenericCommand>
    8542:	22 c0       	rjmp	.+68     	; 0x8588 <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8544:	d5 01       	movw	r26, r10
    8546:	53 96       	adiw	r26, 0x13	; 19
    8548:	8c 91       	ld	r24, X
    854a:	53 97       	sbiw	r26, 0x13	; 19
    854c:	8e 7f       	andi	r24, 0xFE	; 254
    854e:	53 96       	adiw	r26, 0x13	; 19
    8550:	8c 93       	st	X, r24
    8552:	1a c0       	rjmp	.+52     	; 0x8588 <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    8554:	f5 01       	movw	r30, r10
    8556:	83 89       	ldd	r24, Z+19	; 0x13
    8558:	81 60       	ori	r24, 0x01	; 1
    855a:	83 8b       	std	Z+19, r24	; 0x13
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    855c:	6a 81       	ldd	r22, Y+2	; 0x02
    855e:	7b 81       	ldd	r23, Y+3	; 0x03
    8560:	75 87       	std	Z+13, r23	; 0x0d
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    8562:	64 87       	std	Z+12, r22	; 0x0c
    8564:	64 0f       	add	r22, r20
    8566:	75 1f       	adc	r23, r21
    8568:	9a 01       	movw	r18, r20
    856a:	c5 01       	movw	r24, r10
    856c:	03 de       	rcall	.-1018   	; 0x8174 <prvInsertTimerInActiveList>
    856e:	0c c0       	rjmp	.+24     	; 0x8588 <prvTimerTask+0x1b8>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    8570:	d5 01       	movw	r26, r10
    8572:	53 96       	adiw	r26, 0x13	; 19
    8574:	8c 91       	ld	r24, X
    8576:	81 fd       	sbrc	r24, 1
    8578:	04 c0       	rjmp	.+8      	; 0x8582 <prvTimerTask+0x1b2>
						{
							vPortFree( pxTimer );
    857a:	c5 01       	movw	r24, r10
    857c:	0e 94 9f 31 	call	0x633e	; 0x633e <vPortFree>
    8580:	03 c0       	rjmp	.+6      	; 0x8588 <prvTimerTask+0x1b8>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8582:	8e 7f       	andi	r24, 0xFE	; 254
    8584:	f5 01       	movw	r30, r10
    8586:	83 8b       	std	Z+19, r24	; 0x13
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    8588:	4e 2d       	mov	r20, r14
    858a:	5f 2d       	mov	r21, r15
    858c:	6c 2d       	mov	r22, r12
    858e:	7d 2d       	mov	r23, r13
    8590:	80 91 4c 20 	lds	r24, 0x204C	; 0x80204c <xTimerQueue>
    8594:	90 91 4d 20 	lds	r25, 0x204D	; 0x80204d <xTimerQueue+0x1>
    8598:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <xQueueReceive>
    859c:	81 11       	cpse	r24, r1
    859e:	85 cf       	rjmp	.-246    	; 0x84aa <prvTimerTask+0xda>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    85a0:	27 cf       	rjmp	.-434    	; 0x83f0 <prvTimerTask+0x20>
    85a2:	0e 94 9a 3a 	call	0x7534	; 0x7534 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    85a6:	c4 01       	movw	r24, r8
    85a8:	a5 de       	rcall	.-694    	; 0x82f4 <prvSampleTimeNow>
    85aa:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    85ac:	89 81       	ldd	r24, Y+1	; 0x01
    85ae:	81 11       	cpse	r24, r1
    85b0:	7a cf       	rjmp	.-268    	; 0x84a6 <prvTimerTask+0xd6>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    85b2:	e0 91 4e 20 	lds	r30, 0x204E	; 0x80204e <pxOverflowTimerList>
    85b6:	f0 91 4f 20 	lds	r31, 0x204F	; 0x80204f <pxOverflowTimerList+0x1>
    85ba:	80 81       	ld	r24, Z
    85bc:	44 2d       	mov	r20, r4
    85be:	81 11       	cpse	r24, r1
    85c0:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    85c2:	ae 2c       	mov	r10, r14
    85c4:	bf 2c       	mov	r11, r15
    85c6:	60 cf       	rjmp	.-320    	; 0x8488 <prvTimerTask+0xb8>

000085c8 <__floatunsisf>:
    85c8:	e8 94       	clt
    85ca:	09 c0       	rjmp	.+18     	; 0x85de <__floatsisf+0x12>

000085cc <__floatsisf>:
    85cc:	97 fb       	bst	r25, 7
    85ce:	3e f4       	brtc	.+14     	; 0x85de <__floatsisf+0x12>
    85d0:	90 95       	com	r25
    85d2:	80 95       	com	r24
    85d4:	70 95       	com	r23
    85d6:	61 95       	neg	r22
    85d8:	7f 4f       	sbci	r23, 0xFF	; 255
    85da:	8f 4f       	sbci	r24, 0xFF	; 255
    85dc:	9f 4f       	sbci	r25, 0xFF	; 255
    85de:	99 23       	and	r25, r25
    85e0:	a9 f0       	breq	.+42     	; 0x860c <__floatsisf+0x40>
    85e2:	f9 2f       	mov	r31, r25
    85e4:	96 e9       	ldi	r25, 0x96	; 150
    85e6:	bb 27       	eor	r27, r27
    85e8:	93 95       	inc	r25
    85ea:	f6 95       	lsr	r31
    85ec:	87 95       	ror	r24
    85ee:	77 95       	ror	r23
    85f0:	67 95       	ror	r22
    85f2:	b7 95       	ror	r27
    85f4:	f1 11       	cpse	r31, r1
    85f6:	f8 cf       	rjmp	.-16     	; 0x85e8 <__floatsisf+0x1c>
    85f8:	fa f4       	brpl	.+62     	; 0x8638 <__floatsisf+0x6c>
    85fa:	bb 0f       	add	r27, r27
    85fc:	11 f4       	brne	.+4      	; 0x8602 <__floatsisf+0x36>
    85fe:	60 ff       	sbrs	r22, 0
    8600:	1b c0       	rjmp	.+54     	; 0x8638 <__floatsisf+0x6c>
    8602:	6f 5f       	subi	r22, 0xFF	; 255
    8604:	7f 4f       	sbci	r23, 0xFF	; 255
    8606:	8f 4f       	sbci	r24, 0xFF	; 255
    8608:	9f 4f       	sbci	r25, 0xFF	; 255
    860a:	16 c0       	rjmp	.+44     	; 0x8638 <__floatsisf+0x6c>
    860c:	88 23       	and	r24, r24
    860e:	11 f0       	breq	.+4      	; 0x8614 <__floatsisf+0x48>
    8610:	96 e9       	ldi	r25, 0x96	; 150
    8612:	11 c0       	rjmp	.+34     	; 0x8636 <__floatsisf+0x6a>
    8614:	77 23       	and	r23, r23
    8616:	21 f0       	breq	.+8      	; 0x8620 <__floatsisf+0x54>
    8618:	9e e8       	ldi	r25, 0x8E	; 142
    861a:	87 2f       	mov	r24, r23
    861c:	76 2f       	mov	r23, r22
    861e:	05 c0       	rjmp	.+10     	; 0x862a <__floatsisf+0x5e>
    8620:	66 23       	and	r22, r22
    8622:	71 f0       	breq	.+28     	; 0x8640 <__floatsisf+0x74>
    8624:	96 e8       	ldi	r25, 0x86	; 134
    8626:	86 2f       	mov	r24, r22
    8628:	70 e0       	ldi	r23, 0x00	; 0
    862a:	60 e0       	ldi	r22, 0x00	; 0
    862c:	2a f0       	brmi	.+10     	; 0x8638 <__floatsisf+0x6c>
    862e:	9a 95       	dec	r25
    8630:	66 0f       	add	r22, r22
    8632:	77 1f       	adc	r23, r23
    8634:	88 1f       	adc	r24, r24
    8636:	da f7       	brpl	.-10     	; 0x862e <__floatsisf+0x62>
    8638:	88 0f       	add	r24, r24
    863a:	96 95       	lsr	r25
    863c:	87 95       	ror	r24
    863e:	97 f9       	bld	r25, 7
    8640:	08 95       	ret

00008642 <__mulsf3>:
    8642:	0b d0       	rcall	.+22     	; 0x865a <__mulsf3x>
    8644:	78 c0       	rjmp	.+240    	; 0x8736 <__fp_round>
    8646:	69 d0       	rcall	.+210    	; 0x871a <__fp_pscA>
    8648:	28 f0       	brcs	.+10     	; 0x8654 <__mulsf3+0x12>
    864a:	6e d0       	rcall	.+220    	; 0x8728 <__fp_pscB>
    864c:	18 f0       	brcs	.+6      	; 0x8654 <__mulsf3+0x12>
    864e:	95 23       	and	r25, r21
    8650:	09 f0       	breq	.+2      	; 0x8654 <__mulsf3+0x12>
    8652:	5a c0       	rjmp	.+180    	; 0x8708 <__fp_inf>
    8654:	5f c0       	rjmp	.+190    	; 0x8714 <__fp_nan>
    8656:	11 24       	eor	r1, r1
    8658:	a2 c0       	rjmp	.+324    	; 0x879e <__fp_szero>

0000865a <__mulsf3x>:
    865a:	7e d0       	rcall	.+252    	; 0x8758 <__fp_split3>
    865c:	a0 f3       	brcs	.-24     	; 0x8646 <__mulsf3+0x4>

0000865e <__mulsf3_pse>:
    865e:	95 9f       	mul	r25, r21
    8660:	d1 f3       	breq	.-12     	; 0x8656 <__mulsf3+0x14>
    8662:	95 0f       	add	r25, r21
    8664:	50 e0       	ldi	r21, 0x00	; 0
    8666:	55 1f       	adc	r21, r21
    8668:	62 9f       	mul	r22, r18
    866a:	f0 01       	movw	r30, r0
    866c:	72 9f       	mul	r23, r18
    866e:	bb 27       	eor	r27, r27
    8670:	f0 0d       	add	r31, r0
    8672:	b1 1d       	adc	r27, r1
    8674:	63 9f       	mul	r22, r19
    8676:	aa 27       	eor	r26, r26
    8678:	f0 0d       	add	r31, r0
    867a:	b1 1d       	adc	r27, r1
    867c:	aa 1f       	adc	r26, r26
    867e:	64 9f       	mul	r22, r20
    8680:	66 27       	eor	r22, r22
    8682:	b0 0d       	add	r27, r0
    8684:	a1 1d       	adc	r26, r1
    8686:	66 1f       	adc	r22, r22
    8688:	82 9f       	mul	r24, r18
    868a:	22 27       	eor	r18, r18
    868c:	b0 0d       	add	r27, r0
    868e:	a1 1d       	adc	r26, r1
    8690:	62 1f       	adc	r22, r18
    8692:	73 9f       	mul	r23, r19
    8694:	b0 0d       	add	r27, r0
    8696:	a1 1d       	adc	r26, r1
    8698:	62 1f       	adc	r22, r18
    869a:	83 9f       	mul	r24, r19
    869c:	a0 0d       	add	r26, r0
    869e:	61 1d       	adc	r22, r1
    86a0:	22 1f       	adc	r18, r18
    86a2:	74 9f       	mul	r23, r20
    86a4:	33 27       	eor	r19, r19
    86a6:	a0 0d       	add	r26, r0
    86a8:	61 1d       	adc	r22, r1
    86aa:	23 1f       	adc	r18, r19
    86ac:	84 9f       	mul	r24, r20
    86ae:	60 0d       	add	r22, r0
    86b0:	21 1d       	adc	r18, r1
    86b2:	82 2f       	mov	r24, r18
    86b4:	76 2f       	mov	r23, r22
    86b6:	6a 2f       	mov	r22, r26
    86b8:	11 24       	eor	r1, r1
    86ba:	9f 57       	subi	r25, 0x7F	; 127
    86bc:	50 40       	sbci	r21, 0x00	; 0
    86be:	8a f0       	brmi	.+34     	; 0x86e2 <__mulsf3_pse+0x84>
    86c0:	e1 f0       	breq	.+56     	; 0x86fa <__mulsf3_pse+0x9c>
    86c2:	88 23       	and	r24, r24
    86c4:	4a f0       	brmi	.+18     	; 0x86d8 <__mulsf3_pse+0x7a>
    86c6:	ee 0f       	add	r30, r30
    86c8:	ff 1f       	adc	r31, r31
    86ca:	bb 1f       	adc	r27, r27
    86cc:	66 1f       	adc	r22, r22
    86ce:	77 1f       	adc	r23, r23
    86d0:	88 1f       	adc	r24, r24
    86d2:	91 50       	subi	r25, 0x01	; 1
    86d4:	50 40       	sbci	r21, 0x00	; 0
    86d6:	a9 f7       	brne	.-22     	; 0x86c2 <__mulsf3_pse+0x64>
    86d8:	9e 3f       	cpi	r25, 0xFE	; 254
    86da:	51 05       	cpc	r21, r1
    86dc:	70 f0       	brcs	.+28     	; 0x86fa <__mulsf3_pse+0x9c>
    86de:	14 c0       	rjmp	.+40     	; 0x8708 <__fp_inf>
    86e0:	5e c0       	rjmp	.+188    	; 0x879e <__fp_szero>
    86e2:	5f 3f       	cpi	r21, 0xFF	; 255
    86e4:	ec f3       	brlt	.-6      	; 0x86e0 <__mulsf3_pse+0x82>
    86e6:	98 3e       	cpi	r25, 0xE8	; 232
    86e8:	dc f3       	brlt	.-10     	; 0x86e0 <__mulsf3_pse+0x82>
    86ea:	86 95       	lsr	r24
    86ec:	77 95       	ror	r23
    86ee:	67 95       	ror	r22
    86f0:	b7 95       	ror	r27
    86f2:	f7 95       	ror	r31
    86f4:	e7 95       	ror	r30
    86f6:	9f 5f       	subi	r25, 0xFF	; 255
    86f8:	c1 f7       	brne	.-16     	; 0x86ea <__mulsf3_pse+0x8c>
    86fa:	fe 2b       	or	r31, r30
    86fc:	88 0f       	add	r24, r24
    86fe:	91 1d       	adc	r25, r1
    8700:	96 95       	lsr	r25
    8702:	87 95       	ror	r24
    8704:	97 f9       	bld	r25, 7
    8706:	08 95       	ret

00008708 <__fp_inf>:
    8708:	97 f9       	bld	r25, 7
    870a:	9f 67       	ori	r25, 0x7F	; 127
    870c:	80 e8       	ldi	r24, 0x80	; 128
    870e:	70 e0       	ldi	r23, 0x00	; 0
    8710:	60 e0       	ldi	r22, 0x00	; 0
    8712:	08 95       	ret

00008714 <__fp_nan>:
    8714:	9f ef       	ldi	r25, 0xFF	; 255
    8716:	80 ec       	ldi	r24, 0xC0	; 192
    8718:	08 95       	ret

0000871a <__fp_pscA>:
    871a:	00 24       	eor	r0, r0
    871c:	0a 94       	dec	r0
    871e:	16 16       	cp	r1, r22
    8720:	17 06       	cpc	r1, r23
    8722:	18 06       	cpc	r1, r24
    8724:	09 06       	cpc	r0, r25
    8726:	08 95       	ret

00008728 <__fp_pscB>:
    8728:	00 24       	eor	r0, r0
    872a:	0a 94       	dec	r0
    872c:	12 16       	cp	r1, r18
    872e:	13 06       	cpc	r1, r19
    8730:	14 06       	cpc	r1, r20
    8732:	05 06       	cpc	r0, r21
    8734:	08 95       	ret

00008736 <__fp_round>:
    8736:	09 2e       	mov	r0, r25
    8738:	03 94       	inc	r0
    873a:	00 0c       	add	r0, r0
    873c:	11 f4       	brne	.+4      	; 0x8742 <__fp_round+0xc>
    873e:	88 23       	and	r24, r24
    8740:	52 f0       	brmi	.+20     	; 0x8756 <__fp_round+0x20>
    8742:	bb 0f       	add	r27, r27
    8744:	40 f4       	brcc	.+16     	; 0x8756 <__fp_round+0x20>
    8746:	bf 2b       	or	r27, r31
    8748:	11 f4       	brne	.+4      	; 0x874e <__fp_round+0x18>
    874a:	60 ff       	sbrs	r22, 0
    874c:	04 c0       	rjmp	.+8      	; 0x8756 <__fp_round+0x20>
    874e:	6f 5f       	subi	r22, 0xFF	; 255
    8750:	7f 4f       	sbci	r23, 0xFF	; 255
    8752:	8f 4f       	sbci	r24, 0xFF	; 255
    8754:	9f 4f       	sbci	r25, 0xFF	; 255
    8756:	08 95       	ret

00008758 <__fp_split3>:
    8758:	57 fd       	sbrc	r21, 7
    875a:	90 58       	subi	r25, 0x80	; 128
    875c:	44 0f       	add	r20, r20
    875e:	55 1f       	adc	r21, r21
    8760:	59 f0       	breq	.+22     	; 0x8778 <__fp_splitA+0x10>
    8762:	5f 3f       	cpi	r21, 0xFF	; 255
    8764:	71 f0       	breq	.+28     	; 0x8782 <__fp_splitA+0x1a>
    8766:	47 95       	ror	r20

00008768 <__fp_splitA>:
    8768:	88 0f       	add	r24, r24
    876a:	97 fb       	bst	r25, 7
    876c:	99 1f       	adc	r25, r25
    876e:	61 f0       	breq	.+24     	; 0x8788 <__fp_splitA+0x20>
    8770:	9f 3f       	cpi	r25, 0xFF	; 255
    8772:	79 f0       	breq	.+30     	; 0x8792 <__fp_splitA+0x2a>
    8774:	87 95       	ror	r24
    8776:	08 95       	ret
    8778:	12 16       	cp	r1, r18
    877a:	13 06       	cpc	r1, r19
    877c:	14 06       	cpc	r1, r20
    877e:	55 1f       	adc	r21, r21
    8780:	f2 cf       	rjmp	.-28     	; 0x8766 <__fp_split3+0xe>
    8782:	46 95       	lsr	r20
    8784:	f1 df       	rcall	.-30     	; 0x8768 <__fp_splitA>
    8786:	08 c0       	rjmp	.+16     	; 0x8798 <__fp_splitA+0x30>
    8788:	16 16       	cp	r1, r22
    878a:	17 06       	cpc	r1, r23
    878c:	18 06       	cpc	r1, r24
    878e:	99 1f       	adc	r25, r25
    8790:	f1 cf       	rjmp	.-30     	; 0x8774 <__fp_splitA+0xc>
    8792:	86 95       	lsr	r24
    8794:	71 05       	cpc	r23, r1
    8796:	61 05       	cpc	r22, r1
    8798:	08 94       	sec
    879a:	08 95       	ret

0000879c <__fp_zero>:
    879c:	e8 94       	clt

0000879e <__fp_szero>:
    879e:	bb 27       	eor	r27, r27
    87a0:	66 27       	eor	r22, r22
    87a2:	77 27       	eor	r23, r23
    87a4:	cb 01       	movw	r24, r22
    87a6:	97 f9       	bld	r25, 7
    87a8:	08 95       	ret

000087aa <__udivmodhi4>:
    87aa:	aa 1b       	sub	r26, r26
    87ac:	bb 1b       	sub	r27, r27
    87ae:	51 e1       	ldi	r21, 0x11	; 17
    87b0:	07 c0       	rjmp	.+14     	; 0x87c0 <__udivmodhi4_ep>

000087b2 <__udivmodhi4_loop>:
    87b2:	aa 1f       	adc	r26, r26
    87b4:	bb 1f       	adc	r27, r27
    87b6:	a6 17       	cp	r26, r22
    87b8:	b7 07       	cpc	r27, r23
    87ba:	10 f0       	brcs	.+4      	; 0x87c0 <__udivmodhi4_ep>
    87bc:	a6 1b       	sub	r26, r22
    87be:	b7 0b       	sbc	r27, r23

000087c0 <__udivmodhi4_ep>:
    87c0:	88 1f       	adc	r24, r24
    87c2:	99 1f       	adc	r25, r25
    87c4:	5a 95       	dec	r21
    87c6:	a9 f7       	brne	.-22     	; 0x87b2 <__udivmodhi4_loop>
    87c8:	80 95       	com	r24
    87ca:	90 95       	com	r25
    87cc:	bc 01       	movw	r22, r24
    87ce:	cd 01       	movw	r24, r26
    87d0:	08 95       	ret

000087d2 <__divmodhi4>:
    87d2:	97 fb       	bst	r25, 7
    87d4:	07 2e       	mov	r0, r23
    87d6:	16 f4       	brtc	.+4      	; 0x87dc <__divmodhi4+0xa>
    87d8:	00 94       	com	r0
    87da:	06 d0       	rcall	.+12     	; 0x87e8 <__divmodhi4_neg1>
    87dc:	77 fd       	sbrc	r23, 7
    87de:	08 d0       	rcall	.+16     	; 0x87f0 <__divmodhi4_neg2>
    87e0:	e4 df       	rcall	.-56     	; 0x87aa <__udivmodhi4>
    87e2:	07 fc       	sbrc	r0, 7
    87e4:	05 d0       	rcall	.+10     	; 0x87f0 <__divmodhi4_neg2>
    87e6:	3e f4       	brtc	.+14     	; 0x87f6 <__divmodhi4_exit>

000087e8 <__divmodhi4_neg1>:
    87e8:	90 95       	com	r25
    87ea:	81 95       	neg	r24
    87ec:	9f 4f       	sbci	r25, 0xFF	; 255
    87ee:	08 95       	ret

000087f0 <__divmodhi4_neg2>:
    87f0:	70 95       	com	r23
    87f2:	61 95       	neg	r22
    87f4:	7f 4f       	sbci	r23, 0xFF	; 255

000087f6 <__divmodhi4_exit>:
    87f6:	08 95       	ret

000087f8 <__udivmodsi4>:
    87f8:	a1 e2       	ldi	r26, 0x21	; 33
    87fa:	1a 2e       	mov	r1, r26
    87fc:	aa 1b       	sub	r26, r26
    87fe:	bb 1b       	sub	r27, r27
    8800:	fd 01       	movw	r30, r26
    8802:	0d c0       	rjmp	.+26     	; 0x881e <__udivmodsi4_ep>

00008804 <__udivmodsi4_loop>:
    8804:	aa 1f       	adc	r26, r26
    8806:	bb 1f       	adc	r27, r27
    8808:	ee 1f       	adc	r30, r30
    880a:	ff 1f       	adc	r31, r31
    880c:	a2 17       	cp	r26, r18
    880e:	b3 07       	cpc	r27, r19
    8810:	e4 07       	cpc	r30, r20
    8812:	f5 07       	cpc	r31, r21
    8814:	20 f0       	brcs	.+8      	; 0x881e <__udivmodsi4_ep>
    8816:	a2 1b       	sub	r26, r18
    8818:	b3 0b       	sbc	r27, r19
    881a:	e4 0b       	sbc	r30, r20
    881c:	f5 0b       	sbc	r31, r21

0000881e <__udivmodsi4_ep>:
    881e:	66 1f       	adc	r22, r22
    8820:	77 1f       	adc	r23, r23
    8822:	88 1f       	adc	r24, r24
    8824:	99 1f       	adc	r25, r25
    8826:	1a 94       	dec	r1
    8828:	69 f7       	brne	.-38     	; 0x8804 <__udivmodsi4_loop>
    882a:	60 95       	com	r22
    882c:	70 95       	com	r23
    882e:	80 95       	com	r24
    8830:	90 95       	com	r25
    8832:	9b 01       	movw	r18, r22
    8834:	ac 01       	movw	r20, r24
    8836:	bd 01       	movw	r22, r26
    8838:	cf 01       	movw	r24, r30
    883a:	08 95       	ret

0000883c <__tablejump2__>:
    883c:	ee 0f       	add	r30, r30
    883e:	ff 1f       	adc	r31, r31
    8840:	88 1f       	adc	r24, r24
    8842:	8b bf       	out	0x3b, r24	; 59
    8844:	07 90       	elpm	r0, Z+
    8846:	f6 91       	elpm	r31, Z
    8848:	e0 2d       	mov	r30, r0
    884a:	19 94       	eijmp

0000884c <__umulhisi3>:
    884c:	a2 9f       	mul	r26, r18
    884e:	b0 01       	movw	r22, r0
    8850:	b3 9f       	mul	r27, r19
    8852:	c0 01       	movw	r24, r0
    8854:	a3 9f       	mul	r26, r19
    8856:	70 0d       	add	r23, r0
    8858:	81 1d       	adc	r24, r1
    885a:	11 24       	eor	r1, r1
    885c:	91 1d       	adc	r25, r1
    885e:	b2 9f       	mul	r27, r18
    8860:	70 0d       	add	r23, r0
    8862:	81 1d       	adc	r24, r1
    8864:	11 24       	eor	r1, r1
    8866:	91 1d       	adc	r25, r1
    8868:	08 95       	ret

0000886a <__muluhisi3>:
    886a:	f0 df       	rcall	.-32     	; 0x884c <__umulhisi3>
    886c:	a5 9f       	mul	r26, r21
    886e:	90 0d       	add	r25, r0
    8870:	b4 9f       	mul	r27, r20
    8872:	90 0d       	add	r25, r0
    8874:	a4 9f       	mul	r26, r20
    8876:	80 0d       	add	r24, r0
    8878:	91 1d       	adc	r25, r1
    887a:	11 24       	eor	r1, r1
    887c:	08 95       	ret

0000887e <do_rand>:
    887e:	8f 92       	push	r8
    8880:	9f 92       	push	r9
    8882:	af 92       	push	r10
    8884:	bf 92       	push	r11
    8886:	cf 92       	push	r12
    8888:	df 92       	push	r13
    888a:	ef 92       	push	r14
    888c:	ff 92       	push	r15
    888e:	cf 93       	push	r28
    8890:	df 93       	push	r29
    8892:	ec 01       	movw	r28, r24
    8894:	68 81       	ld	r22, Y
    8896:	79 81       	ldd	r23, Y+1	; 0x01
    8898:	8a 81       	ldd	r24, Y+2	; 0x02
    889a:	9b 81       	ldd	r25, Y+3	; 0x03
    889c:	61 15       	cp	r22, r1
    889e:	71 05       	cpc	r23, r1
    88a0:	81 05       	cpc	r24, r1
    88a2:	91 05       	cpc	r25, r1
    88a4:	21 f4       	brne	.+8      	; 0x88ae <do_rand+0x30>
    88a6:	64 e2       	ldi	r22, 0x24	; 36
    88a8:	79 ed       	ldi	r23, 0xD9	; 217
    88aa:	8b e5       	ldi	r24, 0x5B	; 91
    88ac:	97 e0       	ldi	r25, 0x07	; 7
    88ae:	2d e1       	ldi	r18, 0x1D	; 29
    88b0:	33 ef       	ldi	r19, 0xF3	; 243
    88b2:	41 e0       	ldi	r20, 0x01	; 1
    88b4:	50 e0       	ldi	r21, 0x00	; 0
    88b6:	8d d5       	rcall	.+2842   	; 0x93d2 <__divmodsi4>
    88b8:	49 01       	movw	r8, r18
    88ba:	5a 01       	movw	r10, r20
    88bc:	9b 01       	movw	r18, r22
    88be:	ac 01       	movw	r20, r24
    88c0:	a7 ea       	ldi	r26, 0xA7	; 167
    88c2:	b1 e4       	ldi	r27, 0x41	; 65
    88c4:	d2 df       	rcall	.-92     	; 0x886a <__muluhisi3>
    88c6:	6b 01       	movw	r12, r22
    88c8:	7c 01       	movw	r14, r24
    88ca:	ac ee       	ldi	r26, 0xEC	; 236
    88cc:	b4 ef       	ldi	r27, 0xF4	; 244
    88ce:	a5 01       	movw	r20, r10
    88d0:	94 01       	movw	r18, r8
    88d2:	9d d5       	rcall	.+2874   	; 0x940e <__mulohisi3>
    88d4:	dc 01       	movw	r26, r24
    88d6:	cb 01       	movw	r24, r22
    88d8:	8c 0d       	add	r24, r12
    88da:	9d 1d       	adc	r25, r13
    88dc:	ae 1d       	adc	r26, r14
    88de:	bf 1d       	adc	r27, r15
    88e0:	b7 ff       	sbrs	r27, 7
    88e2:	03 c0       	rjmp	.+6      	; 0x88ea <do_rand+0x6c>
    88e4:	01 97       	sbiw	r24, 0x01	; 1
    88e6:	a1 09       	sbc	r26, r1
    88e8:	b0 48       	sbci	r27, 0x80	; 128
    88ea:	88 83       	st	Y, r24
    88ec:	99 83       	std	Y+1, r25	; 0x01
    88ee:	aa 83       	std	Y+2, r26	; 0x02
    88f0:	bb 83       	std	Y+3, r27	; 0x03
    88f2:	9f 77       	andi	r25, 0x7F	; 127
    88f4:	df 91       	pop	r29
    88f6:	cf 91       	pop	r28
    88f8:	ff 90       	pop	r15
    88fa:	ef 90       	pop	r14
    88fc:	df 90       	pop	r13
    88fe:	cf 90       	pop	r12
    8900:	bf 90       	pop	r11
    8902:	af 90       	pop	r10
    8904:	9f 90       	pop	r9
    8906:	8f 90       	pop	r8
    8908:	08 95       	ret

0000890a <rand_r>:
    890a:	b9 cf       	rjmp	.-142    	; 0x887e <do_rand>

0000890c <rand>:
    890c:	80 e0       	ldi	r24, 0x00	; 0
    890e:	92 e0       	ldi	r25, 0x02	; 2
    8910:	b6 cf       	rjmp	.-148    	; 0x887e <do_rand>

00008912 <srand>:
    8912:	a0 e0       	ldi	r26, 0x00	; 0
    8914:	b0 e0       	ldi	r27, 0x00	; 0
    8916:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    891a:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    891e:	a0 93 02 02 	sts	0x0202, r26	; 0x800202 <__DATA_REGION_ORIGIN__+0x2>
    8922:	b0 93 03 02 	sts	0x0203, r27	; 0x800203 <__DATA_REGION_ORIGIN__+0x3>
    8926:	08 95       	ret

00008928 <memcmp>:
    8928:	fb 01       	movw	r30, r22
    892a:	dc 01       	movw	r26, r24
    892c:	04 c0       	rjmp	.+8      	; 0x8936 <memcmp+0xe>
    892e:	8d 91       	ld	r24, X+
    8930:	01 90       	ld	r0, Z+
    8932:	80 19       	sub	r24, r0
    8934:	21 f4       	brne	.+8      	; 0x893e <memcmp+0x16>
    8936:	41 50       	subi	r20, 0x01	; 1
    8938:	50 40       	sbci	r21, 0x00	; 0
    893a:	c8 f7       	brcc	.-14     	; 0x892e <memcmp+0x6>
    893c:	88 1b       	sub	r24, r24
    893e:	99 0b       	sbc	r25, r25
    8940:	08 95       	ret

00008942 <memcpy>:
    8942:	fb 01       	movw	r30, r22
    8944:	dc 01       	movw	r26, r24
    8946:	02 c0       	rjmp	.+4      	; 0x894c <memcpy+0xa>
    8948:	01 90       	ld	r0, Z+
    894a:	0d 92       	st	X+, r0
    894c:	41 50       	subi	r20, 0x01	; 1
    894e:	50 40       	sbci	r21, 0x00	; 0
    8950:	d8 f7       	brcc	.-10     	; 0x8948 <memcpy+0x6>
    8952:	08 95       	ret

00008954 <memset>:
    8954:	dc 01       	movw	r26, r24
    8956:	01 c0       	rjmp	.+2      	; 0x895a <memset+0x6>
    8958:	6d 93       	st	X+, r22
    895a:	41 50       	subi	r20, 0x01	; 1
    895c:	50 40       	sbci	r21, 0x00	; 0
    895e:	e0 f7       	brcc	.-8      	; 0x8958 <memset+0x4>
    8960:	08 95       	ret

00008962 <strcpy>:
    8962:	fb 01       	movw	r30, r22
    8964:	dc 01       	movw	r26, r24
    8966:	01 90       	ld	r0, Z+
    8968:	0d 92       	st	X+, r0
    896a:	00 20       	and	r0, r0
    896c:	e1 f7       	brne	.-8      	; 0x8966 <strcpy+0x4>
    896e:	08 95       	ret

00008970 <strncmp>:
    8970:	fb 01       	movw	r30, r22
    8972:	dc 01       	movw	r26, r24
    8974:	41 50       	subi	r20, 0x01	; 1
    8976:	50 40       	sbci	r21, 0x00	; 0
    8978:	30 f0       	brcs	.+12     	; 0x8986 <strncmp+0x16>
    897a:	8d 91       	ld	r24, X+
    897c:	01 90       	ld	r0, Z+
    897e:	80 19       	sub	r24, r0
    8980:	19 f4       	brne	.+6      	; 0x8988 <strncmp+0x18>
    8982:	00 20       	and	r0, r0
    8984:	b9 f7       	brne	.-18     	; 0x8974 <strncmp+0x4>
    8986:	88 1b       	sub	r24, r24
    8988:	99 0b       	sbc	r25, r25
    898a:	08 95       	ret

0000898c <strncpy>:
    898c:	fb 01       	movw	r30, r22
    898e:	dc 01       	movw	r26, r24
    8990:	41 50       	subi	r20, 0x01	; 1
    8992:	50 40       	sbci	r21, 0x00	; 0
    8994:	48 f0       	brcs	.+18     	; 0x89a8 <strncpy+0x1c>
    8996:	01 90       	ld	r0, Z+
    8998:	0d 92       	st	X+, r0
    899a:	00 20       	and	r0, r0
    899c:	c9 f7       	brne	.-14     	; 0x8990 <strncpy+0x4>
    899e:	01 c0       	rjmp	.+2      	; 0x89a2 <strncpy+0x16>
    89a0:	1d 92       	st	X+, r1
    89a2:	41 50       	subi	r20, 0x01	; 1
    89a4:	50 40       	sbci	r21, 0x00	; 0
    89a6:	e0 f7       	brcc	.-8      	; 0x89a0 <strncpy+0x14>
    89a8:	08 95       	ret

000089aa <strnlen>:
    89aa:	fc 01       	movw	r30, r24
    89ac:	61 50       	subi	r22, 0x01	; 1
    89ae:	70 40       	sbci	r23, 0x00	; 0
    89b0:	01 90       	ld	r0, Z+
    89b2:	01 10       	cpse	r0, r1
    89b4:	d8 f7       	brcc	.-10     	; 0x89ac <strnlen+0x2>
    89b6:	80 95       	com	r24
    89b8:	90 95       	com	r25
    89ba:	8e 0f       	add	r24, r30
    89bc:	9f 1f       	adc	r25, r31
    89be:	08 95       	ret

000089c0 <fdevopen>:
    89c0:	0f 93       	push	r16
    89c2:	1f 93       	push	r17
    89c4:	cf 93       	push	r28
    89c6:	df 93       	push	r29
    89c8:	00 97       	sbiw	r24, 0x00	; 0
    89ca:	31 f4       	brne	.+12     	; 0x89d8 <fdevopen+0x18>
    89cc:	61 15       	cp	r22, r1
    89ce:	71 05       	cpc	r23, r1
    89d0:	19 f4       	brne	.+6      	; 0x89d8 <fdevopen+0x18>
    89d2:	80 e0       	ldi	r24, 0x00	; 0
    89d4:	90 e0       	ldi	r25, 0x00	; 0
    89d6:	39 c0       	rjmp	.+114    	; 0x8a4a <fdevopen+0x8a>
    89d8:	8b 01       	movw	r16, r22
    89da:	ec 01       	movw	r28, r24
    89dc:	6e e0       	ldi	r22, 0x0E	; 14
    89de:	70 e0       	ldi	r23, 0x00	; 0
    89e0:	81 e0       	ldi	r24, 0x01	; 1
    89e2:	90 e0       	ldi	r25, 0x00	; 0
    89e4:	16 d3       	rcall	.+1580   	; 0x9012 <calloc>
    89e6:	fc 01       	movw	r30, r24
    89e8:	89 2b       	or	r24, r25
    89ea:	99 f3       	breq	.-26     	; 0x89d2 <fdevopen+0x12>
    89ec:	80 e8       	ldi	r24, 0x80	; 128
    89ee:	83 83       	std	Z+3, r24	; 0x03
    89f0:	01 15       	cp	r16, r1
    89f2:	11 05       	cpc	r17, r1
    89f4:	71 f0       	breq	.+28     	; 0x8a12 <fdevopen+0x52>
    89f6:	13 87       	std	Z+11, r17	; 0x0b
    89f8:	02 87       	std	Z+10, r16	; 0x0a
    89fa:	81 e8       	ldi	r24, 0x81	; 129
    89fc:	83 83       	std	Z+3, r24	; 0x03
    89fe:	80 91 6a 20 	lds	r24, 0x206A	; 0x80206a <__iob>
    8a02:	90 91 6b 20 	lds	r25, 0x206B	; 0x80206b <__iob+0x1>
    8a06:	89 2b       	or	r24, r25
    8a08:	21 f4       	brne	.+8      	; 0x8a12 <fdevopen+0x52>
    8a0a:	f0 93 6b 20 	sts	0x206B, r31	; 0x80206b <__iob+0x1>
    8a0e:	e0 93 6a 20 	sts	0x206A, r30	; 0x80206a <__iob>
    8a12:	20 97       	sbiw	r28, 0x00	; 0
    8a14:	c9 f0       	breq	.+50     	; 0x8a48 <fdevopen+0x88>
    8a16:	d1 87       	std	Z+9, r29	; 0x09
    8a18:	c0 87       	std	Z+8, r28	; 0x08
    8a1a:	83 81       	ldd	r24, Z+3	; 0x03
    8a1c:	82 60       	ori	r24, 0x02	; 2
    8a1e:	83 83       	std	Z+3, r24	; 0x03
    8a20:	80 91 6c 20 	lds	r24, 0x206C	; 0x80206c <__iob+0x2>
    8a24:	90 91 6d 20 	lds	r25, 0x206D	; 0x80206d <__iob+0x3>
    8a28:	89 2b       	or	r24, r25
    8a2a:	71 f4       	brne	.+28     	; 0x8a48 <fdevopen+0x88>
    8a2c:	f0 93 6d 20 	sts	0x206D, r31	; 0x80206d <__iob+0x3>
    8a30:	e0 93 6c 20 	sts	0x206C, r30	; 0x80206c <__iob+0x2>
    8a34:	80 91 6e 20 	lds	r24, 0x206E	; 0x80206e <__iob+0x4>
    8a38:	90 91 6f 20 	lds	r25, 0x206F	; 0x80206f <__iob+0x5>
    8a3c:	89 2b       	or	r24, r25
    8a3e:	21 f4       	brne	.+8      	; 0x8a48 <fdevopen+0x88>
    8a40:	f0 93 6f 20 	sts	0x206F, r31	; 0x80206f <__iob+0x5>
    8a44:	e0 93 6e 20 	sts	0x206E, r30	; 0x80206e <__iob+0x4>
    8a48:	cf 01       	movw	r24, r30
    8a4a:	df 91       	pop	r29
    8a4c:	cf 91       	pop	r28
    8a4e:	1f 91       	pop	r17
    8a50:	0f 91       	pop	r16
    8a52:	08 95       	ret

00008a54 <printf>:
    8a54:	cf 93       	push	r28
    8a56:	df 93       	push	r29
    8a58:	cd b7       	in	r28, 0x3d	; 61
    8a5a:	de b7       	in	r29, 0x3e	; 62
    8a5c:	ae 01       	movw	r20, r28
    8a5e:	4a 5f       	subi	r20, 0xFA	; 250
    8a60:	5f 4f       	sbci	r21, 0xFF	; 255
    8a62:	fa 01       	movw	r30, r20
    8a64:	61 91       	ld	r22, Z+
    8a66:	71 91       	ld	r23, Z+
    8a68:	af 01       	movw	r20, r30
    8a6a:	80 91 6c 20 	lds	r24, 0x206C	; 0x80206c <__iob+0x2>
    8a6e:	90 91 6d 20 	lds	r25, 0x206D	; 0x80206d <__iob+0x3>
    8a72:	d2 d0       	rcall	.+420    	; 0x8c18 <vfprintf>
    8a74:	df 91       	pop	r29
    8a76:	cf 91       	pop	r28
    8a78:	08 95       	ret

00008a7a <printf_P>:
    8a7a:	0f 93       	push	r16
    8a7c:	1f 93       	push	r17
    8a7e:	cf 93       	push	r28
    8a80:	df 93       	push	r29
    8a82:	cd b7       	in	r28, 0x3d	; 61
    8a84:	de b7       	in	r29, 0x3e	; 62
    8a86:	ae 01       	movw	r20, r28
    8a88:	48 5f       	subi	r20, 0xF8	; 248
    8a8a:	5f 4f       	sbci	r21, 0xFF	; 255
    8a8c:	da 01       	movw	r26, r20
    8a8e:	6d 91       	ld	r22, X+
    8a90:	7d 91       	ld	r23, X+
    8a92:	ad 01       	movw	r20, r26
    8a94:	0a e6       	ldi	r16, 0x6A	; 106
    8a96:	10 e2       	ldi	r17, 0x20	; 32
    8a98:	f8 01       	movw	r30, r16
    8a9a:	82 81       	ldd	r24, Z+2	; 0x02
    8a9c:	93 81       	ldd	r25, Z+3	; 0x03
    8a9e:	dc 01       	movw	r26, r24
    8aa0:	13 96       	adiw	r26, 0x03	; 3
    8aa2:	2c 91       	ld	r18, X
    8aa4:	13 97       	sbiw	r26, 0x03	; 3
    8aa6:	28 60       	ori	r18, 0x08	; 8
    8aa8:	13 96       	adiw	r26, 0x03	; 3
    8aaa:	2c 93       	st	X, r18
    8aac:	b5 d0       	rcall	.+362    	; 0x8c18 <vfprintf>
    8aae:	d8 01       	movw	r26, r16
    8ab0:	12 96       	adiw	r26, 0x02	; 2
    8ab2:	ed 91       	ld	r30, X+
    8ab4:	fc 91       	ld	r31, X
    8ab6:	13 97       	sbiw	r26, 0x03	; 3
    8ab8:	23 81       	ldd	r18, Z+3	; 0x03
    8aba:	27 7f       	andi	r18, 0xF7	; 247
    8abc:	23 83       	std	Z+3, r18	; 0x03
    8abe:	df 91       	pop	r29
    8ac0:	cf 91       	pop	r28
    8ac2:	1f 91       	pop	r17
    8ac4:	0f 91       	pop	r16
    8ac6:	08 95       	ret

00008ac8 <puts>:
    8ac8:	0f 93       	push	r16
    8aca:	1f 93       	push	r17
    8acc:	cf 93       	push	r28
    8ace:	df 93       	push	r29
    8ad0:	e0 91 6c 20 	lds	r30, 0x206C	; 0x80206c <__iob+0x2>
    8ad4:	f0 91 6d 20 	lds	r31, 0x206D	; 0x80206d <__iob+0x3>
    8ad8:	23 81       	ldd	r18, Z+3	; 0x03
    8ada:	21 ff       	sbrs	r18, 1
    8adc:	1b c0       	rjmp	.+54     	; 0x8b14 <puts+0x4c>
    8ade:	8c 01       	movw	r16, r24
    8ae0:	d0 e0       	ldi	r29, 0x00	; 0
    8ae2:	c0 e0       	ldi	r28, 0x00	; 0
    8ae4:	f8 01       	movw	r30, r16
    8ae6:	81 91       	ld	r24, Z+
    8ae8:	8f 01       	movw	r16, r30
    8aea:	60 91 6c 20 	lds	r22, 0x206C	; 0x80206c <__iob+0x2>
    8aee:	70 91 6d 20 	lds	r23, 0x206D	; 0x80206d <__iob+0x3>
    8af2:	db 01       	movw	r26, r22
    8af4:	18 96       	adiw	r26, 0x08	; 8
    8af6:	ed 91       	ld	r30, X+
    8af8:	fc 91       	ld	r31, X
    8afa:	19 97       	sbiw	r26, 0x09	; 9
    8afc:	88 23       	and	r24, r24
    8afe:	31 f0       	breq	.+12     	; 0x8b0c <puts+0x44>
    8b00:	19 95       	eicall
    8b02:	89 2b       	or	r24, r25
    8b04:	79 f3       	breq	.-34     	; 0x8ae4 <puts+0x1c>
    8b06:	df ef       	ldi	r29, 0xFF	; 255
    8b08:	cf ef       	ldi	r28, 0xFF	; 255
    8b0a:	ec cf       	rjmp	.-40     	; 0x8ae4 <puts+0x1c>
    8b0c:	8a e0       	ldi	r24, 0x0A	; 10
    8b0e:	19 95       	eicall
    8b10:	89 2b       	or	r24, r25
    8b12:	19 f0       	breq	.+6      	; 0x8b1a <puts+0x52>
    8b14:	8f ef       	ldi	r24, 0xFF	; 255
    8b16:	9f ef       	ldi	r25, 0xFF	; 255
    8b18:	02 c0       	rjmp	.+4      	; 0x8b1e <puts+0x56>
    8b1a:	8d 2f       	mov	r24, r29
    8b1c:	9c 2f       	mov	r25, r28
    8b1e:	df 91       	pop	r29
    8b20:	cf 91       	pop	r28
    8b22:	1f 91       	pop	r17
    8b24:	0f 91       	pop	r16
    8b26:	08 95       	ret

00008b28 <snprintf_P>:
    8b28:	0f 93       	push	r16
    8b2a:	1f 93       	push	r17
    8b2c:	cf 93       	push	r28
    8b2e:	df 93       	push	r29
    8b30:	cd b7       	in	r28, 0x3d	; 61
    8b32:	de b7       	in	r29, 0x3e	; 62
    8b34:	2e 97       	sbiw	r28, 0x0e	; 14
    8b36:	0f b6       	in	r0, 0x3f	; 63
    8b38:	f8 94       	cli
    8b3a:	de bf       	out	0x3e, r29	; 62
    8b3c:	0f be       	out	0x3f, r0	; 63
    8b3e:	cd bf       	out	0x3d, r28	; 61
    8b40:	0e 89       	ldd	r16, Y+22	; 0x16
    8b42:	1f 89       	ldd	r17, Y+23	; 0x17
    8b44:	88 8d       	ldd	r24, Y+24	; 0x18
    8b46:	99 8d       	ldd	r25, Y+25	; 0x19
    8b48:	2e e0       	ldi	r18, 0x0E	; 14
    8b4a:	2c 83       	std	Y+4, r18	; 0x04
    8b4c:	1a 83       	std	Y+2, r17	; 0x02
    8b4e:	09 83       	std	Y+1, r16	; 0x01
    8b50:	97 ff       	sbrs	r25, 7
    8b52:	02 c0       	rjmp	.+4      	; 0x8b58 <snprintf_P+0x30>
    8b54:	80 e0       	ldi	r24, 0x00	; 0
    8b56:	90 e8       	ldi	r25, 0x80	; 128
    8b58:	01 97       	sbiw	r24, 0x01	; 1
    8b5a:	9e 83       	std	Y+6, r25	; 0x06
    8b5c:	8d 83       	std	Y+5, r24	; 0x05
    8b5e:	ae 01       	movw	r20, r28
    8b60:	44 5e       	subi	r20, 0xE4	; 228
    8b62:	5f 4f       	sbci	r21, 0xFF	; 255
    8b64:	6a 8d       	ldd	r22, Y+26	; 0x1a
    8b66:	7b 8d       	ldd	r23, Y+27	; 0x1b
    8b68:	ce 01       	movw	r24, r28
    8b6a:	01 96       	adiw	r24, 0x01	; 1
    8b6c:	55 d0       	rcall	.+170    	; 0x8c18 <vfprintf>
    8b6e:	4d 81       	ldd	r20, Y+5	; 0x05
    8b70:	5e 81       	ldd	r21, Y+6	; 0x06
    8b72:	57 fd       	sbrc	r21, 7
    8b74:	0a c0       	rjmp	.+20     	; 0x8b8a <snprintf_P+0x62>
    8b76:	2f 81       	ldd	r18, Y+7	; 0x07
    8b78:	38 85       	ldd	r19, Y+8	; 0x08
    8b7a:	42 17       	cp	r20, r18
    8b7c:	53 07       	cpc	r21, r19
    8b7e:	0c f4       	brge	.+2      	; 0x8b82 <snprintf_P+0x5a>
    8b80:	9a 01       	movw	r18, r20
    8b82:	f8 01       	movw	r30, r16
    8b84:	e2 0f       	add	r30, r18
    8b86:	f3 1f       	adc	r31, r19
    8b88:	10 82       	st	Z, r1
    8b8a:	2e 96       	adiw	r28, 0x0e	; 14
    8b8c:	0f b6       	in	r0, 0x3f	; 63
    8b8e:	f8 94       	cli
    8b90:	de bf       	out	0x3e, r29	; 62
    8b92:	0f be       	out	0x3f, r0	; 63
    8b94:	cd bf       	out	0x3d, r28	; 61
    8b96:	df 91       	pop	r29
    8b98:	cf 91       	pop	r28
    8b9a:	1f 91       	pop	r17
    8b9c:	0f 91       	pop	r16
    8b9e:	08 95       	ret

00008ba0 <sprintf>:
    8ba0:	0f 93       	push	r16
    8ba2:	1f 93       	push	r17
    8ba4:	cf 93       	push	r28
    8ba6:	df 93       	push	r29
    8ba8:	cd b7       	in	r28, 0x3d	; 61
    8baa:	de b7       	in	r29, 0x3e	; 62
    8bac:	2e 97       	sbiw	r28, 0x0e	; 14
    8bae:	0f b6       	in	r0, 0x3f	; 63
    8bb0:	f8 94       	cli
    8bb2:	de bf       	out	0x3e, r29	; 62
    8bb4:	0f be       	out	0x3f, r0	; 63
    8bb6:	cd bf       	out	0x3d, r28	; 61
    8bb8:	0e 89       	ldd	r16, Y+22	; 0x16
    8bba:	1f 89       	ldd	r17, Y+23	; 0x17
    8bbc:	86 e0       	ldi	r24, 0x06	; 6
    8bbe:	8c 83       	std	Y+4, r24	; 0x04
    8bc0:	1a 83       	std	Y+2, r17	; 0x02
    8bc2:	09 83       	std	Y+1, r16	; 0x01
    8bc4:	8f ef       	ldi	r24, 0xFF	; 255
    8bc6:	9f e7       	ldi	r25, 0x7F	; 127
    8bc8:	9e 83       	std	Y+6, r25	; 0x06
    8bca:	8d 83       	std	Y+5, r24	; 0x05
    8bcc:	ae 01       	movw	r20, r28
    8bce:	46 5e       	subi	r20, 0xE6	; 230
    8bd0:	5f 4f       	sbci	r21, 0xFF	; 255
    8bd2:	68 8d       	ldd	r22, Y+24	; 0x18
    8bd4:	79 8d       	ldd	r23, Y+25	; 0x19
    8bd6:	ce 01       	movw	r24, r28
    8bd8:	01 96       	adiw	r24, 0x01	; 1
    8bda:	1e d0       	rcall	.+60     	; 0x8c18 <vfprintf>
    8bdc:	ef 81       	ldd	r30, Y+7	; 0x07
    8bde:	f8 85       	ldd	r31, Y+8	; 0x08
    8be0:	e0 0f       	add	r30, r16
    8be2:	f1 1f       	adc	r31, r17
    8be4:	10 82       	st	Z, r1
    8be6:	2e 96       	adiw	r28, 0x0e	; 14
    8be8:	0f b6       	in	r0, 0x3f	; 63
    8bea:	f8 94       	cli
    8bec:	de bf       	out	0x3e, r29	; 62
    8bee:	0f be       	out	0x3f, r0	; 63
    8bf0:	cd bf       	out	0x3d, r28	; 61
    8bf2:	df 91       	pop	r29
    8bf4:	cf 91       	pop	r28
    8bf6:	1f 91       	pop	r17
    8bf8:	0f 91       	pop	r16
    8bfa:	08 95       	ret

00008bfc <vfprintf_P>:
    8bfc:	cf 93       	push	r28
    8bfe:	df 93       	push	r29
    8c00:	ec 01       	movw	r28, r24
    8c02:	8b 81       	ldd	r24, Y+3	; 0x03
    8c04:	88 60       	ori	r24, 0x08	; 8
    8c06:	8b 83       	std	Y+3, r24	; 0x03
    8c08:	ce 01       	movw	r24, r28
    8c0a:	06 d0       	rcall	.+12     	; 0x8c18 <vfprintf>
    8c0c:	2b 81       	ldd	r18, Y+3	; 0x03
    8c0e:	27 7f       	andi	r18, 0xF7	; 247
    8c10:	2b 83       	std	Y+3, r18	; 0x03
    8c12:	df 91       	pop	r29
    8c14:	cf 91       	pop	r28
    8c16:	08 95       	ret

00008c18 <vfprintf>:
    8c18:	2f 92       	push	r2
    8c1a:	3f 92       	push	r3
    8c1c:	4f 92       	push	r4
    8c1e:	5f 92       	push	r5
    8c20:	6f 92       	push	r6
    8c22:	7f 92       	push	r7
    8c24:	8f 92       	push	r8
    8c26:	9f 92       	push	r9
    8c28:	af 92       	push	r10
    8c2a:	bf 92       	push	r11
    8c2c:	cf 92       	push	r12
    8c2e:	df 92       	push	r13
    8c30:	ef 92       	push	r14
    8c32:	ff 92       	push	r15
    8c34:	0f 93       	push	r16
    8c36:	1f 93       	push	r17
    8c38:	cf 93       	push	r28
    8c3a:	df 93       	push	r29
    8c3c:	cd b7       	in	r28, 0x3d	; 61
    8c3e:	de b7       	in	r29, 0x3e	; 62
    8c40:	2b 97       	sbiw	r28, 0x0b	; 11
    8c42:	0f b6       	in	r0, 0x3f	; 63
    8c44:	f8 94       	cli
    8c46:	de bf       	out	0x3e, r29	; 62
    8c48:	0f be       	out	0x3f, r0	; 63
    8c4a:	cd bf       	out	0x3d, r28	; 61
    8c4c:	6c 01       	movw	r12, r24
    8c4e:	7b 01       	movw	r14, r22
    8c50:	8a 01       	movw	r16, r20
    8c52:	fc 01       	movw	r30, r24
    8c54:	17 82       	std	Z+7, r1	; 0x07
    8c56:	16 82       	std	Z+6, r1	; 0x06
    8c58:	83 81       	ldd	r24, Z+3	; 0x03
    8c5a:	81 ff       	sbrs	r24, 1
    8c5c:	bf c1       	rjmp	.+894    	; 0x8fdc <vfprintf+0x3c4>
    8c5e:	ce 01       	movw	r24, r28
    8c60:	01 96       	adiw	r24, 0x01	; 1
    8c62:	3c 01       	movw	r6, r24
    8c64:	f6 01       	movw	r30, r12
    8c66:	93 81       	ldd	r25, Z+3	; 0x03
    8c68:	f7 01       	movw	r30, r14
    8c6a:	93 fd       	sbrc	r25, 3
    8c6c:	85 91       	lpm	r24, Z+
    8c6e:	93 ff       	sbrs	r25, 3
    8c70:	81 91       	ld	r24, Z+
    8c72:	7f 01       	movw	r14, r30
    8c74:	88 23       	and	r24, r24
    8c76:	09 f4       	brne	.+2      	; 0x8c7a <vfprintf+0x62>
    8c78:	ad c1       	rjmp	.+858    	; 0x8fd4 <vfprintf+0x3bc>
    8c7a:	85 32       	cpi	r24, 0x25	; 37
    8c7c:	39 f4       	brne	.+14     	; 0x8c8c <vfprintf+0x74>
    8c7e:	93 fd       	sbrc	r25, 3
    8c80:	85 91       	lpm	r24, Z+
    8c82:	93 ff       	sbrs	r25, 3
    8c84:	81 91       	ld	r24, Z+
    8c86:	7f 01       	movw	r14, r30
    8c88:	85 32       	cpi	r24, 0x25	; 37
    8c8a:	21 f4       	brne	.+8      	; 0x8c94 <vfprintf+0x7c>
    8c8c:	b6 01       	movw	r22, r12
    8c8e:	90 e0       	ldi	r25, 0x00	; 0
    8c90:	06 d3       	rcall	.+1548   	; 0x929e <fputc>
    8c92:	e8 cf       	rjmp	.-48     	; 0x8c64 <vfprintf+0x4c>
    8c94:	91 2c       	mov	r9, r1
    8c96:	21 2c       	mov	r2, r1
    8c98:	31 2c       	mov	r3, r1
    8c9a:	ff e1       	ldi	r31, 0x1F	; 31
    8c9c:	f3 15       	cp	r31, r3
    8c9e:	d8 f0       	brcs	.+54     	; 0x8cd6 <vfprintf+0xbe>
    8ca0:	8b 32       	cpi	r24, 0x2B	; 43
    8ca2:	79 f0       	breq	.+30     	; 0x8cc2 <vfprintf+0xaa>
    8ca4:	38 f4       	brcc	.+14     	; 0x8cb4 <vfprintf+0x9c>
    8ca6:	80 32       	cpi	r24, 0x20	; 32
    8ca8:	79 f0       	breq	.+30     	; 0x8cc8 <vfprintf+0xb0>
    8caa:	83 32       	cpi	r24, 0x23	; 35
    8cac:	a1 f4       	brne	.+40     	; 0x8cd6 <vfprintf+0xbe>
    8cae:	23 2d       	mov	r18, r3
    8cb0:	20 61       	ori	r18, 0x10	; 16
    8cb2:	1d c0       	rjmp	.+58     	; 0x8cee <vfprintf+0xd6>
    8cb4:	8d 32       	cpi	r24, 0x2D	; 45
    8cb6:	61 f0       	breq	.+24     	; 0x8cd0 <vfprintf+0xb8>
    8cb8:	80 33       	cpi	r24, 0x30	; 48
    8cba:	69 f4       	brne	.+26     	; 0x8cd6 <vfprintf+0xbe>
    8cbc:	23 2d       	mov	r18, r3
    8cbe:	21 60       	ori	r18, 0x01	; 1
    8cc0:	16 c0       	rjmp	.+44     	; 0x8cee <vfprintf+0xd6>
    8cc2:	83 2d       	mov	r24, r3
    8cc4:	82 60       	ori	r24, 0x02	; 2
    8cc6:	38 2e       	mov	r3, r24
    8cc8:	e3 2d       	mov	r30, r3
    8cca:	e4 60       	ori	r30, 0x04	; 4
    8ccc:	3e 2e       	mov	r3, r30
    8cce:	2a c0       	rjmp	.+84     	; 0x8d24 <vfprintf+0x10c>
    8cd0:	f3 2d       	mov	r31, r3
    8cd2:	f8 60       	ori	r31, 0x08	; 8
    8cd4:	1d c0       	rjmp	.+58     	; 0x8d10 <vfprintf+0xf8>
    8cd6:	37 fc       	sbrc	r3, 7
    8cd8:	2d c0       	rjmp	.+90     	; 0x8d34 <vfprintf+0x11c>
    8cda:	20 ed       	ldi	r18, 0xD0	; 208
    8cdc:	28 0f       	add	r18, r24
    8cde:	2a 30       	cpi	r18, 0x0A	; 10
    8ce0:	40 f0       	brcs	.+16     	; 0x8cf2 <vfprintf+0xda>
    8ce2:	8e 32       	cpi	r24, 0x2E	; 46
    8ce4:	b9 f4       	brne	.+46     	; 0x8d14 <vfprintf+0xfc>
    8ce6:	36 fc       	sbrc	r3, 6
    8ce8:	75 c1       	rjmp	.+746    	; 0x8fd4 <vfprintf+0x3bc>
    8cea:	23 2d       	mov	r18, r3
    8cec:	20 64       	ori	r18, 0x40	; 64
    8cee:	32 2e       	mov	r3, r18
    8cf0:	19 c0       	rjmp	.+50     	; 0x8d24 <vfprintf+0x10c>
    8cf2:	36 fe       	sbrs	r3, 6
    8cf4:	06 c0       	rjmp	.+12     	; 0x8d02 <vfprintf+0xea>
    8cf6:	8a e0       	ldi	r24, 0x0A	; 10
    8cf8:	98 9e       	mul	r9, r24
    8cfa:	20 0d       	add	r18, r0
    8cfc:	11 24       	eor	r1, r1
    8cfe:	92 2e       	mov	r9, r18
    8d00:	11 c0       	rjmp	.+34     	; 0x8d24 <vfprintf+0x10c>
    8d02:	ea e0       	ldi	r30, 0x0A	; 10
    8d04:	2e 9e       	mul	r2, r30
    8d06:	20 0d       	add	r18, r0
    8d08:	11 24       	eor	r1, r1
    8d0a:	22 2e       	mov	r2, r18
    8d0c:	f3 2d       	mov	r31, r3
    8d0e:	f0 62       	ori	r31, 0x20	; 32
    8d10:	3f 2e       	mov	r3, r31
    8d12:	08 c0       	rjmp	.+16     	; 0x8d24 <vfprintf+0x10c>
    8d14:	8c 36       	cpi	r24, 0x6C	; 108
    8d16:	21 f4       	brne	.+8      	; 0x8d20 <vfprintf+0x108>
    8d18:	83 2d       	mov	r24, r3
    8d1a:	80 68       	ori	r24, 0x80	; 128
    8d1c:	38 2e       	mov	r3, r24
    8d1e:	02 c0       	rjmp	.+4      	; 0x8d24 <vfprintf+0x10c>
    8d20:	88 36       	cpi	r24, 0x68	; 104
    8d22:	41 f4       	brne	.+16     	; 0x8d34 <vfprintf+0x11c>
    8d24:	f7 01       	movw	r30, r14
    8d26:	93 fd       	sbrc	r25, 3
    8d28:	85 91       	lpm	r24, Z+
    8d2a:	93 ff       	sbrs	r25, 3
    8d2c:	81 91       	ld	r24, Z+
    8d2e:	7f 01       	movw	r14, r30
    8d30:	81 11       	cpse	r24, r1
    8d32:	b3 cf       	rjmp	.-154    	; 0x8c9a <vfprintf+0x82>
    8d34:	98 2f       	mov	r25, r24
    8d36:	9f 7d       	andi	r25, 0xDF	; 223
    8d38:	95 54       	subi	r25, 0x45	; 69
    8d3a:	93 30       	cpi	r25, 0x03	; 3
    8d3c:	28 f4       	brcc	.+10     	; 0x8d48 <vfprintf+0x130>
    8d3e:	0c 5f       	subi	r16, 0xFC	; 252
    8d40:	1f 4f       	sbci	r17, 0xFF	; 255
    8d42:	9f e3       	ldi	r25, 0x3F	; 63
    8d44:	99 83       	std	Y+1, r25	; 0x01
    8d46:	0d c0       	rjmp	.+26     	; 0x8d62 <vfprintf+0x14a>
    8d48:	83 36       	cpi	r24, 0x63	; 99
    8d4a:	31 f0       	breq	.+12     	; 0x8d58 <vfprintf+0x140>
    8d4c:	83 37       	cpi	r24, 0x73	; 115
    8d4e:	71 f0       	breq	.+28     	; 0x8d6c <vfprintf+0x154>
    8d50:	83 35       	cpi	r24, 0x53	; 83
    8d52:	09 f0       	breq	.+2      	; 0x8d56 <vfprintf+0x13e>
    8d54:	55 c0       	rjmp	.+170    	; 0x8e00 <vfprintf+0x1e8>
    8d56:	20 c0       	rjmp	.+64     	; 0x8d98 <vfprintf+0x180>
    8d58:	f8 01       	movw	r30, r16
    8d5a:	80 81       	ld	r24, Z
    8d5c:	89 83       	std	Y+1, r24	; 0x01
    8d5e:	0e 5f       	subi	r16, 0xFE	; 254
    8d60:	1f 4f       	sbci	r17, 0xFF	; 255
    8d62:	88 24       	eor	r8, r8
    8d64:	83 94       	inc	r8
    8d66:	91 2c       	mov	r9, r1
    8d68:	53 01       	movw	r10, r6
    8d6a:	12 c0       	rjmp	.+36     	; 0x8d90 <vfprintf+0x178>
    8d6c:	28 01       	movw	r4, r16
    8d6e:	f2 e0       	ldi	r31, 0x02	; 2
    8d70:	4f 0e       	add	r4, r31
    8d72:	51 1c       	adc	r5, r1
    8d74:	f8 01       	movw	r30, r16
    8d76:	a0 80       	ld	r10, Z
    8d78:	b1 80       	ldd	r11, Z+1	; 0x01
    8d7a:	36 fe       	sbrs	r3, 6
    8d7c:	03 c0       	rjmp	.+6      	; 0x8d84 <vfprintf+0x16c>
    8d7e:	69 2d       	mov	r22, r9
    8d80:	70 e0       	ldi	r23, 0x00	; 0
    8d82:	02 c0       	rjmp	.+4      	; 0x8d88 <vfprintf+0x170>
    8d84:	6f ef       	ldi	r22, 0xFF	; 255
    8d86:	7f ef       	ldi	r23, 0xFF	; 255
    8d88:	c5 01       	movw	r24, r10
    8d8a:	0f de       	rcall	.-994    	; 0x89aa <strnlen>
    8d8c:	4c 01       	movw	r8, r24
    8d8e:	82 01       	movw	r16, r4
    8d90:	f3 2d       	mov	r31, r3
    8d92:	ff 77       	andi	r31, 0x7F	; 127
    8d94:	3f 2e       	mov	r3, r31
    8d96:	15 c0       	rjmp	.+42     	; 0x8dc2 <vfprintf+0x1aa>
    8d98:	28 01       	movw	r4, r16
    8d9a:	22 e0       	ldi	r18, 0x02	; 2
    8d9c:	42 0e       	add	r4, r18
    8d9e:	51 1c       	adc	r5, r1
    8da0:	f8 01       	movw	r30, r16
    8da2:	a0 80       	ld	r10, Z
    8da4:	b1 80       	ldd	r11, Z+1	; 0x01
    8da6:	36 fe       	sbrs	r3, 6
    8da8:	03 c0       	rjmp	.+6      	; 0x8db0 <vfprintf+0x198>
    8daa:	69 2d       	mov	r22, r9
    8dac:	70 e0       	ldi	r23, 0x00	; 0
    8dae:	02 c0       	rjmp	.+4      	; 0x8db4 <vfprintf+0x19c>
    8db0:	6f ef       	ldi	r22, 0xFF	; 255
    8db2:	7f ef       	ldi	r23, 0xFF	; 255
    8db4:	c5 01       	movw	r24, r10
    8db6:	68 d2       	rcall	.+1232   	; 0x9288 <strnlen_P>
    8db8:	4c 01       	movw	r8, r24
    8dba:	f3 2d       	mov	r31, r3
    8dbc:	f0 68       	ori	r31, 0x80	; 128
    8dbe:	3f 2e       	mov	r3, r31
    8dc0:	82 01       	movw	r16, r4
    8dc2:	33 fc       	sbrc	r3, 3
    8dc4:	19 c0       	rjmp	.+50     	; 0x8df8 <vfprintf+0x1e0>
    8dc6:	82 2d       	mov	r24, r2
    8dc8:	90 e0       	ldi	r25, 0x00	; 0
    8dca:	88 16       	cp	r8, r24
    8dcc:	99 06       	cpc	r9, r25
    8dce:	a0 f4       	brcc	.+40     	; 0x8df8 <vfprintf+0x1e0>
    8dd0:	b6 01       	movw	r22, r12
    8dd2:	80 e2       	ldi	r24, 0x20	; 32
    8dd4:	90 e0       	ldi	r25, 0x00	; 0
    8dd6:	63 d2       	rcall	.+1222   	; 0x929e <fputc>
    8dd8:	2a 94       	dec	r2
    8dda:	f5 cf       	rjmp	.-22     	; 0x8dc6 <vfprintf+0x1ae>
    8ddc:	f5 01       	movw	r30, r10
    8dde:	37 fc       	sbrc	r3, 7
    8de0:	85 91       	lpm	r24, Z+
    8de2:	37 fe       	sbrs	r3, 7
    8de4:	81 91       	ld	r24, Z+
    8de6:	5f 01       	movw	r10, r30
    8de8:	b6 01       	movw	r22, r12
    8dea:	90 e0       	ldi	r25, 0x00	; 0
    8dec:	58 d2       	rcall	.+1200   	; 0x929e <fputc>
    8dee:	21 10       	cpse	r2, r1
    8df0:	2a 94       	dec	r2
    8df2:	21 e0       	ldi	r18, 0x01	; 1
    8df4:	82 1a       	sub	r8, r18
    8df6:	91 08       	sbc	r9, r1
    8df8:	81 14       	cp	r8, r1
    8dfa:	91 04       	cpc	r9, r1
    8dfc:	79 f7       	brne	.-34     	; 0x8ddc <vfprintf+0x1c4>
    8dfe:	e1 c0       	rjmp	.+450    	; 0x8fc2 <vfprintf+0x3aa>
    8e00:	84 36       	cpi	r24, 0x64	; 100
    8e02:	11 f0       	breq	.+4      	; 0x8e08 <vfprintf+0x1f0>
    8e04:	89 36       	cpi	r24, 0x69	; 105
    8e06:	39 f5       	brne	.+78     	; 0x8e56 <vfprintf+0x23e>
    8e08:	f8 01       	movw	r30, r16
    8e0a:	37 fe       	sbrs	r3, 7
    8e0c:	07 c0       	rjmp	.+14     	; 0x8e1c <vfprintf+0x204>
    8e0e:	60 81       	ld	r22, Z
    8e10:	71 81       	ldd	r23, Z+1	; 0x01
    8e12:	82 81       	ldd	r24, Z+2	; 0x02
    8e14:	93 81       	ldd	r25, Z+3	; 0x03
    8e16:	0c 5f       	subi	r16, 0xFC	; 252
    8e18:	1f 4f       	sbci	r17, 0xFF	; 255
    8e1a:	08 c0       	rjmp	.+16     	; 0x8e2c <vfprintf+0x214>
    8e1c:	60 81       	ld	r22, Z
    8e1e:	71 81       	ldd	r23, Z+1	; 0x01
    8e20:	07 2e       	mov	r0, r23
    8e22:	00 0c       	add	r0, r0
    8e24:	88 0b       	sbc	r24, r24
    8e26:	99 0b       	sbc	r25, r25
    8e28:	0e 5f       	subi	r16, 0xFE	; 254
    8e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    8e2c:	f3 2d       	mov	r31, r3
    8e2e:	ff 76       	andi	r31, 0x6F	; 111
    8e30:	3f 2e       	mov	r3, r31
    8e32:	97 ff       	sbrs	r25, 7
    8e34:	09 c0       	rjmp	.+18     	; 0x8e48 <vfprintf+0x230>
    8e36:	90 95       	com	r25
    8e38:	80 95       	com	r24
    8e3a:	70 95       	com	r23
    8e3c:	61 95       	neg	r22
    8e3e:	7f 4f       	sbci	r23, 0xFF	; 255
    8e40:	8f 4f       	sbci	r24, 0xFF	; 255
    8e42:	9f 4f       	sbci	r25, 0xFF	; 255
    8e44:	f0 68       	ori	r31, 0x80	; 128
    8e46:	3f 2e       	mov	r3, r31
    8e48:	2a e0       	ldi	r18, 0x0A	; 10
    8e4a:	30 e0       	ldi	r19, 0x00	; 0
    8e4c:	a3 01       	movw	r20, r6
    8e4e:	63 d2       	rcall	.+1222   	; 0x9316 <__ultoa_invert>
    8e50:	88 2e       	mov	r8, r24
    8e52:	86 18       	sub	r8, r6
    8e54:	44 c0       	rjmp	.+136    	; 0x8ede <vfprintf+0x2c6>
    8e56:	85 37       	cpi	r24, 0x75	; 117
    8e58:	31 f4       	brne	.+12     	; 0x8e66 <vfprintf+0x24e>
    8e5a:	23 2d       	mov	r18, r3
    8e5c:	2f 7e       	andi	r18, 0xEF	; 239
    8e5e:	b2 2e       	mov	r11, r18
    8e60:	2a e0       	ldi	r18, 0x0A	; 10
    8e62:	30 e0       	ldi	r19, 0x00	; 0
    8e64:	25 c0       	rjmp	.+74     	; 0x8eb0 <vfprintf+0x298>
    8e66:	93 2d       	mov	r25, r3
    8e68:	99 7f       	andi	r25, 0xF9	; 249
    8e6a:	b9 2e       	mov	r11, r25
    8e6c:	8f 36       	cpi	r24, 0x6F	; 111
    8e6e:	c1 f0       	breq	.+48     	; 0x8ea0 <vfprintf+0x288>
    8e70:	18 f4       	brcc	.+6      	; 0x8e78 <vfprintf+0x260>
    8e72:	88 35       	cpi	r24, 0x58	; 88
    8e74:	79 f0       	breq	.+30     	; 0x8e94 <vfprintf+0x27c>
    8e76:	ae c0       	rjmp	.+348    	; 0x8fd4 <vfprintf+0x3bc>
    8e78:	80 37       	cpi	r24, 0x70	; 112
    8e7a:	19 f0       	breq	.+6      	; 0x8e82 <vfprintf+0x26a>
    8e7c:	88 37       	cpi	r24, 0x78	; 120
    8e7e:	21 f0       	breq	.+8      	; 0x8e88 <vfprintf+0x270>
    8e80:	a9 c0       	rjmp	.+338    	; 0x8fd4 <vfprintf+0x3bc>
    8e82:	e9 2f       	mov	r30, r25
    8e84:	e0 61       	ori	r30, 0x10	; 16
    8e86:	be 2e       	mov	r11, r30
    8e88:	b4 fe       	sbrs	r11, 4
    8e8a:	0d c0       	rjmp	.+26     	; 0x8ea6 <vfprintf+0x28e>
    8e8c:	fb 2d       	mov	r31, r11
    8e8e:	f4 60       	ori	r31, 0x04	; 4
    8e90:	bf 2e       	mov	r11, r31
    8e92:	09 c0       	rjmp	.+18     	; 0x8ea6 <vfprintf+0x28e>
    8e94:	34 fe       	sbrs	r3, 4
    8e96:	0a c0       	rjmp	.+20     	; 0x8eac <vfprintf+0x294>
    8e98:	29 2f       	mov	r18, r25
    8e9a:	26 60       	ori	r18, 0x06	; 6
    8e9c:	b2 2e       	mov	r11, r18
    8e9e:	06 c0       	rjmp	.+12     	; 0x8eac <vfprintf+0x294>
    8ea0:	28 e0       	ldi	r18, 0x08	; 8
    8ea2:	30 e0       	ldi	r19, 0x00	; 0
    8ea4:	05 c0       	rjmp	.+10     	; 0x8eb0 <vfprintf+0x298>
    8ea6:	20 e1       	ldi	r18, 0x10	; 16
    8ea8:	30 e0       	ldi	r19, 0x00	; 0
    8eaa:	02 c0       	rjmp	.+4      	; 0x8eb0 <vfprintf+0x298>
    8eac:	20 e1       	ldi	r18, 0x10	; 16
    8eae:	32 e0       	ldi	r19, 0x02	; 2
    8eb0:	f8 01       	movw	r30, r16
    8eb2:	b7 fe       	sbrs	r11, 7
    8eb4:	07 c0       	rjmp	.+14     	; 0x8ec4 <vfprintf+0x2ac>
    8eb6:	60 81       	ld	r22, Z
    8eb8:	71 81       	ldd	r23, Z+1	; 0x01
    8eba:	82 81       	ldd	r24, Z+2	; 0x02
    8ebc:	93 81       	ldd	r25, Z+3	; 0x03
    8ebe:	0c 5f       	subi	r16, 0xFC	; 252
    8ec0:	1f 4f       	sbci	r17, 0xFF	; 255
    8ec2:	06 c0       	rjmp	.+12     	; 0x8ed0 <vfprintf+0x2b8>
    8ec4:	60 81       	ld	r22, Z
    8ec6:	71 81       	ldd	r23, Z+1	; 0x01
    8ec8:	80 e0       	ldi	r24, 0x00	; 0
    8eca:	90 e0       	ldi	r25, 0x00	; 0
    8ecc:	0e 5f       	subi	r16, 0xFE	; 254
    8ece:	1f 4f       	sbci	r17, 0xFF	; 255
    8ed0:	a3 01       	movw	r20, r6
    8ed2:	21 d2       	rcall	.+1090   	; 0x9316 <__ultoa_invert>
    8ed4:	88 2e       	mov	r8, r24
    8ed6:	86 18       	sub	r8, r6
    8ed8:	fb 2d       	mov	r31, r11
    8eda:	ff 77       	andi	r31, 0x7F	; 127
    8edc:	3f 2e       	mov	r3, r31
    8ede:	36 fe       	sbrs	r3, 6
    8ee0:	0d c0       	rjmp	.+26     	; 0x8efc <vfprintf+0x2e4>
    8ee2:	23 2d       	mov	r18, r3
    8ee4:	2e 7f       	andi	r18, 0xFE	; 254
    8ee6:	a2 2e       	mov	r10, r18
    8ee8:	89 14       	cp	r8, r9
    8eea:	58 f4       	brcc	.+22     	; 0x8f02 <vfprintf+0x2ea>
    8eec:	34 fe       	sbrs	r3, 4
    8eee:	0b c0       	rjmp	.+22     	; 0x8f06 <vfprintf+0x2ee>
    8ef0:	32 fc       	sbrc	r3, 2
    8ef2:	09 c0       	rjmp	.+18     	; 0x8f06 <vfprintf+0x2ee>
    8ef4:	83 2d       	mov	r24, r3
    8ef6:	8e 7e       	andi	r24, 0xEE	; 238
    8ef8:	a8 2e       	mov	r10, r24
    8efa:	05 c0       	rjmp	.+10     	; 0x8f06 <vfprintf+0x2ee>
    8efc:	b8 2c       	mov	r11, r8
    8efe:	a3 2c       	mov	r10, r3
    8f00:	03 c0       	rjmp	.+6      	; 0x8f08 <vfprintf+0x2f0>
    8f02:	b8 2c       	mov	r11, r8
    8f04:	01 c0       	rjmp	.+2      	; 0x8f08 <vfprintf+0x2f0>
    8f06:	b9 2c       	mov	r11, r9
    8f08:	a4 fe       	sbrs	r10, 4
    8f0a:	0f c0       	rjmp	.+30     	; 0x8f2a <vfprintf+0x312>
    8f0c:	fe 01       	movw	r30, r28
    8f0e:	e8 0d       	add	r30, r8
    8f10:	f1 1d       	adc	r31, r1
    8f12:	80 81       	ld	r24, Z
    8f14:	80 33       	cpi	r24, 0x30	; 48
    8f16:	21 f4       	brne	.+8      	; 0x8f20 <vfprintf+0x308>
    8f18:	9a 2d       	mov	r25, r10
    8f1a:	99 7e       	andi	r25, 0xE9	; 233
    8f1c:	a9 2e       	mov	r10, r25
    8f1e:	09 c0       	rjmp	.+18     	; 0x8f32 <vfprintf+0x31a>
    8f20:	a2 fe       	sbrs	r10, 2
    8f22:	06 c0       	rjmp	.+12     	; 0x8f30 <vfprintf+0x318>
    8f24:	b3 94       	inc	r11
    8f26:	b3 94       	inc	r11
    8f28:	04 c0       	rjmp	.+8      	; 0x8f32 <vfprintf+0x31a>
    8f2a:	8a 2d       	mov	r24, r10
    8f2c:	86 78       	andi	r24, 0x86	; 134
    8f2e:	09 f0       	breq	.+2      	; 0x8f32 <vfprintf+0x31a>
    8f30:	b3 94       	inc	r11
    8f32:	a3 fc       	sbrc	r10, 3
    8f34:	10 c0       	rjmp	.+32     	; 0x8f56 <vfprintf+0x33e>
    8f36:	a0 fe       	sbrs	r10, 0
    8f38:	06 c0       	rjmp	.+12     	; 0x8f46 <vfprintf+0x32e>
    8f3a:	b2 14       	cp	r11, r2
    8f3c:	80 f4       	brcc	.+32     	; 0x8f5e <vfprintf+0x346>
    8f3e:	28 0c       	add	r2, r8
    8f40:	92 2c       	mov	r9, r2
    8f42:	9b 18       	sub	r9, r11
    8f44:	0d c0       	rjmp	.+26     	; 0x8f60 <vfprintf+0x348>
    8f46:	b2 14       	cp	r11, r2
    8f48:	58 f4       	brcc	.+22     	; 0x8f60 <vfprintf+0x348>
    8f4a:	b6 01       	movw	r22, r12
    8f4c:	80 e2       	ldi	r24, 0x20	; 32
    8f4e:	90 e0       	ldi	r25, 0x00	; 0
    8f50:	a6 d1       	rcall	.+844    	; 0x929e <fputc>
    8f52:	b3 94       	inc	r11
    8f54:	f8 cf       	rjmp	.-16     	; 0x8f46 <vfprintf+0x32e>
    8f56:	b2 14       	cp	r11, r2
    8f58:	18 f4       	brcc	.+6      	; 0x8f60 <vfprintf+0x348>
    8f5a:	2b 18       	sub	r2, r11
    8f5c:	02 c0       	rjmp	.+4      	; 0x8f62 <vfprintf+0x34a>
    8f5e:	98 2c       	mov	r9, r8
    8f60:	21 2c       	mov	r2, r1
    8f62:	a4 fe       	sbrs	r10, 4
    8f64:	0f c0       	rjmp	.+30     	; 0x8f84 <vfprintf+0x36c>
    8f66:	b6 01       	movw	r22, r12
    8f68:	80 e3       	ldi	r24, 0x30	; 48
    8f6a:	90 e0       	ldi	r25, 0x00	; 0
    8f6c:	98 d1       	rcall	.+816    	; 0x929e <fputc>
    8f6e:	a2 fe       	sbrs	r10, 2
    8f70:	16 c0       	rjmp	.+44     	; 0x8f9e <vfprintf+0x386>
    8f72:	a1 fc       	sbrc	r10, 1
    8f74:	03 c0       	rjmp	.+6      	; 0x8f7c <vfprintf+0x364>
    8f76:	88 e7       	ldi	r24, 0x78	; 120
    8f78:	90 e0       	ldi	r25, 0x00	; 0
    8f7a:	02 c0       	rjmp	.+4      	; 0x8f80 <vfprintf+0x368>
    8f7c:	88 e5       	ldi	r24, 0x58	; 88
    8f7e:	90 e0       	ldi	r25, 0x00	; 0
    8f80:	b6 01       	movw	r22, r12
    8f82:	0c c0       	rjmp	.+24     	; 0x8f9c <vfprintf+0x384>
    8f84:	8a 2d       	mov	r24, r10
    8f86:	86 78       	andi	r24, 0x86	; 134
    8f88:	51 f0       	breq	.+20     	; 0x8f9e <vfprintf+0x386>
    8f8a:	a1 fe       	sbrs	r10, 1
    8f8c:	02 c0       	rjmp	.+4      	; 0x8f92 <vfprintf+0x37a>
    8f8e:	8b e2       	ldi	r24, 0x2B	; 43
    8f90:	01 c0       	rjmp	.+2      	; 0x8f94 <vfprintf+0x37c>
    8f92:	80 e2       	ldi	r24, 0x20	; 32
    8f94:	a7 fc       	sbrc	r10, 7
    8f96:	8d e2       	ldi	r24, 0x2D	; 45
    8f98:	b6 01       	movw	r22, r12
    8f9a:	90 e0       	ldi	r25, 0x00	; 0
    8f9c:	80 d1       	rcall	.+768    	; 0x929e <fputc>
    8f9e:	89 14       	cp	r8, r9
    8fa0:	30 f4       	brcc	.+12     	; 0x8fae <vfprintf+0x396>
    8fa2:	b6 01       	movw	r22, r12
    8fa4:	80 e3       	ldi	r24, 0x30	; 48
    8fa6:	90 e0       	ldi	r25, 0x00	; 0
    8fa8:	7a d1       	rcall	.+756    	; 0x929e <fputc>
    8faa:	9a 94       	dec	r9
    8fac:	f8 cf       	rjmp	.-16     	; 0x8f9e <vfprintf+0x386>
    8fae:	8a 94       	dec	r8
    8fb0:	f3 01       	movw	r30, r6
    8fb2:	e8 0d       	add	r30, r8
    8fb4:	f1 1d       	adc	r31, r1
    8fb6:	80 81       	ld	r24, Z
    8fb8:	b6 01       	movw	r22, r12
    8fba:	90 e0       	ldi	r25, 0x00	; 0
    8fbc:	70 d1       	rcall	.+736    	; 0x929e <fputc>
    8fbe:	81 10       	cpse	r8, r1
    8fc0:	f6 cf       	rjmp	.-20     	; 0x8fae <vfprintf+0x396>
    8fc2:	22 20       	and	r2, r2
    8fc4:	09 f4       	brne	.+2      	; 0x8fc8 <vfprintf+0x3b0>
    8fc6:	4e ce       	rjmp	.-868    	; 0x8c64 <vfprintf+0x4c>
    8fc8:	b6 01       	movw	r22, r12
    8fca:	80 e2       	ldi	r24, 0x20	; 32
    8fcc:	90 e0       	ldi	r25, 0x00	; 0
    8fce:	67 d1       	rcall	.+718    	; 0x929e <fputc>
    8fd0:	2a 94       	dec	r2
    8fd2:	f7 cf       	rjmp	.-18     	; 0x8fc2 <vfprintf+0x3aa>
    8fd4:	f6 01       	movw	r30, r12
    8fd6:	86 81       	ldd	r24, Z+6	; 0x06
    8fd8:	97 81       	ldd	r25, Z+7	; 0x07
    8fda:	02 c0       	rjmp	.+4      	; 0x8fe0 <vfprintf+0x3c8>
    8fdc:	8f ef       	ldi	r24, 0xFF	; 255
    8fde:	9f ef       	ldi	r25, 0xFF	; 255
    8fe0:	2b 96       	adiw	r28, 0x0b	; 11
    8fe2:	0f b6       	in	r0, 0x3f	; 63
    8fe4:	f8 94       	cli
    8fe6:	de bf       	out	0x3e, r29	; 62
    8fe8:	0f be       	out	0x3f, r0	; 63
    8fea:	cd bf       	out	0x3d, r28	; 61
    8fec:	df 91       	pop	r29
    8fee:	cf 91       	pop	r28
    8ff0:	1f 91       	pop	r17
    8ff2:	0f 91       	pop	r16
    8ff4:	ff 90       	pop	r15
    8ff6:	ef 90       	pop	r14
    8ff8:	df 90       	pop	r13
    8ffa:	cf 90       	pop	r12
    8ffc:	bf 90       	pop	r11
    8ffe:	af 90       	pop	r10
    9000:	9f 90       	pop	r9
    9002:	8f 90       	pop	r8
    9004:	7f 90       	pop	r7
    9006:	6f 90       	pop	r6
    9008:	5f 90       	pop	r5
    900a:	4f 90       	pop	r4
    900c:	3f 90       	pop	r3
    900e:	2f 90       	pop	r2
    9010:	08 95       	ret

00009012 <calloc>:
    9012:	0f 93       	push	r16
    9014:	1f 93       	push	r17
    9016:	cf 93       	push	r28
    9018:	df 93       	push	r29
    901a:	86 9f       	mul	r24, r22
    901c:	80 01       	movw	r16, r0
    901e:	87 9f       	mul	r24, r23
    9020:	10 0d       	add	r17, r0
    9022:	96 9f       	mul	r25, r22
    9024:	10 0d       	add	r17, r0
    9026:	11 24       	eor	r1, r1
    9028:	c8 01       	movw	r24, r16
    902a:	0d d0       	rcall	.+26     	; 0x9046 <malloc>
    902c:	ec 01       	movw	r28, r24
    902e:	00 97       	sbiw	r24, 0x00	; 0
    9030:	21 f0       	breq	.+8      	; 0x903a <calloc+0x28>
    9032:	a8 01       	movw	r20, r16
    9034:	60 e0       	ldi	r22, 0x00	; 0
    9036:	70 e0       	ldi	r23, 0x00	; 0
    9038:	8d dc       	rcall	.-1766   	; 0x8954 <memset>
    903a:	ce 01       	movw	r24, r28
    903c:	df 91       	pop	r29
    903e:	cf 91       	pop	r28
    9040:	1f 91       	pop	r17
    9042:	0f 91       	pop	r16
    9044:	08 95       	ret

00009046 <malloc>:
    9046:	0f 93       	push	r16
    9048:	1f 93       	push	r17
    904a:	cf 93       	push	r28
    904c:	df 93       	push	r29
    904e:	82 30       	cpi	r24, 0x02	; 2
    9050:	91 05       	cpc	r25, r1
    9052:	10 f4       	brcc	.+4      	; 0x9058 <malloc+0x12>
    9054:	82 e0       	ldi	r24, 0x02	; 2
    9056:	90 e0       	ldi	r25, 0x00	; 0
    9058:	e0 91 72 20 	lds	r30, 0x2072	; 0x802072 <__flp>
    905c:	f0 91 73 20 	lds	r31, 0x2073	; 0x802073 <__flp+0x1>
    9060:	20 e0       	ldi	r18, 0x00	; 0
    9062:	30 e0       	ldi	r19, 0x00	; 0
    9064:	a0 e0       	ldi	r26, 0x00	; 0
    9066:	b0 e0       	ldi	r27, 0x00	; 0
    9068:	30 97       	sbiw	r30, 0x00	; 0
    906a:	19 f1       	breq	.+70     	; 0x90b2 <malloc+0x6c>
    906c:	40 81       	ld	r20, Z
    906e:	51 81       	ldd	r21, Z+1	; 0x01
    9070:	02 81       	ldd	r16, Z+2	; 0x02
    9072:	13 81       	ldd	r17, Z+3	; 0x03
    9074:	48 17       	cp	r20, r24
    9076:	59 07       	cpc	r21, r25
    9078:	c8 f0       	brcs	.+50     	; 0x90ac <malloc+0x66>
    907a:	84 17       	cp	r24, r20
    907c:	95 07       	cpc	r25, r21
    907e:	69 f4       	brne	.+26     	; 0x909a <malloc+0x54>
    9080:	10 97       	sbiw	r26, 0x00	; 0
    9082:	31 f0       	breq	.+12     	; 0x9090 <malloc+0x4a>
    9084:	12 96       	adiw	r26, 0x02	; 2
    9086:	0c 93       	st	X, r16
    9088:	12 97       	sbiw	r26, 0x02	; 2
    908a:	13 96       	adiw	r26, 0x03	; 3
    908c:	1c 93       	st	X, r17
    908e:	27 c0       	rjmp	.+78     	; 0x90de <malloc+0x98>
    9090:	00 93 72 20 	sts	0x2072, r16	; 0x802072 <__flp>
    9094:	10 93 73 20 	sts	0x2073, r17	; 0x802073 <__flp+0x1>
    9098:	22 c0       	rjmp	.+68     	; 0x90de <malloc+0x98>
    909a:	21 15       	cp	r18, r1
    909c:	31 05       	cpc	r19, r1
    909e:	19 f0       	breq	.+6      	; 0x90a6 <malloc+0x60>
    90a0:	42 17       	cp	r20, r18
    90a2:	53 07       	cpc	r21, r19
    90a4:	18 f4       	brcc	.+6      	; 0x90ac <malloc+0x66>
    90a6:	9a 01       	movw	r18, r20
    90a8:	bd 01       	movw	r22, r26
    90aa:	ef 01       	movw	r28, r30
    90ac:	df 01       	movw	r26, r30
    90ae:	f8 01       	movw	r30, r16
    90b0:	db cf       	rjmp	.-74     	; 0x9068 <malloc+0x22>
    90b2:	21 15       	cp	r18, r1
    90b4:	31 05       	cpc	r19, r1
    90b6:	f9 f0       	breq	.+62     	; 0x90f6 <malloc+0xb0>
    90b8:	28 1b       	sub	r18, r24
    90ba:	39 0b       	sbc	r19, r25
    90bc:	24 30       	cpi	r18, 0x04	; 4
    90be:	31 05       	cpc	r19, r1
    90c0:	80 f4       	brcc	.+32     	; 0x90e2 <malloc+0x9c>
    90c2:	8a 81       	ldd	r24, Y+2	; 0x02
    90c4:	9b 81       	ldd	r25, Y+3	; 0x03
    90c6:	61 15       	cp	r22, r1
    90c8:	71 05       	cpc	r23, r1
    90ca:	21 f0       	breq	.+8      	; 0x90d4 <malloc+0x8e>
    90cc:	fb 01       	movw	r30, r22
    90ce:	93 83       	std	Z+3, r25	; 0x03
    90d0:	82 83       	std	Z+2, r24	; 0x02
    90d2:	04 c0       	rjmp	.+8      	; 0x90dc <malloc+0x96>
    90d4:	90 93 73 20 	sts	0x2073, r25	; 0x802073 <__flp+0x1>
    90d8:	80 93 72 20 	sts	0x2072, r24	; 0x802072 <__flp>
    90dc:	fe 01       	movw	r30, r28
    90de:	32 96       	adiw	r30, 0x02	; 2
    90e0:	44 c0       	rjmp	.+136    	; 0x916a <malloc+0x124>
    90e2:	fe 01       	movw	r30, r28
    90e4:	e2 0f       	add	r30, r18
    90e6:	f3 1f       	adc	r31, r19
    90e8:	81 93       	st	Z+, r24
    90ea:	91 93       	st	Z+, r25
    90ec:	22 50       	subi	r18, 0x02	; 2
    90ee:	31 09       	sbc	r19, r1
    90f0:	39 83       	std	Y+1, r19	; 0x01
    90f2:	28 83       	st	Y, r18
    90f4:	3a c0       	rjmp	.+116    	; 0x916a <malloc+0x124>
    90f6:	20 91 70 20 	lds	r18, 0x2070	; 0x802070 <__brkval>
    90fa:	30 91 71 20 	lds	r19, 0x2071	; 0x802071 <__brkval+0x1>
    90fe:	23 2b       	or	r18, r19
    9100:	41 f4       	brne	.+16     	; 0x9112 <malloc+0xcc>
    9102:	20 91 06 02 	lds	r18, 0x0206	; 0x800206 <__malloc_heap_start>
    9106:	30 91 07 02 	lds	r19, 0x0207	; 0x800207 <__malloc_heap_start+0x1>
    910a:	30 93 71 20 	sts	0x2071, r19	; 0x802071 <__brkval+0x1>
    910e:	20 93 70 20 	sts	0x2070, r18	; 0x802070 <__brkval>
    9112:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <__malloc_heap_end>
    9116:	30 91 05 02 	lds	r19, 0x0205	; 0x800205 <__malloc_heap_end+0x1>
    911a:	21 15       	cp	r18, r1
    911c:	31 05       	cpc	r19, r1
    911e:	41 f4       	brne	.+16     	; 0x9130 <malloc+0xea>
    9120:	2d b7       	in	r18, 0x3d	; 61
    9122:	3e b7       	in	r19, 0x3e	; 62
    9124:	40 91 08 02 	lds	r20, 0x0208	; 0x800208 <__malloc_margin>
    9128:	50 91 09 02 	lds	r21, 0x0209	; 0x800209 <__malloc_margin+0x1>
    912c:	24 1b       	sub	r18, r20
    912e:	35 0b       	sbc	r19, r21
    9130:	e0 91 70 20 	lds	r30, 0x2070	; 0x802070 <__brkval>
    9134:	f0 91 71 20 	lds	r31, 0x2071	; 0x802071 <__brkval+0x1>
    9138:	e2 17       	cp	r30, r18
    913a:	f3 07       	cpc	r31, r19
    913c:	a0 f4       	brcc	.+40     	; 0x9166 <malloc+0x120>
    913e:	2e 1b       	sub	r18, r30
    9140:	3f 0b       	sbc	r19, r31
    9142:	28 17       	cp	r18, r24
    9144:	39 07       	cpc	r19, r25
    9146:	78 f0       	brcs	.+30     	; 0x9166 <malloc+0x120>
    9148:	ac 01       	movw	r20, r24
    914a:	4e 5f       	subi	r20, 0xFE	; 254
    914c:	5f 4f       	sbci	r21, 0xFF	; 255
    914e:	24 17       	cp	r18, r20
    9150:	35 07       	cpc	r19, r21
    9152:	48 f0       	brcs	.+18     	; 0x9166 <malloc+0x120>
    9154:	4e 0f       	add	r20, r30
    9156:	5f 1f       	adc	r21, r31
    9158:	50 93 71 20 	sts	0x2071, r21	; 0x802071 <__brkval+0x1>
    915c:	40 93 70 20 	sts	0x2070, r20	; 0x802070 <__brkval>
    9160:	81 93       	st	Z+, r24
    9162:	91 93       	st	Z+, r25
    9164:	02 c0       	rjmp	.+4      	; 0x916a <malloc+0x124>
    9166:	e0 e0       	ldi	r30, 0x00	; 0
    9168:	f0 e0       	ldi	r31, 0x00	; 0
    916a:	cf 01       	movw	r24, r30
    916c:	df 91       	pop	r29
    916e:	cf 91       	pop	r28
    9170:	1f 91       	pop	r17
    9172:	0f 91       	pop	r16
    9174:	08 95       	ret

00009176 <free>:
    9176:	cf 93       	push	r28
    9178:	df 93       	push	r29
    917a:	00 97       	sbiw	r24, 0x00	; 0
    917c:	09 f4       	brne	.+2      	; 0x9180 <free+0xa>
    917e:	81 c0       	rjmp	.+258    	; 0x9282 <free+0x10c>
    9180:	fc 01       	movw	r30, r24
    9182:	32 97       	sbiw	r30, 0x02	; 2
    9184:	13 82       	std	Z+3, r1	; 0x03
    9186:	12 82       	std	Z+2, r1	; 0x02
    9188:	a0 91 72 20 	lds	r26, 0x2072	; 0x802072 <__flp>
    918c:	b0 91 73 20 	lds	r27, 0x2073	; 0x802073 <__flp+0x1>
    9190:	10 97       	sbiw	r26, 0x00	; 0
    9192:	81 f4       	brne	.+32     	; 0x91b4 <free+0x3e>
    9194:	20 81       	ld	r18, Z
    9196:	31 81       	ldd	r19, Z+1	; 0x01
    9198:	82 0f       	add	r24, r18
    919a:	93 1f       	adc	r25, r19
    919c:	20 91 70 20 	lds	r18, 0x2070	; 0x802070 <__brkval>
    91a0:	30 91 71 20 	lds	r19, 0x2071	; 0x802071 <__brkval+0x1>
    91a4:	28 17       	cp	r18, r24
    91a6:	39 07       	cpc	r19, r25
    91a8:	51 f5       	brne	.+84     	; 0x91fe <free+0x88>
    91aa:	f0 93 71 20 	sts	0x2071, r31	; 0x802071 <__brkval+0x1>
    91ae:	e0 93 70 20 	sts	0x2070, r30	; 0x802070 <__brkval>
    91b2:	67 c0       	rjmp	.+206    	; 0x9282 <free+0x10c>
    91b4:	ed 01       	movw	r28, r26
    91b6:	20 e0       	ldi	r18, 0x00	; 0
    91b8:	30 e0       	ldi	r19, 0x00	; 0
    91ba:	ce 17       	cp	r28, r30
    91bc:	df 07       	cpc	r29, r31
    91be:	40 f4       	brcc	.+16     	; 0x91d0 <free+0x5a>
    91c0:	4a 81       	ldd	r20, Y+2	; 0x02
    91c2:	5b 81       	ldd	r21, Y+3	; 0x03
    91c4:	9e 01       	movw	r18, r28
    91c6:	41 15       	cp	r20, r1
    91c8:	51 05       	cpc	r21, r1
    91ca:	f1 f0       	breq	.+60     	; 0x9208 <free+0x92>
    91cc:	ea 01       	movw	r28, r20
    91ce:	f5 cf       	rjmp	.-22     	; 0x91ba <free+0x44>
    91d0:	d3 83       	std	Z+3, r29	; 0x03
    91d2:	c2 83       	std	Z+2, r28	; 0x02
    91d4:	40 81       	ld	r20, Z
    91d6:	51 81       	ldd	r21, Z+1	; 0x01
    91d8:	84 0f       	add	r24, r20
    91da:	95 1f       	adc	r25, r21
    91dc:	c8 17       	cp	r28, r24
    91de:	d9 07       	cpc	r29, r25
    91e0:	59 f4       	brne	.+22     	; 0x91f8 <free+0x82>
    91e2:	88 81       	ld	r24, Y
    91e4:	99 81       	ldd	r25, Y+1	; 0x01
    91e6:	84 0f       	add	r24, r20
    91e8:	95 1f       	adc	r25, r21
    91ea:	02 96       	adiw	r24, 0x02	; 2
    91ec:	91 83       	std	Z+1, r25	; 0x01
    91ee:	80 83       	st	Z, r24
    91f0:	8a 81       	ldd	r24, Y+2	; 0x02
    91f2:	9b 81       	ldd	r25, Y+3	; 0x03
    91f4:	93 83       	std	Z+3, r25	; 0x03
    91f6:	82 83       	std	Z+2, r24	; 0x02
    91f8:	21 15       	cp	r18, r1
    91fa:	31 05       	cpc	r19, r1
    91fc:	29 f4       	brne	.+10     	; 0x9208 <free+0x92>
    91fe:	f0 93 73 20 	sts	0x2073, r31	; 0x802073 <__flp+0x1>
    9202:	e0 93 72 20 	sts	0x2072, r30	; 0x802072 <__flp>
    9206:	3d c0       	rjmp	.+122    	; 0x9282 <free+0x10c>
    9208:	e9 01       	movw	r28, r18
    920a:	fb 83       	std	Y+3, r31	; 0x03
    920c:	ea 83       	std	Y+2, r30	; 0x02
    920e:	49 91       	ld	r20, Y+
    9210:	59 91       	ld	r21, Y+
    9212:	c4 0f       	add	r28, r20
    9214:	d5 1f       	adc	r29, r21
    9216:	ec 17       	cp	r30, r28
    9218:	fd 07       	cpc	r31, r29
    921a:	61 f4       	brne	.+24     	; 0x9234 <free+0xbe>
    921c:	80 81       	ld	r24, Z
    921e:	91 81       	ldd	r25, Z+1	; 0x01
    9220:	84 0f       	add	r24, r20
    9222:	95 1f       	adc	r25, r21
    9224:	02 96       	adiw	r24, 0x02	; 2
    9226:	e9 01       	movw	r28, r18
    9228:	99 83       	std	Y+1, r25	; 0x01
    922a:	88 83       	st	Y, r24
    922c:	82 81       	ldd	r24, Z+2	; 0x02
    922e:	93 81       	ldd	r25, Z+3	; 0x03
    9230:	9b 83       	std	Y+3, r25	; 0x03
    9232:	8a 83       	std	Y+2, r24	; 0x02
    9234:	e0 e0       	ldi	r30, 0x00	; 0
    9236:	f0 e0       	ldi	r31, 0x00	; 0
    9238:	12 96       	adiw	r26, 0x02	; 2
    923a:	8d 91       	ld	r24, X+
    923c:	9c 91       	ld	r25, X
    923e:	13 97       	sbiw	r26, 0x03	; 3
    9240:	00 97       	sbiw	r24, 0x00	; 0
    9242:	19 f0       	breq	.+6      	; 0x924a <free+0xd4>
    9244:	fd 01       	movw	r30, r26
    9246:	dc 01       	movw	r26, r24
    9248:	f7 cf       	rjmp	.-18     	; 0x9238 <free+0xc2>
    924a:	8d 91       	ld	r24, X+
    924c:	9c 91       	ld	r25, X
    924e:	11 97       	sbiw	r26, 0x01	; 1
    9250:	9d 01       	movw	r18, r26
    9252:	2e 5f       	subi	r18, 0xFE	; 254
    9254:	3f 4f       	sbci	r19, 0xFF	; 255
    9256:	82 0f       	add	r24, r18
    9258:	93 1f       	adc	r25, r19
    925a:	20 91 70 20 	lds	r18, 0x2070	; 0x802070 <__brkval>
    925e:	30 91 71 20 	lds	r19, 0x2071	; 0x802071 <__brkval+0x1>
    9262:	28 17       	cp	r18, r24
    9264:	39 07       	cpc	r19, r25
    9266:	69 f4       	brne	.+26     	; 0x9282 <free+0x10c>
    9268:	30 97       	sbiw	r30, 0x00	; 0
    926a:	29 f4       	brne	.+10     	; 0x9276 <free+0x100>
    926c:	10 92 73 20 	sts	0x2073, r1	; 0x802073 <__flp+0x1>
    9270:	10 92 72 20 	sts	0x2072, r1	; 0x802072 <__flp>
    9274:	02 c0       	rjmp	.+4      	; 0x927a <free+0x104>
    9276:	13 82       	std	Z+3, r1	; 0x03
    9278:	12 82       	std	Z+2, r1	; 0x02
    927a:	b0 93 71 20 	sts	0x2071, r27	; 0x802071 <__brkval+0x1>
    927e:	a0 93 70 20 	sts	0x2070, r26	; 0x802070 <__brkval>
    9282:	df 91       	pop	r29
    9284:	cf 91       	pop	r28
    9286:	08 95       	ret

00009288 <strnlen_P>:
    9288:	fc 01       	movw	r30, r24
    928a:	05 90       	lpm	r0, Z+
    928c:	61 50       	subi	r22, 0x01	; 1
    928e:	70 40       	sbci	r23, 0x00	; 0
    9290:	01 10       	cpse	r0, r1
    9292:	d8 f7       	brcc	.-10     	; 0x928a <strnlen_P+0x2>
    9294:	80 95       	com	r24
    9296:	90 95       	com	r25
    9298:	8e 0f       	add	r24, r30
    929a:	9f 1f       	adc	r25, r31
    929c:	08 95       	ret

0000929e <fputc>:
    929e:	0f 93       	push	r16
    92a0:	1f 93       	push	r17
    92a2:	cf 93       	push	r28
    92a4:	df 93       	push	r29
    92a6:	fb 01       	movw	r30, r22
    92a8:	23 81       	ldd	r18, Z+3	; 0x03
    92aa:	21 fd       	sbrc	r18, 1
    92ac:	03 c0       	rjmp	.+6      	; 0x92b4 <fputc+0x16>
    92ae:	8f ef       	ldi	r24, 0xFF	; 255
    92b0:	9f ef       	ldi	r25, 0xFF	; 255
    92b2:	2c c0       	rjmp	.+88     	; 0x930c <fputc+0x6e>
    92b4:	22 ff       	sbrs	r18, 2
    92b6:	16 c0       	rjmp	.+44     	; 0x92e4 <fputc+0x46>
    92b8:	46 81       	ldd	r20, Z+6	; 0x06
    92ba:	57 81       	ldd	r21, Z+7	; 0x07
    92bc:	24 81       	ldd	r18, Z+4	; 0x04
    92be:	35 81       	ldd	r19, Z+5	; 0x05
    92c0:	42 17       	cp	r20, r18
    92c2:	53 07       	cpc	r21, r19
    92c4:	44 f4       	brge	.+16     	; 0x92d6 <fputc+0x38>
    92c6:	a0 81       	ld	r26, Z
    92c8:	b1 81       	ldd	r27, Z+1	; 0x01
    92ca:	9d 01       	movw	r18, r26
    92cc:	2f 5f       	subi	r18, 0xFF	; 255
    92ce:	3f 4f       	sbci	r19, 0xFF	; 255
    92d0:	31 83       	std	Z+1, r19	; 0x01
    92d2:	20 83       	st	Z, r18
    92d4:	8c 93       	st	X, r24
    92d6:	26 81       	ldd	r18, Z+6	; 0x06
    92d8:	37 81       	ldd	r19, Z+7	; 0x07
    92da:	2f 5f       	subi	r18, 0xFF	; 255
    92dc:	3f 4f       	sbci	r19, 0xFF	; 255
    92de:	37 83       	std	Z+7, r19	; 0x07
    92e0:	26 83       	std	Z+6, r18	; 0x06
    92e2:	14 c0       	rjmp	.+40     	; 0x930c <fputc+0x6e>
    92e4:	8b 01       	movw	r16, r22
    92e6:	ec 01       	movw	r28, r24
    92e8:	fb 01       	movw	r30, r22
    92ea:	00 84       	ldd	r0, Z+8	; 0x08
    92ec:	f1 85       	ldd	r31, Z+9	; 0x09
    92ee:	e0 2d       	mov	r30, r0
    92f0:	19 95       	eicall
    92f2:	89 2b       	or	r24, r25
    92f4:	e1 f6       	brne	.-72     	; 0x92ae <fputc+0x10>
    92f6:	d8 01       	movw	r26, r16
    92f8:	16 96       	adiw	r26, 0x06	; 6
    92fa:	8d 91       	ld	r24, X+
    92fc:	9c 91       	ld	r25, X
    92fe:	17 97       	sbiw	r26, 0x07	; 7
    9300:	01 96       	adiw	r24, 0x01	; 1
    9302:	17 96       	adiw	r26, 0x07	; 7
    9304:	9c 93       	st	X, r25
    9306:	8e 93       	st	-X, r24
    9308:	16 97       	sbiw	r26, 0x06	; 6
    930a:	ce 01       	movw	r24, r28
    930c:	df 91       	pop	r29
    930e:	cf 91       	pop	r28
    9310:	1f 91       	pop	r17
    9312:	0f 91       	pop	r16
    9314:	08 95       	ret

00009316 <__ultoa_invert>:
    9316:	fa 01       	movw	r30, r20
    9318:	aa 27       	eor	r26, r26
    931a:	28 30       	cpi	r18, 0x08	; 8
    931c:	51 f1       	breq	.+84     	; 0x9372 <__ultoa_invert+0x5c>
    931e:	20 31       	cpi	r18, 0x10	; 16
    9320:	81 f1       	breq	.+96     	; 0x9382 <__ultoa_invert+0x6c>
    9322:	e8 94       	clt
    9324:	6f 93       	push	r22
    9326:	6e 7f       	andi	r22, 0xFE	; 254
    9328:	6e 5f       	subi	r22, 0xFE	; 254
    932a:	7f 4f       	sbci	r23, 0xFF	; 255
    932c:	8f 4f       	sbci	r24, 0xFF	; 255
    932e:	9f 4f       	sbci	r25, 0xFF	; 255
    9330:	af 4f       	sbci	r26, 0xFF	; 255
    9332:	b1 e0       	ldi	r27, 0x01	; 1
    9334:	3e d0       	rcall	.+124    	; 0x93b2 <__ultoa_invert+0x9c>
    9336:	b4 e0       	ldi	r27, 0x04	; 4
    9338:	3c d0       	rcall	.+120    	; 0x93b2 <__ultoa_invert+0x9c>
    933a:	67 0f       	add	r22, r23
    933c:	78 1f       	adc	r23, r24
    933e:	89 1f       	adc	r24, r25
    9340:	9a 1f       	adc	r25, r26
    9342:	a1 1d       	adc	r26, r1
    9344:	68 0f       	add	r22, r24
    9346:	79 1f       	adc	r23, r25
    9348:	8a 1f       	adc	r24, r26
    934a:	91 1d       	adc	r25, r1
    934c:	a1 1d       	adc	r26, r1
    934e:	6a 0f       	add	r22, r26
    9350:	71 1d       	adc	r23, r1
    9352:	81 1d       	adc	r24, r1
    9354:	91 1d       	adc	r25, r1
    9356:	a1 1d       	adc	r26, r1
    9358:	20 d0       	rcall	.+64     	; 0x939a <__ultoa_invert+0x84>
    935a:	09 f4       	brne	.+2      	; 0x935e <__ultoa_invert+0x48>
    935c:	68 94       	set
    935e:	3f 91       	pop	r19
    9360:	2a e0       	ldi	r18, 0x0A	; 10
    9362:	26 9f       	mul	r18, r22
    9364:	11 24       	eor	r1, r1
    9366:	30 19       	sub	r19, r0
    9368:	30 5d       	subi	r19, 0xD0	; 208
    936a:	31 93       	st	Z+, r19
    936c:	de f6       	brtc	.-74     	; 0x9324 <__ultoa_invert+0xe>
    936e:	cf 01       	movw	r24, r30
    9370:	08 95       	ret
    9372:	46 2f       	mov	r20, r22
    9374:	47 70       	andi	r20, 0x07	; 7
    9376:	40 5d       	subi	r20, 0xD0	; 208
    9378:	41 93       	st	Z+, r20
    937a:	b3 e0       	ldi	r27, 0x03	; 3
    937c:	0f d0       	rcall	.+30     	; 0x939c <__ultoa_invert+0x86>
    937e:	c9 f7       	brne	.-14     	; 0x9372 <__ultoa_invert+0x5c>
    9380:	f6 cf       	rjmp	.-20     	; 0x936e <__ultoa_invert+0x58>
    9382:	46 2f       	mov	r20, r22
    9384:	4f 70       	andi	r20, 0x0F	; 15
    9386:	40 5d       	subi	r20, 0xD0	; 208
    9388:	4a 33       	cpi	r20, 0x3A	; 58
    938a:	18 f0       	brcs	.+6      	; 0x9392 <__ultoa_invert+0x7c>
    938c:	49 5d       	subi	r20, 0xD9	; 217
    938e:	31 fd       	sbrc	r19, 1
    9390:	40 52       	subi	r20, 0x20	; 32
    9392:	41 93       	st	Z+, r20
    9394:	02 d0       	rcall	.+4      	; 0x939a <__ultoa_invert+0x84>
    9396:	a9 f7       	brne	.-22     	; 0x9382 <__ultoa_invert+0x6c>
    9398:	ea cf       	rjmp	.-44     	; 0x936e <__ultoa_invert+0x58>
    939a:	b4 e0       	ldi	r27, 0x04	; 4
    939c:	a6 95       	lsr	r26
    939e:	97 95       	ror	r25
    93a0:	87 95       	ror	r24
    93a2:	77 95       	ror	r23
    93a4:	67 95       	ror	r22
    93a6:	ba 95       	dec	r27
    93a8:	c9 f7       	brne	.-14     	; 0x939c <__ultoa_invert+0x86>
    93aa:	00 97       	sbiw	r24, 0x00	; 0
    93ac:	61 05       	cpc	r22, r1
    93ae:	71 05       	cpc	r23, r1
    93b0:	08 95       	ret
    93b2:	9b 01       	movw	r18, r22
    93b4:	ac 01       	movw	r20, r24
    93b6:	0a 2e       	mov	r0, r26
    93b8:	06 94       	lsr	r0
    93ba:	57 95       	ror	r21
    93bc:	47 95       	ror	r20
    93be:	37 95       	ror	r19
    93c0:	27 95       	ror	r18
    93c2:	ba 95       	dec	r27
    93c4:	c9 f7       	brne	.-14     	; 0x93b8 <__ultoa_invert+0xa2>
    93c6:	62 0f       	add	r22, r18
    93c8:	73 1f       	adc	r23, r19
    93ca:	84 1f       	adc	r24, r20
    93cc:	95 1f       	adc	r25, r21
    93ce:	a0 1d       	adc	r26, r0
    93d0:	08 95       	ret

000093d2 <__divmodsi4>:
    93d2:	05 2e       	mov	r0, r21
    93d4:	97 fb       	bst	r25, 7
    93d6:	16 f4       	brtc	.+4      	; 0x93dc <__divmodsi4+0xa>
    93d8:	00 94       	com	r0
    93da:	0f d0       	rcall	.+30     	; 0x93fa <__negsi2>
    93dc:	57 fd       	sbrc	r21, 7
    93de:	05 d0       	rcall	.+10     	; 0x93ea <__divmodsi4_neg2>
    93e0:	0b da       	rcall	.-3050   	; 0x87f8 <__udivmodsi4>
    93e2:	07 fc       	sbrc	r0, 7
    93e4:	02 d0       	rcall	.+4      	; 0x93ea <__divmodsi4_neg2>
    93e6:	46 f4       	brtc	.+16     	; 0x93f8 <__divmodsi4_exit>
    93e8:	08 c0       	rjmp	.+16     	; 0x93fa <__negsi2>

000093ea <__divmodsi4_neg2>:
    93ea:	50 95       	com	r21
    93ec:	40 95       	com	r20
    93ee:	30 95       	com	r19
    93f0:	21 95       	neg	r18
    93f2:	3f 4f       	sbci	r19, 0xFF	; 255
    93f4:	4f 4f       	sbci	r20, 0xFF	; 255
    93f6:	5f 4f       	sbci	r21, 0xFF	; 255

000093f8 <__divmodsi4_exit>:
    93f8:	08 95       	ret

000093fa <__negsi2>:
    93fa:	90 95       	com	r25
    93fc:	80 95       	com	r24
    93fe:	70 95       	com	r23
    9400:	61 95       	neg	r22
    9402:	7f 4f       	sbci	r23, 0xFF	; 255
    9404:	8f 4f       	sbci	r24, 0xFF	; 255
    9406:	9f 4f       	sbci	r25, 0xFF	; 255
    9408:	08 95       	ret

0000940a <__mulshisi3>:
    940a:	b7 ff       	sbrs	r27, 7
    940c:	2e ca       	rjmp	.-2980   	; 0x886a <__muluhisi3>

0000940e <__mulohisi3>:
    940e:	2d da       	rcall	.-2982   	; 0x886a <__muluhisi3>
    9410:	82 1b       	sub	r24, r18
    9412:	93 0b       	sbc	r25, r19
    9414:	08 95       	ret

00009416 <_exit>:
    9416:	f8 94       	cli

00009418 <__stop_program>:
    9418:	ff cf       	rjmp	.-2      	; 0x9418 <__stop_program>
